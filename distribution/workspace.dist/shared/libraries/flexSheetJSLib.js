/**
 * State-based routing for AngularJS
 * @version v0.2.18
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/* commonjs package manager support (eg componentjs) */
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports){
  module.exports = 'ui.router';
}

(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy,
    toJson = angular.toJson;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] !== second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * IE8-safe wrapper for `Object.keys()`.
 *
 * @param {Object} object A JavaScript object.
 * @return {Array} Returns the keys of the object as an array.
 */
function objectKeys(object) {
  if (Object.keys) {
    return Object.keys(object);
  }
  var result = [];

  forEach(object, function(val, key) {
    result.push(key);
  });
  return result;
}

/**
 * IE8-safe wrapper for `Array.prototype.indexOf()`.
 *
 * @param {Array} array A JavaScript array.
 * @param {*} value A value to search the array for.
 * @return {Number} Returns the array index value of `value`, or `-1` if not present.
 */
function indexOf(array, value) {
  if (Array.prototype.indexOf) {
    return array.indexOf(value, Number(arguments[2]) || 0);
  }
  var len = array.length >>> 0, from = Number(arguments[2]) || 0;
  from = (from < 0) ? Math.ceil(from) : Math.floor(from);

  if (from < 0) from += len;

  for (; from < len; from++) {
    if (from in array && array[from] === value) return from;
  }
  return -1;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i] || !parents[i].params) continue;
    parentParams = objectKeys(parents[i].params);
    if (!parentParams.length) continue;

    for (var j in parentParams) {
      if (indexOf(inheritList, parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

/**
 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
 *
 * @param {Object} a The first object.
 * @param {Object} b The second object.
 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
 *                     it defaults to the list of keys in `a`.
 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
 */
function equalForKeys(a, b, keys) {
  if (!keys) {
    keys = [];
    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
  }

  for (var i=0; i<keys.length; i++) {
    var k = keys[i];
    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
  }
  return true;
}

/**
 * Returns the subset of an object, based on a list of keys.
 *
 * @param {Array} keys
 * @param {Object} values
 * @return {Boolean} Returns a subset of `values`.
 */
function filterByKeys(keys, values) {
  var filtered = {};

  forEach(keys, function (name) {
    filtered[name] = values[name];
  });
  return filtered;
}

// like _.indexBy
// when you know that your index values will be unique, or you want last-one-in to win
function indexBy(array, propName) {
  var result = {};
  forEach(array, function(item) {
    result[item[propName]] = item;
  });
  return result;
}

// extracted from underscore.js
// Return a copy of the object only containing the whitelisted properties.
function pick(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  forEach(keys, function(key) {
    if (key in obj) copy[key] = obj[key];
  });
  return copy;
}

// extracted from underscore.js
// Return a copy of the object omitting the blacklisted properties.
function omit(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  for (var key in obj) {
    if (indexOf(keys, key) == -1) copy[key] = obj[key];
  }
  return copy;
}

function pluck(collection, key) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = isFunction(key) ? key(val) : val[key];
  });
  return result;
}

function filter(collection, callback) {
  var array = isArray(collection);
  var result = array ? [] : {};
  forEach(collection, function(val, i) {
    if (callback(val, i)) {
      result[array ? result.length : i] = val;
    }
  });
  return result;
}

function map(collection, callback) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = callback(val, i);
  });
  return result;
}

/**
 * @ngdoc overview
 * @name ui.router.util
 *
 * @description
 * # ui.router.util sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.util', ['ng']);

/**
 * @ngdoc overview
 * @name ui.router.router
 * 
 * @requires ui.router.util
 *
 * @description
 * # ui.router.router sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 */
angular.module('ui.router.router', ['ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router.state
 * 
 * @requires ui.router.router
 * @requires ui.router.util
 *
 * @description
 * # ui.router.state sub-module
 *
 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 * 
 */
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router
 *
 * @requires ui.router.state
 *
 * @description
 * # ui.router
 * 
 * ## The main module for ui.router 
 * There are several sub-modules included with the ui.router module, however only this module is needed
 * as a dependency within your angular app. The other modules are for organization purposes. 
 *
 * The modules are:
 * * ui.router - the main "umbrella" module
 * * ui.router.router - 
 * 
 * *You'll need to include **only** this module as the dependency within your angular app.*
 * 
 * <pre>
 * <!doctype html>
 * <html ng-app="myApp">
 * <head>
 *   <script src="js/angular.js"></script>
 *   <!-- Include the ui-router script -->
 *   <script src="js/angular-ui-router.min.js"></script>
 *   <script>
 *     // ...and add 'ui.router' as a dependency
 *     var myApp = angular.module('myApp', ['ui.router']);
 *   </script>
 * </head>
 * <body>
 * </body>
 * </html>
 * </pre>
 */
angular.module('ui.router', ['ui.router.state']);

angular.module('ui.router.compat', ['ui.router']);

/**
 * @ngdoc object
 * @name ui.router.util.$resolve
 *
 * @requires $q
 * @requires $injector
 *
 * @description
 * Manages resolution of (acyclic) graphs of promises.
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {
  
  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
  

  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#study
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Studies a set of invocables that are likely to be used multiple times.
   * <pre>
   * $resolve.study(invocables)(locals, parent, self)
   * </pre>
   * is equivalent to
   * <pre>
   * $resolve.resolve(invocables, locals, parent, self)
   * </pre>
   * but the former is more efficient (in fact `resolve` just calls `study` 
   * internally).
   *
   * @param {object} invocables Invocable objects
   * @return {function} a function to pass in locals, parent and self
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
    var invocableKeys = objectKeys(invocables || {});
    
    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;
      
      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, indexOf(cycle, key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;
      
      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }
      
      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required
    
    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }
    
    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }       
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }
      
      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = resolution.promise,
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;
          
      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values); 
          result.$$values = values;
          result.$$promises = result.$$promises || true; // keep for isResolve()
          delete result.$$inheritedValues;
          resolution.resolve(values);
        }
      }
      
      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }

      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }
      
      if (parent.$$inheritedValues) {
        merge(values, omit(parent.$$inheritedValues, invocableKeys));
      }

      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      extend(promises, parent.$$promises);
      if (parent.$$values) {
        merged = merge(values, omit(parent.$$values, invocableKeys));
        result.$$inheritedValues = omit(parent.$$values, invocableKeys);
        done();
      } else {
        if (parent.$$inheritedValues) {
          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
        }        
        parent.then(done, fail);
      }
      
      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }
      
      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        forEach(params, function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = invocation.promise;
      }
      
      return result;
    };
  };
  
  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#resolve
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Resolves a set of invocables. An invocable is a function to be invoked via 
   * `$injector.invoke()`, and can have an arbitrary number of dependencies. 
   * An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the 
   * resulting value will be used instead. Dependencies of invocables are resolved 
   * (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve` 
   *   (or recursively
   * - from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains 
   * (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises 
   * returned by injectables have been resolved. If any invocable 
   * (or `$injector.invoke`) throws an exception, or if a promise returned by an 
   * invocable is rejected, the `$resolve` promise is immediately rejected with the 
   * same error. A rejection of a `parent` promise (if specified) will likewise be 
   * propagated immediately. Once the `$resolve` promise has been rejected, no 
   * further invocables will be called.
   * 
   * Cyclic dependencies between invocables are not permitted and will cause `$resolve`
   * to throw an error. As a special case, an injectable can depend on a parameter 
   * with the same name as the injectable, which will be fulfilled from the `parent` 
   * injectable of the same name. This allows inherited values to be decorated. 
   * Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an 
   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) 
   * exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available. 
   * This is true even for dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to 
   * be a service name to be passed to `$injector.get()`. This is supported primarily 
   * for backwards-compatibility with the `resolve` property of `$routeProvider` 
   * routes.
   *
   * @param {object} invocables functions to invoke or 
   * `$injector` services to fetch.
   * @param {object} locals  values to make available to the injectables
   * @param {object} parent  a promise returned by another call to `$resolve`.
   * @param {object} self  the `this` for the invoked methods
   * @return {object} Promise for an object that contains the resolved return value
   * of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);


/**
 * @ngdoc object
 * @name ui.router.util.$templateFactory
 *
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 *
 * @description
 * Service. Manages loading of templates.
 */
$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
function $TemplateFactory(  $http,   $templateCache,   $injector) {

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromConfig
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a configuration object. 
   *
   * @param {object} config Configuration object for which to load a template. 
   * The following properties are search in the specified order, and the first one 
   * that is defined is used to create the template:
   *
   * @param {string|object} config.template html string template or function to 
   * load via {@link ui.router.util.$templateFactory#fromString fromString}.
   * @param {string|object} config.templateUrl url to load or a function returning 
   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider function to invoke via 
   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
   * @param {object} params  Parameters to pass to the template function.
   * @param {object} locals Locals to pass to `invoke` if the template is loaded 
   * via a `templateProvider`. Defaults to `{ params: params }`.
   *
   * @return {string|object}  The template html as a string, or a promise for 
   * that string,or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromString
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a string or a function returning a string.
   *
   * @param {string|object} template html template as a string or function that 
   * returns an html template as a string.
   * @param {object} params Parameters to pass to the template function.
   *
   * @return {string|object} The template html as a string, or a promise for that 
   * string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromUrl
   * @methodOf ui.router.util.$templateFactory
   * 
   * @description
   * Loads a template from the a URL via `$http` and `$templateCache`.
   *
   * @param {string|Function} url url of the template to load, or a function 
   * that returns a url.
   * @param {Object} params Parameters to pass to the url function.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else return $http
        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})
        .then(function(response) { return response.data; });
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromProvider
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template by invoking an injectable provider function.
   *
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} locals Locals to pass to `invoke`. Defaults to 
   * `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

var $$UMFP; // reference to $UrlMatcherFactoryProvider

/**
 * @ngdoc object
 * @name ui.router.util.type:UrlMatcher
 *
 * @description
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
 *
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * `':'` name - colon placeholder
 * * `'*'` name - catch-all placeholder
 * * `'{' name '}'` - curly placeholder
 * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
 *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 *
 * Examples:
 *
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 * @param {string} pattern  The pattern to compile into a matcher.
 * @param {Object} config  A configuration object hash:
 * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
 *   an existing UrlMatcher
 *
 * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
 * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
 *   non-null) will start with this prefix.
 *
 * @property {string} source  The pattern that was passed into the constructor
 *
 * @property {string} sourcePath  The path portion of the source property
 *
 * @property {string} sourceSearch  The search portion of the source property
 *
 * @property {string} regex  The constructed regex that will be used to match against the url when
 *   it is time to determine which url will match.
 *
 * @returns {Object}  New `UrlMatcher` object
 */
function UrlMatcher(pattern, config, parentMatcher) {
  config = extend({ params: {} }, isObject(config) ? config : {});

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
  //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                       - anything other than curly braces or backslash
  //    \\.                            - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
  var placeholder       = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      compiled = '^', last = 0, m,
      segments = this.segments = [],
      parentParams = parentMatcher ? parentMatcher.params : {},
      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
      paramNames = [];

  function addParameter(id, type, config, location) {
    paramNames.push(id);
    if (parentParams[id]) return parentParams[id];
    if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    params[id] = new $$UMFP.Param(id, type, config, location);
    return params[id];
  }

  function quoteRegExp(string, pattern, squash, optional) {
    var surroundPattern = ['',''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    if (!pattern) return result;
    switch(squash) {
      case false: surroundPattern = ['(', ')' + (optional ? "?" : "")]; break;
      case true:
        result = result.replace(/\/$/, '');
        surroundPattern = ['(?:\/(', ')|\/)?'];
      break;
      default:    surroundPattern = ['(' + squash + "|", ')?']; break;
    }
    return result + surroundPattern[0] + pattern + surroundPattern[1];
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  function matchDetails(m, isSearch) {
    var id, regexp, segment, type, cfg, arrayMode;
    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    cfg         = config.params[id];
    segment     = pattern.substring(last, m.index);
    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);

    if (regexp) {
      type      = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
    }

    return {
      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
    };
  }

  var p, param, segment;
  while ((m = placeholder.exec(pattern))) {
    p = matchDetails(m, false);
    if (p.segment.indexOf('?') >= 0) break; // we're into the search part

    param = addParameter(p.id, p.type, p.cfg, "path");
    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
    segments.push(p.segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');

  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last + i);

    if (search.length > 0) {
      last = 0;
      while ((m = searchPlaceholder.exec(search))) {
        p = matchDetails(m, true);
        param = addParameter(p.id, p.type, p.cfg, "search");
        last = placeholder.lastIndex;
        // check if ?&
      }
    }
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
  segments.push(segment);

  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
  this.prefix = segments[0];
  this.$$paramNames = paramNames;
}

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#concat
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * @example
 * The following two matchers are equivalent:
 * <pre>
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * </pre>
 *
 * @param {string} pattern  The pattern to append.
 * @param {Object} config  An object hash of the configuration for the matcher.
 * @returns {UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern, config) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  var defaultConfig = {
    caseInsensitive: $$UMFP.caseInsensitive(),
    strict: $$UMFP.strictMode(),
    squash: $$UMFP.defaultSquashPolicy()
  };
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#exec
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
 *   x: '1', q: 'hello'
 * });
 * // returns { id: 'bob', q: 'hello', r: null }
 * </pre>
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @returns {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;
  searchParams = searchParams || {};

  var paramNames = this.parameters(), nTotal = paramNames.length,
    nPath = this.segments.length - 1,
    values = {}, i, j, cfg, paramName;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  function decodePathArray(string) {
    function reverseString(str) { return str.split("").reverse().join(""); }
    function unquoteDashes(str) { return str.replace(/\\-/g, "-"); }

    var split = reverseString(string).split(/-(?!\\)/);
    var allReversed = map(split, reverseString);
    return map(allReversed, unquoteDashes).reverse();
  }

  var param, paramVal;
  for (i = 0; i < nPath; i++) {
    paramName = paramNames[i];
    param = this.params[paramName];
    paramVal = m[i+1];
    // if the param value matches a pre-replace pair, replace the value before decoding.
    for (j = 0; j < param.replace.length; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
    values[paramName] = param.value(paramVal);
  }
  for (/**/; i < nTotal; i++) {
    paramName = paramNames[i];
    values[paramName] = this.params[paramName].value(searchParams[paramName]);
    param = this.params[paramName];
    paramVal = searchParams[paramName];
    for (j = 0; j < param.replace.length; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (isDefined(paramVal)) paramVal = param.type.decode(paramVal);
    values[paramName] = param.value(paramVal);
  }

  return values;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#parameters
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 *
 * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function (param) {
  if (!isDefined(param)) return this.$$paramNames;
  return this.params[param] || null;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#validates
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Checks an object hash of parameters to validate their correctness according to the parameter
 * types of this `UrlMatcher`.
 *
 * @param {Object} params The object hash of parameters to validate.
 * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
 */
UrlMatcher.prototype.validates = function (params) {
  return this.params.$$validates(params);
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#format
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * </pre>
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @returns {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  values = values || {};
  var segments = this.segments, params = this.parameters(), paramset = this.params;
  if (!this.validates(values)) return null;

  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];

  function encodeDashes(str) { // Replace dashes with encoded "\-"
    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });
  }

  for (i = 0; i < nTotal; i++) {
    var isPathParam = i < nPath;
    var name = params[i], param = paramset[name], value = param.value(values[name]);
    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
    var squash = isDefaultValue ? param.squash : false;
    var encoded = param.type.encode(value);

    if (isPathParam) {
      var nextSegment = segments[i + 1];
      var isFinalPathParam = i + 1 === nPath;

      if (squash === false) {
        if (encoded != null) {
          if (isArray(encoded)) {
            result += map(encoded, encodeDashes).join("-");
          } else {
            result += encodeURIComponent(encoded);
          }
        }
        result += nextSegment;
      } else if (squash === true) {
        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
        result += nextSegment.match(capture)[1];
      } else if (isString(squash)) {
        result += squash + nextSegment;
      }

      if (isFinalPathParam && param.squash === true && result.slice(-1) === '/') result = result.slice(0, -1);
    } else {
      if (encoded == null || (isDefaultValue && squash !== false)) continue;
      if (!isArray(encoded)) encoded = [ encoded ];
      if (encoded.length === 0) continue;
      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
      result += (search ? '&' : '?') + (name + '=' + encoded);
      search = true;
    }
  }

  return result;
};

/**
 * @ngdoc object
 * @name ui.router.util.type:Type
 *
 * @description
 * Implements an interface to define custom parameter types that can be decoded from and encoded to
 * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
 * objects when matching or formatting URLs, or comparing or validating parameter values.
 *
 * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
 * information on registering custom types.
 *
 * @param {Object} config  A configuration object which contains the custom type definition.  The object's
 *        properties will override the default methods and/or pattern in `Type`'s public interface.
 * @example
 * <pre>
 * {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 * </pre>
 *
 * @property {RegExp} pattern The regular expression pattern used to match values of this type when
 *           coming from a substring of a URL.
 *
 * @returns {Object}  Returns a new `Type` object.
 */
function Type(config) {
  extend(this, config);
}

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#is
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Detects whether a value is of a particular type. Accepts a native (decoded) value
 * and determines whether it matches the current `Type` object.
 *
 * @param {*} val  The value to check.
 * @param {string} key  Optional. If the type check is happening in the context of a specific
 *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
 *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
 * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
 */
Type.prototype.is = function(val, key) {
  return true;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#encode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
 * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
 * only needs to be a representation of `val` that has been coerced to a string.
 *
 * @param {*} val  The value to encode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
 */
Type.prototype.encode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#decode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Converts a parameter value (from URL string or transition param) to a custom/native value.
 *
 * @param {string} val  The URL parameter value to decode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {*}  Returns a custom representation of the URL parameter value.
 */
Type.prototype.decode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#equals
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Determines whether two decoded values are equivalent.
 *
 * @param {*} a  A value to compare against.
 * @param {*} b  A value to compare against.
 * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
 */
Type.prototype.equals = function(a, b) {
  return a == b;
};

Type.prototype.$subPattern = function() {
  var sub = this.pattern.toString();
  return sub.substr(1, sub.length - 2);
};

Type.prototype.pattern = /.*/;

Type.prototype.toString = function() { return "{Type:" + this.name + "}"; };

/** Given an encoded string, or a decoded object, returns a decoded object */
Type.prototype.$normalize = function(val) {
  return this.is(val) ? val : this.decode(val);
};

/*
 * Wraps an existing custom Type as an array of Type, depending on 'mode'.
 * e.g.:
 * - urlmatcher pattern "/path?{queryParam[]:int}"
 * - url: "/path?queryParam=1&queryParam=2
 * - $stateParams.queryParam will be [1, 2]
 * if `mode` is "auto", then
 * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
 * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
 */
Type.prototype.$asArray = function(mode, isSearch) {
  if (!mode) return this;
  if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");

  function ArrayType(type, mode) {
    function bindTo(type, callbackName) {
      return function() {
        return type[callbackName].apply(type, arguments);
      };
    }

    // Wrap non-array value as array
    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
      switch(val.length) {
        case 0: return undefined;
        case 1: return mode === "auto" ? val[0] : val;
        default: return val;
      }
    }
    function falsey(val) { return !val; }

    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
      return function handleArray(val) {
        if (isArray(val) && val.length === 0) return val;
        val = arrayWrap(val);
        var result = map(val, callback);
        if (allTruthyMode === true)
          return filter(result, falsey).length === 0;
        return arrayUnwrap(result);
      };
    }

    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
      return function handleArray(val1, val2) {
        var left = arrayWrap(val1), right = arrayWrap(val2);
        if (left.length !== right.length) return false;
        for (var i = 0; i < left.length; i++) {
          if (!callback(left[i], right[i])) return false;
        }
        return true;
      };
    }

    this.encode = arrayHandler(bindTo(type, 'encode'));
    this.decode = arrayHandler(bindTo(type, 'decode'));
    this.is     = arrayHandler(bindTo(type, 'is'), true);
    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
    this.pattern = type.pattern;
    this.$normalize = arrayHandler(bindTo(type, '$normalize'));
    this.name = type.name;
    this.$arrayMode = mode;
  }

  return new ArrayType(this, mode);
};



/**
 * @ngdoc object
 * @name ui.router.util.$urlMatcherFactory
 *
 * @description
 * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
 * is also available to providers under the name `$urlMatcherFactoryProvider`.
 */
function $UrlMatcherFactory() {
  $$UMFP = this;

  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;

  // Use tildes to pre-encode slashes.
  // If the slashes are simply URLEncoded, the browser can choose to pre-decode them,
  // and bidirectional encoding/decoding fails.
  // Tilde was chosen because it's not a RFC 3986 section 2.2 Reserved Character
  function valToString(val) { return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val; }
  function valFromString(val) { return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val; }

  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
    "string": {
      encode: valToString,
      decode: valFromString,
      // TODO: in 1.0, make string .is() return false if value is undefined/null by default.
      // In 0.2.x, string params are optional by default for backwards compat
      is: function(val) { return val == null || !isDefined(val) || typeof val === "string"; },
      pattern: /[^/]*/
    },
    "int": {
      encode: valToString,
      decode: function(val) { return parseInt(val, 10); },
      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },
      pattern: /\d+/
    },
    "bool": {
      encode: function(val) { return val ? 1 : 0; },
      decode: function(val) { return parseInt(val, 10) !== 0; },
      is: function(val) { return val === true || val === false; },
      pattern: /0|1/
    },
    "date": {
      encode: function (val) {
        if (!this.is(val))
          return undefined;
        return [ val.getFullYear(),
          ('0' + (val.getMonth() + 1)).slice(-2),
          ('0' + val.getDate()).slice(-2)
        ].join("-");
      },
      decode: function (val) {
        if (this.is(val)) return val;
        var match = this.capture.exec(val);
        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
      },
      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },
      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },
      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
    },
    "json": {
      encode: angular.toJson,
      decode: angular.fromJson,
      is: angular.isObject,
      equals: angular.equals,
      pattern: /[^/]*/
    },
    "any": { // does not encode/decode
      encode: angular.identity,
      decode: angular.identity,
      equals: angular.equals,
      pattern: /.*/
    }
  };

  function getDefaultConfig() {
    return {
      strict: isStrictMode,
      caseInsensitive: isCaseInsensitive
    };
  }

  function isInjectable(value) {
    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
  }

  /**
   * [Internal] Get the default value of a parameter, which may be an injectable function.
   */
  $UrlMatcherFactory.$$getDefaultValue = function(config) {
    if (!isInjectable(config.value)) return config.value;
    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
    return injector.invoke(config.value);
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#caseInsensitive
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URL matching should be case sensitive (the default behavior), or not.
   *
   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
   * @returns {boolean} the current value of caseInsensitive
   */
  this.caseInsensitive = function(value) {
    if (isDefined(value))
      isCaseInsensitive = value;
    return isCaseInsensitive;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#strictMode
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URLs should match trailing slashes, or not (the default behavior).
   *
   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
   * @returns {boolean} the current value of strictMode
   */
  this.strictMode = function(value) {
    if (isDefined(value))
      isStrictMode = value;
    return isStrictMode;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Sets the default behavior when generating or matching URLs with default parameter values.
   *
   * @param {string} value A string that defines the default parameter URL squashing behavior.
   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
   *             parameter is surrounded by slashes, squash (remove) one slash from the URL
   *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
   *             the parameter value from the URL and replace it with this string.
   */
  this.defaultSquashPolicy = function(value) {
    if (!isDefined(value)) return defaultSquashPolicy;
    if (value !== true && value !== false && !isString(value))
      throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
    defaultSquashPolicy = value;
    return value;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#compile
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
   *
   * @param {string} pattern  The URL pattern.
   * @param {Object} config  The config object hash.
   * @returns {UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern, config) {
    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#isMatcher
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
   *
   * @param {Object} object  The object to perform the type check against.
   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
   *          implementing all the same methods.
   */
  this.isMatcher = function (o) {
    if (!isObject(o)) return false;
    var result = true;

    forEach(UrlMatcher.prototype, function(val, name) {
      if (isFunction(val)) {
        result = result && (isDefined(o[name]) && isFunction(o[name]));
      }
    });
    return result;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#type
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
   * generate URLs with typed parameters.
   *
   * @param {string} name  The type name.
   * @param {Object|Function} definition   The type definition. See
   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   * @param {Object|Function} definitionFn (optional) A function that is injected before the app
   *        runtime starts.  The result of this function is merged into the existing `definition`.
   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   *
   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
   *
   * @example
   * This is a simple example of a custom type that encodes and decodes items from an
   * array, using the array index as the URL-encoded value:
   *
   * <pre>
   * var list = ['John', 'Paul', 'George', 'Ringo'];
   *
   * $urlMatcherFactoryProvider.type('listItem', {
   *   encode: function(item) {
   *     // Represent the list item in the URL using its corresponding index
   *     return list.indexOf(item);
   *   },
   *   decode: function(item) {
   *     // Look up the list item by index
   *     return list[parseInt(item, 10)];
   *   },
   *   is: function(item) {
   *     // Ensure the item is valid by checking to see that it appears
   *     // in the list
   *     return list.indexOf(item) > -1;
   *   }
   * });
   *
   * $stateProvider.state('list', {
   *   url: "/list/{item:listItem}",
   *   controller: function($scope, $stateParams) {
   *     console.log($stateParams.item);
   *   }
   * });
   *
   * // ...
   *
   * // Changes URL to '/list/3', logs "Ringo" to the console
   * $state.go('list', { item: "Ringo" });
   * </pre>
   *
   * This is a more complex example of a type that relies on dependency injection to
   * interact with services, and uses the parameter name from the URL to infer how to
   * handle encoding and decoding parameter values:
   *
   * <pre>
   * // Defines a custom type that gets a value from a service,
   * // where each service gets different types of values from
   * // a backend API:
   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
   *
   *   // Matches up services to URL parameter names
   *   var services = {
   *     user: Users,
   *     post: Posts
   *   };
   *
   *   return {
   *     encode: function(object) {
   *       // Represent the object in the URL using its unique ID
   *       return object.id;
   *     },
   *     decode: function(value, key) {
   *       // Look up the object by ID, using the parameter
   *       // name (key) to call the correct service
   *       return services[key].findById(value);
   *     },
   *     is: function(object, key) {
   *       // Check that object is a valid dbObject
   *       return angular.isObject(object) && object.id && services[key];
   *     }
   *     equals: function(a, b) {
   *       // Check the equality of decoded objects by comparing
   *       // their unique IDs
   *       return a.id === b.id;
   *     }
   *   };
   * });
   *
   * // In a config() block, you can then attach URLs with
   * // type-annotated parameters:
   * $stateProvider.state('users', {
   *   url: "/users",
   *   // ...
   * }).state('users.item', {
   *   url: "/{user:dbObject}",
   *   controller: function($scope, $stateParams) {
   *     // $stateParams.user will now be an object returned from
   *     // the Users service
   *   },
   *   // ...
   * });
   * </pre>
   */
  this.type = function (name, definition, definitionFn) {
    if (!isDefined(definition)) return $types[name];
    if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");

    $types[name] = new Type(extend({ name: name }, definition));
    if (definitionFn) {
      typeQueue.push({ name: name, def: definitionFn });
      if (!enqueue) flushTypeQueue();
    }
    return this;
  };

  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
  function flushTypeQueue() {
    while(typeQueue.length) {
      var type = typeQueue.shift();
      if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
      angular.extend($types[type.name], injector.invoke(type.def));
    }
  }

  // Register default types. Store them in the prototype of $types.
  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });
  $types = inherit($types, {});

  /* No need to document $get, since it returns this */
  this.$get = ['$injector', function ($injector) {
    injector = $injector;
    enqueue = false;
    flushTypeQueue();

    forEach(defaultTypes, function(type, name) {
      if (!$types[name]) $types[name] = new Type(type);
    });
    return this;
  }];

  this.Param = function Param(id, type, config, location) {
    var self = this;
    config = unwrapShorthand(config);
    type = getType(config, type, location);
    var arrayMode = getArrayMode();
    type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
    if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
      config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
    var isOptional = config.value !== undefined;
    var squash = getSquashPolicy(config, isOptional);
    var replace = getReplace(config, arrayMode, isOptional, squash);

    function unwrapShorthand(config) {
      var keys = isObject(config) ? objectKeys(config) : [];
      var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 &&
                        indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
      if (isShorthand) config = { value: config };
      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };
      return config;
    }

    function getType(config, urlType, location) {
      if (config.type && urlType) throw new Error("Param '"+id+"' has two type configurations.");
      if (urlType) return urlType;
      if (!config.type) return (location === "config" ? $types.any : $types.string);

      if (angular.isString(config.type))
        return $types[config.type];
      if (config.type instanceof Type)
        return config.type;
      return new Type(config.type);
    }

    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
    function getArrayMode() {
      var arrayDefaults = { array: (location === "search" ? "auto" : false) };
      var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
      return extend(arrayDefaults, arrayParamNomenclature, config).array;
    }

    /**
     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
     */
    function getSquashPolicy(config, isOptional) {
      var squash = config.squash;
      if (!isOptional || squash === false) return false;
      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
      if (squash === true || isString(squash)) return squash;
      throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }

    function getReplace(config, arrayMode, isOptional, squash) {
      var replace, configuredKeys, defaultPolicy = [
        { from: "",   to: (isOptional || arrayMode ? undefined : "") },
        { from: null, to: (isOptional || arrayMode ? undefined : "") }
      ];
      replace = isArray(config.replace) ? config.replace : [];
      if (isString(squash))
        replace.push({ from: squash, to: undefined });
      configuredKeys = map(replace, function(item) { return item.from; } );
      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);
    }

    /**
     * [Internal] Get the default value of a parameter, which may be an injectable function.
     */
    function $$getDefaultValue() {
      if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
      var defaultValue = injector.invoke(config.$$fn);
      if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
        throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
      return defaultValue;
    }

    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    function $value(value) {
      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }
      function $replace(value) {
        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });
        return replacement.length ? replacement[0] : value;
      }
      value = $replace(value);
      return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
    }

    function toString() { return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"; }

    extend(this, {
      id: id,
      type: type,
      location: location,
      array: arrayMode,
      squash: squash,
      replace: replace,
      isOptional: isOptional,
      value: $value,
      dynamic: undefined,
      config: config,
      toString: toString
    });
  };

  function ParamSet(params) {
    extend(this, params || {});
  }

  ParamSet.prototype = {
    $$new: function() {
      return inherit(this, extend(new ParamSet(), { $$parent: this}));
    },
    $$keys: function () {
      var keys = [], chain = [], parent = this,
        ignore = objectKeys(ParamSet.prototype);
      while (parent) { chain.push(parent); parent = parent.$$parent; }
      chain.reverse();
      forEach(chain, function(paramset) {
        forEach(objectKeys(paramset), function(key) {
            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
        });
      });
      return keys;
    },
    $$values: function(paramValues) {
      var values = {}, self = this;
      forEach(self.$$keys(), function(key) {
        values[key] = self[key].value(paramValues && paramValues[key]);
      });
      return values;
    },
    $$equals: function(paramValues1, paramValues2) {
      var equal = true, self = this;
      forEach(self.$$keys(), function(key) {
        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
        if (!self[key].type.equals(left, right)) equal = false;
      });
      return equal;
    },
    $$validates: function $$validate(paramValues) {
      var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
      for (i = 0; i < keys.length; i++) {
        param = this[keys[i]];
        rawVal = paramValues[keys[i]];
        if ((rawVal === undefined || rawVal === null) && param.isOptional)
          break; // There was no parameter value, but the param is optional
        normalized = param.type.$normalize(rawVal);
        if (!param.type.is(normalized))
          return false; // The value was not of the correct Type, and could not be decoded to the correct Type
        encoded = param.type.encode(normalized);
        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
          return false; // The value was of the correct type, but when encoded, did not match the Type's regexp
      }
      return true;
    },
    $$parent: undefined
  };

  this.ParamSet = ParamSet;
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);

/**
 * @ngdoc object
 * @name ui.router.router.$urlRouterProvider
 *
 * @requires ui.router.util.$urlMatcherFactoryProvider
 * @requires $locationProvider
 *
 * @description
 * `$urlRouterProvider` has the responsibility of watching `$location`. 
 * When `$location` changes it runs through a list of rules one by one until a 
 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify 
 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
 *
 * There are several methods on `$urlRouterProvider` that make it useful to use directly
 * in your module config.
 */
$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
function $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {
  var rules = [], otherwise = null, interceptDeferred = false, listener;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#rule
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines rules that are used by `$urlRouterProvider` to find matches for
   * specific URLs.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // Here's an example of how you might allow case insensitive urls
   *   $urlRouterProvider.rule(function ($injector, $location) {
   *     var path = $location.path(),
   *         normalized = path.toLowerCase();
   *
   *     if (path !== normalized) {
   *       return normalized;
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {function} rule Handler function that takes `$injector` and `$location`
   * services as arguments. You can use them to return a valid path as a string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.rule = function (rule) {
    if (!isFunction(rule)) throw new Error("'rule' must be a function");
    rules.push(rule);
    return this;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouterProvider#otherwise
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines a path that is used when an invalid route is requested.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // if the path doesn't match any of the urls you configured
   *   // otherwise will take care of routing the user to the
   *   // specified url
   *   $urlRouterProvider.otherwise('/index');
   *
   *   // Example of using function rule as param
   *   $urlRouterProvider.otherwise(function ($injector, $location) {
   *     return '/a/valid/url';
   *   });
   * });
   * </pre>
   *
   * @param {string|function} rule The url path you want to redirect to or a function 
   * rule that returns the url path. The function version is passed two params: 
   * `$injector` and `$location` services, and must return a url string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.otherwise = function (rule) {
    if (isString(rule)) {
      var redirect = rule;
      rule = function () { return redirect; };
    }
    else if (!isFunction(rule)) throw new Error("'rule' must be a function");
    otherwise = rule;
    return this;
  };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#when
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Registers a handler for a given url matching. 
   * 
   * If the handler is a string, it is
   * treated as a redirect, and is interpolated according to the syntax of match
   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
   *
   * If the handler is a function, it is injectable. It gets invoked if `$location`
   * matches. You have the option of inject the match object as `$match`.
   *
   * The handler can return
   *
   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
   *   will continue trying to find another one that matches.
   * - **string** which is treated as a redirect and passed to `$location.url()`
   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
   *     if ($state.$current.navigable !== state ||
   *         !equalForKeys($match, $stateParams) {
   *      $state.transitionTo(state, $match, false);
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {string|object} what The incoming path that you want to redirect.
   * @param {string|function} handler The path you want to redirect your user to.
   */
  this.when = function (what, handler) {
    var redirect, handlerIsString = isString(handler);
    if (isString(what)) what = $urlMatcherFactory.compile(what);

    if (!handlerIsString && !isFunction(handler) && !isArray(handler))
      throw new Error("invalid 'handler' in when()");

    var strategies = {
      matcher: function (what, handler) {
        if (handlerIsString) {
          redirect = $urlMatcherFactory.compile(handler);
          handler = ['$match', function ($match) { return redirect.format($match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
        }, {
          prefix: isString(what.prefix) ? what.prefix : ''
        });
      },
      regex: function (what, handler) {
        if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

        if (handlerIsString) {
          redirect = handler;
          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path()));
        }, {
          prefix: regExpPrefix(what)
        });
      }
    };

    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

    for (var n in check) {
      if (check[n]) return this.rule(strategies[n](what, handler));
    }

    throw new Error("invalid 'what' in when()");
  };

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#deferIntercept
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Disables (or enables) deferring location change interception.
   *
   * If you wish to customize the behavior of syncing the URL (for example, if you wish to
   * defer a transition but maintain the current URL), call this method at configuration time.
   * Then, at run time, call `$urlRouter.listen()` after you have configured your own
   * `$locationChangeSuccess` event handler.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *
   *   // Prevent $urlRouter from automatically intercepting URL changes;
   *   // this allows you to configure custom behavior in between
   *   // location changes and route synchronization:
   *   $urlRouterProvider.deferIntercept();
   *
   * }).run(function ($rootScope, $urlRouter, UserService) {
   *
   *   $rootScope.$on('$locationChangeSuccess', function(e) {
   *     // UserService is an example service for managing user state
   *     if (UserService.isLoggedIn()) return;
   *
   *     // Prevent $urlRouter's default handler from firing
   *     e.preventDefault();
   *
   *     UserService.handleLogin().then(function() {
   *       // Once the user has logged in, sync the current URL
   *       // to the router:
   *       $urlRouter.sync();
   *     });
   *   });
   *
   *   // Configures $urlRouter's listener *after* your custom listener
   *   $urlRouter.listen();
   * });
   * </pre>
   *
   * @param {boolean} defer Indicates whether to defer location change interception. Passing
            no parameter is equivalent to `true`.
   */
  this.deferIntercept = function (defer) {
    if (defer === undefined) defer = true;
    interceptDeferred = defer;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouter
   *
   * @requires $location
   * @requires $rootScope
   * @requires $injector
   * @requires $browser
   *
   * @description
   *
   */
  this.$get = $get;
  $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
  function $get(   $location,   $rootScope,   $injector,   $browser,   $sniffer) {

    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;

    function appendBasePath(url, isHtml5, absolute) {
      if (baseHref === '/') return url;
      if (isHtml5) return baseHref.slice(0, -1) + url;
      if (absolute) return baseHref.slice(1) + url;
      return url;
    }

    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
    function update(evt) {
      if (evt && evt.defaultPrevented) return;
      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
      lastPushedUrl = undefined;
      // TODO: Re-implement this in 1.0 for https://github.com/angular-ui/ui-router/issues/1573
      //if (ignoreUpdate) return true;

      function check(rule) {
        var handled = rule($injector, $location);

        if (!handled) return false;
        if (isString(handled)) $location.replace().url(handled);
        return true;
      }
      var n = rules.length, i;

      for (i = 0; i < n; i++) {
        if (check(rules[i])) return;
      }
      // always check otherwise last to allow dynamic updates to the set of rules
      if (otherwise) check(otherwise);
    }

    function listen() {
      listener = listener || $rootScope.$on('$locationChangeSuccess', update);
      return listener;
    }

    if (!interceptDeferred) listen();

    return {
      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#sync
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
       * with the transition by calling `$urlRouter.sync()`.
       *
       * @example
       * <pre>
       * angular.module('app', ['ui.router'])
       *   .run(function($rootScope, $urlRouter) {
       *     $rootScope.$on('$locationChangeSuccess', function(evt) {
       *       // Halt state change from even starting
       *       evt.preventDefault();
       *       // Perform custom logic
       *       var meetsRequirement = ...
       *       // Continue with the update and state transition if logic allows
       *       if (meetsRequirement) $urlRouter.sync();
       *     });
       * });
       * </pre>
       */
      sync: function() {
        update();
      },

      listen: function() {
        return listen();
      },

      update: function(read) {
        if (read) {
          location = $location.url();
          return;
        }
        if ($location.url() === location) return;

        $location.url(location);
        $location.replace();
      },

      push: function(urlMatcher, params, options) {
         var url = urlMatcher.format(params || {});

        // Handle the special hash param, if needed
        if (url !== null && params && params['#']) {
            url += '#' + params['#'];
        }

        $location.url(url);
        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
        if (options && options.replace) $location.replace();
      },

      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#href
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * A URL generation method that returns the compiled URL for a given
       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
       *
       * @example
       * <pre>
       * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
       *   person: "bob"
       * });
       * // $bob == "/about/bob";
       * </pre>
       *
       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
       * @param {object=} params An object of parameter values to fill the matcher's required parameters.
       * @param {object=} options Options object. The options are:
       *
       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
       *
       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
       */
      href: function(urlMatcher, params, options) {
        if (!urlMatcher.validates(params)) return null;

        var isHtml5 = $locationProvider.html5Mode();
        if (angular.isObject(isHtml5)) {
          isHtml5 = isHtml5.enabled;
        }

        isHtml5 = isHtml5 && $sniffer.history;
        
        var url = urlMatcher.format(params);
        options = options || {};

        if (!isHtml5 && url !== null) {
          url = "#" + $locationProvider.hashPrefix() + url;
        }

        // Handle special hash param, if needed
        if (url !== null && params && params['#']) {
          url += '#' + params['#'];
        }

        url = appendBasePath(url, isHtml5, options.absolute);

        if (!options.absolute || !url) {
          return url;
        }

        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();
        port = (port === 80 || port === 443 ? '' : ':' + port);

        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
      }
    };
  }
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$stateProvider
 *
 * @requires ui.router.router.$urlRouterProvider
 * @requires ui.router.util.$urlMatcherFactoryProvider
 *
 * @description
 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a "place" in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The `$stateProvider` provides interfaces to declare these states for your app.
 */
$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {

  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = inherit(state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url, config = { params: state.params || {} };

      if (isString(url)) {
        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
        return (state.parent.navigable || root).url.concat(url, config);
      }

      if (!url || $urlMatcherFactory.isMatcher(url)) return url;
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
    ownParams: function(state) {
      var params = state.url && state.url.params || new $$UMFP.ParamSet();
      forEach(state.params || {}, function(config, id) {
        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
      });
      return params;
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      var ownParams = pick(state.ownParams, state.ownParams.$$keys());
      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    },

    $delegates: {}
  };

  function isRelative(stateName) {
    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
  }

  function findState(stateOrName, base) {
    if (!stateOrName) return undefined;

    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = isRelative(name);

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      base = findState(base);
      
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }

  function queueState(parentName, state) {
    if (!queue[parentName]) {
      queue[parentName] = [];
    }
    queue[parentName].push(state);
  }

  function flushQueuedChildren(parentName) {
    var queued = queue[parentName] || [];
    while(queued.length) {
      registerState(queued.shift());
    }
  }

  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");

    // Get parent name
    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
        : (isString(state.parent)) ? state.parent
        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name
        : '';

    // If parent is not registered yet, add state to queue and register later
    if (parentName && !states[parentName]) {
      return queueState(parentName, state.self);
    }

    for (var key in stateBuilder) {
      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state[abstractKey] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, { inherit: true, location: false });
        }
      }]);
    }

    // Register any queued children
    flushQueuedChildren(name);

    return state;
  }

  // Checks text to see if it looks like a glob.
  function isGlob (text) {
    return text.indexOf('*') > -1;
  }

  // Returns true if glob matches current $state name.
  function doesStateMatchGlob (glob) {
    var globSegments = glob.split('.'),
        segments = $state.$current.name.split('.');

    //match single stars
    for (var i = 0, l = globSegments.length; i < l; i++) {
      if (globSegments[i] === '*') {
        segments[i] = '*';
      }
    }

    //match greedy starts
    if (globSegments[0] === '**') {
       segments = segments.slice(indexOf(segments, globSegments[1]));
       segments.unshift('**');
    }
    //match greedy ends
    if (globSegments[globSegments.length - 1] === '**') {
       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
       segments.push('**');
    }

    if (globSegments.length != segments.length) {
      return false;
    }

    return segments.join('') === globSegments.join('');
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#decorator
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Allows you to extend (carefully) or override (at your own peril) the 
   * `stateBuilder` object used internally by `$stateProvider`. This can be used 
   * to add custom functionality to ui-router, for example inferring templateUrl 
   * based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches `name`.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new 
   * properties within the state's internal definition. There is currently no clear 
   * use-case for this beyond accessing internal states (i.e. $state.$current), 
   * however, expect this to become increasingly relevant as we introduce additional 
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of 
   * execution of the builder functions in non-deterministic. Builder functions 
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** `{object}` - returns the parent state object.
   * - **data** `{object}` - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
   *   or `null`.
   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is 
   *   navigable).
   * - **params** `{object}` - returns an array of state params that are ensured to 
   *   be a super-set of parent's params.
   * - **views** `{object}` - returns a views object where each key is an absolute view 
   *   name (i.e. "viewName@stateName") and each value is the config object 
   *   (template, controller) for the view. Even when you don't use the views object 
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template 
   *   and controller properties.
   * - **ownParams** `{object}` - returns an array of params that belong to the state, 
   *   not including any params defined by ancestor states.
   * - **path** `{string}` - returns the full path from the root down to this state. 
   *   Needed for state activation.
   * - **includes** `{object}` - returns an object that includes every state that 
   *   would pass a `$state.includes()` test.
   *
   * @example
   * <pre>
   * // Override the internal 'views' builder with a function that takes the state
   * // definition, and a reference to the internal function being overridden:
   * $stateProvider.decorator('views', function (state, parent) {
   *   var result = {},
   *       views = parent(state);
   *
   *   angular.forEach(views, function (config, name) {
   *     var autoName = (state.name + '.' + name).replace('.', '/');
   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state('home', {
   *   views: {
   *     'contact.list': { controller: 'ListController' },
   *     'contact.item': { controller: 'ItemController' }
   *   }
   * });
   *
   * // ...
   *
   * $state.go('home');
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * </pre>
   *
   * @param {string} name The name of the builder function to decorate. 
   * @param {object} func A function that is responsible for decorating the original 
   * builder function. The function receives two parameters:
   *
   *   - `{object}` - state - The state config object.
   *   - `{object}` - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  this.decorator = decorator;
  function decorator(name, func) {
    /*jshint validthis: true */
    if (isString(name) && !isDefined(func)) {
      return stateBuilder[name];
    }
    if (!isFunction(func) || !isString(name)) {
      return this;
    }
    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
      stateBuilder.$delegates[name] = stateBuilder[name];
    }
    stateBuilder[name] = func;
    return this;
  }

  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#state
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Registers a state configuration under a given state name. The stateConfig object
   * has the following acceptable properties.
   *
   * @param {string} name A unique state name, e.g. "home", "about", "contacts".
   * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
   * @param {object} stateConfig State configuration object.
   * @param {string|function=} stateConfig.template
   * <a id='template'></a>
   *   html template as a string or a function that returns
   *   an html template as a string which should be used by the uiView directives. This property 
   *   takes precedence over templateUrl.
   *   
   *   If `template` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * <pre>template:
   *   "<h1>inline template definition</h1>" +
   *   "<div ui-view></div>"</pre>
   * <pre>template: function(params) {
   *       return "<h1>generated template</h1>"; }</pre>
   * </div>
   *
   * @param {string|function=} stateConfig.templateUrl
   * <a id='templateUrl'></a>
   *
   *   path or function that returns a path to an html
   *   template that should be used by uiView.
   *   
   *   If `templateUrl` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by 
   *     applying the current state
   *
   * <pre>templateUrl: "home.html"</pre>
   * <pre>templateUrl: function(params) {
   *     return myTemplates[params.pageId]; }</pre>
   *
   * @param {function=} stateConfig.templateProvider
   * <a id='templateProvider'></a>
   *    Provider function that returns HTML content string.
   * <pre> templateProvider:
   *       function(MyTemplateService, params) {
   *         return MyTemplateService.getTemplate(params.pageId);
   *       }</pre>
   *
   * @param {string|function=} stateConfig.controller
   * <a id='controller'></a>
   *
   *  Controller fn that should be associated with newly
   *   related scope or the name of a registered controller if passed as a string.
   *   Optionally, the ControllerAs may be declared here.
   * <pre>controller: "MyRegisteredController"</pre>
   * <pre>controller:
   *     "MyRegisteredController as fooCtrl"}</pre>
   * <pre>controller: function($scope, MyService) {
   *     $scope.data = MyService.getData(); }</pre>
   *
   * @param {function=} stateConfig.controllerProvider
   * <a id='controllerProvider'></a>
   *
   * Injectable provider function that returns the actual controller or string.
   * <pre>controllerProvider:
   *   function(MyResolveData) {
   *     if (MyResolveData.foo)
   *       return "FooCtrl"
   *     else if (MyResolveData.bar)
   *       return "BarCtrl";
   *     else return function($scope) {
   *       $scope.baz = "Qux";
   *     }
   *   }</pre>
   *
   * @param {string=} stateConfig.controllerAs
   * <a id='controllerAs'></a>
   * 
   * A controller alias name. If present the controller will be
   *   published to scope under the controllerAs name.
   * <pre>controllerAs: "myCtrl"</pre>
   *
   * @param {string|object=} stateConfig.parent
   * <a id='parent'></a>
   * Optionally specifies the parent state of this state.
   *
   * <pre>parent: 'parentState'</pre>
   * <pre>parent: parentState // JS variable</pre>
   *
   * @param {object=} stateConfig.resolve
   * <a id='resolve'></a>
   *
   * An optional map&lt;string, function&gt; of dependencies which
   *   should be injected into the controller. If any of these dependencies are promises, 
   *   the router will wait for them all to be resolved before the controller is instantiated.
   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
   *   and the values of the resolved promises are injected into any controllers that reference them.
   *   If any  of the promises are rejected the $stateChangeError event is fired.
   *
   *   The map object is:
   *   
   *   - key - {string}: name of dependency to be injected into controller
   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
   *     it is injected and return value it treated as dependency. If result is a promise, it is 
   *     resolved before its value is injected into controller.
   *
   * <pre>resolve: {
   *     myResolve1:
   *       function($http, $stateParams) {
   *         return $http.get("/api/foos/"+stateParams.fooID);
   *       }
   *     }</pre>
   *
   * @param {string=} stateConfig.url
   * <a id='url'></a>
   *
   *   A url fragment with optional parameters. When a state is navigated or
   *   transitioned to, the `$stateParams` service will be populated with any 
   *   parameters that were passed.
   *
   *   (See {@link ui.router.util.type:UrlMatcher UrlMatcher} `UrlMatcher`} for
   *   more details on acceptable patterns )
   *
   * examples:
   * <pre>url: "/home"
   * url: "/users/:userid"
   * url: "/books/{bookid:[a-zA-Z_-]}"
   * url: "/books/{categoryid:int}"
   * url: "/books/{publishername:string}/{categoryid:int}"
   * url: "/messages?before&after"
   * url: "/messages?{before:date}&{after:date}"
   * url: "/messages/:mailboxid?{before:date}&{after:date}"
   * </pre>
   *
   * @param {object=} stateConfig.views
   * <a id='views'></a>
   * an optional map&lt;string, object&gt; which defined multiple views, or targets views
   * manually/explicitly.
   *
   * Examples:
   *
   * Targets three named `ui-view`s in the parent state's template
   * <pre>views: {
   *     header: {
   *       controller: "headerCtrl",
   *       templateUrl: "header.html"
   *     }, body: {
   *       controller: "bodyCtrl",
   *       templateUrl: "body.html"
   *     }, footer: {
   *       controller: "footCtrl",
   *       templateUrl: "footer.html"
   *     }
   *   }</pre>
   *
   * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
   * <pre>views: {
   *     'header@top': {
   *       controller: "msgHeaderCtrl",
   *       templateUrl: "msgHeader.html"
   *     }, 'body': {
   *       controller: "messagesCtrl",
   *       templateUrl: "messages.html"
   *     }
   *   }</pre>
   *
   * @param {boolean=} [stateConfig.abstract=false]
   * <a id='abstract'></a>
   * An abstract state will never be directly activated,
   *   but can provide inherited properties to its common children states.
   * <pre>abstract: true</pre>
   *
   * @param {function=} stateConfig.onEnter
   * <a id='onEnter'></a>
   *
   * Callback function for when a state is entered. Good way
   *   to trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explicitly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onEnter: function(MyService, $stateParams) {
   *     MyService.foo($stateParams.myParam);
   * }</pre>
   *
   * @param {function=} stateConfig.onExit
   * <a id='onExit'></a>
   *
   * Callback function for when a state is exited. Good way to
   *   trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explicitly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onExit: function(MyService, $stateParams) {
   *     MyService.cleanup($stateParams.myParam);
   * }</pre>
   *
   * @param {boolean=} [stateConfig.reloadOnSearch=true]
   * <a id='reloadOnSearch'></a>
   *
   * If `false`, will not retrigger the same state
   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
   *   Useful for when you'd like to modify $location.search() without triggering a reload.
   * <pre>reloadOnSearch: false</pre>
   *
   * @param {object=} stateConfig.data
   * <a id='data'></a>
   *
   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
   *   prototypally inherited.  In other words, adding a data property to a state adds it to
   *   the entire subtree via prototypal inheritance.
   *
   * <pre>data: {
   *     requiredRole: 'foo'
   * } </pre>
   *
   * @param {object=} stateConfig.params
   * <a id='params'></a>
   *
   * A map which optionally configures parameters declared in the `url`, or
   *   defines additional non-url parameters.  For each parameter being
   *   configured, add a configuration object keyed to the name of the parameter.
   *
   *   Each parameter configuration object may contain the following properties:
   *
   *   - ** value ** - {object|function=}: specifies the default value for this
   *     parameter.  This implicitly sets this parameter as optional.
   *
   *     When UI-Router routes to a state and no value is
   *     specified for this parameter in the URL or transition, the
   *     default value will be used instead.  If `value` is a function,
   *     it will be injected and invoked, and the return value used.
   *
   *     *Note*: `undefined` is treated as "no default value" while `null`
   *     is treated as "the default value is `null`".
   *
   *     *Shorthand*: If you only need to configure the default value of the
   *     parameter, you may use a shorthand syntax.   In the **`params`**
   *     map, instead mapping the param name to a full parameter configuration
   *     object, simply set map it to the default parameter value, e.g.:
   *
   * <pre>// define a parameter's default value
   * params: {
   *     param1: { value: "defaultValue" }
   * }
   * // shorthand default values
   * params: {
   *     param1: "defaultValue",
   *     param2: "param2Default"
   * }</pre>
   *
   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
   *     treated as an array of values.  If you specified a Type, the value will be
   *     treated as an array of the specified Type.  Note: query parameter values
   *     default to a special `"auto"` mode.
   *
   *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
   *     value (e.g.: `{ foo: '1' }`).
   *
   * <pre>params: {
   *     param1: { array: true }
   * }</pre>
   *
   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
   *     configured default squash policy.
   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
   *
   *   There are three squash settings:
   *
   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
   *       This can allow for cleaner looking URLs.
   *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
   *
   * <pre>params: {
   *     param1: {
   *       value: "defaultId",
   *       squash: true
   * } }
   * // squash "defaultValue" to "~"
   * params: {
   *     param1: {
   *       value: "defaultValue",
   *       squash: "~"
   * } }
   * </pre>
   *
   *
   * @example
   * <pre>
   * // Some state name examples
   *
   * // stateName can be a single top-level name (must be unique).
   * $stateProvider.state("home", {});
   *
   * // Or it can be a nested state name. This state is a child of the
   * // above "home" state.
   * $stateProvider.state("home.newest", {});
   *
   * // Nest states as deeply as needed.
   * $stateProvider.state("home.newest.abc.xyz.inception", {});
   *
   * // state() returns $stateProvider, so you can chain state declarations.
   * $stateProvider
   *   .state("home", {})
   *   .state("about", {})
   *   .state("contacts", {});
   * </pre>
   *
   */
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  /**
   * @ngdoc object
   * @name ui.router.state.$state
   *
   * @requires $rootScope
   * @requires $q
   * @requires ui.router.state.$view
   * @requires $injector
   * @requires ui.router.util.$resolve
   * @requires ui.router.state.$stateParams
   * @requires ui.router.router.$urlRouter
   *
   * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
   * you'd like to test against the current active state.
   * @property {object} current A reference to the state's config object. However 
   * you passed it in. Useful for accessing custom data.
   * @property {object} transition Currently pending transition. A promise that'll 
   * resolve or reject.
   *
   * @description
   * `$state` service is responsible for representing states as well as transitioning
   * between them. It also provides interfaces to ask for current state or even states
   * you're coming from.
   */
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {

    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
    var TransitionPrevented = $q.reject(new Error('transition prevented'));
    var TransitionAborted = $q.reject(new Error('transition aborted'));
    var TransitionFailed = $q.reject(new Error('transition failed'));

    // Handles the case where a state which is the target of a transition is not found, and the user
    // can optionally retry or defer the transition
    function handleRedirect(redirect, state, params, options) {
      /**
       * @ngdoc event
       * @name ui.router.state.$state#$stateNotFound
       * @eventOf ui.router.state.$state
       * @eventType broadcast on root scope
       * @description
       * Fired when a requested state **cannot be found** using the provided state name during transition.
       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
       *
       * @param {Object} event Event object.
       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
       * @param {State} fromState Current state object.
       * @param {Object} fromParams Current state params.
       *
       * @example
       *
       * <pre>
       * // somewhere, assume lazy.state has not been defined
       * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
       *
       * // somewhere else
       * $scope.$on('$stateNotFound',
       * function(event, unfoundState, fromState, fromParams){
       *     console.log(unfoundState.to); // "lazy.state"
       *     console.log(unfoundState.toParams); // {a:1, b:2}
       *     console.log(unfoundState.options); // {inherit:false} + default options
       * })
       * </pre>
       */
      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

      if (evt.defaultPrevented) {
        $urlRouter.update();
        return TransitionAborted;
      }

      if (!evt.retry) {
        return null;
      }

      // Allow the handler to return a promise to defer state lookup retry
      if (options.$retry) {
        $urlRouter.update();
        return TransitionFailed;
      }
      var retryTransition = $state.transition = $q.when(evt.retry);

      retryTransition.then(function() {
        if (retryTransition !== $state.transition) return TransitionSuperseded;
        redirect.options.$retry = true;
        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
      }, function() {
        return TransitionAborted;
      });
      $urlRouter.update();

      return retryTransition;
    }

    root.locals = { resolve: null, globals: { $stateParams: {} } };

    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#reload
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method that force reloads the current state. All resolves are re-resolved,
     * controllers reinstantiated, and events re-fired.
     *
     * @example
     * <pre>
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>
     *
     * @param {string=|object=} state - A state name or a state object, which is the root of the resolves to be re-resolved.
     * @example
     * <pre>
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item' 
     * //and current state is 'contacts.detail.item'
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>

     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.reload = function reload(state) {
      return $state.transitionTo($state.current, $stateParams, { reload: state || true, inherit: false, notify: true});
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#go
     * @methodOf ui.router.state.$state
     *
     * @description
     * Convenience method for transitioning to a new state. `$state.go` calls 
     * `$state.transitionTo` internally but automatically sets options to 
     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. 
     * This allows you to easily use an absolute or relative to path and specify 
     * only the parameters you'd like to update (while letting unspecified parameters 
     * inherit from the currently active ancestor states).
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * </pre>
     * <img src='../ngdoc_assets/StateGoExamples.png'/>
     *
     * @param {string} to Absolute state name or relative state path. Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to a parent state
     * - `$state.go('^.sibling')` - will go to a sibling state
     * - `$state.go('.child.grandchild')` - will go to grandchild state
     *
     * @param {object=} params A map of the parameters that will be sent to the state, 
     * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
     * defined parameters. Only parameters specified in the state definition can be overridden, new 
     * parameters will be ignored. This allows, for example, going to a sibling state that shares parameters
     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
     * will get you all current parameters, etc.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false|string|object}, If `true` will force transition even if no state or params
     *    have changed.  It will reload the resolves and views of the current state and parent states.
     *    If `reload` is a string (or state object), the state object is fetched (by name, or object reference); and \
     *    the transition reloads the resolves and views for that matched state, and all its children states.
     *
     * @returns {promise} A promise representing the state of the new transition.
     *
     * Possible success values:
     *
     * - $state.current
     *
     * <br/>Possible rejection values:
     *
     * - 'transition superseded' - when a newer transition has been started after this one
     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
     *   when a `$stateNotFound` `event.retry` promise errors.
     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
     * - *resolve error* - when an error has occurred with a `resolve`
     *
     */
    $state.go = function go(to, params, options) {
      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#transitionTo
     * @methodOf ui.router.state.$state
     *
     * @description
     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * </pre>
     *
     * @param {string} to State name.
     * @param {object=} toParams A map of the parameters that will be sent to the state,
     * will populate $stateParams.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false|string=|object=}, If `true` will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *    if String, then will reload the state with the name given in reload, and any children.
     *    if Object, then a stateObj is expected, will reload the state found in stateObj, and any children.
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.transitionTo = function transitionTo(to, toParams, options) {
      toParams = toParams || {};
      options = extend({
        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
      }, options || {});

      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
      var evt, toState = findState(to, options.relative);

      // Store the hash param for later (since it will be stripped out by various methods)
      var hash = toParams['#'];

      if (!isDefined(toState)) {
        var redirect = { to: to, toParams: toParams, options: options };
        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

        if (redirectResult) {
          return redirectResult;
        }

        // Always retry once if the $stateNotFound was not prevented
        // (handles either redirect changed or state lazy-definition)
        to = redirect.to;
        toParams = redirect.toParams;
        options = redirect.options;
        toState = findState(to, options.relative);

        if (!isDefined(toState)) {
          if (!options.relative) throw new Error("No such state '" + to + "'");
          throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
        }
      }
      if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      if (!toState.params.$$validates(toParams)) return TransitionFailed;

      toParams = toState.params.$$values(toParams);
      to = toState;

      var toPath = to.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

      if (!options.reload) {
        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      } else if (isString(options.reload) || isObject(options.reload)) {
        if (isObject(options.reload) && !options.reload.name) {
          throw new Error('Invalid reload state object');
        }
        
        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
        if (options.reload && !reloadState) {
          throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
        }

        while (state && state === fromPath[keep] && state !== reloadState) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change
      // that we've initiated ourselves, because we might accidentally abort a legitimate
      // transition initiated from code?
      if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
        if (hash) toParams['#'] = hash;
        $state.params = toParams;
        copy($state.params, $stateParams);
        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
        if (options.location && to.navigable && to.navigable.url) {
          $urlRouter.push(to.navigable.url, toParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
          $urlRouter.update(true);
        }
        $state.transition = null;
        return $q.when($state.current);
      }

      // Filter parameters before we pass them to event handlers etc.
      toParams = filterByKeys(to.params.$$keys(), toParams || {});
      
      // Re-add the saved hash before we start returning things or broadcasting $stateChangeStart
      if (hash) toParams['#'] = hash;
      
      // Broadcast start event and cancel the transition if requested
      if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeStart
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when the state transition **begins**. You can use `event.preventDefault()`
         * to prevent the transition from happening and then the transition promise will be
         * rejected with a `'transition prevented'` value.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         *
         * @example
         *
         * <pre>
         * $rootScope.$on('$stateChangeStart',
         * function(event, toState, toParams, fromState, fromParams){
         *     event.preventDefault();
         *     // transitionTo() promise will be rejected with
         *     // a 'transition prevented' error
         * })
         * </pre>
         */
        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
          $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
          //Don't update and resync url if there's been a new transition started. see issue #2238, #600
          if ($state.transition == null) $urlRouter.update();
          return TransitionPrevented;
        }
      }

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);

      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
      }

      // Once everything is resolved, we are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit 'from' states not kept
        for (l = fromPath.length - 1; l >= keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l = keep; l < toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Run it again, to catch any transitions in callbacks
        if ($state.transition !== transition) return TransitionSuperseded;

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        if (options.location && to.navigable) {
          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
        }

        if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeSuccess
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired once the state transition is **complete**.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         */
          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
        }
        $urlRouter.update(true);

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeError
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when an **error occurs** during transition. It's important to note that if you
         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
         * they will not throw traditionally. You must listen for this $stateChangeError event to
         * catch **ALL** errors.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         * @param {Error} error The resolve error object.
         */
        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

        if (!evt.defaultPrevented) {
            $urlRouter.update();
        }

        return $q.reject(error);
      });

      return transition;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#is
     * @methodOf ui.router.state.$state
     *
     * @description
     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
     * but only checks for the full state name. If params is supplied then it will be
     * tested for strict equality against the current active params object, so all params
     * must match with none missing and no extras.
     *
     * @example
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * </pre>
     *
     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
     * test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it is the state.
     */
    $state.is = function is(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) { return undefined; }
      if ($state.$current !== state) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#includes
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * @example
     * Partial and relative names
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     *
     * // Using relative names (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
     * </pre>
     *
     * Basic globbing patterns
     * <pre>
     * $state.$current.name = 'contacts.details.item.url';
     *
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * </pre>
     *
     * @param {string} stateOrName A partial name, relative name, or glob pattern
     * to be searched for within the current state name.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
     * that you'd like to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
     * .includes will test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    $state.includes = function includes(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      if (isString(stateOrName) && isGlob(stateOrName)) {
        if (!doesStateMatchGlob(stateOrName)) {
          return false;
        }
        stateOrName = $state.$current.name;
      }

      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) { return undefined; }
      if (!isDefined($state.$current.includes[state.name])) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
    };


    /**
     * @ngdoc function
     * @name ui.router.state.$state#href
     * @methodOf ui.router.state.$state
     *
     * @description
     * A url generation method that returns the compiled url for the given state populated with the given params.
     *
     * @example
     * <pre>
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * </pre>
     *
     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
     * @param {object=} params An object of parameter values to fill the state's required parameters.
     * @param {object=} options Options object. The options are:
     *
     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
     *    ancestor with a valid url).
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     * 
     * @returns {string} compiled state url
     */
    $state.href = function href(stateOrName, params, options) {
      options = extend({
        lossy:    true,
        inherit:  true,
        absolute: false,
        relative: $state.$current
      }, options || {});

      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) return null;
      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
      
      var nav = (state && options.lossy) ? state.navigable : state;

      if (!nav || nav.url === undefined || nav.url === null) {
        return null;
      }
      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {
        absolute: options.absolute
      });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#get
     * @methodOf ui.router.state.$state
     *
     * @description
     * Returns the state configuration object for any specific state or all states.
     *
     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
     * the requested state. If not provided, returns an array of ALL state configs.
     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
     * @returns {Object|Array} State configuration object or array of all objects.
     */
    $state.get = function (stateOrName, context) {
      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });
      var state = findState(stateOrName, context || $state.$current);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [dst.resolve.then(function (globals) {
        dst.globals = globals;
      })];
      if (inherited) promises.push(inherited);

      function resolveViews() {
        var viewsPromises = [];

        // Resolve template and dependencies for all views.
        forEach(state.views, function (view, name) {
          var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
          injectables.$template = [ function () {
            return $view.load(name, { view: view, locals: dst.globals, params: $stateParams, notify: options.notify }) || '';
          }];

          viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
            // References to the controller (only instantiated at link time)
            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
              var injectLocals = angular.extend({}, injectables, dst.globals);
              result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
            } else {
              result.$$controller = view.controller;
            }
            // Provide access to the state itself for internal use
            result.$$state = state;
            result.$$controllerAs = view.controllerAs;
            dst[name] = result;
          }));
        });

        return $q.all(viewsPromises).then(function(){
          return dst.globals;
        });
      }

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(resolveViews).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
    // Return true if there are no differences in non-search (path/object) params, false if there are differences
    function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
      // Identify whether all the parameters that differ between `fromParams` and `toParams` were search params.
      function notSearchParam(key) {
        return fromAndToState.params[key].location != "search";
      }
      var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
      var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
      var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
      return nonQueryParamSet.$$equals(fromParams, toParams);
    }

    // If reload was not explicitly requested
    // and we're transitioning to the same state we're already in
    // and    the locals didn't change
    //     or they changed in a way that doesn't merit reloading
    //        (reloadOnParams:false, or reloadOnSearch.false and only search params changed)
    // Then return true.
    if (!options.reload && to === from &&
      (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
      return true;
    }
  }
}

angular.module('ui.router.state')
  .factory('$stateParams', function () { return {}; })
  .provider('$state', $StateProvider);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  /**
   * @ngdoc object
   * @name ui.router.state.$view
   *
   * @requires ui.router.util.$templateFactory
   * @requires $rootScope
   *
   * @description
   *
   */
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      /**
       * @ngdoc function
       * @name ui.router.state.$view#load
       * @methodOf ui.router.state.$view
       *
       * @description
       *
       * @param {string} name name
       * @param {object} options option object.
       */
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$uiViewScrollProvider
 *
 * @description
 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
 */
function $ViewScrollProvider() {

  var useAnchorScroll = false;

  /**
   * @ngdoc function
   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
   * @methodOf ui.router.state.$uiViewScrollProvider
   *
   * @description
   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
   * scrolling based on the url anchor.
   */
  this.useAnchorScroll = function () {
    useAnchorScroll = true;
  };

  /**
   * @ngdoc object
   * @name ui.router.state.$uiViewScroll
   *
   * @requires $anchorScroll
   * @requires $timeout
   *
   * @description
   * When called with a jqLite element, it scrolls the element into view (after a
   * `$timeout` so the DOM has time to refresh).
   *
   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
   */
  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
    if (useAnchorScroll) {
      return $anchorScroll;
    }

    return function ($element) {
      return $timeout(function () {
        $element[0].scrollIntoView();
      }, 0, false);
    };
  }];
}

angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

var ngMajorVer = angular.version.major;
var ngMinorVer = angular.version.minor;
/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-view
 *
 * @requires ui.router.state.$state
 * @requires $compile
 * @requires $controller
 * @requires $injector
 * @requires ui.router.state.$uiViewScroll
 * @requires $document
 *
 * @restrict ECA
 *
 * @description
 * The ui-view directive tells $state where to place your templates.
 *
 * @param {string=} name A view name. The name should be unique amongst the other views in the
 * same state. You can have views of the same name that live in different states.
 *
 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
 * scroll ui-view elements into view when they are populated during a state activation.
 *
 * @param {string=} noanimation If truthy, the non-animated renderer will be selected (no animations
 * will be applied to the ui-view)
 *
 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
 *
 * @param {string=} onload Expression to evaluate whenever the view updates.
 * 
 * @example
 * A view can be unnamed or named. 
 * <pre>
 * <!-- Unnamed -->
 * <div ui-view></div> 
 * 
 * <!-- Named -->
 * <div ui-view="viewName"></div>
 * </pre>
 *
 * You can only have one unnamed view within any template (or root html). If you are only using a 
 * single view and it is unnamed then you can populate it like so:
 * <pre>
 * <div ui-view></div> 
 * $stateProvider.state("home", {
 *   template: "<h1>HELLO!</h1>"
 * })
 * </pre>
 * 
 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
 * config property, by name, in this case an empty name:
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 * 
 * But typically you'll only use the views property if you name your view or have more than one view 
 * in the same template. There's not really a compelling reason to name a view if its the only one, 
 * but you could if you wanted, like so:
 * <pre>
 * <div ui-view="main"></div>
 * </pre> 
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "main": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 * 
 * Really though, you'll use views to set up multiple views:
 * <pre>
 * <div ui-view></div>
 * <div ui-view="chart"></div> 
 * <div ui-view="data"></div> 
 * </pre>
 * 
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     },
 *     "chart": {
 *       template: "<chart_thing/>"
 *     },
 *     "data": {
 *       template: "<data_thing/>"
 *     }
 *   }    
 * })
 * </pre>
 *
 * Examples for `autoscroll`:
 *
 * <pre>
 * <!-- If autoscroll present with no expression,
 *      then scroll ui-view into view -->
 * <ui-view autoscroll/>
 *
 * <!-- If autoscroll present with valid expression,
 *      then scroll ui-view into view if expression evaluates to true -->
 * <ui-view autoscroll='true'/>
 * <ui-view autoscroll='false'/>
 * <ui-view autoscroll='scopeVariable'/>
 * </pre>
 */
$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
function $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {

  function getService() {
    return ($injector.has) ? function(service) {
      return $injector.has(service) ? $injector.get(service) : null;
    } : function(service) {
      try {
        return $injector.get(service);
      } catch (e) {
        return null;
      }
    };
  }

  var service = getService(),
      $animator = service('$animator'),
      $animate = service('$animate');

  // Returns a set of DOM manipulation functions based on which Angular version
  // it should use
  function getRenderer(attrs, scope) {
    var statics = {
      enter: function (element, target, cb) { target.after(element); cb(); },
      leave: function (element, cb) { element.remove(); cb(); }
    };

    if (!!attrs.noanimation) return statics;

    function animEnabled(element) {
      if (ngMajorVer === 1 && ngMinorVer >= 4) return !!$animate.enabled(element);
      if (ngMajorVer === 1 && ngMinorVer >= 2) return !!$animate.enabled();
      return (!!$animator);
    }

    // ng 1.2+
    if ($animate) {
      return {
        enter: function(element, target, cb) {
          if (!animEnabled(element)) {
            statics.enter(element, target, cb);
          } else if (angular.version.minor > 2) {
            $animate.enter(element, null, target).then(cb);
          } else {
            $animate.enter(element, null, target, cb);
          }
        },
        leave: function(element, cb) {
          if (!animEnabled(element)) {
            statics.leave(element, cb);
          } else if (angular.version.minor > 2) {
            $animate.leave(element).then(cb);
          } else {
            $animate.leave(element, cb);
          }
        }
      };
    }

    // ng 1.1.5
    if ($animator) {
      var animate = $animator && $animator(scope, attrs);

      return {
        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },
        leave: function(element, cb) { animate.leave(element); cb(); }
      };
    }

    return statics;
  }

  var directive = {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    compile: function (tElement, tAttrs, $transclude) {
      return function (scope, $element, attrs) {
        var previousEl, currentEl, currentScope, latestLocals,
            onloadExp     = attrs.onload || '',
            autoScrollExp = attrs.autoscroll,
            renderer      = getRenderer(attrs, scope);

        scope.$on('$stateChangeSuccess', function() {
          updateView(false);
        });

        updateView(true);

        function cleanupLastView() {
          var _previousEl = previousEl;
          var _currentScope = currentScope;

          if (_currentScope) {
            _currentScope._willBeDestroyed = true;
          }

          function cleanOld() {
            if (_previousEl) {
              _previousEl.remove();
            }

            if (_currentScope) {
              _currentScope.$destroy();
            }
          }

          if (currentEl) {
            renderer.leave(currentEl, function() {
              cleanOld();
              previousEl = null;
            });

            previousEl = currentEl;
          } else {
            cleanOld();
            previousEl = null;
          }

          currentEl = null;
          currentScope = null;
        }

        function updateView(firstTime) {
          var newScope,
              name            = getUiViewName(scope, attrs, $element, $interpolate),
              previousLocals  = name && $state.$current && $state.$current.locals[name];

          if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed) return; // nothing to do
          newScope = scope.$new();
          latestLocals = $state.$current.locals[name];

          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoading
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description
           *
           * Fired once the view **begins loading**, *before* the DOM is rendered.
           *
           * @param {Object} event Event object.
           * @param {string} viewName Name of the view.
           */
          newScope.$emit('$viewContentLoading', name);

          var clone = $transclude(newScope, function(clone) {
            renderer.enter(clone, $element, function onUiViewEnter() {
              if(currentScope) {
                currentScope.$emit('$viewContentAnimationEnded');
              }

              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                $uiViewScroll(clone);
              }
            });
            cleanupLastView();
          });

          currentEl = clone;
          currentScope = newScope;
          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoaded
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description
           * Fired once the view is **loaded**, *after* the DOM is rendered.
           *
           * @param {Object} event Event object.
           * @param {string} viewName Name of the view.
           */
          currentScope.$emit('$viewContentLoaded', name);
          currentScope.$eval(onloadExp);
        }
      };
    }
  };

  return directive;
}

$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
function $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {
  return {
    restrict: 'ECA',
    priority: -400,
    compile: function (tElement) {
      var initial = tElement.html();
      return function (scope, $element, attrs) {
        var current = $state.$current,
            name = getUiViewName(scope, attrs, $element, $interpolate),
            locals  = current && current.locals[name];

        if (! locals) {
          return;
        }

        $element.data('$uiView', { name: name, state: locals.$$state });
        $element.html(locals.$template ? locals.$template : initial);

        var link = $compile($element.contents());

        if (locals.$$controller) {
          locals.$scope = scope;
          locals.$element = $element;
          var controller = $controller(locals.$$controller, locals);
          if (locals.$$controllerAs) {
            scope[locals.$$controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }

        link(scope);
      };
    }
  };
}

/**
 * Shared ui-view code for both directives:
 * Given scope, element, and its attributes, return the view's name
 */
function getUiViewName(scope, attrs, element, $interpolate) {
  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
  var inherited = element.inheritedData('$uiView');
  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);
angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

function parseStateRef(ref, current) {
  var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
  if (preparsed) ref = current + '(' + preparsed[1] + ')';
  parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

function stateContext(el) {
  var stateData = el.parent().inheritedData('$uiView');

  if (stateData && stateData.state && stateData.state.name) {
    return stateData.state;
  }
}

function getTypeInfo(el) {
  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
  var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
  var isForm = el[0].nodeName === "FORM";

  return {
    attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
    isAnchor: el.prop("tagName").toUpperCase() === "A",
    clickable: !isForm
  };
}

function clickHook(el, $state, $timeout, type, current) {
  return function(e) {
    var button = e.which || e.button, target = current();

    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
      var transition = $timeout(function() {
        $state.go(target.state, target.params, target.options);
      });
      e.preventDefault();

      // if the state has no URL, ignore one preventDefault from the <a> directive.
      var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1: 0;

      e.preventDefault = function() {
        if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition);
      };
    }
  };
}

function defaultOpts(el, $state) {
  return { relative: stateContext(el) || $state.$current, inherit: true };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref
 *
 * @requires ui.router.state.$state
 * @requires $timeout
 *
 * @restrict A
 *
 * @description
 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated
 * URL, the directive will automatically generate & update the `href` attribute via
 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking
 * the link will trigger a state transition with optional parameters.
 *
 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be
 * handled natively by the browser.
 *
 * You can also use relative state paths within ui-sref, just like the relative
 * paths passed to `$state.go()`. You just need to be aware that the path is relative
 * to the state that the link lives in, in other words the state that loaded the
 * template containing the link.
 *
 * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
 * and `reload`.
 *
 * @example
 * Here's an example of how you'd use ui-sref and how it would compile. If you have the
 * following template:
 * <pre>
 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
 *     </li>
 * </ul>
 * </pre>
 *
 * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
 * <pre>
 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
 *
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
 *     </li>
 * </ul>
 *
 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
 * </pre>
 *
 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}
 */
$StateRefDirective.$inject = ['$state', '$timeout'];
function $StateRefDirective($state, $timeout) {
  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var ref    = parseStateRef(attrs.uiSref, $state.current.name);
      var def    = { state: ref.state, href: null, params: null };
      var type   = getTypeInfo(element);
      var active = uiSrefActive[1] || uiSrefActive[0];

      def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});

      var update = function(val) {
        if (val) def.params = angular.copy(val);
        def.href = $state.href(ref.state, def.params, def.options);

        if (active) active.$$addStateInfo(ref.state, def.params);
        if (def.href !== null) attrs.$set(type.attr, def.href);
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(val) { if (val !== def.params) update(val); }, true);
        def.params = angular.copy(scope.$eval(ref.paramExpr));
      }
      update();

      if (!type.clickable) return;
      element.bind("click", clickHook(element, $state, $timeout, type, function() { return def; }));
    }
  };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-state
 *
 * @requires ui.router.state.uiSref
 *
 * @restrict A
 *
 * @description
 * Much like ui-sref, but will accept named $scope properties to evaluate for a state definition,
 * params and override options.
 *
 * @param {string} ui-state 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-state-params params to pass to {@link ui.router.state.$state#href $state.href()}
 * @param {Object} ui-state-opts options to pass to {@link ui.router.state.$state#go $state.go()}
 */
$StateRefDynamicDirective.$inject = ['$state', '$timeout'];
function $StateRefDynamicDirective($state, $timeout) {
  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var type   = getTypeInfo(element);
      var active = uiSrefActive[1] || uiSrefActive[0];
      var group  = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
      var watch  = '[' + group.map(function(val) { return val || 'null'; }).join(', ') + ']';
      var def    = { state: null, params: null, options: null, href: null };

      function runStateRefLink (group) {
        def.state = group[0]; def.params = group[1]; def.options = group[2];
        def.href = $state.href(def.state, def.params, def.options);

        if (active) active.$$addStateInfo(def.state, def.params);
        if (def.href) attrs.$set(type.attr, def.href);
      }

      scope.$watch(watch, runStateRefLink, true);
      runStateRefLink(scope.$eval(watch));

      if (!type.clickable) return;
      element.bind("click", clickHook(element, $state, $timeout, type, function() { return def; }));
    }
  };
}


/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * A directive working alongside ui-sref to add classes to an element when the
 * related ui-sref directive's state is active, and removing them when it is inactive.
 * The primary use-case is to simplify the special appearance of navigation menus
 * relying on `ui-sref`, by having the "active" state's menu button appear different,
 * distinguishing it from the inactive menu items.
 *
 * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
 * ui-sref-active found at the same level or above the ui-sref will be used.
 *
 * Will activate when the ui-sref's target state or any child state is active. If you
 * need to activate only when the ui-sref target state is active and *not* any of
 * it's children, then you will use
 * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
 *
 * @example
 * Given the following template:
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item">
 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 *
 * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
 * the resulting HTML will appear as (note the 'active' class):
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item active">
 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * The class name is interpolated **once** during the directives link time (any further changes to the
 * interpolated value are ignored).
 *
 * Multiple classes may be specified in a space-separated format:
 * <pre>
 * <ul>
 *   <li ui-sref-active='class1 class2 class3'>
 *     <a ui-sref="app.user">link</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * It is also possible to pass ui-sref-active an expression that evaluates
 * to an object hash, whose keys represent active class names and whose
 * values represent the respective state names/globs.
 * ui-sref-active will match if the current active state **includes** any of
 * the specified state names/globs, even the abstract ones.
 *
 * @Example
 * Given the following template, with "admin" being an abstract state:
 * <pre>
 * <div ui-sref-active="{'active': 'admin.*'}">
 *   <a ui-sref-active="active" ui-sref="admin.roles">Roles</a>
 * </div>
 * </pre>
 *
 * When the current state is "admin.roles" the "active" class will be applied
 * to both the <div> and <a> elements. It is important to note that the state
 * names/globs passed to ui-sref-active shadow the state provided by ui-sref.
 */

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active-eq
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
 * when the exact target state used in the `ui-sref` is active; no child states.
 *
 */
$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
function $StateRefActiveDirective($state, $stateParams, $interpolate) {
  return  {
    restrict: "A",
    controller: ['$scope', '$element', '$attrs', '$timeout', function ($scope, $element, $attrs, $timeout) {
      var states = [], activeClasses = {}, activeEqClass, uiSrefActive;

      // There probably isn't much point in $observing this
      // uiSrefActive and uiSrefActiveEq share the same directive object with some
      // slight difference in logic routing
      activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);

      try {
        uiSrefActive = $scope.$eval($attrs.uiSrefActive);
      } catch (e) {
        // Do nothing. uiSrefActive is not a valid expression.
        // Fall back to using $interpolate below
      }
      uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
      if (isObject(uiSrefActive)) {
        forEach(uiSrefActive, function(stateOrName, activeClass) {
          if (isString(stateOrName)) {
            var ref = parseStateRef(stateOrName, $state.current.name);
            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
          }
        });
      }

      // Allow uiSref to communicate with uiSrefActive[Equals]
      this.$$addStateInfo = function (newState, newParams) {
        // we already got an explicit state provided by ui-sref-active, so we
        // shadow the one that comes from ui-sref
        if (isObject(uiSrefActive) && states.length > 0) {
          return;
        }
        addState(newState, newParams, uiSrefActive);
        update();
      };

      $scope.$on('$stateChangeSuccess', update);

      function addState(stateName, stateParams, activeClass) {
        var state = $state.get(stateName, stateContext($element));
        var stateHash = createStateHash(stateName, stateParams);

        states.push({
          state: state || { name: stateName },
          params: stateParams,
          hash: stateHash
        });

        activeClasses[stateHash] = activeClass;
      }

      /**
       * @param {string} state
       * @param {Object|string} [params]
       * @return {string}
       */
      function createStateHash(state, params) {
        if (!isString(state)) {
          throw new Error('state should be a string');
        }
        if (isObject(params)) {
          return state + toJson(params);
        }
        params = $scope.$eval(params);
        if (isObject(params)) {
          return state + toJson(params);
        }
        return state;
      }

      // Update route state
      function update() {
        for (var i = 0; i < states.length; i++) {
          if (anyMatch(states[i].state, states[i].params)) {
            addClass($element, activeClasses[states[i].hash]);
          } else {
            removeClass($element, activeClasses[states[i].hash]);
          }

          if (exactMatch(states[i].state, states[i].params)) {
            addClass($element, activeEqClass);
          } else {
            removeClass($element, activeEqClass);
          }
        }
      }

      function addClass(el, className) { $timeout(function () { el.addClass(className); }); }
      function removeClass(el, className) { el.removeClass(className); }
      function anyMatch(state, params) { return $state.includes(state.name, params); }
      function exactMatch(state, params) { return $state.is(state.name, params); }

      update();
    }]
  };
}

angular.module('ui.router.state')
  .directive('uiSref', $StateRefDirective)
  .directive('uiSrefActive', $StateRefActiveDirective)
  .directive('uiSrefActiveEq', $StateRefActiveDirective)
  .directive('uiState', $StateRefDynamicDirective);

/**
 * @ngdoc filter
 * @name ui.router.state.filter:isState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
 */
$IsStateFilter.$inject = ['$state'];
function $IsStateFilter($state) {
  var isFilter = function (state, params) {
    return $state.is(state, params);
  };
  isFilter.$stateful = true;
  return isFilter;
}

/**
 * @ngdoc filter
 * @name ui.router.state.filter:includedByState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
 */
$IncludedByStateFilter.$inject = ['$state'];
function $IncludedByStateFilter($state) {
  var includesFilter = function (state, params, options) {
    return $state.includes(state, params, options);
  };
  includesFilter.$stateful = true;
  return  includesFilter;
}

angular.module('ui.router.state')
  .filter('isState', $IsStateFilter)
  .filter('includedByState', $IncludedByStateFilter);
})(window, window.angular);
/*!
 * Bootstrap v3.3.2 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.2",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.2",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")&&(c.prop("checked")&&this.$element.hasClass("active")?a=!1:b.find(".active").removeClass("active")),a&&c.prop("checked",!this.$element.hasClass("active")).trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active"));a&&this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=this.sliding=this.interval=this.$active=this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.2",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&"show"==b&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a(this.options.trigger).filter('[href="#'+b.id+'"], [data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.2",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0,trigger:'[data-toggle="collapse"]'},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":a.extend({},e.data(),{trigger:this});c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){b&&3===b.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=c(d),f={relatedTarget:this};e.hasClass("open")&&(e.trigger(b=a.Event("hide.bs.dropdown",f)),b.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger("hidden.bs.dropdown",f)))}))}function c(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.2",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=c(e),g=f.hasClass("open");if(b(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a('<div class="dropdown-backdrop"/>').insertAfter(a(this)).on("click",b);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(b){if(/(38|40|27|32)/.test(b.which)&&!/input|textarea/i.test(b.target.tagName)){var d=a(this);if(b.preventDefault(),b.stopPropagation(),!d.is(".disabled, :disabled")){var e=c(d),g=e.hasClass("open");if(!g&&27!=b.which||g&&27==b.which)return 27==b.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.divider):visible a",i=e.find('[role="menu"]'+h+', [role="listbox"]'+h);if(i.length){var j=i.index(b.target);38==b.which&&j>0&&j--,40==b.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",b).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",'[role="menu"]',g.prototype.keydown).on("keydown.bs.dropdown.data-api",'[role="listbox"]',g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$backdrop=this.isShown=null,this.scrollbarWidth=0,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.2",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.options.backdrop&&d.adjustBackdrop(),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in").attr("aria-hidden",!1),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$element.find(".modal-dialog").one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").attr("aria-hidden",!0).off("click.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a('<div class="modal-backdrop '+e+'" />').prependTo(this.$element).on("click.dismiss.bs.modal",a.proxy(function(a){a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus.call(this.$element[0]):this.hide.call(this))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.options.backdrop&&this.adjustBackdrop(),this.adjustDialog()},c.prototype.adjustBackdrop=function(){this.$backdrop.css("height",0).css("height",this.$element[0].scrollHeight)},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){this.bodyIsOverflowing=document.body.scrollHeight>document.documentElement.clientHeight,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right","")},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||"destroy"!=b)&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=this.options=this.enabled=this.timeout=this.hoverState=this.$element=null,this.init("tooltip",a,b)};c.VERSION="3.3.2",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(this.options.viewport.selector||this.options.viewport);for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c&&c.$tip&&c.$tip.is(":visible")?void(c.hoverState="in"):(c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide()},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.options.container?a(this.options.container):this.$element.parent(),p=this.getPosition(o);h="bottom"==h&&k.bottom+m>p.bottom?"top":"top"==h&&k.top-m<p.top?"bottom":"right"==h&&k.right+l>p.width?"left":"left"==h&&k.left-l<p.left?"right":h,f.removeClass(n).addClass(h)}var q=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(q,h);var r=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",r).emulateTransitionEnd(c.TRANSITION_DURATION):r()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top=b.top+g,b.left=b.left+h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=this.tip(),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.width&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){return this.$tip=this.$tip||a(this.options.template)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type)})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||"destroy"!=b)&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.2",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")},c.prototype.tip=function(){return this.$tip||(this.$tip=a(this.options.template)),this.$tip};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){var e=a.proxy(this.process,this);this.$body=a("body"),this.$scrollElement=a(a(c).is("body")?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",e),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.2",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b="offset",c=0;a.isWindow(this.$scrollElement[0])||(b="position",c=this.$scrollElement.scrollTop()),this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight();var d=this;this.$body.find(this.selector).map(function(){var d=a(this),e=d.data("target")||d.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[b]().top+c,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){d.offsets.push(this[0]),d.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(!e[a+1]||b<=e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.2",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu")&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()
}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=this.unpin=this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.2",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=a("body").height();"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

/*--------------------------------------------------------------------------
 * linq.js - LINQ for JavaScript
 * ver 3.0.4-Beta5 (Jun. 20th, 2013)
 *
 * created and maintained by neuecc <ils@neue.cc>
 * licensed under MIT License
 * http://linqjs.codeplex.com/
 *------------------------------------------------------------------------*/

(function (root, undefined) {
    // ReadOnly Function
    var Functions = {
        Identity: function (x) { return x; },
        True: function () { return true; },
        Blank: function () { }
    };

    // const Type
    var Types = {
        Boolean: typeof true,
        Number: typeof 0,
        String: typeof "",
        Object: typeof {},
        Undefined: typeof undefined,
        Function: typeof function () { }
    };

    // createLambda cache
    var funcCache = { "": Functions.Identity };

    // private utility methods
    var Utils = {
        // Create anonymous function from lambda expression string
        createLambda: function (expression) {
            if (expression == null) return Functions.Identity;
            if (typeof expression === Types.String) {
                // get from cache
                var f = funcCache[expression];
                if (f != null) {
                    return f;
                }

                if (expression.indexOf("=>") === -1) {
                    var regexp = new RegExp("[$]+", "g");

                    var maxLength = 0;
                    var match;
                    while ((match = regexp.exec(expression)) != null) {
                        var paramNumber = match[0].length;
                        if (paramNumber > maxLength) {
                            maxLength = paramNumber;
                        }
                    }

                    var argArray = [];
                    for (var i = 1; i <= maxLength; i++) {
                        var dollar = "";
                        for (var j = 0; j < i; j++) {
                            dollar += "$";
                        }
                        argArray.push(dollar);
                    }

                    var args = Array.prototype.join.call(argArray, ",");

                    f = new Function(args, "return " + expression);
                    funcCache[expression] = f;
                    return f;
                }
                else {
                    var expr = expression.match(/^[(\s]*([^()]*?)[)\s]*=>(.*)/);
                    f = new Function(expr[1], "return " + expr[2]);
                    funcCache[expression] = f;
                    return f;
                }
            }
            return expression;
        },

        isIEnumerable: function (obj) {
            if (typeof Enumerator !== Types.Undefined) {
                try {
                    new Enumerator(obj); // check JScript(IE)'s Enumerator
                    return true;
                }
                catch (e) { }
            }

            return false;
        },

        // IE8's defineProperty is defined but cannot use, therefore check defineProperties
        defineProperty: (Object.defineProperties != null)
            ? function (target, methodName, value) {
                Object.defineProperty(target, methodName, {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                    value: value
                })
            }
            : function (target, methodName, value) {
                target[methodName] = value;
            },

        compare: function (a, b) {
            return (a === b) ? 0
                 : (a > b) ? 1
                 : -1;
        },

        dispose: function (obj) {
            if (obj != null) obj.dispose();
        }
    };

    // IEnumerator State
    var State = { Before: 0, Running: 1, After: 2 };

    // "Enumerator" is conflict JScript's "Enumerator"
    var IEnumerator = function (initialize, tryGetNext, dispose) {
        var yielder = new Yielder();
        var state = State.Before;

        this.current = yielder.current;

        this.moveNext = function () {
            try {
                switch (state) {
                    case State.Before:
                        state = State.Running;
                        initialize();
                        // fall through
                    case State.Running:
                        if (tryGetNext.apply(yielder)) {
                            return true;
                        }
                        else {
                            this.dispose();
                            return false;
                        }
                    case State.After:
                        return false;
                }
            }
            catch (e) {
                this.dispose();
                throw e;
            }
        };

        this.dispose = function () {
            if (state != State.Running) return;

            try {
                dispose();
            }
            finally {
                state = State.After;
            }
        };
    };

    // for tryGetNext
    var Yielder = function () {
        var current = null;
        this.current = function () { return current; };
        this.yieldReturn = function (value) {
            current = value;
            return true;
        };
        this.yieldBreak = function () {
            return false;
        };
    };

    // Enumerable constuctor
    var Enumerable = function (getEnumerator) {
        this.getEnumerator = getEnumerator;
    };

    // Utility

    Enumerable.Utils = {}; // container

    Enumerable.Utils.createLambda = function (expression) {
        return Utils.createLambda(expression);
    };

    Enumerable.Utils.createEnumerable = function (getEnumerator) {
        return new Enumerable(getEnumerator);
    };

    Enumerable.Utils.createEnumerator = function (initialize, tryGetNext, dispose) {
        return new IEnumerator(initialize, tryGetNext, dispose);
    };

    Enumerable.Utils.extendTo = function (type) {
        var typeProto = type.prototype;
        var enumerableProto;

        if (type === Array) {
            enumerableProto = ArrayEnumerable.prototype;
            Utils.defineProperty(typeProto, "getSource", function () {
                return this;
            });
        }
        else {
            enumerableProto = Enumerable.prototype;
            Utils.defineProperty(typeProto, "getEnumerator", function () {
                return Enumerable.from(this).getEnumerator();
            });
        }

        for (var methodName in enumerableProto) {
            var func = enumerableProto[methodName];

            // already extended
            if (typeProto[methodName] == func) continue;

            // already defined(example Array#reverse/join/forEach...)
            if (typeProto[methodName] != null) {
                methodName = methodName + "ByLinq";
                if (typeProto[methodName] == func) continue; // recheck
            }

            if (func instanceof Function) {
                Utils.defineProperty(typeProto, methodName, func);
            }
        }
    };

    // Generator

    Enumerable.choice = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].getEnumerator != null) ? args[0].toArray()
                        : args;
                },
                function () {
                    return this.yieldReturn(args[Math.floor(Math.random() * args.length)]);
                },
                Functions.Blank);
        });
    };

    Enumerable.cycle = function () // variable argument
    {
        var args = arguments;

        return new Enumerable(function () {
            var index = 0;
            return new IEnumerator(
                function () {
                    args = (args[0] instanceof Array) ? args[0]
                        : (args[0].getEnumerator != null) ? args[0].toArray()
                        : args;
                },
                function () {
                    if (index >= args.length) index = 0;
                    return this.yieldReturn(args[index++]);
                },
                Functions.Blank);
        });
    };

    Enumerable.empty = function () {
        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return false; },
                Functions.Blank);
        });
    };

    Enumerable.from = function (obj) {
        if (obj == null) {
            return Enumerable.empty();
        }
        if (obj instanceof Enumerable) {
            return obj;
        }
        if (typeof obj == Types.Number || typeof obj == Types.Boolean) {
            return Enumerable.repeat(obj, 1);
        }
        if (typeof obj == Types.String) {
            return new Enumerable(function () {
                var index = 0;
                return new IEnumerator(
                    Functions.Blank,
                    function () {
                        return (index < obj.length) ? this.yieldReturn(obj.charAt(index++)) : false;
                    },
                    Functions.Blank);
            });
        }
        if (typeof obj != Types.Function) {
            // array or array like object
            if (typeof obj.length == Types.Number) {
                return new ArrayEnumerable(obj);
            }

            // JScript's IEnumerable
            if (!(obj instanceof Object) && Utils.isIEnumerable(obj)) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = new Enumerator(obj); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.atEnd()) ? false : this.yieldReturn(enumerator.item());
                        },
                        Functions.Blank);
                });
            }

            // WinMD IIterable<T>
            if (typeof Windows === Types.Object && typeof obj.first === Types.Function) {
                return new Enumerable(function () {
                    var isFirst = true;
                    var enumerator;
                    return new IEnumerator(
                        function () { enumerator = obj.first(); },
                        function () {
                            if (isFirst) isFirst = false;
                            else enumerator.moveNext();

                            return (enumerator.hasCurrent) ? this.yieldReturn(enumerator.current) : this.yieldBreak();
                        },
                        Functions.Blank);
                });
            }
        }

        // case function/object : Create keyValuePair[]
        return new Enumerable(function () {
            var array = [];
            var index = 0;

            return new IEnumerator(
                function () {
                    for (var key in obj) {
                        var value = obj[key];
                        if (!(value instanceof Function) && Object.prototype.hasOwnProperty.call(obj, key)) {
                            array.push({ key: key, value: value });
                        }
                    }
                },
                function () {
                    return (index < array.length)
                        ? this.yieldReturn(array[index++])
                        : false;
                },
                Functions.Blank);
        });
    },

    Enumerable.make = function (element) {
        return Enumerable.repeat(element, 1);
    };

    // Overload:function(input, pattern)
    // Overload:function(input, pattern, flags)
    Enumerable.matches = function (input, pattern, flags) {
        if (flags == null) flags = "";
        if (pattern instanceof RegExp) {
            flags += (pattern.ignoreCase) ? "i" : "";
            flags += (pattern.multiline) ? "m" : "";
            pattern = pattern.source;
        }
        if (flags.indexOf("g") === -1) flags += "g";

        return new Enumerable(function () {
            var regex;
            return new IEnumerator(
                function () { regex = new RegExp(pattern, flags); },
                function () {
                    var match = regex.exec(input);
                    return (match) ? this.yieldReturn(match) : false;
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, count)
    // Overload:function(start, count, step)
    Enumerable.range = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start - step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value += step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, count)
    // Overload:function(start, count, step)
    Enumerable.rangeDown = function (start, count, step) {
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            var index = 0;

            return new IEnumerator(
                function () { value = start + step; },
                function () {
                    return (index++ < count)
                        ? this.yieldReturn(value -= step)
                        : this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    // Overload:function(start, to)
    // Overload:function(start, to, step)
    Enumerable.rangeTo = function (start, to, step) {
        if (step == null) step = 1;

        if (start < to) {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start - step; },
                function () {
                    var next = value += step;
                    return (next <= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
        else {
            return new Enumerable(function () {
                var value;

                return new IEnumerator(
                function () { value = start + step; },
                function () {
                    var next = value -= step;
                    return (next >= to)
                        ? this.yieldReturn(next)
                        : this.yieldBreak();
                },
                Functions.Blank);
            });
        }
    };

    // Overload:function(element)
    // Overload:function(element, count)
    Enumerable.repeat = function (element, count) {
        if (count != null) return Enumerable.repeat(element).take(count);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(element); },
                Functions.Blank);
        });
    };

    Enumerable.repeatWithFinalize = function (initializer, finalizer) {
        initializer = Utils.createLambda(initializer);
        finalizer = Utils.createLambda(finalizer);

        return new Enumerable(function () {
            var element;
            return new IEnumerator(
                function () { element = initializer(); },
                function () { return this.yieldReturn(element); },
                function () {
                    if (element != null) {
                        finalizer(element);
                        element = null;
                    }
                });
        });
    };

    // Overload:function(func)
    // Overload:function(func, count)
    Enumerable.generate = function (func, count) {
        if (count != null) return Enumerable.generate(func).take(count);
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            return new IEnumerator(
                Functions.Blank,
                function () { return this.yieldReturn(func()); },
                Functions.Blank);
        });
    };

    // Overload:function()
    // Overload:function(start)
    // Overload:function(start, step)
    Enumerable.toInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start - step; },
                function () { return this.yieldReturn(value += step); },
                Functions.Blank);
        });
    };

    // Overload:function()
    // Overload:function(start)
    // Overload:function(start, step)
    Enumerable.toNegativeInfinity = function (start, step) {
        if (start == null) start = 0;
        if (step == null) step = 1;

        return new Enumerable(function () {
            var value;
            return new IEnumerator(
                function () { value = start + step; },
                function () { return this.yieldReturn(value -= step); },
                Functions.Blank);
        });
    };

    Enumerable.unfold = function (seed, func) {
        func = Utils.createLambda(func);

        return new Enumerable(function () {
            var isFirst = true;
            var value;
            return new IEnumerator(
                Functions.Blank,
                function () {
                    if (isFirst) {
                        isFirst = false;
                        value = seed;
                        return this.yieldReturn(value);
                    }
                    value = func(value);
                    return this.yieldReturn(value);
                },
                Functions.Blank);
        });
    };

    Enumerable.defer = function (enumerableFactory) {

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = Enumerable.from(enumerableFactory()).getEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : this.yieldBreak();
                },
                function () {
                    Utils.dispose(enumerator);
                });
        });
    };

    // Extension Methods

    /* Projection and Filtering Methods */

    // Overload:function(func)
    // Overload:function(func, resultSelector<element>)
    // Overload:function(func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseBreadthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var nestLevel = 0;
            var buffer = [];

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            buffer.push(enumerator.current());
                            return this.yieldReturn(resultSelector(enumerator.current(), nestLevel));
                        }

                        var next = Enumerable.from(buffer).selectMany(function (x) { return func(x); });
                        if (!next.any()) {
                            return false;
                        }
                        else {
                            nestLevel++;
                            buffer = [];
                            Utils.dispose(enumerator);
                            enumerator = next.getEnumerator();
                        }
                    }
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(func)
    // Overload:function(func, resultSelector<element>)
    // Overload:function(func, resultSelector<element, nestLevel>)
    Enumerable.prototype.traverseDepthFirst = function (func, resultSelector) {
        var source = this;
        func = Utils.createLambda(func);
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumeratorStack = [];
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (enumerator.moveNext()) {
                            var value = resultSelector(enumerator.current(), enumeratorStack.length);
                            enumeratorStack.push(enumerator);
                            enumerator = Enumerable.from(func(enumerator.current())).getEnumerator();
                            return this.yieldReturn(value);
                        }

                        if (enumeratorStack.length <= 0) return false;
                        Utils.dispose(enumerator);
                        enumerator = enumeratorStack.pop();
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Enumerable.from(enumeratorStack).forEach(function (s) { s.dispose(); });
                    }
                });
        });
    };

    Enumerable.prototype.flatten = function () {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = null;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (true) {
                        if (middleEnumerator != null) {
                            if (middleEnumerator.moveNext()) {
                                return this.yieldReturn(middleEnumerator.current());
                            }
                            else {
                                middleEnumerator = null;
                            }
                        }

                        if (enumerator.moveNext()) {
                            if (enumerator.current() instanceof Array) {
                                Utils.dispose(middleEnumerator);
                                middleEnumerator = Enumerable.from(enumerator.current())
                                    .selectMany(Functions.Identity)
                                    .flatten()
                                    .getEnumerator();
                                continue;
                            }
                            else {
                                return this.yieldReturn(enumerator.current());
                            }
                        }

                        return false;
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(middleEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.pairwise = function (selector) {
        var source = this;
        selector = Utils.createLambda(selector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    enumerator.moveNext();
                },
                function () {
                    var prev = enumerator.current();
                    return (enumerator.moveNext())
                        ? this.yieldReturn(selector(prev, enumerator.current()))
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(func)
    // Overload:function(seed,func<value,element>)
    Enumerable.prototype.scan = function (seed, func) {
        var isUseSeed;
        if (func == null) {
            func = Utils.createLambda(seed); // arguments[0]
            isUseSeed = false;
        } else {
            func = Utils.createLambda(func);
            isUseSeed = true;
        }
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var value;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (isFirst) {
                        isFirst = false;
                        if (!isUseSeed) {
                            if (enumerator.moveNext()) {
                                return this.yieldReturn(value = enumerator.current());
                            }
                        }
                        else {
                            return this.yieldReturn(value = seed);
                        }
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(value = func(value, enumerator.current()))
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(selector<element>)
    // Overload:function(selector<element,index>)
    Enumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            return new WhereSelectEnumerable(this, null, selector);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.getEnumerator(); },
                    function () {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(selector(enumerator.current(), index++))
                            : false;
                    },
                    function () { Utils.dispose(enumerator); });
            });
        }
    };

    // Overload:function(collectionSelector<element>)
    // Overload:function(collectionSelector<element,index>)
    // Overload:function(collectionSelector<element>,resultSelector)
    // Overload:function(collectionSelector<element,index>,resultSelector)
    Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {
        var source = this;
        collectionSelector = Utils.createLambda(collectionSelector);
        if (resultSelector == null) resultSelector = function (a, b) { return b; };
        resultSelector = Utils.createLambda(resultSelector);

        return new Enumerable(function () {
            var enumerator;
            var middleEnumerator = undefined;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (middleEnumerator === undefined) {
                        if (!enumerator.moveNext()) return false;
                    }
                    do {
                        if (middleEnumerator == null) {
                            var middleSeq = collectionSelector(enumerator.current(), index++);
                            middleEnumerator = Enumerable.from(middleSeq).getEnumerator();
                        }
                        if (middleEnumerator.moveNext()) {
                            return this.yieldReturn(resultSelector(enumerator.current(), middleEnumerator.current()));
                        }
                        Utils.dispose(middleEnumerator);
                        middleEnumerator = null;
                    } while (enumerator.moveNext());
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(middleEnumerator);
                    }
                });
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            return new WhereEnumerable(this, predicate);
        }
        else {
            var source = this;

            return new Enumerable(function () {
                var enumerator;
                var index = 0;

                return new IEnumerator(
                    function () { enumerator = source.getEnumerator(); },
                    function () {
                        while (enumerator.moveNext()) {
                            if (predicate(enumerator.current(), index++)) {
                                return this.yieldReturn(enumerator.current());
                            }
                        }
                        return false;
                    },
                    function () { Utils.dispose(enumerator); });
            });
        }
    };


    // Overload:function(selector<element>)
    // Overload:function(selector<element,index>)
    Enumerable.prototype.choose = function (selector) {
        selector = Utils.createLambda(selector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        var result = selector(enumerator.current(), index++);
                        if (result != null) {
                            return this.yieldReturn(result);
                        }
                    }
                    return this.yieldBreak();
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.ofType = function (type) {
        var typeName;
        switch (type) {
            case Number:
                typeName = Types.Number;
                break;
            case String:
                typeName = Types.String;
                break;
            case Boolean:
                typeName = Types.Boolean;
                break;
            case Function:
                typeName = Types.Function;
                break;
            default:
                typeName = null;
                break;
        }
        return (typeName === null)
            ? this.where(function (x) { return x instanceof type; })
            : this.where(function (x) { return typeof x === typeName; });
    };

    // mutiple arguments, last one is selector, others are enumerable
    Enumerable.prototype.zip = function () {
        var args = arguments;
        var selector = Utils.createLambda(arguments[arguments.length - 1]);

        var source = this;
        // optimized case:argument is 2
        if (arguments.length == 2) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;
                var index = 0;

                return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    secondEnumerator = Enumerable.from(second).getEnumerator();
                },
                function () {
                    if (firstEnumerator.moveNext() && secondEnumerator.moveNext()) {
                        return this.yieldReturn(selector(firstEnumerator.current(), secondEnumerator.current(), index++));
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    } finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            return new Enumerable(function () {
                var enumerators;
                var index = 0;

                return new IEnumerator(
                function () {
                    var array = Enumerable.make(source)
                        .concat(Enumerable.from(args).takeExceptLast().select(Enumerable.from))
                        .select(function (x) { return x.getEnumerator() })
                        .toArray();
                    enumerators = Enumerable.from(array);
                },
                function () {
                    if (enumerators.all(function (x) { return x.moveNext() })) {
                        var array = enumerators
                            .select(function (x) { return x.current() })
                            .toArray();
                        array.push(index++);
                        return this.yieldReturn(selector.apply(null, array));
                    }
                    else {
                        return this.yieldBreak();
                    }
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.dispose);
                });
            });
        }
    };

    // mutiple arguments
    Enumerable.prototype.merge = function () {
        var args = arguments;
        var source = this;

        return new Enumerable(function () {
            var enumerators;
            var index = -1;

            return new IEnumerator(
                function () {
                    enumerators = Enumerable.make(source)
                        .concat(Enumerable.from(args).select(Enumerable.from))
                        .select(function (x) { return x.getEnumerator() })
                        .toArray();
                },
                function () {
                    while (enumerators.length > 0) {
                        index = (index >= enumerators.length - 1) ? 0 : index + 1;
                        var enumerator = enumerators[index];

                        if (enumerator.moveNext()) {
                            return this.yieldReturn(enumerator.current());
                        }
                        else {
                            enumerator.dispose();
                            enumerators.splice(index--, 1);
                        }
                    }
                    return this.yieldBreak();
                },
                function () {
                    Enumerable.from(enumerators).forEach(Utils.dispose);
                });
        });
    };

    /* Join Methods */

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var outerEnumerator;
            var lookup;
            var innerElements = null;
            var innerCount = 0;

            return new IEnumerator(
                function () {
                    outerEnumerator = source.getEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);
                },
                function () {
                    while (true) {
                        if (innerElements != null) {
                            var innerElement = innerElements[innerCount++];
                            if (innerElement !== undefined) {
                                return this.yieldReturn(resultSelector(outerEnumerator.current(), innerElement));
                            }

                            innerElement = null;
                            innerCount = 0;
                        }

                        if (outerEnumerator.moveNext()) {
                            var key = outerKeySelector(outerEnumerator.current());
                            innerElements = lookup.get(key).toArray();
                        } else {
                            return false;
                        }
                    }
                },
                function () { Utils.dispose(outerEnumerator); });
        });
    };

    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)
    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)
    Enumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {
        outerKeySelector = Utils.createLambda(outerKeySelector);
        innerKeySelector = Utils.createLambda(innerKeySelector);
        resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator = source.getEnumerator();
            var lookup = null;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);
                },
                function () {
                    if (enumerator.moveNext()) {
                        var innerElement = lookup.get(outerKeySelector(enumerator.current()));
                        return this.yieldReturn(resultSelector(enumerator.current(), innerElement));
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    /* Set Methods */

    Enumerable.prototype.all = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var result = true;
        this.forEach(function (x) {
            if (!predicate(x)) {
                result = false;
                return false; // break
            }
        });
        return result;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.any = function (predicate) {
        predicate = Utils.createLambda(predicate);

        var enumerator = this.getEnumerator();
        try {
            if (arguments.length == 0) return enumerator.moveNext(); // case:function()

            while (enumerator.moveNext()) // case:function(predicate)
            {
                if (predicate(enumerator.current())) return true;
            }
            return false;
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    Enumerable.prototype.isEmpty = function () {
        return !this.any();
    };

    // multiple arguments
    Enumerable.prototype.concat = function () {
        var source = this;

        if (arguments.length == 1) {
            var second = arguments[0];

            return new Enumerable(function () {
                var firstEnumerator;
                var secondEnumerator;

                return new IEnumerator(
                function () { firstEnumerator = source.getEnumerator(); },
                function () {
                    if (secondEnumerator == null) {
                        if (firstEnumerator.moveNext()) return this.yieldReturn(firstEnumerator.current());
                        secondEnumerator = Enumerable.from(second).getEnumerator();
                    }
                    if (secondEnumerator.moveNext()) return this.yieldReturn(secondEnumerator.current());
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
            });
        }
        else {
            var args = arguments;

            return new Enumerable(function () {
                var enumerators;

                return new IEnumerator(
                    function () {
                        enumerators = Enumerable.make(source)
                            .concat(Enumerable.from(args).select(Enumerable.from))
                            .select(function (x) { return x.getEnumerator() })
                            .toArray();
                    },
                    function () {
                        while (enumerators.length > 0) {
                            var enumerator = enumerators[0];

                            if (enumerator.moveNext()) {
                                return this.yieldReturn(enumerator.current());
                            }
                            else {
                                enumerator.dispose();
                                enumerators.splice(0, 1);
                            }
                        }
                        return this.yieldBreak();
                    },
                    function () {
                        Enumerable.from(enumerators).forEach(Utils.dispose);
                    });
            });
        }
    };

    Enumerable.prototype.insert = function (index, second) {
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var count = 0;
            var isEnumerated = false;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    secondEnumerator = Enumerable.from(second).getEnumerator();
                },
                function () {
                    if (count == index && secondEnumerator.moveNext()) {
                        isEnumerated = true;
                        return this.yieldReturn(secondEnumerator.current());
                    }
                    if (firstEnumerator.moveNext()) {
                        count++;
                        return this.yieldReturn(firstEnumerator.current());
                    }
                    if (!isEnumerated && secondEnumerator.moveNext()) {
                        return this.yieldReturn(secondEnumerator.current());
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
        });
    };

    Enumerable.prototype.alternate = function (alternateValueOrSequence) {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var enumerator;
            var alternateSequence;
            var alternateEnumerator;

            return new IEnumerator(
                function () {
                    if (alternateValueOrSequence instanceof Array || alternateValueOrSequence.getEnumerator != null) {
                        alternateSequence = Enumerable.from(Enumerable.from(alternateValueOrSequence).toArray()); // freeze
                    }
                    else {
                        alternateSequence = Enumerable.make(alternateValueOrSequence);
                    }
                    enumerator = source.getEnumerator();
                    if (enumerator.moveNext()) buffer = enumerator.current();
                },
                function () {
                    while (true) {
                        if (alternateEnumerator != null) {
                            if (alternateEnumerator.moveNext()) {
                                return this.yieldReturn(alternateEnumerator.current());
                            }
                            else {
                                alternateEnumerator = null;
                            }
                        }

                        if (buffer == null && enumerator.moveNext()) {
                            buffer = enumerator.current(); // hasNext
                            alternateEnumerator = alternateSequence.getEnumerator();
                            continue; // GOTO
                        }
                        else if (buffer != null) {
                            var retVal = buffer;
                            buffer = null;
                            return this.yieldReturn(retVal);
                        }

                        return this.yieldBreak();
                    }
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    }
                    finally {
                        Utils.dispose(alternateEnumerator);
                    }
                });
        });
    };

    // Overload:function(value)
    // Overload:function(value, compareSelector)
    Enumerable.prototype.contains = function (value, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var enumerator = this.getEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (compareSelector(enumerator.current()) === value) return true;
            }
            return false;
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    Enumerable.prototype.defaultIfEmpty = function (defaultValue) {
        var source = this;
        if (defaultValue === undefined) defaultValue = null;

        return new Enumerable(function () {
            var enumerator;
            var isFirst = true;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        isFirst = false;
                        return this.yieldReturn(enumerator.current());
                    }
                    else if (isFirst) {
                        isFirst = false;
                        return this.yieldReturn(defaultValue);
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function()
    // Overload:function(compareSelector)
    Enumerable.prototype.distinct = function (compareSelector) {
        return this.except(Enumerable.empty(), compareSelector);
    };

    Enumerable.prototype.distinctUntilChanged = function (compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var compareKey;
            var initial;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        var key = compareSelector(enumerator.current());

                        if (initial) {
                            initial = false;
                            compareKey = key;
                            return this.yieldReturn(enumerator.current());
                        }

                        if (compareKey === key) {
                            continue;
                        }

                        compareKey = key;
                        return this.yieldReturn(enumerator.current());
                    }
                    return this.yieldBreak();
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.except = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    keys = new Dictionary(compareSelector);
                    Enumerable.from(second).forEach(function (key) { keys.add(key); });
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.current();
                        if (!keys.contains(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.intersect = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var keys;
            var outs;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();

                    keys = new Dictionary(compareSelector);
                    Enumerable.from(second).forEach(function (key) { keys.add(key); });
                    outs = new Dictionary(compareSelector);
                },
                function () {
                    while (enumerator.moveNext()) {
                        var current = enumerator.current();
                        if (!outs.contains(current) && keys.contains(current)) {
                            outs.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(second)
    // Overload:function(second, compareSelector)
    Enumerable.prototype.sequenceEqual = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);

        var firstEnumerator = this.getEnumerator();
        try {
            var secondEnumerator = Enumerable.from(second).getEnumerator();
            try {
                while (firstEnumerator.moveNext()) {
                    if (!secondEnumerator.moveNext()
                    || compareSelector(firstEnumerator.current()) !== compareSelector(secondEnumerator.current())) {
                        return false;
                    }
                }

                if (secondEnumerator.moveNext()) return false;
                return true;
            }
            finally {
                Utils.dispose(secondEnumerator);
            }
        }
        finally {
            Utils.dispose(firstEnumerator);
        }
    };

    Enumerable.prototype.union = function (second, compareSelector) {
        compareSelector = Utils.createLambda(compareSelector);
        var source = this;

        return new Enumerable(function () {
            var firstEnumerator;
            var secondEnumerator;
            var keys;

            return new IEnumerator(
                function () {
                    firstEnumerator = source.getEnumerator();
                    keys = new Dictionary(compareSelector);
                },
                function () {
                    var current;
                    if (secondEnumerator === undefined) {
                        while (firstEnumerator.moveNext()) {
                            current = firstEnumerator.current();
                            if (!keys.contains(current)) {
                                keys.add(current);
                                return this.yieldReturn(current);
                            }
                        }
                        secondEnumerator = Enumerable.from(second).getEnumerator();
                    }
                    while (secondEnumerator.moveNext()) {
                        current = secondEnumerator.current();
                        if (!keys.contains(current)) {
                            keys.add(current);
                            return this.yieldReturn(current);
                        }
                    }
                    return false;
                },
                function () {
                    try {
                        Utils.dispose(firstEnumerator);
                    }
                    finally {
                        Utils.dispose(secondEnumerator);
                    }
                });
        });
    };

    /* Ordering Methods */

    Enumerable.prototype.orderBy = function (keySelector) {
        return new OrderedEnumerable(this, keySelector, false);
    };

    Enumerable.prototype.orderByDescending = function (keySelector) {
        return new OrderedEnumerable(this, keySelector, true);
    };

    Enumerable.prototype.reverse = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;
            var index;

            return new IEnumerator(
                function () {
                    buffer = source.toArray();
                    index = buffer.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(buffer[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.shuffle = function () {
        var source = this;

        return new Enumerable(function () {
            var buffer;

            return new IEnumerator(
                function () { buffer = source.toArray(); },
                function () {
                    if (buffer.length > 0) {
                        var i = Math.floor(Math.random() * buffer.length);
                        return this.yieldReturn(buffer.splice(i, 1)[0]);
                    }
                    return false;
                },
                Functions.Blank);
        });
    };

    Enumerable.prototype.weightedSample = function (weightSelector) {
        weightSelector = Utils.createLambda(weightSelector);
        var source = this;

        return new Enumerable(function () {
            var sortedByBound;
            var totalWeight = 0;

            return new IEnumerator(
                function () {
                    sortedByBound = source
                        .choose(function (x) {
                            var weight = weightSelector(x);
                            if (weight <= 0) return null; // ignore 0

                            totalWeight += weight;
                            return { value: x, bound: totalWeight };
                        })
                        .toArray();
                },
                function () {
                    if (sortedByBound.length > 0) {
                        var draw = Math.floor(Math.random() * totalWeight) + 1;

                        var lower = -1;
                        var upper = sortedByBound.length;
                        while (upper - lower > 1) {
                            var index = Math.floor((lower + upper) / 2);
                            if (sortedByBound[index].bound >= draw) {
                                upper = index;
                            }
                            else {
                                lower = index;
                            }
                        }

                        return this.yieldReturn(sortedByBound[upper].value);
                    }

                    return this.yieldBreak();
                },
                Functions.Blank);
        });
    };

    /* Grouping Methods */

    // Overload:function(keySelector)
    // Overload:function(keySelector,elementSelector)
    // Overload:function(keySelector,elementSelector,resultSelector)
    // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.groupBy = function (keySelector, elementSelector, resultSelector, compareSelector) {
        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        if (resultSelector != null) resultSelector = Utils.createLambda(resultSelector);
        compareSelector = Utils.createLambda(compareSelector);

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = source.toLookup(keySelector, elementSelector, compareSelector)
                        .toEnumerable()
                        .getEnumerator();
                },
                function () {
                    while (enumerator.moveNext()) {
                        return (resultSelector == null)
                            ? this.yieldReturn(enumerator.current())
                            : this.yieldReturn(resultSelector(enumerator.current().key(), enumerator.current()));
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(keySelector)
    // Overload:function(keySelector,elementSelector)
    // Overload:function(keySelector,elementSelector,resultSelector)
    // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)
    Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, compareSelector) {

        var source = this;
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);
        var hasResultSelector;
        if (resultSelector == null) {
            hasResultSelector = false;
            resultSelector = function (key, group) { return new Grouping(key, group); };
        }
        else {
            hasResultSelector = true;
            resultSelector = Utils.createLambda(resultSelector);
        }

        return new Enumerable(function () {
            var enumerator;
            var key;
            var compareKey;
            var group = [];

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    if (enumerator.moveNext()) {
                        key = keySelector(enumerator.current());
                        compareKey = compareSelector(key);
                        group.push(elementSelector(enumerator.current()));
                    }
                },
                function () {
                    var hasNext;
                    while ((hasNext = enumerator.moveNext()) == true) {
                        if (compareKey === compareSelector(keySelector(enumerator.current()))) {
                            group.push(elementSelector(enumerator.current()));
                        }
                        else break;
                    }

                    if (group.length > 0) {
                        var result = (hasResultSelector)
                            ? resultSelector(key, Enumerable.from(group))
                            : resultSelector(key, group);
                        if (hasNext) {
                            key = keySelector(enumerator.current());
                            compareKey = compareSelector(key);
                            group = [elementSelector(enumerator.current())];
                        }
                        else group = [];

                        return this.yieldReturn(result);
                    }

                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.buffer = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    var array = [];
                    var index = 0;
                    while (enumerator.moveNext()) {
                        array.push(enumerator.current());
                        if (++index >= count) return this.yieldReturn(array);
                    }
                    if (array.length > 0) return this.yieldReturn(array);
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    /* Aggregate Methods */

    // Overload:function(func)
    // Overload:function(seed,func)
    // Overload:function(seed,func,resultSelector)
    Enumerable.prototype.aggregate = function (seed, func, resultSelector) {
        resultSelector = Utils.createLambda(resultSelector);
        return resultSelector(this.scan(seed, func, resultSelector).last());
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.average = function (selector) {
        selector = Utils.createLambda(selector);

        var sum = 0;
        var count = 0;
        this.forEach(function (x) {
            sum += selector(x);
            ++count;
        });

        return sum / count;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.count = function (predicate) {
        predicate = (predicate == null) ? Functions.True : Utils.createLambda(predicate);

        var count = 0;
        this.forEach(function (x, i) {
            if (predicate(x, i))++count;
        });
        return count;
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.max = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) { return (a > b) ? a : b; });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.min = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(function (a, b) { return (a < b) ? a : b; });
    };

    Enumerable.prototype.maxBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) { return (keySelector(a) > keySelector(b)) ? a : b; });
    };

    Enumerable.prototype.minBy = function (keySelector) {
        keySelector = Utils.createLambda(keySelector);
        return this.aggregate(function (a, b) { return (keySelector(a) < keySelector(b)) ? a : b; });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.sum = function (selector) {
        if (selector == null) selector = Functions.Identity;
        return this.select(selector).aggregate(0, function (a, b) { return a + b; });
    };

    /* Paging Methods */

    Enumerable.prototype.elementAt = function (index) {
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        if (!found) throw new Error("index is less than 0 or greater than or equal to the number of elements in source.");
        return value;
    };

    Enumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var value;
        var found = false;
        this.forEach(function (x, i) {
            if (i == index) {
                value = x;
                found = true;
                return false;
            }
        });

        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.first = function (predicate) {
        if (predicate != null) return this.where(predicate).first();

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });

        if (!found) throw new Error("first:No element satisfies the condition.");
        return value;
    };

    Enumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).firstOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            value = x;
            found = true;
            return false;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.last = function (predicate) {
        if (predicate != null) return this.where(predicate).last();

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });

        if (!found) throw new Error("last:No element satisfies the condition.");
        return value;
    };

    // Overload:function(defaultValue)
    // Overload:function(defaultValue,predicate)
    Enumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).lastOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            found = true;
            value = x;
        });
        return (!found) ? defaultValue : value;
    };

    // Overload:function()
    // Overload:function(predicate)
    Enumerable.prototype.single = function (predicate) {
        if (predicate != null) return this.where(predicate).single();

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        if (!found) throw new Error("single:No element satisfies the condition.");
        return value;
    };

    // Overload:function(defaultValue)
    // Overload:function(defaultValue,predicate)
    Enumerable.prototype.singleOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) return this.where(predicate).singleOrDefault(null, defaultValue);

        var value;
        var found = false;
        this.forEach(function (x) {
            if (!found) {
                found = true;
                value = x;
            } else throw new Error("single:sequence contains more than one element.");
        });

        return (!found) ? defaultValue : value;
    };

    Enumerable.prototype.skip = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () {
                    enumerator = source.getEnumerator();
                    while (index++ < count && enumerator.moveNext()) {
                    }
                    ;
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.skipWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;
            var isSkipEnd = false;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (!isSkipEnd) {
                        if (enumerator.moveNext()) {
                            if (!predicate(enumerator.current(), index++)) {
                                isSkipEnd = true;
                                return this.yieldReturn(enumerator.current());
                            }
                            continue;
                        } else return false;
                    }

                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;

                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.take = function (count) {
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (index++ < count && enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); }
            );
        });
    };

    // Overload:function(predicate<element>)
    // Overload:function(predicate<element,index>)
    Enumerable.prototype.takeWhile = function (predicate) {
        predicate = Utils.createLambda(predicate);
        var source = this;

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (enumerator.moveNext() && predicate(enumerator.current(), index++))
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function()
    // Overload:function(count)
    Enumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        var source = this;

        return new Enumerable(function () {
            if (count <= 0) return source.getEnumerator(); // do nothing

            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    while (enumerator.moveNext()) {
                        if (q.length == count) {
                            q.push(enumerator.current());
                            return this.yieldReturn(q.shift());
                        }
                        q.push(enumerator.current());
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.takeFromLast = function (count) {
        if (count <= 0 || count == null) return Enumerable.empty();
        var source = this;

        return new Enumerable(function () {
            var sourceEnumerator;
            var enumerator;
            var q = [];

            return new IEnumerator(
                function () { sourceEnumerator = source.getEnumerator(); },
                function () {
                    while (sourceEnumerator.moveNext()) {
                        if (q.length == count) q.shift();
                        q.push(sourceEnumerator.current());
                    }
                    if (enumerator == null) {
                        enumerator = Enumerable.from(q).getEnumerator();
                    }
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(item)
    // Overload:function(predicate)
    Enumerable.prototype.indexOf = function (item) {
        var found = null;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) {
                    found = i;
                    return false;
                }
            });
        }
        else {
            this.forEach(function (x, i) {
                if (x === item) {
                    found = i;
                    return false;
                }
            });
        }

        return (found !== null) ? found : -1;
    };

    // Overload:function(item)
    // Overload:function(predicate)
    Enumerable.prototype.lastIndexOf = function (item) {
        var result = -1;

        // item as predicate
        if (typeof (item) === Types.Function) {
            this.forEach(function (x, i) {
                if (item(x, i)) result = i;
            });
        }
        else {
            this.forEach(function (x, i) {
                if (x === item) result = i;
            });
        }

        return result;
    };

    /* Convert Methods */

    Enumerable.prototype.cast = function () {
        return this;
    };

    Enumerable.prototype.asEnumerable = function () {
        return Enumerable.from(this);
    };

    Enumerable.prototype.toArray = function () {
        var array = [];
        this.forEach(function (x) { array.push(x); });
        return array;
    };

    // Overload:function(keySelector)
    // Overload:function(keySelector, elementSelector)
    // Overload:function(keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toLookup = function (keySelector, elementSelector, compareSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);

        var dict = new Dictionary(compareSelector);
        this.forEach(function (x) {
            var key = keySelector(x);
            var element = elementSelector(x);

            var array = dict.get(key);
            if (array !== undefined) array.push(element);
            else dict.add(key, [element]);
        });
        return new Lookup(dict);
    };

    Enumerable.prototype.toObject = function (keySelector, elementSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);

        var obj = {};
        this.forEach(function (x) {
            obj[keySelector(x)] = elementSelector(x);
        });
        return obj;
    };

    // Overload:function(keySelector, elementSelector)
    // Overload:function(keySelector, elementSelector, compareSelector)
    Enumerable.prototype.toDictionary = function (keySelector, elementSelector, compareSelector) {
        keySelector = Utils.createLambda(keySelector);
        elementSelector = Utils.createLambda(elementSelector);
        compareSelector = Utils.createLambda(compareSelector);

        var dict = new Dictionary(compareSelector);
        this.forEach(function (x) {
            dict.add(keySelector(x), elementSelector(x));
        });
        return dict;
    };

    // Overload:function()
    // Overload:function(replacer)
    // Overload:function(replacer, space)
    Enumerable.prototype.toJSONString = function (replacer, space) {
        if (typeof JSON === Types.Undefined || JSON.stringify == null) {
            throw new Error("toJSONString can't find JSON.stringify. This works native JSON support Browser or include json2.js");
        }
        return JSON.stringify(this.toArray(), replacer, space);
    };

    // Overload:function()
    // Overload:function(separator)
    // Overload:function(separator,selector)
    Enumerable.prototype.toJoinedString = function (separator, selector) {
        if (separator == null) separator = "";
        if (selector == null) selector = Functions.Identity;

        return this.select(selector).toArray().join(separator);
    };


    /* Action Methods */

    // Overload:function(action<element>)
    // Overload:function(action<element,index>)
    Enumerable.prototype.doAction = function (action) {
        var source = this;
        action = Utils.createLambda(action);

        return new Enumerable(function () {
            var enumerator;
            var index = 0;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    if (enumerator.moveNext()) {
                        action(enumerator.current(), index++);
                        return this.yieldReturn(enumerator.current());
                    }
                    return false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    // Overload:function(action<element>)
    // Overload:function(action<element,index>)
    // Overload:function(func<element,bool>)
    // Overload:function(func<element,index,bool>)
    Enumerable.prototype.forEach = function (action) {
        action = Utils.createLambda(action);

        var index = 0;
        var enumerator = this.getEnumerator();
        try {
            while (enumerator.moveNext()) {
                if (action(enumerator.current(), index++) === false) break;
            }
        } finally {
            Utils.dispose(enumerator);
        }
    };

    // Overload:function()
    // Overload:function(separator)
    // Overload:function(separator,selector)
    Enumerable.prototype.write = function (separator, selector) {
        if (separator == null) separator = "";
        selector = Utils.createLambda(selector);

        var isFirst = true;
        this.forEach(function (item) {
            if (isFirst) isFirst = false;
            else document.write(separator);
            document.write(selector(item));
        });
    };

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.writeLine = function (selector) {
        selector = Utils.createLambda(selector);

        this.forEach(function (item) {
            document.writeln(selector(item) + "<br />");
        });
    };

    Enumerable.prototype.force = function () {
        var enumerator = this.getEnumerator();

        try {
            while (enumerator.moveNext()) {
            }
        }
        finally {
            Utils.dispose(enumerator);
        }
    };

    /* Functional Methods */

    Enumerable.prototype.letBind = function (func) {
        func = Utils.createLambda(func);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () {
                    enumerator = Enumerable.from(func(source)).getEnumerator();
                },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.share = function () {
        var source = this;
        var sharedEnumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            return new IEnumerator(
                function () {
                    if (sharedEnumerator == null) {
                        sharedEnumerator = source.getEnumerator();
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    return (sharedEnumerator.moveNext())
                        ? this.yieldReturn(sharedEnumerator.current())
                        : false;
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.dispose(sharedEnumerator);
        });
    };

    Enumerable.prototype.memoize = function () {
        var source = this;
        var cache;
        var enumerator;
        var disposed = false;

        return new DisposableEnumerable(function () {
            var index = -1;

            return new IEnumerator(
                function () {
                    if (enumerator == null) {
                        enumerator = source.getEnumerator();
                        cache = [];
                    }
                },
                function () {
                    if (disposed) throw new Error("enumerator is disposed");

                    index++;
                    if (cache.length <= index) {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(cache[index] = enumerator.current())
                            : false;
                    }

                    return this.yieldReturn(cache[index]);
                },
                Functions.Blank
            );
        }, function () {
            disposed = true;
            Utils.dispose(enumerator);
            cache = null;
        });
    };

    /* Error Handling Methods */

    Enumerable.prototype.catchError = function (handler) {
        handler = Utils.createLambda(handler);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    try {
                        return (enumerator.moveNext())
                            ? this.yieldReturn(enumerator.current())
                            : false;
                    } catch (e) {
                        handler(e);
                        return false;
                    }
                },
                function () { Utils.dispose(enumerator); });
        });
    };

    Enumerable.prototype.finallyAction = function (finallyAction) {
        finallyAction = Utils.createLambda(finallyAction);
        var source = this;

        return new Enumerable(function () {
            var enumerator;

            return new IEnumerator(
                function () { enumerator = source.getEnumerator(); },
                function () {
                    return (enumerator.moveNext())
                        ? this.yieldReturn(enumerator.current())
                        : false;
                },
                function () {
                    try {
                        Utils.dispose(enumerator);
                    } finally {
                        finallyAction();
                    }
                });
        });
    };

    /* For Debug Methods */

    // Overload:function()
    // Overload:function(selector)
    Enumerable.prototype.log = function (selector) {
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(selector(item));
            }
        });
    };

    // Overload:function()
    // Overload:function(message)
    // Overload:function(message,selector)
    Enumerable.prototype.trace = function (message, selector) {
        if (message == null) message = "Trace";
        selector = Utils.createLambda(selector);

        return this.doAction(function (item) {
            if (typeof console !== Types.Undefined) {
                console.log(message, selector(item));
            }
        });
    };

    // private

    var OrderedEnumerable = function (source, keySelector, descending, parent) {
        this.source = source;
        this.keySelector = Utils.createLambda(keySelector);
        this.descending = descending;
        this.parent = parent;
    };
    OrderedEnumerable.prototype = new Enumerable();

    OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, descending) {
        return new OrderedEnumerable(this.source, keySelector, descending, this);
    };

    OrderedEnumerable.prototype.thenBy = function (keySelector) {
        return this.createOrderedEnumerable(keySelector, false);
    };

    OrderedEnumerable.prototype.thenByDescending = function (keySelector) {
        return this.createOrderedEnumerable(keySelector, true);
    };

    OrderedEnumerable.prototype.getEnumerator = function () {
        var self = this;
        var buffer;
        var indexes;
        var index = 0;

        return new IEnumerator(
            function () {
                buffer = [];
                indexes = [];
                self.source.forEach(function (item, index) {
                    buffer.push(item);
                    indexes.push(index);
                });
                var sortContext = SortContext.create(self, null);
                sortContext.GenerateKeys(buffer);

                indexes.sort(function (a, b) { return sortContext.compare(a, b); });
            },
            function () {
                return (index < indexes.length)
                    ? this.yieldReturn(buffer[indexes[index++]])
                    : false;
            },
            Functions.Blank
        );
    };

    var SortContext = function (keySelector, descending, child) {
        this.keySelector = keySelector;
        this.descending = descending;
        this.child = child;
        this.keys = null;
    };

    SortContext.create = function (orderedEnumerable, currentContext) {
        var context = new SortContext(orderedEnumerable.keySelector, orderedEnumerable.descending, currentContext);
        if (orderedEnumerable.parent != null) return SortContext.create(orderedEnumerable.parent, context);
        return context;
    };

    SortContext.prototype.GenerateKeys = function (source) {
        var len = source.length;
        var keySelector = this.keySelector;
        var keys = new Array(len);
        for (var i = 0; i < len; i++) keys[i] = keySelector(source[i]);
        this.keys = keys;

        if (this.child != null) this.child.GenerateKeys(source);
    };

    SortContext.prototype.compare = function (index1, index2) {
        var comparison = Utils.compare(this.keys[index1], this.keys[index2]);

        if (comparison == 0) {
            if (this.child != null) return this.child.compare(index1, index2);
            return Utils.compare(index1, index2);
        }

        return (this.descending) ? -comparison : comparison;
    };

    var DisposableEnumerable = function (getEnumerator, dispose) {
        this.dispose = dispose;
        Enumerable.call(this, getEnumerator);
    };
    DisposableEnumerable.prototype = new Enumerable();

    // optimize array or arraylike object

    var ArrayEnumerable = function (source) {
        this.getSource = function () { return source; };
    };
    ArrayEnumerable.prototype = new Enumerable();

    ArrayEnumerable.prototype.any = function (predicate) {
        return (predicate == null)
            ? (this.getSource().length > 0)
            : Enumerable.prototype.any.apply(this, arguments);
    };

    ArrayEnumerable.prototype.count = function (predicate) {
        return (predicate == null)
            ? this.getSource().length
            : Enumerable.prototype.count.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAt = function (index) {
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : Enumerable.prototype.elementAt.apply(this, arguments);
    };

    ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        var source = this.getSource();
        return (0 <= index && index < source.length)
            ? source[index]
            : defaultValue;
    };

    ArrayEnumerable.prototype.first = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[0]
            : Enumerable.prototype.first.apply(this, arguments);
    };

    ArrayEnumerable.prototype.firstOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) {
            return Enumerable.prototype.firstOrDefault.apply(this, arguments);
        }

        var source = this.getSource();
        return source.length > 0 ? source[0] : defaultValue;
    };

    ArrayEnumerable.prototype.last = function (predicate) {
        var source = this.getSource();
        return (predicate == null && source.length > 0)
            ? source[source.length - 1]
            : Enumerable.prototype.last.apply(this, arguments);
    };

    ArrayEnumerable.prototype.lastOrDefault = function (predicate, defaultValue) {
        if (defaultValue === undefined) defaultValue = null;
        if (predicate != null) {
            return Enumerable.prototype.lastOrDefault.apply(this, arguments);
        }

        var source = this.getSource();
        return source.length > 0 ? source[source.length - 1] : defaultValue;
    };

    ArrayEnumerable.prototype.skip = function (count) {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () { index = (count < 0) ? 0 : count; },
                function () {
                    return (index < source.length)
                        ? this.yieldReturn(source[index++])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.takeExceptLast = function (count) {
        if (count == null) count = 1;
        return this.take(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.takeFromLast = function (count) {
        return this.skip(this.getSource().length - count);
    };

    ArrayEnumerable.prototype.reverse = function () {
        var source = this.getSource();

        return new Enumerable(function () {
            var index;

            return new IEnumerator(
                function () {
                    index = source.length;
                },
                function () {
                    return (index > 0)
                        ? this.yieldReturn(source[--index])
                        : false;
                },
                Functions.Blank);
        });
    };

    ArrayEnumerable.prototype.sequenceEqual = function (second, compareSelector) {
        if ((second instanceof ArrayEnumerable || second instanceof Array)
            && compareSelector == null
            && Enumerable.from(second).count() != this.count()) {
            return false;
        }

        return Enumerable.prototype.sequenceEqual.apply(this, arguments);
    };

    ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {
        var source = this.getSource();
        if (selector != null || !(source instanceof Array)) {
            return Enumerable.prototype.toJoinedString.apply(this, arguments);
        }

        if (separator == null) separator = "";
        return source.join(separator);
    };

    ArrayEnumerable.prototype.getEnumerator = function () {
        var source = this.getSource();
        var index = -1;

        // fast and simple enumerator
        return {
            current: function () { return source[index]; },
            moveNext: function () {
                return ++index < source.length;
            },
            dispose: Functions.Blank
        };
    };

    // optimization for multiple where and multiple select and whereselect

    var WhereEnumerable = function (source, predicate) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1
    };
    WhereEnumerable.prototype = new Enumerable();

    WhereEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        if (predicate.length <= 1) {
            var prevPredicate = this.prevPredicate;
            var composedPredicate = function (x) { return prevPredicate(x) && predicate(x); };
            return new WhereEnumerable(this.prevSource, composedPredicate);
        }
        else {
            // if predicate use index, can't compose
            return Enumerable.prototype.where.call(this, predicate);
        }
    };

    WhereEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        return (selector.length <= 1)
            ? new WhereSelectEnumerable(this.prevSource, this.prevPredicate, selector)
            : Enumerable.prototype.select.call(this, selector);
    };

    WhereEnumerable.prototype.getEnumerator = function () {
        var predicate = this.prevPredicate;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.getEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate(enumerator.current())) {
                        return this.yieldReturn(enumerator.current());
                    }
                }
                return false;
            },
            function () { Utils.dispose(enumerator); });
    };

    var WhereSelectEnumerable = function (source, predicate, selector) {
        this.prevSource = source;
        this.prevPredicate = predicate; // predicate.length always <= 1 or null
        this.prevSelector = selector; // selector.length always <= 1
    };
    WhereSelectEnumerable.prototype = new Enumerable();

    WhereSelectEnumerable.prototype.where = function (predicate) {
        predicate = Utils.createLambda(predicate);

        return (predicate.length <= 1)
            ? new WhereEnumerable(this, predicate)
            : Enumerable.prototype.where.call(this, predicate);
    };

    WhereSelectEnumerable.prototype.select = function (selector) {
        selector = Utils.createLambda(selector);

        if (selector.length <= 1) {
            var prevSelector = this.prevSelector;
            var composedSelector = function (x) { return selector(prevSelector(x)); };
            return new WhereSelectEnumerable(this.prevSource, this.prevPredicate, composedSelector);
        }
        else {
            // if selector use index, can't compose
            return Enumerable.prototype.select.call(this, selector);
        }
    };

    WhereSelectEnumerable.prototype.getEnumerator = function () {
        var predicate = this.prevPredicate;
        var selector = this.prevSelector;
        var source = this.prevSource;
        var enumerator;

        return new IEnumerator(
            function () { enumerator = source.getEnumerator(); },
            function () {
                while (enumerator.moveNext()) {
                    if (predicate == null || predicate(enumerator.current())) {
                        return this.yieldReturn(selector(enumerator.current()));
                    }
                }
                return false;
            },
            function () { Utils.dispose(enumerator); });
    };

    // Collections

    var Dictionary = (function () {
        // static utility methods
        var callHasOwnProperty = function (target, key) {
            return Object.prototype.hasOwnProperty.call(target, key);
        };

        var computeHashCode = function (obj) {
            if (obj === null) return "null";
            if (obj === undefined) return "undefined";

            return (typeof obj.toString === Types.Function)
                ? obj.toString()
                : Object.prototype.toString.call(obj);
        };

        // LinkedList for Dictionary
        var HashEntry = function (key, value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        };

        var EntryList = function () {
            this.first = null;
            this.last = null;
        };
        EntryList.prototype =
        {
            addLast: function (entry) {
                if (this.last != null) {
                    this.last.next = entry;
                    entry.prev = this.last;
                    this.last = entry;
                } else this.first = this.last = entry;
            },

            replace: function (entry, newEntry) {
                if (entry.prev != null) {
                    entry.prev.next = newEntry;
                    newEntry.prev = entry.prev;
                } else this.first = newEntry;

                if (entry.next != null) {
                    entry.next.prev = newEntry;
                    newEntry.next = entry.next;
                } else this.last = newEntry;

            },

            remove: function (entry) {
                if (entry.prev != null) entry.prev.next = entry.next;
                else this.first = entry.next;

                if (entry.next != null) entry.next.prev = entry.prev;
                else this.last = entry.prev;
            }
        };

        // Overload:function()
        // Overload:function(compareSelector)
        var Dictionary = function (compareSelector) {
            this.countField = 0;
            this.entryList = new EntryList();
            this.buckets = {}; // as Dictionary<string,List<object>>
            this.compareSelector = (compareSelector == null) ? Functions.Identity : compareSelector;
        };
        Dictionary.prototype =
        {
            add: function (key, value) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                var entry = new HashEntry(key, value);
                if (callHasOwnProperty(this.buckets, hash)) {
                    var array = this.buckets[hash];
                    for (var i = 0; i < array.length; i++) {
                        if (this.compareSelector(array[i].key) === compareKey) {
                            this.entryList.replace(array[i], entry);
                            array[i] = entry;
                            return;
                        }
                    }
                    array.push(entry);
                } else {
                    this.buckets[hash] = [entry];
                }
                this.countField++;
                this.entryList.addLast(entry);
            },

            get: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return undefined;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    var entry = array[i];
                    if (this.compareSelector(entry.key) === compareKey) return entry.value;
                }
                return undefined;
            },

            set: function (key, value) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (callHasOwnProperty(this.buckets, hash)) {
                    var array = this.buckets[hash];
                    for (var i = 0; i < array.length; i++) {
                        if (this.compareSelector(array[i].key) === compareKey) {
                            var newEntry = new HashEntry(key, value);
                            this.entryList.replace(array[i], newEntry);
                            array[i] = newEntry;
                            return true;
                        }
                    }
                }
                return false;
            },

            contains: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return false;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    if (this.compareSelector(array[i].key) === compareKey) return true;
                }
                return false;
            },

            clear: function () {
                this.countField = 0;
                this.buckets = {};
                this.entryList = new EntryList();
            },

            remove: function (key) {
                var compareKey = this.compareSelector(key);
                var hash = computeHashCode(compareKey);
                if (!callHasOwnProperty(this.buckets, hash)) return;

                var array = this.buckets[hash];
                for (var i = 0; i < array.length; i++) {
                    if (this.compareSelector(array[i].key) === compareKey) {
                        this.entryList.remove(array[i]);
                        array.splice(i, 1);
                        if (array.length == 0) delete this.buckets[hash];
                        this.countField--;
                        return;
                    }
                }
            },

            count: function () {
                return this.countField;
            },

            toEnumerable: function () {
                var self = this;
                return new Enumerable(function () {
                    var currentEntry;

                    return new IEnumerator(
                        function () { currentEntry = self.entryList.first; },
                        function () {
                            if (currentEntry != null) {
                                var result = { key: currentEntry.key, value: currentEntry.value };
                                currentEntry = currentEntry.next;
                                return this.yieldReturn(result);
                            }
                            return false;
                        },
                        Functions.Blank);
                });
            }
        };

        return Dictionary;
    })();

    // dictionary = Dictionary<TKey, TValue[]>
    var Lookup = function (dictionary) {
        this.count = function () {
            return dictionary.count();
        };
        this.get = function (key) {
            return Enumerable.from(dictionary.get(key));
        };
        this.contains = function (key) {
            return dictionary.contains(key);
        };
        this.toEnumerable = function () {
            return dictionary.toEnumerable().select(function (kvp) {
                return new Grouping(kvp.key, kvp.value);
            });
        };
    };

    var Grouping = function (groupKey, elements) {
        this.key = function () {
            return groupKey;
        };
        ArrayEnumerable.call(this, elements);
    };
    Grouping.prototype = new ArrayEnumerable();

    // module export
    if (typeof define === Types.Function && define.amd) { // AMD
        define("linqjs", [], function () { return Enumerable; });
    }
    else if (typeof module !== Types.Undefined && module.exports) { // Node
        module.exports = Enumerable;
    }
    else {
        root.Enumerable = Enumerable;
    }
})(this);
/*!
 * angular-cache
 * @version 4.5.0 - Homepage <https://github.com/jmdobry/angular-cache>
 * @author Jason Dobry <jason.dobry@gmail.com>
 * @copyright (c) 2013-2016 Jason Dobry 
 * @license MIT <https://github.com/jmdobry/angular-cache/blob/master/LICENSE>
 * 
 * @overview angular-cache is a very useful replacement for Angular's $cacheFactory.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("angular"));
	else if(typeof define === 'function' && define.amd)
		define("angular-cache", ["angular"], factory);
	else if(typeof exports === 'object')
		exports["angularCacheModuleName"] = factory(require("angular"));
	else
		root["angularCacheModuleName"] = factory(root["angular"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var angular = __webpack_require__(1);
	var CacheFactory = __webpack_require__(2);
	
	CacheFactory.utils.equals = angular.equals;
	CacheFactory.utils.isObject = angular.isObject;
	CacheFactory.utils.fromJson = angular.fromJson;
	
	function BinaryHeapProvider() {
	  this.$get = function () {
	    return CacheFactory.BinaryHeap;
	  };
	}
	
	function CacheFactoryProvider() {
	  this.defaults = CacheFactory.defaults;
	  this.defaults.storagePrefix = 'angular-cache.caches.';
	
	  this.$get = ['$q', function ($q) {
	    CacheFactory.utils.Promise = $q;
	    return CacheFactory;
	  }];
	}
	
	angular.module('angular-cache', []).provider('BinaryHeap', BinaryHeapProvider).provider('CacheFactory', CacheFactoryProvider);
	
	module.exports = 'angular-cache';
	try {
	  module.exports.name = 'angular-cache';
	} catch (err) {}

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * cachefactory
	 * @version 1.4.0 - Homepage <https://github.com/jmdobry/CacheFactory>
	 * @author Jason Dobry <jason.dobry@gmail.com>
	 * @copyright (c) 2013-2016 Jason Dobry 
	 * @license MIT <https://github.com/jmdobry/CacheFactory/blob/master/LICENSE>
	 * 
	 * @overview CacheFactory is a very simple and useful cache for the browser.
	 */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define("cachefactory", [], factory);
		else if(typeof exports === 'object')
			exports["CacheFactory"] = factory();
		else
			root["CacheFactory"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		'use strict';
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
		
		var BinaryHeap = __webpack_require__(1);
		var _Promise = null;
		try {
		  _Promise = window.Promise;
		} catch (e) {}
		
		var utils = {
		  isNumber: function isNumber(value) {
		    return typeof value === 'number';
		  },
		  isString: function isString(value) {
		    return typeof value === 'string';
		  },
		  isObject: function isObject(value) {
		    return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
		  },
		  isFunction: function isFunction(value) {
		    return typeof value === 'function';
		  },
		  fromJson: function fromJson(value) {
		    return JSON.parse(value);
		  },
		  equals: function equals(a, b) {
		    return a === b;
		  },
		
		  Promise: _Promise
		};
		
		function _keys(collection) {
		  var keys = [];
		  var key = undefined;
		  if (!utils.isObject(collection)) {
		    return keys;
		  }
		  for (key in collection) {
		    if (collection.hasOwnProperty(key)) {
		      keys.push(key);
		    }
		  }
		  return keys;
		}
		
		function _isPromiseLike(value) {
		  return value && typeof value.then === 'function';
		}
		
		function _stringifyNumber(number) {
		  if (utils.isNumber(number)) {
		    return number.toString();
		  }
		  return number;
		}
		
		function _keySet(collection) {
		  var keySet = {};
		  var key = undefined;
		  if (!utils.isObject(collection)) {
		    return keySet;
		  }
		  for (key in collection) {
		    if (collection.hasOwnProperty(key)) {
		      keySet[key] = key;
		    }
		  }
		  return keySet;
		}
		
		var defaults = {
		  capacity: Number.MAX_VALUE,
		  maxAge: Number.MAX_VALUE,
		  deleteOnExpire: 'none',
		  onExpire: null,
		  cacheFlushInterval: null,
		  recycleFreq: 1000,
		  storageMode: 'memory',
		  storageImpl: null,
		  disabled: false,
		  storagePrefix: 'cachefactory.caches.',
		  storeOnResolve: false,
		  storeOnReject: false
		};
		
		var caches = {};
		
		function createCache(cacheId, options) {
		  if (cacheId in caches) {
		    throw new Error(cacheId + ' already exists!');
		  } else if (!utils.isString(cacheId)) {
		    throw new Error('cacheId must be a string!');
		  }
		
		  var $$data = {};
		  var $$promises = {};
		  var $$storage = null;
		  var $$expiresHeap = new BinaryHeap(function (x) {
		    return x.expires;
		  }, utils.equals);
		  var $$lruHeap = new BinaryHeap(function (x) {
		    return x.accessed;
		  }, utils.equals);
		
		  var cache = caches[cacheId] = {
		
		    $$id: cacheId,
		
		    destroy: function destroy() {
		      clearInterval(this.$$cacheFlushIntervalId);
		      clearInterval(this.$$recycleFreqId);
		      this.removeAll();
		      if ($$storage) {
		        $$storage().removeItem(this.$$prefix + '.keys');
		        $$storage().removeItem(this.$$prefix);
		      }
		      $$storage = null;
		      $$data = null;
		      $$lruHeap = null;
		      $$expiresHeap = null;
		      this.$$prefix = null;
		      delete caches[this.$$id];
		    },
		    disable: function disable() {
		      this.$$disabled = true;
		    },
		    enable: function enable() {
		      delete this.$$disabled;
		    },
		    get: function get(key, options) {
		      var _this2 = this;
		
		      if (Array.isArray(key)) {
		        var _ret = function () {
		          var keys = key;
		          var values = [];
		
		          keys.forEach(function (key) {
		            var value = _this2.get(key, options);
		            if (value !== null && value !== undefined) {
		              values.push(value);
		            }
		          });
		
		          return {
		            v: values
		          };
		        }();
		
		        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
		      } else {
		        key = _stringifyNumber(key);
		
		        if (this.$$disabled) {
		          return;
		        }
		      }
		
		      options = options || {};
		      if (!utils.isString(key)) {
		        throw new Error('key must be a string!');
		      } else if (options && !utils.isObject(options)) {
		        throw new Error('options must be an object!');
		      } else if (options.onExpire && !utils.isFunction(options.onExpire)) {
		        throw new Error('options.onExpire must be a function!');
		      }
		
		      var item = undefined;
		
		      if ($$storage) {
		        if ($$promises[key]) {
		          return $$promises[key];
		        }
		
		        var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);
		
		        if (itemJson) {
		          item = utils.fromJson(itemJson);
		        } else {
		          return;
		        }
		      } else if (utils.isObject($$data)) {
		        if (!(key in $$data)) {
		          return;
		        }
		
		        item = $$data[key];
		      }
		
		      var value = item.value;
		      var now = new Date().getTime();
		
		      if ($$storage) {
		        $$lruHeap.remove({
		          key: key,
		          accessed: item.accessed
		        });
		        item.accessed = now;
		        $$lruHeap.push({
		          key: key,
		          accessed: now
		        });
		      } else {
		        $$lruHeap.remove(item);
		        item.accessed = now;
		        $$lruHeap.push(item);
		      }
		
		      if (this.$$deleteOnExpire === 'passive' && 'expires' in item && item.expires < now) {
		        this.remove(key);
		
		        if (this.$$onExpire) {
		          this.$$onExpire(key, item.value, options.onExpire);
		        } else if (options.onExpire) {
		          options.onExpire.call(this, key, item.value);
		        }
		        value = undefined;
		      } else if ($$storage) {
		        $$storage().setItem(this.$$prefix + '.data.' + key, JSON.stringify(item));
		      }
		
		      return value;
		    },
		    info: function info(key) {
		      if (key) {
		        var item = undefined;
		        if ($$storage) {
		          var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);
		
		          if (itemJson) {
		            item = utils.fromJson(itemJson);
		            return {
		              created: item.created,
		              accessed: item.accessed,
		              expires: item.expires,
		              isExpired: new Date().getTime() - item.created > (item.maxAge || this.$$maxAge)
		            };
		          } else {
		            return undefined;
		          }
		        } else if (utils.isObject($$data) && key in $$data) {
		          item = $$data[key];
		
		          return {
		            created: item.created,
		            accessed: item.accessed,
		            expires: item.expires,
		            isExpired: new Date().getTime() - item.created > (item.maxAge || this.$$maxAge)
		          };
		        } else {
		          return undefined;
		        }
		      } else {
		        return {
		          id: this.$$id,
		          capacity: this.$$capacity,
		          maxAge: this.$$maxAge,
		          deleteOnExpire: this.$$deleteOnExpire,
		          onExpire: this.$$onExpire,
		          cacheFlushInterval: this.$$cacheFlushInterval,
		          recycleFreq: this.$$recycleFreq,
		          storageMode: this.$$storageMode,
		          storageImpl: $$storage ? $$storage() : undefined,
		          disabled: !!this.$$disabled,
		          size: $$lruHeap && $$lruHeap.size() || 0
		        };
		      }
		    },
		    keys: function keys() {
		      if ($$storage) {
		        var keysJson = $$storage().getItem(this.$$prefix + '.keys');
		
		        if (keysJson) {
		          return utils.fromJson(keysJson);
		        } else {
		          return [];
		        }
		      } else {
		        return _keys($$data);
		      }
		    },
		    keySet: function keySet() {
		      if ($$storage) {
		        var keysJson = $$storage().getItem(this.$$prefix + '.keys');
		        var kSet = {};
		
		        if (keysJson) {
		          var keys = utils.fromJson(keysJson);
		
		          for (var i = 0; i < keys.length; i++) {
		            kSet[keys[i]] = keys[i];
		          }
		        }
		        return kSet;
		      } else {
		        return _keySet($$data);
		      }
		    },
		    put: function put(key, value, options) {
		      var _this3 = this;
		
		      options || (options = {});
		
		      var storeOnResolve = 'storeOnResolve' in options ? !!options.storeOnResolve : this.$$storeOnResolve;
		      var storeOnReject = 'storeOnReject' in options ? !!options.storeOnReject : this.$$storeOnReject;
		
		      var getHandler = function getHandler(store, isError) {
		        return function (v) {
		          if (store) {
		            delete $$promises[key];
		            if (utils.isObject(v) && 'status' in v && 'data' in v) {
		              v = [v.status, v.data, v.headers(), v.statusText];
		              _this3.put(key, v);
		            } else {
		              _this3.put(key, v);
		            }
		          }
		          if (isError) {
		            if (utils.Promise) {
		              return utils.Promise.reject(v);
		            } else {
		              throw v;
		            }
		          } else {
		            return v;
		          }
		        };
		      };
		
		      if (this.$$disabled || !utils.isObject($$data) || value === null || value === undefined) {
		        return;
		      }
		      key = _stringifyNumber(key);
		
		      if (!utils.isString(key)) {
		        throw new Error('key must be a string!');
		      }
		
		      var now = new Date().getTime();
		      var item = {
		        key: key,
		        value: _isPromiseLike(value) ? value.then(getHandler(storeOnResolve, false), getHandler(storeOnReject, true)) : value,
		        created: options.created === undefined ? now : options.created,
		        accessed: options.accessed === undefined ? now : options.accessed
		      };
		      if (options.maxAge) {
		        item.maxAge = options.maxAge;
		      }
		
		      if (options.expires === undefined) {
		        item.expires = item.created + (item.maxAge || this.$$maxAge);
		      } else {
		        item.expires = options.expires;
		      }
		
		      if ($$storage) {
		        if (_isPromiseLike(item.value)) {
		          $$promises[key] = item.value;
		          return $$promises[key];
		        }
		        var keysJson = $$storage().getItem(this.$$prefix + '.keys');
		        var keys = keysJson ? utils.fromJson(keysJson) : [];
		        var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);
		
		        // Remove existing
		        if (itemJson) {
		          this.remove(key);
		        }
		        // Add to expires heap
		        $$expiresHeap.push({
		          key: key,
		          expires: item.expires
		        });
		        // Add to lru heap
		        $$lruHeap.push({
		          key: key,
		          accessed: item.accessed
		        });
		        // Set item
		        $$storage().setItem(this.$$prefix + '.data.' + key, JSON.stringify(item));
		        var exists = false;
		        for (var i = 0; i < keys.length; i++) {
		          if (keys[i] === key) {
		            exists = true;
		            break;
		          }
		        }
		        if (!exists) {
		          keys.push(key);
		        }
		        $$storage().setItem(this.$$prefix + '.keys', JSON.stringify(keys));
		      } else {
		        // Remove existing
		        if ($$data[key]) {
		          this.remove(key);
		        }
		        // Add to expires heap
		        $$expiresHeap.push(item);
		        // Add to lru heap
		        $$lruHeap.push(item);
		        // Set item
		        $$data[key] = item;
		        delete $$promises[key];
		      }
		
		      // Handle exceeded capacity
		      if ($$lruHeap.size() > this.$$capacity) {
		        this.remove($$lruHeap.peek().key);
		      }
		
		      return value;
		    },
		    remove: function remove(key) {
		      key += '';
		      delete $$promises[key];
		      if ($$storage) {
		        var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);
		
		        if (itemJson) {
		          var item = utils.fromJson(itemJson);
		          $$lruHeap.remove({
		            key: key,
		            accessed: item.accessed
		          });
		          $$expiresHeap.remove({
		            key: key,
		            expires: item.expires
		          });
		          $$storage().removeItem(this.$$prefix + '.data.' + key);
		          var keysJson = $$storage().getItem(this.$$prefix + '.keys');
		          var keys = keysJson ? utils.fromJson(keysJson) : [];
		          var index = keys.indexOf(key);
		
		          if (index >= 0) {
		            keys.splice(index, 1);
		          }
		          $$storage().setItem(this.$$prefix + '.keys', JSON.stringify(keys));
		          return item.value;
		        }
		      } else if (utils.isObject($$data)) {
		        var value = $$data[key] ? $$data[key].value : undefined;
		        $$lruHeap.remove($$data[key]);
		        $$expiresHeap.remove($$data[key]);
		        $$data[key] = null;
		        delete $$data[key];
		        return value;
		      }
		    },
		    removeAll: function removeAll() {
		      if ($$storage) {
		        $$lruHeap.removeAll();
		        $$expiresHeap.removeAll();
		        var keysJson = $$storage().getItem(this.$$prefix + '.keys');
		
		        if (keysJson) {
		          var keys = utils.fromJson(keysJson);
		
		          for (var i = 0; i < keys.length; i++) {
		            this.remove(keys[i]);
		          }
		        }
		        $$storage().setItem(this.$$prefix + '.keys', JSON.stringify([]));
		      } else if (utils.isObject($$data)) {
		        $$lruHeap.removeAll();
		        $$expiresHeap.removeAll();
		        for (var key in $$data) {
		          $$data[key] = null;
		        }
		        $$data = {};
		      } else {
		        $$lruHeap.removeAll();
		        $$expiresHeap.removeAll();
		        $$data = {};
		      }
		      $$promises = {};
		    },
		    removeExpired: function removeExpired() {
		      var now = new Date().getTime();
		      var expired = {};
		      var key = undefined;
		      var expiredItem = undefined;
		
		      while ((expiredItem = $$expiresHeap.peek()) && expiredItem.expires <= now) {
		        expired[expiredItem.key] = expiredItem.value ? expiredItem.value : null;
		        $$expiresHeap.pop();
		      }
		
		      if ($$storage) {
		        for (key in expired) {
		          var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);
		          if (itemJson) {
		            expired[key] = utils.fromJson(itemJson).value;
		            this.remove(key);
		          }
		        }
		      } else {
		        for (key in expired) {
		          this.remove(key);
		        }
		      }
		
		      if (this.$$onExpire) {
		        for (key in expired) {
		          this.$$onExpire(key, expired[key]);
		        }
		      }
		
		      return expired;
		    },
		    setCacheFlushInterval: function setCacheFlushInterval(cacheFlushInterval) {
		      var _this = this;
		      if (cacheFlushInterval === null) {
		        delete _this.$$cacheFlushInterval;
		      } else if (!utils.isNumber(cacheFlushInterval)) {
		        throw new Error('cacheFlushInterval must be a number!');
		      } else if (cacheFlushInterval < 0) {
		        throw new Error('cacheFlushInterval must be greater than zero!');
		      } else if (cacheFlushInterval !== _this.$$cacheFlushInterval) {
		        _this.$$cacheFlushInterval = cacheFlushInterval;
		
		        clearInterval(_this.$$cacheFlushIntervalId); // eslint-disable-line
		
		        _this.$$cacheFlushIntervalId = setInterval(function () {
		          _this.removeAll();
		        }, _this.$$cacheFlushInterval);
		      }
		    },
		    setCapacity: function setCapacity(capacity) {
		      if (capacity === null) {
		        delete this.$$capacity;
		      } else if (!utils.isNumber(capacity)) {
		        throw new Error('capacity must be a number!');
		      } else if (capacity < 0) {
		        throw new Error('capacity must be greater than zero!');
		      } else {
		        this.$$capacity = capacity;
		      }
		      var removed = {};
		      while ($$lruHeap.size() > this.$$capacity) {
		        removed[$$lruHeap.peek().key] = this.remove($$lruHeap.peek().key);
		      }
		      return removed;
		    },
		    setDeleteOnExpire: function setDeleteOnExpire(deleteOnExpire, setRecycleFreq) {
		      if (deleteOnExpire === null) {
		        delete this.$$deleteOnExpire;
		      } else if (!utils.isString(deleteOnExpire)) {
		        throw new Error('deleteOnExpire must be a string!');
		      } else if (deleteOnExpire !== 'none' && deleteOnExpire !== 'passive' && deleteOnExpire !== 'aggressive') {
		        throw new Error('deleteOnExpire must be "none", "passive" or "aggressive"!');
		      } else {
		        this.$$deleteOnExpire = deleteOnExpire;
		      }
		      if (setRecycleFreq !== false) {
		        this.setRecycleFreq(this.$$recycleFreq);
		      }
		    },
		    setMaxAge: function setMaxAge(maxAge) {
		      if (maxAge === null) {
		        this.$$maxAge = Number.MAX_VALUE;
		      } else if (!utils.isNumber(maxAge)) {
		        throw new Error('maxAge must be a number!');
		      } else if (maxAge < 0) {
		        throw new Error('maxAge must be greater than zero!');
		      } else {
		        this.$$maxAge = maxAge;
		      }
		      var i = undefined,
		          keys = undefined,
		          key = undefined;
		
		      $$expiresHeap.removeAll();
		
		      if ($$storage) {
		        var keysJson = $$storage().getItem(this.$$prefix + '.keys');
		
		        keys = keysJson ? utils.fromJson(keysJson) : [];
		
		        for (i = 0; i < keys.length; i++) {
		          key = keys[i];
		          var itemJson = $$storage().getItem(this.$$prefix + '.data.' + key);
		
		          if (itemJson) {
		            var item = utils.fromJson(itemJson);
		            if (this.$$maxAge === Number.MAX_VALUE) {
		              item.expires = Number.MAX_VALUE;
		            } else {
		              item.expires = item.created + (item.maxAge || this.$$maxAge);
		            }
		            $$expiresHeap.push({
		              key: key,
		              expires: item.expires
		            });
		          }
		        }
		      } else {
		        keys = _keys($$data);
		
		        for (i = 0; i < keys.length; i++) {
		          key = keys[i];
		          if (this.$$maxAge === Number.MAX_VALUE) {
		            $$data[key].expires = Number.MAX_VALUE;
		          } else {
		            $$data[key].expires = $$data[key].created + ($$data[key].maxAge || this.$$maxAge);
		          }
		          $$expiresHeap.push($$data[key]);
		        }
		      }
		      if (this.$$deleteOnExpire === 'aggressive') {
		        return this.removeExpired();
		      } else {
		        return {};
		      }
		    },
		    setOnExpire: function setOnExpire(onExpire) {
		      if (onExpire === null) {
		        delete this.$$onExpire;
		      } else if (!utils.isFunction(onExpire)) {
		        throw new Error('onExpire must be a function!');
		      } else {
		        this.$$onExpire = onExpire;
		      }
		    },
		    setOptions: function setOptions(cacheOptions, strict) {
		      cacheOptions = cacheOptions || {};
		      strict = !!strict;
		      if (!utils.isObject(cacheOptions)) {
		        throw new Error('cacheOptions must be an object!');
		      }
		
		      if ('storagePrefix' in cacheOptions) {
		        this.$$storagePrefix = cacheOptions.storagePrefix;
		      } else if (strict) {
		        this.$$storagePrefix = defaults.storagePrefix;
		      }
		
		      this.$$prefix = this.$$storagePrefix + this.$$id;
		
		      if ('disabled' in cacheOptions) {
		        this.$$disabled = !!cacheOptions.disabled;
		      } else if (strict) {
		        this.$$disabled = defaults.disabled;
		      }
		
		      if ('deleteOnExpire' in cacheOptions) {
		        this.setDeleteOnExpire(cacheOptions.deleteOnExpire, false);
		      } else if (strict) {
		        this.setDeleteOnExpire(defaults.deleteOnExpire, false);
		      }
		
		      if ('recycleFreq' in cacheOptions) {
		        this.setRecycleFreq(cacheOptions.recycleFreq);
		      } else if (strict) {
		        this.setRecycleFreq(defaults.recycleFreq);
		      }
		
		      if ('maxAge' in cacheOptions) {
		        this.setMaxAge(cacheOptions.maxAge);
		      } else if (strict) {
		        this.setMaxAge(defaults.maxAge);
		      }
		
		      if ('storeOnResolve' in cacheOptions) {
		        this.$$storeOnResolve = !!cacheOptions.storeOnResolve;
		      } else if (strict) {
		        this.$$storeOnResolve = defaults.storeOnResolve;
		      }
		
		      if ('storeOnReject' in cacheOptions) {
		        this.$$storeOnReject = !!cacheOptions.storeOnReject;
		      } else if (strict) {
		        this.$$storeOnReject = defaults.storeOnReject;
		      }
		
		      if ('capacity' in cacheOptions) {
		        this.setCapacity(cacheOptions.capacity);
		      } else if (strict) {
		        this.setCapacity(defaults.capacity);
		      }
		
		      if ('cacheFlushInterval' in cacheOptions) {
		        this.setCacheFlushInterval(cacheOptions.cacheFlushInterval);
		      } else if (strict) {
		        this.setCacheFlushInterval(defaults.cacheFlushInterval);
		      }
		
		      if ('onExpire' in cacheOptions) {
		        this.setOnExpire(cacheOptions.onExpire);
		      } else if (strict) {
		        this.setOnExpire(defaults.onExpire);
		      }
		
		      if ('storageMode' in cacheOptions || 'storageImpl' in cacheOptions) {
		        this.setStorageMode(cacheOptions.storageMode || defaults.storageMode, cacheOptions.storageImpl || defaults.storageImpl);
		      } else if (strict) {
		        this.setStorageMode(defaults.storageMode, defaults.storageImpl);
		      }
		    },
		    setRecycleFreq: function setRecycleFreq(recycleFreq) {
		      if (recycleFreq === null) {
		        delete this.$$recycleFreq;
		      } else if (!utils.isNumber(recycleFreq)) {
		        throw new Error('recycleFreq must be a number!');
		      } else if (recycleFreq < 0) {
		        throw new Error('recycleFreq must be greater than zero!');
		      } else {
		        this.$$recycleFreq = recycleFreq;
		      }
		      clearInterval(this.$$recycleFreqId);
		      if (this.$$deleteOnExpire === 'aggressive') {
		        (function (self) {
		          self.$$recycleFreqId = setInterval(function () {
		            self.removeExpired();
		          }, self.$$recycleFreq);
		        })(this);
		      } else {
		        delete this.$$recycleFreqId;
		      }
		    },
		    setStorageMode: function setStorageMode(storageMode, storageImpl) {
		      if (!utils.isString(storageMode)) {
		        throw new Error('storageMode must be a string!');
		      } else if (storageMode !== 'memory' && storageMode !== 'localStorage' && storageMode !== 'sessionStorage') {
		        throw new Error('storageMode must be "memory", "localStorage" or "sessionStorage"!');
		      }
		
		      var prevStorage = $$storage;
		      var prevData = $$data;
		      var shouldReInsert = false;
		      var items = {};
		
		      function load(prevStorage, prevData) {
		        var keys = this.keys();
		        var length = keys.length;
		        if (length) {
		          var _key = undefined;
		          var prevDataIsObject = utils.isObject(prevData);
		          for (var i = 0; i < length; i++) {
		            _key = keys[i];
		            if (prevStorage) {
		              var itemJson = prevStorage().getItem(this.$$prefix + '.data.' + _key);
		              if (itemJson) {
		                items[_key] = utils.fromJson(itemJson);
		              }
		            } else if (prevDataIsObject) {
		              items[_key] = prevData[_key];
		            }
		            this.remove(_key);
		          }
		          shouldReInsert = true;
		        }
		      }
		
		      if (!this.$$initializing) {
		        load.call(this, prevStorage, prevData);
		      }
		
		      this.$$storageMode = storageMode;
		
		      if (storageImpl) {
		        if (!utils.isObject(storageImpl)) {
		          throw new Error('storageImpl must be an object!');
		        } else if (!('setItem' in storageImpl) || typeof storageImpl.setItem !== 'function') {
		          throw new Error('storageImpl must implement "setItem(key, value)"!');
		        } else if (!('getItem' in storageImpl) || typeof storageImpl.getItem !== 'function') {
		          throw new Error('storageImpl must implement "getItem(key)"!');
		        } else if (!('removeItem' in storageImpl) || typeof storageImpl.removeItem !== 'function') {
		          throw new Error('storageImpl must implement "removeItem(key)"!');
		        }
		        $$storage = function $$storage() {
		          return storageImpl;
		        };
		      } else if (this.$$storageMode === 'localStorage') {
		        try {
		          localStorage.setItem('cachefactory', 'cachefactory');
		          localStorage.removeItem('cachefactory');
		          $$storage = function $$storage() {
		            return localStorage;
		          };
		        } catch (e) {
		          $$storage = null;
		          this.$$storageMode = 'memory';
		        }
		      } else if (this.$$storageMode === 'sessionStorage') {
		        try {
		          sessionStorage.setItem('cachefactory', 'cachefactory');
		          sessionStorage.removeItem('cachefactory');
		          $$storage = function $$storage() {
		            return sessionStorage;
		          };
		        } catch (e) {
		          $$storage = null;
		          this.$$storageMode = 'memory';
		        }
		      } else {
		        $$storage = null;
		        this.$$storageModel = 'memory';
		      }
		
		      if (this.$$initializing) {
		        load.call(this, $$storage, $$data);
		      }
		
		      if (shouldReInsert) {
		        var item = undefined;
		        for (var key in items) {
		          item = items[key];
		          this.put(key, item.value, {
		            created: item.created,
		            accessed: item.accessed,
		            expires: item.expires
		          });
		        }
		      }
		    },
		    touch: function touch(key) {
		      var _this4 = this;
		
		      if (key) {
		        var val = this.get(key, {
		          onExpire: function onExpire(k, v) {
		            return _this4.put(k, v);
		          }
		        });
		        if (val) {
		          this.put(key, val);
		        }
		      } else {
		        var keys = this.keys();
		        for (var i = 0; i < keys.length; i++) {
		          this.touch(keys[i]);
		        }
		      }
		    },
		    values: function values() {
		      var keys = this.keys();
		      var items = [];
		      for (var i = 0; i < keys.length; i++) {
		        items.push(this.get(keys[i]));
		      }
		      return items;
		    }
		  };
		
		  cache.$$initializing = true;
		  cache.setOptions(options, true);
		  cache.$$initializing = false;
		
		  return cache;
		}
		
		function CacheFactory(cacheId, options) {
		  return createCache(cacheId, options);
		}
		
		CacheFactory.createCache = createCache;
		CacheFactory.defaults = defaults;
		
		CacheFactory.info = function () {
		  var keys = _keys(caches);
		  var info = {
		    size: keys.length,
		    caches: {}
		  };
		  for (var opt in defaults) {
		    if (defaults.hasOwnProperty(opt)) {
		      info[opt] = defaults[opt];
		    }
		  }
		  for (var i = 0; i < keys.length; i++) {
		    var key = keys[i];
		    info.caches[key] = caches[key].info();
		  }
		  return info;
		};
		
		CacheFactory.get = function (cacheId) {
		  return caches[cacheId];
		};
		CacheFactory.keySet = function () {
		  return _keySet(caches);
		};
		CacheFactory.keys = function () {
		  return _keys(caches);
		};
		CacheFactory.destroy = function (cacheId) {
		  if (caches[cacheId]) {
		    caches[cacheId].destroy();
		    delete caches[cacheId];
		  }
		};
		CacheFactory.destroyAll = function () {
		  for (var cacheId in caches) {
		    caches[cacheId].destroy();
		  }
		  caches = {};
		};
		CacheFactory.clearAll = function () {
		  for (var cacheId in caches) {
		    caches[cacheId].removeAll();
		  }
		};
		CacheFactory.removeExpiredFromAll = function () {
		  var expired = {};
		  for (var cacheId in caches) {
		    expired[cacheId] = caches[cacheId].removeExpired();
		  }
		  return expired;
		};
		CacheFactory.enableAll = function () {
		  for (var cacheId in caches) {
		    caches[cacheId].$$disabled = false;
		  }
		};
		CacheFactory.disableAll = function () {
		  for (var cacheId in caches) {
		    caches[cacheId].$$disabled = true;
		  }
		};
		CacheFactory.touchAll = function () {
		  for (var cacheId in caches) {
		    caches[cacheId].touch();
		  }
		};
		
		CacheFactory.utils = utils;
		CacheFactory.BinaryHeap = BinaryHeap;
		
		module.exports = CacheFactory;
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*!
		 * yabh
		 * @version 1.1.0 - Homepage <http://jmdobry.github.io/yabh/>
		 * @author Jason Dobry <jason.dobry@gmail.com>
		 * @copyright (c) 2015 Jason Dobry 
		 * @license MIT <https://github.com/jmdobry/yabh/blob/master/LICENSE>
		 * 
		 * @overview Yet another Binary Heap.
		 */
		(function webpackUniversalModuleDefinition(root, factory) {
			if(true)
				module.exports = factory();
			else if(typeof define === 'function' && define.amd)
				define("yabh", factory);
			else if(typeof exports === 'object')
				exports["BinaryHeap"] = factory();
			else
				root["BinaryHeap"] = factory();
		})(this, function() {
		return /******/ (function(modules) { // webpackBootstrap
		/******/ 	// The module cache
		/******/ 	var installedModules = {};
		
		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {
		
		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId])
		/******/ 			return installedModules[moduleId].exports;
		
		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
		/******/ 			exports: {},
		/******/ 			id: moduleId,
		/******/ 			loaded: false
		/******/ 		};
		
		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		
		/******/ 		// Flag the module as loaded
		/******/ 		module.loaded = true;
		
		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}
		
		
		/******/ 	// expose the modules object (__webpack_modules__)
		/******/ 	__webpack_require__.m = modules;
		
		/******/ 	// expose the module cache
		/******/ 	__webpack_require__.c = installedModules;
		
		/******/ 	// __webpack_public_path__
		/******/ 	__webpack_require__.p = "";
		
		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(0);
		/******/ })
		/************************************************************************/
		/******/ ([
		/* 0 */
		/***/ function(module, exports, __webpack_require__) {
		
			/**
			 * @method bubbleUp
			 * @param {array} heap The heap.
			 * @param {function} weightFunc The weight function.
			 * @param {number} n The index of the element to bubble up.
			 */
			function bubbleUp(heap, weightFunc, n) {
			  var element = heap[n];
			  var weight = weightFunc(element);
			  // When at 0, an element can not go up any further.
			  while (n > 0) {
			    // Compute the parent element's index, and fetch it.
			    var parentN = Math.floor((n + 1) / 2) - 1;
			    var _parent = heap[parentN];
			    // If the parent has a lesser weight, things are in order and we
			    // are done.
			    if (weight >= weightFunc(_parent)) {
			      break;
			    } else {
			      heap[parentN] = element;
			      heap[n] = _parent;
			      n = parentN;
			    }
			  }
			}
		
			/**
			 * @method bubbleDown
			 * @param {array} heap The heap.
			 * @param {function} weightFunc The weight function.
			 * @param {number} n The index of the element to sink down.
			 */
			var bubbleDown = function bubbleDown(heap, weightFunc, n) {
			  var length = heap.length;
			  var node = heap[n];
			  var nodeWeight = weightFunc(node);
		
			  while (true) {
			    var child2N = (n + 1) * 2,
			        child1N = child2N - 1;
			    var swap = null;
			    if (child1N < length) {
			      var child1 = heap[child1N],
			          child1Weight = weightFunc(child1);
			      // If the score is less than our node's, we need to swap.
			      if (child1Weight < nodeWeight) {
			        swap = child1N;
			      }
			    }
			    // Do the same checks for the other child.
			    if (child2N < length) {
			      var child2 = heap[child2N],
			          child2Weight = weightFunc(child2);
			      if (child2Weight < (swap === null ? nodeWeight : weightFunc(heap[child1N]))) {
			        swap = child2N;
			      }
			    }
		
			    if (swap === null) {
			      break;
			    } else {
			      heap[n] = heap[swap];
			      heap[swap] = node;
			      n = swap;
			    }
			  }
			};
		
			function BinaryHeap(weightFunc, compareFunc) {
			  if (!weightFunc) {
			    weightFunc = function (x) {
			      return x;
			    };
			  }
			  if (!compareFunc) {
			    compareFunc = function (x, y) {
			      return x === y;
			    };
			  }
			  if (typeof weightFunc !== 'function') {
			    throw new Error('BinaryHeap([weightFunc][, compareFunc]): "weightFunc" must be a function!');
			  }
			  if (typeof compareFunc !== 'function') {
			    throw new Error('BinaryHeap([weightFunc][, compareFunc]): "compareFunc" must be a function!');
			  }
			  this.weightFunc = weightFunc;
			  this.compareFunc = compareFunc;
			  this.heap = [];
			}
		
			var BHProto = BinaryHeap.prototype;
		
			BHProto.push = function (node) {
			  this.heap.push(node);
			  bubbleUp(this.heap, this.weightFunc, this.heap.length - 1);
			};
		
			BHProto.peek = function () {
			  return this.heap[0];
			};
		
			BHProto.pop = function () {
			  var front = this.heap[0];
			  var end = this.heap.pop();
			  if (this.heap.length > 0) {
			    this.heap[0] = end;
			    bubbleDown(this.heap, this.weightFunc, 0);
			  }
			  return front;
			};
		
			BHProto.remove = function (node) {
			  var length = this.heap.length;
			  for (var i = 0; i < length; i++) {
			    if (this.compareFunc(this.heap[i], node)) {
			      var removed = this.heap[i];
			      var end = this.heap.pop();
			      if (i !== length - 1) {
			        this.heap[i] = end;
			        bubbleUp(this.heap, this.weightFunc, i);
			        bubbleDown(this.heap, this.weightFunc, i);
			      }
			      return removed;
			    }
			  }
			  return null;
			};
		
			BHProto.removeAll = function () {
			  this.heap = [];
			};
		
			BHProto.size = function () {
			  return this.heap.length;
			};
		
			module.exports = BinaryHeap;
		
		/***/ }
		/******/ ])
		});
		;
	
	/***/ }
	/******/ ])
	});
	;
	// sourceMappingURL=cachefactory.js.map

/***/ }
/******/ ])
});
;
// sourceMappingURL=angular-cache.js.map
/*!
 * Pusher JavaScript Library v2.2.4
 * http://pusher.com/
 *
 * Copyright 2014, Pusher
 * Released under the MIT licence.
 */

;(function() {
  function Pusher(app_key, options) {
    checkAppKey(app_key);
    options = options || {};

    var self = this;

    this.key = app_key;
    this.config = Pusher.Util.extend(
      Pusher.getGlobalConfig(),
      options.cluster ? Pusher.getClusterConfig(options.cluster) : {},
      options
    );

    this.channels = new Pusher.Channels();
    this.global_emitter = new Pusher.EventsDispatcher();
    this.sessionID = Math.floor(Math.random() * 1000000000);

    this.timeline = new Pusher.Timeline(this.key, this.sessionID, {
      cluster: this.config.cluster,
      features: Pusher.Util.getClientFeatures(),
      params: this.config.timelineParams || {},
      limit: 50,
      level: Pusher.Timeline.INFO,
      version: Pusher.VERSION
    });
    if (!this.config.disableStats) {
      this.timelineSender = new Pusher.TimelineSender(this.timeline, {
        host: this.config.statsHost,
        path: "/timeline/v2/jsonp"
      });
    }

    var getStrategy = function(options) {
      var config = Pusher.Util.extend({}, self.config, options);
      return Pusher.StrategyBuilder.build(
        Pusher.getDefaultStrategy(config), config
      );
    };

    this.connection = new Pusher.ConnectionManager(
      this.key,
      Pusher.Util.extend(
        { getStrategy: getStrategy,
          timeline: this.timeline,
          activityTimeout: this.config.activity_timeout,
          pongTimeout: this.config.pong_timeout,
          unavailableTimeout: this.config.unavailable_timeout
        },
        this.config,
        { encrypted: this.isEncrypted() }
      )
    );

    this.connection.bind('connected', function() {
      self.subscribeAll();
      if (self.timelineSender) {
        self.timelineSender.send(self.connection.isEncrypted());
      }
    });
    this.connection.bind('message', function(params) {
      var internal = (params.event.indexOf('pusher_internal:') === 0);
      if (params.channel) {
        var channel = self.channel(params.channel);
        if (channel) {
          channel.handleEvent(params.event, params.data);
        }
      }
      // Emit globaly [deprecated]
      if (!internal) {
        self.global_emitter.emit(params.event, params.data);
      }
    });
    this.connection.bind('disconnected', function() {
      self.channels.disconnect();
    });
    this.connection.bind('error', function(err) {
      Pusher.warn('Error', err);
    });

    Pusher.instances.push(this);
    this.timeline.info({ instances: Pusher.instances.length });

    if (Pusher.isReady) {
      self.connect();
    }
  }
  var prototype = Pusher.prototype;

  Pusher.instances = [];
  Pusher.isReady = false;

  // To receive log output provide a Pusher.log function, for example
  // Pusher.log = function(m){console.log(m)}
  Pusher.debug = function() {
    if (!Pusher.log) {
      return;
    }
    Pusher.log(Pusher.Util.stringify.apply(this, arguments));
  };

  Pusher.warn = function() {
    var message = Pusher.Util.stringify.apply(this, arguments);
    if (window.console) {
      if (window.console.warn) {
        window.console.warn(message);
      } else if (window.console.log) {
        window.console.log(message);
      }
    }
    if (Pusher.log) {
      Pusher.log(message);
    }
  };

  Pusher.ready = function() {
    Pusher.isReady = true;
    for (var i = 0, l = Pusher.instances.length; i < l; i++) {
      Pusher.instances[i].connect();
    }
  };

  prototype.channel = function(name) {
    return this.channels.find(name);
  };

  prototype.allChannels = function() {
    return this.channels.all();
  };

  prototype.connect = function() {
    this.connection.connect();

    if (this.timelineSender) {
      if (!this.timelineSenderTimer) {
        var encrypted = this.connection.isEncrypted();
        var timelineSender = this.timelineSender;
        this.timelineSenderTimer = new Pusher.PeriodicTimer(60000, function() {
          timelineSender.send(encrypted);
        });
      }
    }
  };

  prototype.disconnect = function() {
    this.connection.disconnect();

    if (this.timelineSenderTimer) {
      this.timelineSenderTimer.ensureAborted();
      this.timelineSenderTimer = null;
    }
  };

  prototype.bind = function(event_name, callback) {
    this.global_emitter.bind(event_name, callback);
    return this;
  };

  prototype.bind_all = function(callback) {
    this.global_emitter.bind_all(callback);
    return this;
  };

  prototype.subscribeAll = function() {
    var channelName;
    for (channelName in this.channels.channels) {
      if (this.channels.channels.hasOwnProperty(channelName)) {
        this.subscribe(channelName);
      }
    }
  };

  prototype.subscribe = function(channel_name) {
    var channel = this.channels.add(channel_name, this);
    if (this.connection.state === 'connected') {
      channel.subscribe();
    }
    return channel;
  };

  prototype.unsubscribe = function(channel_name) {
    var channel = this.channels.remove(channel_name);
    if (this.connection.state === 'connected') {
      channel.unsubscribe();
    }
  };

  prototype.send_event = function(event_name, data, channel) {
    return this.connection.send_event(event_name, data, channel);
  };

  prototype.isEncrypted = function() {
    if (Pusher.Util.getDocument().location.protocol === "https:") {
      return true;
    } else {
      return Boolean(this.config.encrypted);
    }
  };

  function checkAppKey(key) {
    if (key === null || key === undefined) {
      Pusher.warn(
        'Warning', 'You must pass your app key when you instantiate Pusher.'
      );
    }
  }

  Pusher.HTTP = {};

  this.Pusher = Pusher;
}).call(this);

;(function() {
  // We need to bind clear functions this way to avoid exceptions on IE8
  function clearTimeout(timer) {
    window.clearTimeout(timer);
  }
  function clearInterval(timer) {
    window.clearInterval(timer);
  }

  function GenericTimer(set, clear, delay, callback) {
    var self = this;

    this.clear = clear;
    this.timer = set(function() {
      if (self.timer !== null) {
        self.timer = callback(self.timer);
      }
    }, delay);
  }
  var prototype = GenericTimer.prototype;

  /** Returns whether the timer is still running.
   *
   * @return {Boolean}
   */
  prototype.isRunning = function() {
    return this.timer !== null;
  };

  /** Aborts a timer when it's running. */
  prototype.ensureAborted = function() {
    if (this.timer) {
      // Clear function is already bound
      this.clear(this.timer);
      this.timer = null;
    }
  };

  /** Cross-browser compatible one-off timer abstraction.
   *
   * @param {Number} delay
   * @param {Function} callback
   */
  Pusher.Timer = function(delay, callback) {
    return new GenericTimer(setTimeout, clearTimeout, delay, function(timer) {
      callback();
      return null;
    });
  };
  /** Cross-browser compatible periodic timer abstraction.
   *
   * @param {Number} delay
   * @param {Function} callback
   */
  Pusher.PeriodicTimer = function(delay, callback) {
    return new GenericTimer(setInterval, clearInterval, delay, function(timer) {
      callback();
      return timer;
    });
  };
}).call(this);

;(function() {
  Pusher.Util = {
    now: function() {
      if (Date.now) {
        return Date.now();
      } else {
        return new Date().valueOf();
      }
    },

    defer: function(callback) {
      return new Pusher.Timer(0, callback);
    },

    /** Merges multiple objects into the target argument.
     *
     * For properties that are plain Objects, performs a deep-merge. For the
     * rest it just copies the value of the property.
     *
     * To extend prototypes use it as following:
     *   Pusher.Util.extend(Target.prototype, Base.prototype)
     *
     * You can also use it to merge objects without altering them:
     *   Pusher.Util.extend({}, object1, object2)
     *
     * @param  {Object} target
     * @return {Object} the target argument
     */
    extend: function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var extensions = arguments[i];
        for (var property in extensions) {
          if (extensions[property] && extensions[property].constructor &&
              extensions[property].constructor === Object) {
            target[property] = Pusher.Util.extend(
              target[property] || {}, extensions[property]
            );
          } else {
            target[property] = extensions[property];
          }
        }
      }
      return target;
    },

    stringify: function() {
      var m = ["Pusher"];
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] === "string") {
          m.push(arguments[i]);
        } else {
          if (window.JSON === undefined) {
            m.push(arguments[i].toString());
          } else {
            m.push(JSON.stringify(arguments[i]));
          }
        }
      }
      return m.join(" : ");
    },

    arrayIndexOf: function(array, item) { // MSIE doesn't have array.indexOf
      var nativeIndexOf = Array.prototype.indexOf;
      if (array === null) {
        return -1;
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) {
        return array.indexOf(item);
      }
      for (var i = 0, l = array.length; i < l; i++) {
        if (array[i] === item) {
          return i;
        }
      }
      return -1;
    },

    /** Applies a function f to all properties of an object.
     *
     * Function f gets 3 arguments passed:
     * - element from the object
     * - key of the element
     * - reference to the object
     *
     * @param {Object} object
     * @param {Function} f
     */
    objectApply: function(object, f) {
      for (var key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          f(object[key], key, object);
        }
      }
    },

    /** Return a list of object's own property keys
     *
     * @param {Object} object
     * @returns {Array}
     */
    keys: function(object) {
      var keys = [];
      Pusher.Util.objectApply(object, function(_, key) {
        keys.push(key);
      });
      return keys;
    },

    /** Return a list of object's own property values
     *
     * @param {Object} object
     * @returns {Array}
     */
    values: function(object) {
      var values = [];
      Pusher.Util.objectApply(object, function(value) {
        values.push(value);
      });
      return values;
    },

    /** Applies a function f to all elements of an array.
     *
     * Function f gets 3 arguments passed:
     * - element from the array
     * - index of the element
     * - reference to the array
     *
     * @param {Array} array
     * @param {Function} f
     */
    apply: function(array, f, context) {
      for (var i = 0; i < array.length; i++) {
        f.call(context || window, array[i], i, array);
      }
    },

    /** Maps all elements of the array and returns the result.
     *
     * Function f gets 4 arguments passed:
     * - element from the array
     * - index of the element
     * - reference to the source array
     * - reference to the destination array
     *
     * @param {Array} array
     * @param {Function} f
     */
    map: function(array, f) {
      var result = [];
      for (var i = 0; i < array.length; i++) {
        result.push(f(array[i], i, array, result));
      }
      return result;
    },

    /** Maps all elements of the object and returns the result.
     *
     * Function f gets 4 arguments passed:
     * - element from the object
     * - key of the element
     * - reference to the source object
     * - reference to the destination object
     *
     * @param {Object} object
     * @param {Function} f
     */
    mapObject: function(object, f) {
      var result = {};
      Pusher.Util.objectApply(object, function(value, key) {
        result[key] = f(value);
      });
      return result;
    },

    /** Filters elements of the array using a test function.
     *
     * Function test gets 4 arguments passed:
     * - element from the array
     * - index of the element
     * - reference to the source array
     * - reference to the destination array
     *
     * @param {Array} array
     * @param {Function} f
     */
    filter: function(array, test) {
      test = test || function(value) { return !!value; };

      var result = [];
      for (var i = 0; i < array.length; i++) {
        if (test(array[i], i, array, result)) {
          result.push(array[i]);
        }
      }
      return result;
    },

    /** Filters properties of the object using a test function.
     *
     * Function test gets 4 arguments passed:
     * - element from the object
     * - key of the element
     * - reference to the source object
     * - reference to the destination object
     *
     * @param {Object} object
     * @param {Function} f
     */
    filterObject: function(object, test) {
      var result = {};
      Pusher.Util.objectApply(object, function(value, key) {
        if ((test && test(value, key, object, result)) || Boolean(value)) {
          result[key] = value;
        }
      });
      return result;
    },

    /** Flattens an object into a two-dimensional array.
     *
     * @param  {Object} object
     * @return {Array} resulting array of [key, value] pairs
     */
    flatten: function(object) {
      var result = [];
      Pusher.Util.objectApply(object, function(value, key) {
        result.push([key, value]);
      });
      return result;
    },

    /** Checks whether any element of the array passes the test.
     *
     * Function test gets 3 arguments passed:
     * - element from the array
     * - index of the element
     * - reference to the source array
     *
     * @param {Array} array
     * @param {Function} f
     */
    any: function(array, test) {
      for (var i = 0; i < array.length; i++) {
        if (test(array[i], i, array)) {
          return true;
        }
      }
      return false;
    },

    /** Checks whether all elements of the array pass the test.
     *
     * Function test gets 3 arguments passed:
     * - element from the array
     * - index of the element
     * - reference to the source array
     *
     * @param {Array} array
     * @param {Function} f
     */
    all: function(array, test) {
      for (var i = 0; i < array.length; i++) {
        if (!test(array[i], i, array)) {
          return false;
        }
      }
      return true;
    },

    /** Builds a function that will proxy a method call to its first argument.
     *
     * Allows partial application of arguments, so additional arguments are
     * prepended to the argument list.
     *
     * @param  {String} name method name
     * @return {Function} proxy function
     */
    method: function(name) {
      var boundArguments = Array.prototype.slice.call(arguments, 1);
      return function(object) {
        return object[name].apply(object, boundArguments.concat(arguments));
      };
    },

    getWindow: function() {
      return window;
    },

    getDocument: function() {
      return document;
    },

    getNavigator: function() {
      return navigator;
    },

    getLocalStorage: function() {
      try {
        return window.localStorage;
      } catch (e) {
        return undefined;
      }
    },

    getClientFeatures: function() {
      return Pusher.Util.keys(
        Pusher.Util.filterObject(
          { "ws": Pusher.WSTransport, "flash": Pusher.FlashTransport },
          function (t) { return t.isSupported({}); }
        )
      );
    },

    addWindowListener: function(event, listener) {
      var _window = Pusher.Util.getWindow();
      if (_window.addEventListener !== undefined) {
        _window.addEventListener(event, listener, false);
      } else {
        _window.attachEvent("on" + event, listener);
      }
    },

    removeWindowListener: function(event, listener) {
      var _window = Pusher.Util.getWindow();
      if (_window.addEventListener !== undefined) {
        _window.removeEventListener(event, listener, false);
      } else {
        _window.detachEvent("on" + event, listener);
      }
    },

    isXHRSupported: function() {
      var XHR = window.XMLHttpRequest;
      return Boolean(XHR) && (new XHR()).withCredentials !== undefined;
    },

    isXDRSupported: function(encrypted) {
      var protocol = encrypted ? "https:" : "http:";
      var documentProtocol = Pusher.Util.getDocument().location.protocol;
      return Boolean(window.XDomainRequest) && documentProtocol === protocol;
    }
  };
}).call(this);

;(function() {
  Pusher.VERSION = '2.2.4';
  Pusher.PROTOCOL = 7;

  // DEPRECATED: WS connection parameters
  Pusher.host = 'ws.pusherapp.com';
  Pusher.ws_port = 80;
  Pusher.wss_port = 443;
  // DEPRECATED: SockJS fallback parameters
  Pusher.sockjs_host = 'sockjs.pusher.com';
  Pusher.sockjs_http_port = 80;
  Pusher.sockjs_https_port = 443;
  Pusher.sockjs_path = "/pusher";
  // DEPRECATED: Stats
  Pusher.stats_host = 'stats.pusher.com';
  // DEPRECATED: Other settings
  Pusher.channel_auth_endpoint = '/pusher/auth';
  Pusher.channel_auth_transport = 'ajax';
  Pusher.activity_timeout = 120000;
  Pusher.pong_timeout = 30000;
  Pusher.unavailable_timeout = 10000;
  // CDN configuration
  Pusher.cdn_http = 'http://js.pusher.com/';
  Pusher.cdn_https = 'https://js.pusher.com/';
  Pusher.dependency_suffix = '';

  Pusher.getDefaultStrategy = function(config) {
    var wsStrategy;
    if (config.encrypted) {
      wsStrategy = [
        ":best_connected_ever",
        ":ws_loop",
        [":delayed", 2000, [":http_fallback_loop"]]
      ];
    } else {
      wsStrategy = [
        ":best_connected_ever",
        ":ws_loop",
        [":delayed", 2000, [":wss_loop"]],
        [":delayed", 5000, [":http_fallback_loop"]]
      ];
    }

    return [
      [":def", "ws_options", {
        hostUnencrypted: config.wsHost + ":" + config.wsPort,
        hostEncrypted: config.wsHost + ":" + config.wssPort
      }],
      [":def", "wss_options", [":extend", ":ws_options", {
        encrypted: true
      }]],
      [":def", "sockjs_options", {
        hostUnencrypted: config.httpHost + ":" + config.httpPort,
        hostEncrypted: config.httpHost + ":" + config.httpsPort,
        httpPath: config.httpPath
      }],
      [":def", "timeouts", {
        loop: true,
        timeout: 15000,
        timeoutLimit: 60000
      }],

      [":def", "ws_manager", [":transport_manager", {
        lives: 2,
        minPingDelay: 10000,
        maxPingDelay: config.activity_timeout
      }]],
      [":def", "streaming_manager", [":transport_manager", {
        lives: 2,
        minPingDelay: 10000,
        maxPingDelay: config.activity_timeout
      }]],

      [":def_transport", "ws", "ws", 3, ":ws_options", ":ws_manager"],
      [":def_transport", "wss", "ws", 3, ":wss_options", ":ws_manager"],
      [":def_transport", "flash", "flash", 2, ":ws_options", ":ws_manager"],
      [":def_transport", "sockjs", "sockjs", 1, ":sockjs_options"],
      [":def_transport", "xhr_streaming", "xhr_streaming", 1, ":sockjs_options", ":streaming_manager"],
      [":def_transport", "xdr_streaming", "xdr_streaming", 1, ":sockjs_options", ":streaming_manager"],
      [":def_transport", "xhr_polling", "xhr_polling", 1, ":sockjs_options"],
      [":def_transport", "xdr_polling", "xdr_polling", 1, ":sockjs_options"],

      [":def", "ws_loop", [":sequential", ":timeouts", ":ws"]],
      [":def", "wss_loop", [":sequential", ":timeouts", ":wss"]],
      [":def", "flash_loop", [":sequential", ":timeouts", ":flash"]],
      [":def", "sockjs_loop", [":sequential", ":timeouts", ":sockjs"]],

      [":def", "streaming_loop", [":sequential", ":timeouts",
        [":if", [":is_supported", ":xhr_streaming"],
          ":xhr_streaming",
          ":xdr_streaming"
        ]
      ]],
      [":def", "polling_loop", [":sequential", ":timeouts",
        [":if", [":is_supported", ":xhr_polling"],
          ":xhr_polling",
          ":xdr_polling"
        ]
      ]],

      [":def", "http_loop", [":if", [":is_supported", ":streaming_loop"], [
        ":best_connected_ever",
          ":streaming_loop",
          [":delayed", 4000, [":polling_loop"]]
      ], [
        ":polling_loop"
      ]]],

      [":def", "http_fallback_loop",
        [":if", [":is_supported", ":http_loop"], [
          ":http_loop"
        ], [
          ":sockjs_loop"
        ]]
      ],

      [":def", "strategy",
        [":cached", 1800000,
          [":first_connected",
            [":if", [":is_supported", ":ws"],
              wsStrategy,
            [":if", [":is_supported", ":flash"], [
              ":best_connected_ever",
              ":flash_loop",
              [":delayed", 2000, [":http_fallback_loop"]]
            ], [
              ":http_fallback_loop"
            ]]]
          ]
        ]
      ]
    ];
  };
}).call(this);

;(function() {
  Pusher.getGlobalConfig = function() {
    return {
      wsHost: Pusher.host,
      wsPort: Pusher.ws_port,
      wssPort: Pusher.wss_port,
      httpHost: Pusher.sockjs_host,
      httpPort: Pusher.sockjs_http_port,
      httpsPort: Pusher.sockjs_https_port,
      httpPath: Pusher.sockjs_path,
      statsHost: Pusher.stats_host,
      authEndpoint: Pusher.channel_auth_endpoint,
      authTransport: Pusher.channel_auth_transport,
      // TODO make this consistent with other options in next major version
      activity_timeout: Pusher.activity_timeout,
      pong_timeout: Pusher.pong_timeout,
      unavailable_timeout: Pusher.unavailable_timeout
    };
  };

  Pusher.getClusterConfig = function(clusterName) {
    return {
      wsHost: "ws-" + clusterName + ".pusher.com",
      httpHost: "sockjs-" + clusterName + ".pusher.com"
    };
  };
}).call(this);

;(function() {
  function buildExceptionClass(name) {
    var constructor = function(message) {
      Error.call(this, message);
      this.name = name;
    };
    Pusher.Util.extend(constructor.prototype, Error.prototype);

    return constructor;
  }

  /** Error classes used throughout pusher-js library. */
  Pusher.Errors = {
    BadEventName: buildExceptionClass("BadEventName"),
    RequestTimedOut: buildExceptionClass("RequestTimedOut"),
    TransportPriorityTooLow: buildExceptionClass("TransportPriorityTooLow"),
    TransportClosed: buildExceptionClass("TransportClosed"),
    UnsupportedTransport: buildExceptionClass("UnsupportedTransport"),
    UnsupportedStrategy: buildExceptionClass("UnsupportedStrategy")
  };
}).call(this);

;(function() {
  /** Manages callback bindings and event emitting.
   *
   * @param Function failThrough called when no listeners are bound to an event
   */
  function EventsDispatcher(failThrough) {
    this.callbacks = new CallbackRegistry();
    this.global_callbacks = [];
    this.failThrough = failThrough;
  }
  var prototype = EventsDispatcher.prototype;

  prototype.bind = function(eventName, callback, context) {
    this.callbacks.add(eventName, callback, context);
    return this;
  };

  prototype.bind_all = function(callback) {
    this.global_callbacks.push(callback);
    return this;
  };

  prototype.unbind = function(eventName, callback, context) {
    this.callbacks.remove(eventName, callback, context);
    return this;
  };

  prototype.unbind_all = function(eventName, callback) {
    this.callbacks.remove(eventName, callback);
    return this;
  };

  prototype.emit = function(eventName, data) {
    var i;

    for (i = 0; i < this.global_callbacks.length; i++) {
      this.global_callbacks[i](eventName, data);
    }

    var callbacks = this.callbacks.get(eventName);
    if (callbacks && callbacks.length > 0) {
      for (i = 0; i < callbacks.length; i++) {
        callbacks[i].fn.call(callbacks[i].context || window, data);
      }
    } else if (this.failThrough) {
      this.failThrough(eventName, data);
    }

    return this;
  };

  /** Callback registry helper. */

  function CallbackRegistry() {
    this._callbacks = {};
  }

  CallbackRegistry.prototype.get = function(name) {
    return this._callbacks[prefix(name)];
  };

  CallbackRegistry.prototype.add = function(name, callback, context) {
    var prefixedEventName = prefix(name);
    this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [];
    this._callbacks[prefixedEventName].push({
      fn: callback,
      context: context
    });
  };

  CallbackRegistry.prototype.remove = function(name, callback, context) {
    if (!name && !callback && !context) {
      this._callbacks = {};
      return;
    }

    var names = name ? [prefix(name)] : Pusher.Util.keys(this._callbacks);

    if (callback || context) {
      Pusher.Util.apply(names, function(name) {
        this._callbacks[name] = Pusher.Util.filter(
          this._callbacks[name] || [],
          function(binding) {
            return (callback && callback !== binding.fn) ||
                   (context && context !== binding.context);
          }
        );
        if (this._callbacks[name].length === 0) {
          delete this._callbacks[name];
        }
      }, this);
    } else {
      Pusher.Util.apply(names, function(name) {
        delete this._callbacks[name];
      }, this);
    }
  };

  function prefix(name) {
    return "_" + name;
  }

  Pusher.EventsDispatcher = EventsDispatcher;
}).call(this);

(function() {
  /** Builds receivers for JSONP and Script requests.
   *
   * Each receiver is an object with following fields:
   * - number - unique (for the factory instance), numerical id of the receiver
   * - id - a string ID that can be used in DOM attributes
   * - name - name of the function triggering the receiver
   * - callback - callback function
   *
   * Receivers are triggered only once, on the first callback call.
   *
   * Receivers can be called by their name or by accessing factory object
   * by the number key.
   *
   * @param {String} prefix the prefix used in ids
   * @param {String} name the name of the object
   */
  function ScriptReceiverFactory(prefix, name) {
    this.lastId = 0;
    this.prefix = prefix;
    this.name = name;
  }
  var prototype = ScriptReceiverFactory.prototype;

  /** Creates a script receiver.
   *
   * @param {Function} callback
   * @return {ScriptReceiver}
   */
  prototype.create = function(callback) {
    this.lastId++;

    var number = this.lastId;
    var id = this.prefix + number;
    var name = this.name + "[" + number + "]";

    var called = false;
    var callbackWrapper = function() {
      if (!called) {
        callback.apply(null, arguments);
        called = true;
      }
    };

    this[number] = callbackWrapper;
    return { number: number, id: id, name: name, callback: callbackWrapper };
  };

  /** Removes the script receiver from the list.
   *
   * @param {ScriptReceiver} receiver
   */
  prototype.remove = function(receiver) {
    delete this[receiver.number];
  };

  Pusher.ScriptReceiverFactory = ScriptReceiverFactory;
  Pusher.ScriptReceivers = new ScriptReceiverFactory(
    "_pusher_script_", "Pusher.ScriptReceivers"
  );
}).call(this);

(function() {
  /** Sends a generic HTTP GET request using a script tag.
   *
   * By constructing URL in a specific way, it can be used for loading
   * JavaScript resources or JSONP requests. It can notify about errors, but
   * only in certain environments. Please take care of monitoring the state of
   * the request yourself.
   *
   * @param {String} src
   */
  function ScriptRequest(src) {
    this.src = src;
  }
  var prototype = ScriptRequest.prototype;

  /** Sends the actual script request.
   *
   * @param {ScriptReceiver} receiver
   */
  prototype.send = function(receiver) {
    var self = this;
    var errorString = "Error loading " + self.src;

    self.script = document.createElement("script");
    self.script.id = receiver.id;
    self.script.src = self.src;
    self.script.type = "text/javascript";
    self.script.charset = "UTF-8";

    if (self.script.addEventListener) {
      self.script.onerror = function() {
        receiver.callback(errorString);
      };
      self.script.onload = function() {
        receiver.callback(null);
      };
    } else {
      self.script.onreadystatechange = function() {
        if (self.script.readyState === 'loaded' ||
            self.script.readyState === 'complete') {
          receiver.callback(null);
        }
      };
    }

    // Opera<11.6 hack for missing onerror callback
    if (self.script.async === undefined && document.attachEvent &&
        /opera/i.test(navigator.userAgent)) {
      self.errorScript = document.createElement("script");
      self.errorScript.id = receiver.id + "_error";
      self.errorScript.text = receiver.name + "('" + errorString + "');";
      self.script.async = self.errorScript.async = false;
    } else {
      self.script.async = true;
    }

    var head = document.getElementsByTagName('head')[0];
    head.insertBefore(self.script, head.firstChild);
    if (self.errorScript) {
      head.insertBefore(self.errorScript, self.script.nextSibling);
    }
  };

  /** Cleans up the DOM remains of the script request. */
  prototype.cleanup = function() {
    if (this.script) {
      this.script.onload = this.script.onerror = null;
      this.script.onreadystatechange = null;
    }
    if (this.script && this.script.parentNode) {
      this.script.parentNode.removeChild(this.script);
    }
    if (this.errorScript && this.errorScript.parentNode) {
      this.errorScript.parentNode.removeChild(this.errorScript);
    }
    this.script = null;
    this.errorScript = null;
  };

  Pusher.ScriptRequest = ScriptRequest;
}).call(this);

;(function() {
  /** Handles loading dependency files.
   *
   * Dependency loaders don't remember whether a resource has been loaded or
   * not. It is caller's responsibility to make sure the resource is not loaded
   * twice. This is because it's impossible to detect resource loading status
   * without knowing its content.
   *
   * Options:
   * - cdn_http - url to HTTP CND
   * - cdn_https - url to HTTPS CDN
   * - version - version of pusher-js
   * - suffix - suffix appended to all names of dependency files
   *
   * @param {Object} options
   */
  function DependencyLoader(options) {
    this.options = options;
    this.receivers = options.receivers || Pusher.ScriptReceivers;
    this.loading = {};
  }
  var prototype = DependencyLoader.prototype;

  /** Loads the dependency from CDN.
   *
   * @param  {String} name
   * @param  {Function} callback
   */
  prototype.load = function(name, options, callback) {
    var self = this;

    if (self.loading[name] && self.loading[name].length > 0) {
      self.loading[name].push(callback);
    } else {
      self.loading[name] = [callback];

      var request = new Pusher.ScriptRequest(self.getPath(name, options));
      var receiver = self.receivers.create(function(error) {
        self.receivers.remove(receiver);

        if (self.loading[name]) {
          var callbacks = self.loading[name];
          delete self.loading[name];

          var successCallback = function(wasSuccessful) {
            if (!wasSuccessful) {
              request.cleanup();
            }
          };
          for (var i = 0; i < callbacks.length; i++) {
            callbacks[i](error, successCallback);
          }
        }
      });
      request.send(receiver);
    }
  };

  /** Returns a root URL for pusher-js CDN.
   *
   * @returns {String}
   */
  prototype.getRoot = function(options) {
    var cdn;
    var protocol = Pusher.Util.getDocument().location.protocol;
    if ((options && options.encrypted) || protocol === "https:") {
      cdn = this.options.cdn_https;
    } else {
      cdn = this.options.cdn_http;
    }
    // make sure there are no double slashes
    return cdn.replace(/\/*$/, "") + "/" + this.options.version;
  };

  /** Returns a full path to a dependency file.
   *
   * @param {String} name
   * @returns {String}
   */
  prototype.getPath = function(name, options) {
    return this.getRoot(options) + '/' + name + this.options.suffix + '.js';
  };

  Pusher.DependencyLoader = DependencyLoader;
}).call(this);

;(function() {
  Pusher.DependenciesReceivers = new Pusher.ScriptReceiverFactory(
    "_pusher_dependencies", "Pusher.DependenciesReceivers"
  );
  Pusher.Dependencies = new Pusher.DependencyLoader({
    cdn_http: Pusher.cdn_http,
    cdn_https: Pusher.cdn_https,
    version: Pusher.VERSION,
    suffix: Pusher.dependency_suffix,
    receivers: Pusher.DependenciesReceivers
  });

  function initialize() {
    Pusher.ready();
  }

  // Allows calling a function when the document body is available
   function onDocumentBody(callback) {
    if (document.body) {
      callback();
    } else {
      setTimeout(function() {
        onDocumentBody(callback);
      }, 0);
    }
  }

  function initializeOnDocumentBody() {
    onDocumentBody(initialize);
  }

  if (!window.JSON) {
    Pusher.Dependencies.load("json2", {}, initializeOnDocumentBody);
  } else {
    initializeOnDocumentBody();
  }
})();

(function() {

  var Base64 = {
    encode: function (s) {
      return btoa(utob(s));
    }
  };

  var fromCharCode = String.fromCharCode;

  var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  var b64tab = {};

  for (var i = 0, l = b64chars.length; i < l; i++) {
    b64tab[b64chars.charAt(i)] = i;
  }

  var cb_utob = function(c) {
    var cc = c.charCodeAt(0);
    return cc < 0x80 ? c
        : cc < 0x800 ? fromCharCode(0xc0 | (cc >>> 6)) +
                       fromCharCode(0x80 | (cc & 0x3f))
        : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +
          fromCharCode(0x80 | ((cc >>>  6) & 0x3f)) +
          fromCharCode(0x80 | ( cc         & 0x3f));
  };

  var utob = function(u) {
    return u.replace(/[^\x00-\x7F]/g, cb_utob);
  };

  var cb_encode = function(ccc) {
    var padlen = [0, 2, 1][ccc.length % 3];
    var ord = ccc.charCodeAt(0) << 16
      | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
      | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0));
    var chars = [
      b64chars.charAt( ord >>> 18),
      b64chars.charAt((ord >>> 12) & 63),
      padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
      padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
    ];
    return chars.join('');
  };

  var btoa = window.btoa || function(b) {
    return b.replace(/[\s\S]{1,3}/g, cb_encode);
  };

  Pusher.Base64 = Base64;

}).call(this);

(function() {
  /** Sends data via JSONP.
   *
   * Data is a key-value map. Its values are JSON-encoded and then passed
   * through base64. Finally, keys and encoded values are appended to the query
   * string.
   *
   * The class itself does not guarantee raising errors on failures, as it's not
   * possible to support such feature on all browsers. Instead, JSONP endpoint
   * should call back in a way that's easy to distinguish from browser calls,
   * for example by passing a second argument to the receiver.
   *
   * @param {String} url
   * @param {Object} data key-value map of data to be submitted
   */
  function JSONPRequest(url, data) {
    this.url = url;
    this.data = data;
  }
  var prototype = JSONPRequest.prototype;

  /** Sends the actual JSONP request.
   *
   * @param {ScriptReceiver} receiver
   */
  prototype.send = function(receiver) {
    if (this.request) {
      return;
    }

    var params = Pusher.Util.filterObject(this.data, function(value) {
      return value !== undefined;
    });
    var query = Pusher.Util.map(
      Pusher.Util.flatten(encodeParamsObject(params)),
      Pusher.Util.method("join", "=")
    ).join("&");
    var url = this.url + "/" + receiver.number + "?" + query;

    this.request = new Pusher.ScriptRequest(url);
    this.request.send(receiver);
  };

  /** Cleans up the DOM remains of the JSONP request. */
  prototype.cleanup = function() {
    if (this.request) {
      this.request.cleanup();
    }
  };

  function encodeParamsObject(data) {
    return Pusher.Util.mapObject(data, function(value) {
      if (typeof value === "object") {
        value = JSON.stringify(value);
      }
      return encodeURIComponent(Pusher.Base64.encode(value.toString()));
    });
  }

  Pusher.JSONPRequest = JSONPRequest;
}).call(this);

(function() {
  function Timeline(key, session, options) {
    this.key = key;
    this.session = session;
    this.events = [];
    this.options = options || {};
    this.sent = 0;
    this.uniqueID = 0;
  }
  var prototype = Timeline.prototype;

  // Log levels
  Timeline.ERROR = 3;
  Timeline.INFO = 6;
  Timeline.DEBUG = 7;

  prototype.log = function(level, event) {
    if (level <= this.options.level) {
      this.events.push(
        Pusher.Util.extend({}, event, { timestamp: Pusher.Util.now() })
      );
      if (this.options.limit && this.events.length > this.options.limit) {
        this.events.shift();
      }
    }
  };

  prototype.error = function(event) {
    this.log(Timeline.ERROR, event);
  };

  prototype.info = function(event) {
    this.log(Timeline.INFO, event);
  };

  prototype.debug = function(event) {
    this.log(Timeline.DEBUG, event);
  };

  prototype.isEmpty = function() {
    return this.events.length === 0;
  };

  prototype.send = function(sendJSONP, callback) {
    var self = this;

    var data = Pusher.Util.extend({
      session: self.session,
      bundle: self.sent + 1,
      key: self.key,
      lib: "js",
      version: self.options.version,
      cluster: self.options.cluster,
      features: self.options.features,
      timeline: self.events
    }, self.options.params);

    self.events = [];
    sendJSONP(data, function(error, result) {
      if (!error) {
        self.sent++;
      }
      if (callback) {
        callback(error, result);
      }
    });

    return true;
  };

  prototype.generateUniqueID = function() {
    this.uniqueID++;
    return this.uniqueID;
  };

  Pusher.Timeline = Timeline;
}).call(this);

(function() {
  function TimelineSender(timeline, options) {
    this.timeline = timeline;
    this.options = options || {};
  }
  var prototype = TimelineSender.prototype;

  prototype.send = function(encrypted, callback) {
    var self = this;

    if (self.timeline.isEmpty()) {
      return;
    }

    var sendJSONP = function(data, callback) {
      var scheme = "http" + (encrypted ? "s" : "") + "://";
      var url = scheme + (self.host || self.options.host) + self.options.path;
      var request = new Pusher.JSONPRequest(url, data);

      var receiver = Pusher.ScriptReceivers.create(function(error, result) {
        Pusher.ScriptReceivers.remove(receiver);
        request.cleanup();

        if (result && result.host) {
          self.host = result.host;
        }
        if (callback) {
          callback(error, result);
        }
      });
      request.send(receiver);
    };
    self.timeline.send(sendJSONP, callback);
  };

  Pusher.TimelineSender = TimelineSender;
}).call(this);

;(function() {
  /** Launches all substrategies and emits prioritized connected transports.
   *
   * @param {Array} strategies
   */
  function BestConnectedEverStrategy(strategies) {
    this.strategies = strategies;
  }
  var prototype = BestConnectedEverStrategy.prototype;

  prototype.isSupported = function() {
    return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"));
  };

  prototype.connect = function(minPriority, callback) {
    return connect(this.strategies, minPriority, function(i, runners) {
      return function(error, handshake) {
        runners[i].error = error;
        if (error) {
          if (allRunnersFailed(runners)) {
            callback(true);
          }
          return;
        }
        Pusher.Util.apply(runners, function(runner) {
          runner.forceMinPriority(handshake.transport.priority);
        });
        callback(null, handshake);
      };
    });
  };

  /** Connects to all strategies in parallel.
   *
   * Callback builder should be a function that takes two arguments: index
   * and a list of runners. It should return another function that will be
   * passed to the substrategy with given index. Runners can be aborted using
   * abortRunner(s) functions from this class.
   *
   * @param  {Array} strategies
   * @param  {Function} callbackBuilder
   * @return {Object} strategy runner
   */
  function connect(strategies, minPriority, callbackBuilder) {
    var runners = Pusher.Util.map(strategies, function(strategy, i, _, rs) {
      return strategy.connect(minPriority, callbackBuilder(i, rs));
    });
    return {
      abort: function() {
        Pusher.Util.apply(runners, abortRunner);
      },
      forceMinPriority: function(p) {
        Pusher.Util.apply(runners, function(runner) {
          runner.forceMinPriority(p);
        });
      }
    };
  }

  function allRunnersFailed(runners) {
    return Pusher.Util.all(runners, function(runner) {
      return Boolean(runner.error);
    });
  }

  function abortRunner(runner) {
    if (!runner.error && !runner.aborted) {
      runner.abort();
      runner.aborted = true;
    }
  }

  Pusher.BestConnectedEverStrategy = BestConnectedEverStrategy;
}).call(this);

;(function() {
  /** Caches last successful transport and uses it for following attempts.
   *
   * @param {Strategy} strategy
   * @param {Object} transports
   * @param {Object} options
   */
  function CachedStrategy(strategy, transports, options) {
    this.strategy = strategy;
    this.transports = transports;
    this.ttl = options.ttl || 1800*1000;
    this.encrypted = options.encrypted;
    this.timeline = options.timeline;
  }
  var prototype = CachedStrategy.prototype;

  prototype.isSupported = function() {
    return this.strategy.isSupported();
  };

  prototype.connect = function(minPriority, callback) {
    var encrypted = this.encrypted;
    var info = fetchTransportCache(encrypted);

    var strategies = [this.strategy];
    if (info && info.timestamp + this.ttl >= Pusher.Util.now()) {
      var transport = this.transports[info.transport];
      if (transport) {
        this.timeline.info({
          cached: true,
          transport: info.transport,
          latency: info.latency
        });
        strategies.push(new Pusher.SequentialStrategy([transport], {
          timeout: info.latency * 2 + 1000,
          failFast: true
        }));
      }
    }

    var startTimestamp = Pusher.Util.now();
    var runner = strategies.pop().connect(
      minPriority,
      function cb(error, handshake) {
        if (error) {
          flushTransportCache(encrypted);
          if (strategies.length > 0) {
            startTimestamp = Pusher.Util.now();
            runner = strategies.pop().connect(minPriority, cb);
          } else {
            callback(error);
          }
        } else {
          storeTransportCache(
            encrypted,
            handshake.transport.name,
            Pusher.Util.now() - startTimestamp
          );
          callback(null, handshake);
        }
      }
    );

    return {
      abort: function() {
        runner.abort();
      },
      forceMinPriority: function(p) {
        minPriority = p;
        if (runner) {
          runner.forceMinPriority(p);
        }
      }
    };
  };

  function getTransportCacheKey(encrypted) {
    return "pusherTransport" + (encrypted ? "Encrypted" : "Unencrypted");
  }

  function fetchTransportCache(encrypted) {
    var storage = Pusher.Util.getLocalStorage();
    if (storage) {
      try {
        var serializedCache = storage[getTransportCacheKey(encrypted)];
        if (serializedCache) {
          return JSON.parse(serializedCache);
        }
      } catch (e) {
        flushTransportCache(encrypted);
      }
    }
    return null;
  }

  function storeTransportCache(encrypted, transport, latency) {
    var storage = Pusher.Util.getLocalStorage();
    if (storage) {
      try {
        storage[getTransportCacheKey(encrypted)] = JSON.stringify({
          timestamp: Pusher.Util.now(),
          transport: transport,
          latency: latency
        });
      } catch (e) {
        // catch over quota exceptions raised by localStorage
      }
    }
  }

  function flushTransportCache(encrypted) {
    var storage = Pusher.Util.getLocalStorage();
    if (storage) {
      try {
        delete storage[getTransportCacheKey(encrypted)];
      } catch (e) {
        // catch exceptions raised by localStorage
      }
    }
  }

  Pusher.CachedStrategy = CachedStrategy;
}).call(this);

;(function() {
  /** Runs substrategy after specified delay.
   *
   * Options:
   * - delay - time in miliseconds to delay the substrategy attempt
   *
   * @param {Strategy} strategy
   * @param {Object} options
   */
  function DelayedStrategy(strategy, options) {
    this.strategy = strategy;
    this.options = { delay: options.delay };
  }
  var prototype = DelayedStrategy.prototype;

  prototype.isSupported = function() {
    return this.strategy.isSupported();
  };

  prototype.connect = function(minPriority, callback) {
    var strategy = this.strategy;
    var runner;
    var timer = new Pusher.Timer(this.options.delay, function() {
      runner = strategy.connect(minPriority, callback);
    });

    return {
      abort: function() {
        timer.ensureAborted();
        if (runner) {
          runner.abort();
        }
      },
      forceMinPriority: function(p) {
        minPriority = p;
        if (runner) {
          runner.forceMinPriority(p);
        }
      }
    };
  };

  Pusher.DelayedStrategy = DelayedStrategy;
}).call(this);

;(function() {
  /** Launches the substrategy and terminates on the first open connection.
   *
   * @param {Strategy} strategy
   */
  function FirstConnectedStrategy(strategy) {
    this.strategy = strategy;
  }
  var prototype = FirstConnectedStrategy.prototype;

  prototype.isSupported = function() {
    return this.strategy.isSupported();
  };

  prototype.connect = function(minPriority, callback) {
    var runner = this.strategy.connect(
      minPriority,
      function(error, handshake) {
        if (handshake) {
          runner.abort();
        }
        callback(error, handshake);
      }
    );
    return runner;
  };

  Pusher.FirstConnectedStrategy = FirstConnectedStrategy;
}).call(this);

;(function() {
  /** Proxies method calls to one of substrategies basing on the test function.
   *
   * @param {Function} test
   * @param {Strategy} trueBranch strategy used when test returns true
   * @param {Strategy} falseBranch strategy used when test returns false
   */
  function IfStrategy(test, trueBranch, falseBranch) {
    this.test = test;
    this.trueBranch = trueBranch;
    this.falseBranch = falseBranch;
  }
  var prototype = IfStrategy.prototype;

  prototype.isSupported = function() {
    var branch = this.test() ? this.trueBranch : this.falseBranch;
    return branch.isSupported();
  };

  prototype.connect = function(minPriority, callback) {
    var branch = this.test() ? this.trueBranch : this.falseBranch;
    return branch.connect(minPriority, callback);
  };

  Pusher.IfStrategy = IfStrategy;
}).call(this);

;(function() {
  /** Loops through strategies with optional timeouts.
   *
   * Options:
   * - loop - whether it should loop through the substrategy list
   * - timeout - initial timeout for a single substrategy
   * - timeoutLimit - maximum timeout
   *
   * @param {Strategy[]} strategies
   * @param {Object} options
   */
  function SequentialStrategy(strategies, options) {
    this.strategies = strategies;
    this.loop = Boolean(options.loop);
    this.failFast = Boolean(options.failFast);
    this.timeout = options.timeout;
    this.timeoutLimit = options.timeoutLimit;
  }
  var prototype = SequentialStrategy.prototype;

  prototype.isSupported = function() {
    return Pusher.Util.any(this.strategies, Pusher.Util.method("isSupported"));
  };

  prototype.connect = function(minPriority, callback) {
    var self = this;

    var strategies = this.strategies;
    var current = 0;
    var timeout = this.timeout;
    var runner = null;

    var tryNextStrategy = function(error, handshake) {
      if (handshake) {
        callback(null, handshake);
      } else {
        current = current + 1;
        if (self.loop) {
          current = current % strategies.length;
        }

        if (current < strategies.length) {
          if (timeout) {
            timeout = timeout * 2;
            if (self.timeoutLimit) {
              timeout = Math.min(timeout, self.timeoutLimit);
            }
          }
          runner = self.tryStrategy(
            strategies[current],
            minPriority,
            { timeout: timeout, failFast: self.failFast },
            tryNextStrategy
          );
        } else {
          callback(true);
        }
      }
    };

    runner = this.tryStrategy(
      strategies[current],
      minPriority,
      { timeout: timeout, failFast: this.failFast },
      tryNextStrategy
    );

    return {
      abort: function() {
        runner.abort();
      },
      forceMinPriority: function(p) {
        minPriority = p;
        if (runner) {
          runner.forceMinPriority(p);
        }
      }
    };
  };

  /** @private */
  prototype.tryStrategy = function(strategy, minPriority, options, callback) {
    var timer = null;
    var runner = null;

    if (options.timeout > 0) {
      timer = new Pusher.Timer(options.timeout, function() {
        runner.abort();
        callback(true);
      });
    }

    runner = strategy.connect(minPriority, function(error, handshake) {
      if (error && timer && timer.isRunning() && !options.failFast) {
        // advance to the next strategy after the timeout
        return;
      }
      if (timer) {
        timer.ensureAborted();
      }
      callback(error, handshake);
    });

    return {
      abort: function() {
        if (timer) {
          timer.ensureAborted();
        }
        runner.abort();
      },
      forceMinPriority: function(p) {
        runner.forceMinPriority(p);
      }
    };
  };

  Pusher.SequentialStrategy = SequentialStrategy;
}).call(this);

;(function() {
  /** Provides a strategy interface for transports.
   *
   * @param {String} name
   * @param {Number} priority
   * @param {Class} transport
   * @param {Object} options
   */
  function TransportStrategy(name, priority, transport, options) {
    this.name = name;
    this.priority = priority;
    this.transport = transport;
    this.options = options || {};
  }
  var prototype = TransportStrategy.prototype;

  /** Returns whether the transport is supported in the browser.
   *
   * @returns {Boolean}
   */
  prototype.isSupported = function() {
    return this.transport.isSupported({
      encrypted: this.options.encrypted
    });
  };

  /** Launches a connection attempt and returns a strategy runner.
   *
   * @param  {Function} callback
   * @return {Object} strategy runner
   */
  prototype.connect = function(minPriority, callback) {
    if (!this.isSupported()) {
      return failAttempt(new Pusher.Errors.UnsupportedStrategy(), callback);
    } else if (this.priority < minPriority) {
      return failAttempt(new Pusher.Errors.TransportPriorityTooLow(), callback);
    }

    var self = this;
    var connected = false;

    var transport = this.transport.createConnection(
      this.name, this.priority, this.options.key, this.options
    );
    var handshake = null;

    var onInitialized = function() {
      transport.unbind("initialized", onInitialized);
      transport.connect();
    };
    var onOpen = function() {
      handshake = new Pusher.Handshake(transport, function(result) {
        connected = true;
        unbindListeners();
        callback(null, result);
      });
    };
    var onError = function(error) {
      unbindListeners();
      callback(error);
    };
    var onClosed = function() {
      unbindListeners();
      callback(new Pusher.Errors.TransportClosed(transport));
    };

    var unbindListeners = function() {
      transport.unbind("initialized", onInitialized);
      transport.unbind("open", onOpen);
      transport.unbind("error", onError);
      transport.unbind("closed", onClosed);
    };

    transport.bind("initialized", onInitialized);
    transport.bind("open", onOpen);
    transport.bind("error", onError);
    transport.bind("closed", onClosed);

    // connect will be called automatically after initialization
    transport.initialize();

    return {
      abort: function() {
        if (connected) {
          return;
        }
        unbindListeners();
        if (handshake) {
          handshake.close();
        } else {
          transport.close();
        }
      },
      forceMinPriority: function(p) {
        if (connected) {
          return;
        }
        if (self.priority < p) {
          if (handshake) {
            handshake.close();
          } else {
            transport.close();
          }
        }
      }
    };
  };

  function failAttempt(error, callback) {
    Pusher.Util.defer(function() {
      callback(error);
    });
    return {
      abort: function() {},
      forceMinPriority: function() {}
    };
  }

  Pusher.TransportStrategy = TransportStrategy;
}).call(this);

(function() {
  function getGenericURL(baseScheme, params, path) {
    var scheme = baseScheme + (params.encrypted ? "s" : "");
    var host = params.encrypted ? params.hostEncrypted : params.hostUnencrypted;
    return scheme + "://" + host + path;
  }

  function getGenericPath(key, queryString) {
    var path = "/app/" + key;
    var query =
      "?protocol=" + Pusher.PROTOCOL +
      "&client=js" +
      "&version=" + Pusher.VERSION +
      (queryString ? ("&" + queryString) : "");
    return path + query;
  }

  /** URL schemes for different transport types. */
  Pusher.URLSchemes = {
    /** Standard WebSocket URL scheme. */
    ws: {
      getInitial: function(key, params) {
        return getGenericURL("ws", params, getGenericPath(key, "flash=false"));
      }
    },
    /** URL scheme for Flash. Same as WebSocket, but with a flash parameter. */
    flash: {
      getInitial: function(key, params) {
        return getGenericURL("ws", params, getGenericPath(key, "flash=true"));
      }
    },
    /** SockJS URL scheme. Supplies the path separately from the initial URL. */
    sockjs: {
      getInitial: function(key, params) {
        return getGenericURL("http", params, params.httpPath || "/pusher", "");
      },
      getPath: function(key, params) {
        return getGenericPath(key);
      }
    },
    /** URL scheme for HTTP transports. Basically, WS scheme with a prefix. */
    http: {
      getInitial: function(key, params) {
        var path = (params.httpPath || "/pusher") + getGenericPath(key);
        return getGenericURL("http", params, path);
      }
    }
  };
}).call(this);

(function() {
  /** Provides universal API for transport connections.
   *
   * Transport connection is a low-level object that wraps a connection method
   * and exposes a simple evented interface for the connection state and
   * messaging. It does not implement Pusher-specific WebSocket protocol.
   *
   * Additionally, it fetches resources needed for transport to work and exposes
   * an interface for querying transport features.
   *
   * States:
   * - new - initial state after constructing the object
   * - initializing - during initialization phase, usually fetching resources
   * - intialized - ready to establish a connection
   * - connection - when connection is being established
   * - open - when connection ready to be used
   * - closed - after connection was closed be either side
   *
   * Emits:
   * - error - after the connection raised an error
   *
   * Options:
   * - encrypted - whether connection should use ssl
   * - hostEncrypted - host to connect to when connection is encrypted
   * - hostUnencrypted - host to connect to when connection is not encrypted
   *
   * @param {String} key application key
   * @param {Object} options
   */
  function TransportConnection(hooks, name, priority, key, options) {
    Pusher.EventsDispatcher.call(this);

    this.hooks = hooks;
    this.name = name;
    this.priority = priority;
    this.key = key;
    this.options = options;

    this.state = "new";
    this.timeline = options.timeline;
    this.activityTimeout = options.activityTimeout;
    this.id = this.timeline.generateUniqueID();
  }
  var prototype = TransportConnection.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

  /** Checks whether the transport handles activity checks by itself.
   *
   * @return {Boolean}
   */
  prototype.handlesActivityChecks = function() {
    return Boolean(this.hooks.handlesActivityChecks);
  };

  /** Checks whether the transport supports the ping/pong API.
   *
   * @return {Boolean}
   */
  prototype.supportsPing = function() {
    return Boolean(this.hooks.supportsPing);
  };

  /** Initializes the transport.
   *
   * Fetches resources if needed and then transitions to initialized.
   */
  prototype.initialize = function() {
    var self = this;

    self.timeline.info(self.buildTimelineMessage({
      transport: self.name + (self.options.encrypted ? "s" : "")
    }));

    if (self.hooks.beforeInitialize) {
      self.hooks.beforeInitialize.call(self);
    }

    if (self.hooks.isInitialized()) {
      self.changeState("initialized");
    } else if (self.hooks.file) {
      self.changeState("initializing");
      Pusher.Dependencies.load(
        self.hooks.file,
        { encrypted: self.options.encrypted },
        function(error, callback) {
          if (self.hooks.isInitialized()) {
            self.changeState("initialized");
            callback(true);
          } else {
            if (error) {
              self.onError(error);
            }
            self.onClose();
            callback(false);
          }
        }
      );
    } else {
      self.onClose();
    }
  };

  /** Tries to establish a connection.
   *
   * @returns {Boolean} false if transport is in invalid state
   */
  prototype.connect = function() {
    var self = this;

    if (self.socket || self.state !== "initialized") {
      return false;
    }

    var url = self.hooks.urls.getInitial(self.key, self.options);
    try {
      self.socket = self.hooks.getSocket(url, self.options);
    } catch (e) {
      Pusher.Util.defer(function() {
        self.onError(e);
        self.changeState("closed");
      });
      return false;
    }

    self.bindListeners();

    Pusher.debug("Connecting", { transport: self.name, url: url });
    self.changeState("connecting");
    return true;
  };

  /** Closes the connection.
   *
   * @return {Boolean} true if there was a connection to close
   */
  prototype.close = function() {
    if (this.socket) {
      this.socket.close();
      return true;
    } else {
      return false;
    }
  };

  /** Sends data over the open connection.
   *
   * @param {String} data
   * @return {Boolean} true only when in the "open" state
   */
  prototype.send = function(data) {
    var self = this;

    if (self.state === "open") {
      // Workaround for MobileSafari bug (see https://gist.github.com/2052006)
      Pusher.Util.defer(function() {
        if (self.socket) {
          self.socket.send(data);
        }
      });
      return true;
    } else {
      return false;
    }
  };

  /** Sends a ping if the connection is open and transport supports it. */
  prototype.ping = function() {
    if (this.state === "open" && this.supportsPing()) {
      this.socket.ping();
    }
  };

  /** @private */
  prototype.onOpen = function() {
    if (this.hooks.beforeOpen) {
      this.hooks.beforeOpen(
        this.socket, this.hooks.urls.getPath(this.key, this.options)
      );
    }
    this.changeState("open");
    this.socket.onopen = undefined;
  };

  /** @private */
  prototype.onError = function(error) {
    this.emit("error", { type: 'WebSocketError', error: error });
    this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));
  };

  /** @private */
  prototype.onClose = function(closeEvent) {
    if (closeEvent) {
      this.changeState("closed", {
        code: closeEvent.code,
        reason: closeEvent.reason,
        wasClean: closeEvent.wasClean
      });
    } else {
      this.changeState("closed");
    }
    this.unbindListeners();
    this.socket = undefined;
  };

  /** @private */
  prototype.onMessage = function(message) {
    this.emit("message", message);
  };

  /** @private */
  prototype.onActivity = function() {
    this.emit("activity");
  };

  /** @private */
  prototype.bindListeners = function() {
    var self = this;

    self.socket.onopen = function() {
      self.onOpen();
    };
    self.socket.onerror = function(error) {
      self.onError(error);
    };
    self.socket.onclose = function(closeEvent) {
      self.onClose(closeEvent);
    };
    self.socket.onmessage = function(message) {
      self.onMessage(message);
    };

    if (self.supportsPing()) {
      self.socket.onactivity = function() { self.onActivity(); };
    }
  };

  /** @private */
  prototype.unbindListeners = function() {
    if (this.socket) {
      this.socket.onopen = undefined;
      this.socket.onerror = undefined;
      this.socket.onclose = undefined;
      this.socket.onmessage = undefined;
      if (this.supportsPing()) {
        this.socket.onactivity = undefined;
      }
    }
  };

  /** @private */
  prototype.changeState = function(state, params) {
    this.state = state;
    this.timeline.info(this.buildTimelineMessage({
      state: state,
      params: params
    }));
    this.emit(state, params);
  };

  /** @private */
  prototype.buildTimelineMessage = function(message) {
    return Pusher.Util.extend({ cid: this.id }, message);
  };

  Pusher.TransportConnection = TransportConnection;
}).call(this);

(function() {
  /** Provides interface for transport connection instantiation.
   *
   * Takes transport-specific hooks as the only argument, which allow checking
   * for transport support and creating its connections.
   *
   * Supported hooks:
   * - file - the name of the file to be fetched during initialization
   * - urls - URL scheme to be used by transport
   * - handlesActivityCheck - true when the transport handles activity checks
   * - supportsPing - true when the transport has a ping/activity API
   * - isSupported - tells whether the transport is supported in the environment
   * - getSocket - creates a WebSocket-compatible transport socket
   *
   * See transports.js for specific implementations.
   *
   * @param {Object} hooks object containing all needed transport hooks
   */
  function Transport(hooks) {
    this.hooks = hooks;
  }
  var prototype = Transport.prototype;

  /** Returns whether the transport is supported in the environment.
   *
   * @param {Object} environment the environment details (encryption, settings)
   * @returns {Boolean} true when the transport is supported
   */
  prototype.isSupported = function(environment) {
    return this.hooks.isSupported(environment);
  };

  /** Creates a transport connection.
   *
   * @param {String} name
   * @param {Number} priority
   * @param {String} key the application key
   * @param {Object} options
   * @returns {TransportConnection}
   */
  prototype.createConnection = function(name, priority, key, options) {
    return new Pusher.TransportConnection(
      this.hooks, name, priority, key, options
    );
  };

  Pusher.Transport = Transport;
}).call(this);

(function() {
  /** WebSocket transport.
   *
   * Uses native WebSocket implementation, including MozWebSocket supported by
   * earlier Firefox versions.
   */
  Pusher.WSTransport = new Pusher.Transport({
    urls: Pusher.URLSchemes.ws,
    handlesActivityChecks: false,
    supportsPing: false,

    isInitialized: function() {
      return Boolean(window.WebSocket || window.MozWebSocket);
    },
    isSupported: function() {
      return Boolean(window.WebSocket || window.MozWebSocket);
    },
    getSocket: function(url) {
      var Constructor = window.WebSocket || window.MozWebSocket;
      return new Constructor(url);
    }
  });

  /** Flash transport using the WebSocket protocol. */
  Pusher.FlashTransport = new Pusher.Transport({
    file: "flashfallback",
    urls: Pusher.URLSchemes.flash,
    handlesActivityChecks: false,
    supportsPing: false,

    isSupported: function() {
      try {
        return Boolean(new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
      } catch (e1) {
        try {
          var nav = Pusher.Util.getNavigator();
          return Boolean(
            nav &&
            nav.mimeTypes &&
            nav.mimeTypes["application/x-shockwave-flash"] !== undefined
          );
        } catch (e2) {
          return false;
        }
      }
    },
    beforeInitialize: function() {
      if (window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR === undefined) {
        window.WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR = true;
      }
      window.WEB_SOCKET_SWF_LOCATION =
        Pusher.Dependencies.getRoot({ encrypted: this.options.encrypted }) +
        "/WebSocketMain.swf";
    },
    isInitialized: function() {
      return window.FlashWebSocket !== undefined;
    },
    getSocket: function(url) {
      return new FlashWebSocket(url);
    }
  });

  /** SockJS transport. */
  Pusher.SockJSTransport = new Pusher.Transport({
    file: "sockjs",
    urls: Pusher.URLSchemes.sockjs,
    handlesActivityChecks: true,
    supportsPing: false,

    isSupported: function() {
      return true;
    },
    isInitialized: function() {
      return window.SockJS !== undefined;
    },
    getSocket: function(url, options) {
      return new SockJS(url, null, {
        js_path: Pusher.Dependencies.getPath("sockjs", {
          encrypted: options.encrypted
        }),
        ignore_null_origin: options.ignoreNullOrigin
      });
    },
    beforeOpen: function(socket, path) {
      socket.send(JSON.stringify({
        path: path
      }));
    }
  });

  var httpConfiguration = {
    urls: Pusher.URLSchemes.http,
    handlesActivityChecks: false,
    supportsPing: true,
    isInitialized: function() {
      return Boolean(Pusher.HTTP.Socket);
    }
  };

  var streamingConfiguration = Pusher.Util.extend(
    { getSocket: function(url) {
        return Pusher.HTTP.getStreamingSocket(url);
      }
    },
    httpConfiguration
  );
  var pollingConfiguration = Pusher.Util.extend(
    { getSocket: function(url) {
        return Pusher.HTTP.getPollingSocket(url);
      }
    },
    httpConfiguration
  );

  var xhrConfiguration = {
    file: "xhr",
    isSupported: Pusher.Util.isXHRSupported
  };
  var xdrConfiguration = {
    file: "xdr",
    isSupported: function(environment) {
      return Pusher.Util.isXDRSupported(environment.encrypted);
    }
  };

  /** HTTP streaming transport using CORS-enabled XMLHttpRequest. */
  Pusher.XHRStreamingTransport = new Pusher.Transport(
    Pusher.Util.extend({}, streamingConfiguration, xhrConfiguration)
  );
  /** HTTP streaming transport using XDomainRequest (IE 8,9). */
  Pusher.XDRStreamingTransport = new Pusher.Transport(
    Pusher.Util.extend({}, streamingConfiguration, xdrConfiguration)
  );
  /** HTTP long-polling transport using CORS-enabled XMLHttpRequest. */
  Pusher.XHRPollingTransport = new Pusher.Transport(
    Pusher.Util.extend({}, pollingConfiguration, xhrConfiguration)
  );
  /** HTTP long-polling transport using XDomainRequest (IE 8,9). */
  Pusher.XDRPollingTransport = new Pusher.Transport(
    Pusher.Util.extend({}, pollingConfiguration, xdrConfiguration)
  );
}).call(this);

;(function() {
  /** Creates transport connections monitored by a transport manager.
   *
   * When a transport is closed, it might mean the environment does not support
   * it. It's possible that messages get stuck in an intermediate buffer or
   * proxies terminate inactive connections. To combat these problems,
   * assistants monitor the connection lifetime, report unclean exits and
   * adjust ping timeouts to keep the connection active. The decision to disable
   * a transport is the manager's responsibility.
   *
   * @param {TransportManager} manager
   * @param {TransportConnection} transport
   * @param {Object} options
   */
  function AssistantToTheTransportManager(manager, transport, options) {
    this.manager = manager;
    this.transport = transport;
    this.minPingDelay = options.minPingDelay;
    this.maxPingDelay = options.maxPingDelay;
    this.pingDelay = undefined;
  }
  var prototype = AssistantToTheTransportManager.prototype;

  /** Creates a transport connection.
   *
   * This function has the same API as Transport#createConnection.
   *
   * @param {String} name
   * @param {Number} priority
   * @param {String} key the application key
   * @param {Object} options
   * @returns {TransportConnection}
   */
  prototype.createConnection = function(name, priority, key, options) {
    var self = this;

    options = Pusher.Util.extend({}, options, {
      activityTimeout: self.pingDelay
    });
    var connection = self.transport.createConnection(
      name, priority, key, options
    );

    var openTimestamp = null;

    var onOpen = function() {
      connection.unbind("open", onOpen);
      connection.bind("closed", onClosed);
      openTimestamp = Pusher.Util.now();
    };
    var onClosed = function(closeEvent) {
      connection.unbind("closed", onClosed);

      if (closeEvent.code === 1002 || closeEvent.code === 1003) {
        // we don't want to use transports not obeying the protocol
        self.manager.reportDeath();
      } else if (!closeEvent.wasClean && openTimestamp) {
        // report deaths only for short-living transport
        var lifespan = Pusher.Util.now() - openTimestamp;
        if (lifespan < 2 * self.maxPingDelay) {
          self.manager.reportDeath();
          self.pingDelay = Math.max(lifespan / 2, self.minPingDelay);
        }
      }
    };

    connection.bind("open", onOpen);
    return connection;
  };

  /** Returns whether the transport is supported in the environment.
   *
   * This function has the same API as Transport#isSupported. Might return false
   * when the manager decides to kill the transport.
   *
   * @param {Object} environment the environment details (encryption, settings)
   * @returns {Boolean} true when the transport is supported
   */
  prototype.isSupported = function(environment) {
    return this.manager.isAlive() && this.transport.isSupported(environment);
  };

  Pusher.AssistantToTheTransportManager = AssistantToTheTransportManager;
}).call(this);

;(function() {
  /** Keeps track of the number of lives left for a transport.
   *
   * In the beginning of a session, transports may be assigned a number of
   * lives. When an AssistantToTheTransportManager instance reports a transport
   * connection closed uncleanly, the transport loses a life. When the number
   * of lives drops to zero, the transport gets disabled by its manager.
   *
   * @param {Object} options
   */
  function TransportManager(options) {
    this.options = options || {};
    this.livesLeft = this.options.lives || Infinity;
  }
  var prototype = TransportManager.prototype;

  /** Creates a assistant for the transport.
   *
   * @param {Transport} transport
   * @returns {AssistantToTheTransportManager}
   */
  prototype.getAssistant = function(transport) {
    return new Pusher.AssistantToTheTransportManager(this, transport, {
      minPingDelay: this.options.minPingDelay,
      maxPingDelay: this.options.maxPingDelay
    });
  };

  /** Returns whether the transport has any lives left.
   *
   * @returns {Boolean}
   */
  prototype.isAlive = function() {
    return this.livesLeft > 0;
  };

  /** Takes one life from the transport. */
  prototype.reportDeath = function() {
    this.livesLeft -= 1;
  };

  Pusher.TransportManager = TransportManager;
}).call(this);

;(function() {
  var StrategyBuilder = {
    /** Transforms a JSON scheme to a strategy tree.
     *
     * @param {Array} scheme JSON strategy scheme
     * @param {Object} options a hash of symbols to be included in the scheme
     * @returns {Strategy} strategy tree that's represented by the scheme
     */
    build: function(scheme, options) {
      var context = Pusher.Util.extend({}, globalContext, options);
      return evaluate(scheme, context)[1].strategy;
    }
  };

  var transports = {
    ws: Pusher.WSTransport,
    flash: Pusher.FlashTransport,
    sockjs: Pusher.SockJSTransport,
    xhr_streaming: Pusher.XHRStreamingTransport,
    xdr_streaming: Pusher.XDRStreamingTransport,
    xhr_polling: Pusher.XHRPollingTransport,
    xdr_polling: Pusher.XDRPollingTransport
  };

  var UnsupportedStrategy = {
    isSupported: function() {
      return false;
    },
    connect: function(_, callback) {
      var deferred = Pusher.Util.defer(function() {
        callback(new Pusher.Errors.UnsupportedStrategy());
      });
      return {
        abort: function() {
          deferred.ensureAborted();
        },
        forceMinPriority: function() {}
      };
    }
  };

  // DSL bindings

  function returnWithOriginalContext(f) {
    return function(context) {
      return [f.apply(this, arguments), context];
    };
  }

  var globalContext = {
    extend: function(context, first, second) {
      return [Pusher.Util.extend({}, first, second), context];
    },

    def: function(context, name, value) {
      if (context[name] !== undefined) {
        throw "Redefining symbol " + name;
      }
      context[name] = value;
      return [undefined, context];
    },

    def_transport: function(context, name, type, priority, options, manager) {
      var transportClass = transports[type];
      if (!transportClass) {
        throw new Pusher.Errors.UnsupportedTransport(type);
      }

      var enabled =
        (!context.enabledTransports ||
          Pusher.Util.arrayIndexOf(context.enabledTransports, name) !== -1) &&
        (!context.disabledTransports ||
          Pusher.Util.arrayIndexOf(context.disabledTransports, name) === -1) &&
        (name !== "flash" || context.disableFlash !== true);

      var transport;
      if (enabled) {
        transport = new Pusher.TransportStrategy(
          name,
          priority,
          manager ? manager.getAssistant(transportClass) : transportClass,
          Pusher.Util.extend({
            key: context.key,
            encrypted: context.encrypted,
            timeline: context.timeline,
            ignoreNullOrigin: context.ignoreNullOrigin
          }, options)
        );
      } else {
        transport = UnsupportedStrategy;
      }

      var newContext = context.def(context, name, transport)[1];
      newContext.transports = context.transports || {};
      newContext.transports[name] = transport;
      return [undefined, newContext];
    },

    transport_manager: returnWithOriginalContext(function(_, options) {
      return new Pusher.TransportManager(options);
    }),

    sequential: returnWithOriginalContext(function(_, options) {
      var strategies = Array.prototype.slice.call(arguments, 2);
      return new Pusher.SequentialStrategy(strategies, options);
    }),

    cached: returnWithOriginalContext(function(context, ttl, strategy){
      return new Pusher.CachedStrategy(strategy, context.transports, {
        ttl: ttl,
        timeline: context.timeline,
        encrypted: context.encrypted
      });
    }),

    first_connected: returnWithOriginalContext(function(_, strategy) {
      return new Pusher.FirstConnectedStrategy(strategy);
    }),

    best_connected_ever: returnWithOriginalContext(function() {
      var strategies = Array.prototype.slice.call(arguments, 1);
      return new Pusher.BestConnectedEverStrategy(strategies);
    }),

    delayed: returnWithOriginalContext(function(_, delay, strategy) {
      return new Pusher.DelayedStrategy(strategy, { delay: delay });
    }),

    "if": returnWithOriginalContext(function(_, test, trueBranch, falseBranch) {
      return new Pusher.IfStrategy(test, trueBranch, falseBranch);
    }),

    is_supported: returnWithOriginalContext(function(_, strategy) {
      return function() {
        return strategy.isSupported();
      };
    })
  };

  // DSL interpreter

  function isSymbol(expression) {
    return (typeof expression === "string") && expression.charAt(0) === ":";
  }

  function getSymbolValue(expression, context) {
    return context[expression.slice(1)];
  }

  function evaluateListOfExpressions(expressions, context) {
    if (expressions.length === 0) {
      return [[], context];
    }
    var head = evaluate(expressions[0], context);
    var tail = evaluateListOfExpressions(expressions.slice(1), head[1]);
    return [[head[0]].concat(tail[0]), tail[1]];
  }

  function evaluateString(expression, context) {
    if (!isSymbol(expression)) {
      return [expression, context];
    }
    var value = getSymbolValue(expression, context);
    if (value === undefined) {
      throw "Undefined symbol " + expression;
    }
    return [value, context];
  }

  function evaluateArray(expression, context) {
    if (isSymbol(expression[0])) {
      var f = getSymbolValue(expression[0], context);
      if (expression.length > 1) {
        if (typeof f !== "function") {
          throw "Calling non-function " + expression[0];
        }
        var args = [Pusher.Util.extend({}, context)].concat(
          Pusher.Util.map(expression.slice(1), function(arg) {
            return evaluate(arg, Pusher.Util.extend({}, context))[0];
          })
        );
        return f.apply(this, args);
      } else {
        return [f, context];
      }
    } else {
      return evaluateListOfExpressions(expression, context);
    }
  }

  function evaluate(expression, context) {
    var expressionType = typeof expression;
    if (typeof expression === "string") {
      return evaluateString(expression, context);
    } else if (typeof expression === "object") {
      if (expression instanceof Array && expression.length > 0) {
        return evaluateArray(expression, context);
      }
    }
    return [expression, context];
  }

  Pusher.StrategyBuilder = StrategyBuilder;
}).call(this);

;(function() {
  /**
   * Provides functions for handling Pusher protocol-specific messages.
   */
  var Protocol = {};

  /**
   * Decodes a message in a Pusher format.
   *
   * Throws errors when messages are not parse'able.
   *
   * @param  {Object} message
   * @return {Object}
   */
  Protocol.decodeMessage = function(message) {
    try {
      var params = JSON.parse(message.data);
      if (typeof params.data === 'string') {
        try {
          params.data = JSON.parse(params.data);
        } catch (e) {
          if (!(e instanceof SyntaxError)) {
            // TODO looks like unreachable code
            // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse
            throw e;
          }
        }
      }
      return params;
    } catch (e) {
      throw { type: 'MessageParseError', error: e, data: message.data};
    }
  };

  /**
   * Encodes a message to be sent.
   *
   * @param  {Object} message
   * @return {String}
   */
  Protocol.encodeMessage = function(message) {
    return JSON.stringify(message);
  };

  /** Processes a handshake message and returns appropriate actions.
   *
   * Returns an object with an 'action' and other action-specific properties.
   *
   * There are three outcomes when calling this function. First is a successful
   * connection attempt, when pusher:connection_established is received, which
   * results in a 'connected' action with an 'id' property. When passed a
   * pusher:error event, it returns a result with action appropriate to the
   * close code and an error. Otherwise, it raises an exception.
   *
   * @param {String} message
   * @result Object
   */
  Protocol.processHandshake = function(message) {
    message = this.decodeMessage(message);

    if (message.event === "pusher:connection_established") {
      if (!message.data.activity_timeout) {
        throw "No activity timeout specified in handshake";
      }
      return {
        action: "connected",
        id: message.data.socket_id,
        activityTimeout: message.data.activity_timeout * 1000
      };
    } else if (message.event === "pusher:error") {
      // From protocol 6 close codes are sent only once, so this only
      // happens when connection does not support close codes
      return {
        action: this.getCloseAction(message.data),
        error: this.getCloseError(message.data)
      };
    } else {
      throw "Invalid handshake";
    }
  };

  /**
   * Dispatches the close event and returns an appropriate action name.
   *
   * See:
   * 1. https://developer.mozilla.org/en-US/docs/WebSockets/WebSockets_reference/CloseEvent
   * 2. http://pusher.com/docs/pusher_protocol
   *
   * @param  {CloseEvent} closeEvent
   * @return {String} close action name
   */
  Protocol.getCloseAction = function(closeEvent) {
    if (closeEvent.code < 4000) {
      // ignore 1000 CLOSE_NORMAL, 1001 CLOSE_GOING_AWAY,
      //        1005 CLOSE_NO_STATUS, 1006 CLOSE_ABNORMAL
      // ignore 1007...3999
      // handle 1002 CLOSE_PROTOCOL_ERROR, 1003 CLOSE_UNSUPPORTED,
      //        1004 CLOSE_TOO_LARGE
      if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {
        return "backoff";
      } else {
        return null;
      }
    } else if (closeEvent.code === 4000) {
      return "ssl_only";
    } else if (closeEvent.code < 4100) {
      return "refused";
    } else if (closeEvent.code < 4200) {
      return "backoff";
    } else if (closeEvent.code < 4300) {
      return "retry";
    } else {
      // unknown error
      return "refused";
    }
  };

  /**
   * Returns an error or null basing on the close event.
   *
   * Null is returned when connection was closed cleanly. Otherwise, an object
   * with error details is returned.
   *
   * @param  {CloseEvent} closeEvent
   * @return {Object} error object
   */
  Protocol.getCloseError = function(closeEvent) {
    if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {
      return {
        type: 'PusherError',
        data: {
          code: closeEvent.code,
          message: closeEvent.reason || closeEvent.message
        }
      };
    } else {
      return null;
    }
  };

  Pusher.Protocol = Protocol;
}).call(this);

;(function() {
  /**
   * Provides Pusher protocol interface for transports.
   *
   * Emits following events:
   * - message - on received messages
   * - ping - on ping requests
   * - pong - on pong responses
   * - error - when the transport emits an error
   * - closed - after closing the transport
   *
   * It also emits more events when connection closes with a code.
   * See Protocol.getCloseAction to get more details.
   *
   * @param {Number} id
   * @param {AbstractTransport} transport
   */
  function Connection(id, transport) {
    Pusher.EventsDispatcher.call(this);

    this.id = id;
    this.transport = transport;
    this.activityTimeout = transport.activityTimeout;
    this.bindListeners();
  }
  var prototype = Connection.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

  /** Returns whether used transport handles activity checks by itself
   *
   * @returns {Boolean} true if activity checks are handled by the transport
   */
  prototype.handlesActivityChecks = function() {
    return this.transport.handlesActivityChecks();
  };

  /** Sends raw data.
   *
   * @param {String} data
   */
  prototype.send = function(data) {
    return this.transport.send(data);
  };

  /** Sends an event.
   *
   * @param {String} name
   * @param {String} data
   * @param {String} [channel]
   * @returns {Boolean} whether message was sent or not
   */
  prototype.send_event = function(name, data, channel) {
    var message = { event: name, data: data };
    if (channel) {
      message.channel = channel;
    }
    Pusher.debug('Event sent', message);
    return this.send(Pusher.Protocol.encodeMessage(message));
  };

  /** Sends a ping message to the server.
   *
   * Basing on the underlying transport, it might send either transport's
   * protocol-specific ping or pusher:ping event.
   */
  prototype.ping = function() {
    if (this.transport.supportsPing()) {
      this.transport.ping();
    } else {
      this.send_event('pusher:ping', {});
    }
  };

  /** Closes the connection. */
  prototype.close = function() {
    this.transport.close();
  };

  /** @private */
  prototype.bindListeners = function() {
    var self = this;

    var listeners = {
      message: function(m) {
        var message;
        try {
          message = Pusher.Protocol.decodeMessage(m);
        } catch(e) {
          self.emit('error', {
            type: 'MessageParseError',
            error: e,
            data: m.data
          });
        }

        if (message !== undefined) {
          Pusher.debug('Event recd', message);

          switch (message.event) {
            case 'pusher:error':
              self.emit('error', { type: 'PusherError', data: message.data });
              break;
            case 'pusher:ping':
              self.emit("ping");
              break;
            case 'pusher:pong':
              self.emit("pong");
              break;
          }
          self.emit('message', message);
        }
      },
      activity: function() {
        self.emit("activity");
      },
      error: function(error) {
        self.emit("error", { type: "WebSocketError", error: error });
      },
      closed: function(closeEvent) {
        unbindListeners();

        if (closeEvent && closeEvent.code) {
          self.handleCloseEvent(closeEvent);
        }

        self.transport = null;
        self.emit("closed");
      }
    };

    var unbindListeners = function() {
      Pusher.Util.objectApply(listeners, function(listener, event) {
        self.transport.unbind(event, listener);
      });
    };

    Pusher.Util.objectApply(listeners, function(listener, event) {
      self.transport.bind(event, listener);
    });
  };

  /** @private */
  prototype.handleCloseEvent = function(closeEvent) {
    var action = Pusher.Protocol.getCloseAction(closeEvent);
    var error = Pusher.Protocol.getCloseError(closeEvent);
    if (error) {
      this.emit('error', error);
    }
    if (action) {
      this.emit(action);
    }
  };

  Pusher.Connection = Connection;
}).call(this);

;(function() {
  /**
   * Handles Pusher protocol handshakes for transports.
   *
   * Calls back with a result object after handshake is completed. Results
   * always have two fields:
   * - action - string describing action to be taken after the handshake
   * - transport - the transport object passed to the constructor
   *
   * Different actions can set different additional properties on the result.
   * In the case of 'connected' action, there will be a 'connection' property
   * containing a Connection object for the transport. Other actions should
   * carry an 'error' property.
   *
   * @param {AbstractTransport} transport
   * @param {Function} callback
   */
  function Handshake(transport, callback) {
    this.transport = transport;
    this.callback = callback;
    this.bindListeners();
  }
  var prototype = Handshake.prototype;

  prototype.close = function() {
    this.unbindListeners();
    this.transport.close();
  };

  /** @private */
  prototype.bindListeners = function() {
    var self = this;

    self.onMessage = function(m) {
      self.unbindListeners();

      try {
        var result = Pusher.Protocol.processHandshake(m);
        if (result.action === "connected") {
          self.finish("connected", {
            connection: new Pusher.Connection(result.id, self.transport),
            activityTimeout: result.activityTimeout
          });
        } else {
          self.finish(result.action, { error: result.error });
          self.transport.close();
        }
      } catch (e) {
        self.finish("error", { error: e });
        self.transport.close();
      }
    };

    self.onClosed = function(closeEvent) {
      self.unbindListeners();

      var action = Pusher.Protocol.getCloseAction(closeEvent) || "backoff";
      var error = Pusher.Protocol.getCloseError(closeEvent);
      self.finish(action, { error: error });
    };

    self.transport.bind("message", self.onMessage);
    self.transport.bind("closed", self.onClosed);
  };

  /** @private */
  prototype.unbindListeners = function() {
    this.transport.unbind("message", this.onMessage);
    this.transport.unbind("closed", this.onClosed);
  };

  /** @private */
  prototype.finish = function(action, params) {
    this.callback(
      Pusher.Util.extend({ transport: this.transport, action: action }, params)
    );
  };

  Pusher.Handshake = Handshake;
}).call(this);

;(function() {
  /** Manages connection to Pusher.
   *
   * Uses a strategy (currently only default), timers and network availability
   * info to establish a connection and export its state. In case of failures,
   * manages reconnection attempts.
   *
   * Exports state changes as following events:
   * - "state_change", { previous: p, current: state }
   * - state
   *
   * States:
   * - initialized - initial state, never transitioned to
   * - connecting - connection is being established
   * - connected - connection has been fully established
   * - disconnected - on requested disconnection
   * - unavailable - after connection timeout or when there's no network
   * - failed - when the connection strategy is not supported
   *
   * Options:
   * - unavailableTimeout - time to transition to unavailable state
   * - activityTimeout - time after which ping message should be sent
   * - pongTimeout - time for Pusher to respond with pong before reconnecting
   *
   * @param {String} key application key
   * @param {Object} options
   */
  function ConnectionManager(key, options) {
    Pusher.EventsDispatcher.call(this);

    this.key = key;
    this.options = options || {};
    this.state = "initialized";
    this.connection = null;
    this.encrypted = !!options.encrypted;
    this.timeline = this.options.timeline;

    this.connectionCallbacks = this.buildConnectionCallbacks();
    this.errorCallbacks = this.buildErrorCallbacks();
    this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);

    var self = this;

    Pusher.Network.bind("online", function() {
      self.timeline.info({ netinfo: "online" });
      if (self.state === "connecting" || self.state === "unavailable") {
        self.retryIn(0);
      }
    });
    Pusher.Network.bind("offline", function() {
      self.timeline.info({ netinfo: "offline" });
      if (self.connection) {
        self.sendActivityCheck();
      }
    });

    this.updateStrategy();
  }
  var prototype = ConnectionManager.prototype;

  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

  /** Establishes a connection to Pusher.
   *
   * Does nothing when connection is already established. See top-level doc
   * to find events emitted on connection attempts.
   */
  prototype.connect = function() {
    if (this.connection || this.runner) {
      return;
    }
    if (!this.strategy.isSupported()) {
      this.updateState("failed");
      return;
    }
    this.updateState("connecting");
    this.startConnecting();
    this.setUnavailableTimer();
  };

  /** Sends raw data.
   *
   * @param {String} data
   */
  prototype.send = function(data) {
    if (this.connection) {
      return this.connection.send(data);
    } else {
      return false;
    }
  };

  /** Sends an event.
   *
   * @param {String} name
   * @param {String} data
   * @param {String} [channel]
   * @returns {Boolean} whether message was sent or not
   */
  prototype.send_event = function(name, data, channel) {
    if (this.connection) {
      return this.connection.send_event(name, data, channel);
    } else {
      return false;
    }
  };

  /** Closes the connection. */
  prototype.disconnect = function() {
    this.disconnectInternally();
    this.updateState("disconnected");
  };

  prototype.isEncrypted = function() {
    return this.encrypted;
  };

  /** @private */
  prototype.startConnecting = function() {
    var self = this;
    var callback = function(error, handshake) {
      if (error) {
        self.runner = self.strategy.connect(0, callback);
      } else {
        if (handshake.action === "error") {
          self.emit("error", { type: "HandshakeError", error: handshake.error });
          self.timeline.error({ handshakeError: handshake.error });
        } else {
          self.abortConnecting(); // we don't support switching connections yet
          self.handshakeCallbacks[handshake.action](handshake);
        }
      }
    };
    self.runner = self.strategy.connect(0, callback);
  };

  /** @private */
  prototype.abortConnecting = function() {
    if (this.runner) {
      this.runner.abort();
      this.runner = null;
    }
  };

  /** @private */
  prototype.disconnectInternally = function() {
    this.abortConnecting();
    this.clearRetryTimer();
    this.clearUnavailableTimer();
    if (this.connection) {
      var connection = this.abandonConnection();
      connection.close();
    }
  };

  /** @private */
  prototype.updateStrategy = function() {
    this.strategy = this.options.getStrategy({
      key: this.key,
      timeline: this.timeline,
      encrypted: this.encrypted
    });
  };

  /** @private */
  prototype.retryIn = function(delay) {
    var self = this;
    self.timeline.info({ action: "retry", delay: delay });
    if (delay > 0) {
      self.emit("connecting_in", Math.round(delay / 1000));
    }
    self.retryTimer = new Pusher.Timer(delay || 0, function() {
      self.disconnectInternally();
      self.connect();
    });
  };

  /** @private */
  prototype.clearRetryTimer = function() {
    if (this.retryTimer) {
      this.retryTimer.ensureAborted();
      this.retryTimer = null;
    }
  };

  /** @private */
  prototype.setUnavailableTimer = function() {
    var self = this;
    self.unavailableTimer = new Pusher.Timer(
      self.options.unavailableTimeout,
      function() {
        self.updateState("unavailable");
      }
    );
  };

  /** @private */
  prototype.clearUnavailableTimer = function() {
    if (this.unavailableTimer) {
      this.unavailableTimer.ensureAborted();
    }
  };

  /** @private */
  prototype.sendActivityCheck = function() {
    var self = this;
    self.stopActivityCheck();
    self.connection.ping();
    // wait for pong response
    self.activityTimer = new Pusher.Timer(
      self.options.pongTimeout,
      function() {
        self.timeline.error({ pong_timed_out: self.options.pongTimeout });
        self.retryIn(0);
      }
    );
  };

  /** @private */
  prototype.resetActivityCheck = function() {
    var self = this;
    self.stopActivityCheck();
    // send ping after inactivity
    if (!self.connection.handlesActivityChecks()) {
      self.activityTimer = new Pusher.Timer(self.activityTimeout, function() {
        self.sendActivityCheck();
      });
    }
  };

  /** @private */
  prototype.stopActivityCheck = function() {
    if (this.activityTimer) {
      this.activityTimer.ensureAborted();
    }
  };

  /** @private */
  prototype.buildConnectionCallbacks = function() {
    var self = this;
    return {
      message: function(message) {
        // includes pong messages from server
        self.resetActivityCheck();
        self.emit('message', message);
      },
      ping: function() {
        self.send_event('pusher:pong', {});
      },
      activity: function() {
        self.resetActivityCheck();
      },
      error: function(error) {
        // just emit error to user - socket will already be closed by browser
        self.emit("error", { type: "WebSocketError", error: error });
      },
      closed: function() {
        self.abandonConnection();
        if (self.shouldRetry()) {
          self.retryIn(1000);
        }
      }
    };
  };

  /** @private */
  prototype.buildHandshakeCallbacks = function(errorCallbacks) {
    var self = this;
    return Pusher.Util.extend({}, errorCallbacks, {
      connected: function(handshake) {
        self.activityTimeout = Math.min(
          self.options.activityTimeout,
          handshake.activityTimeout,
          handshake.connection.activityTimeout || Infinity
        );
        self.clearUnavailableTimer();
        self.setConnection(handshake.connection);
        self.socket_id = self.connection.id;
        self.updateState("connected", { socket_id: self.socket_id });
      }
    });
  };

  /** @private */
  prototype.buildErrorCallbacks = function() {
    var self = this;

    function withErrorEmitted(callback) {
      return function(result) {
        if (result.error) {
          self.emit("error", { type: "WebSocketError", error: result.error });
        }
        callback(result);
      };
    }

    return {
      ssl_only: withErrorEmitted(function() {
        self.encrypted = true;
        self.updateStrategy();
        self.retryIn(0);
      }),
      refused: withErrorEmitted(function() {
        self.disconnect();
      }),
      backoff: withErrorEmitted(function() {
        self.retryIn(1000);
      }),
      retry: withErrorEmitted(function() {
        self.retryIn(0);
      })
    };
  };

  /** @private */
  prototype.setConnection = function(connection) {
    this.connection = connection;
    for (var event in this.connectionCallbacks) {
      this.connection.bind(event, this.connectionCallbacks[event]);
    }
    this.resetActivityCheck();
  };

  /** @private */
  prototype.abandonConnection = function() {
    if (!this.connection) {
      return;
    }
    this.stopActivityCheck();
    for (var event in this.connectionCallbacks) {
      this.connection.unbind(event, this.connectionCallbacks[event]);
    }
    var connection = this.connection;
    this.connection = null;
    return connection;
  };

  /** @private */
  prototype.updateState = function(newState, data) {
    var previousState = this.state;
    this.state = newState;
    if (previousState !== newState) {
      Pusher.debug('State changed', previousState + ' -> ' + newState);
      this.timeline.info({ state: newState, params: data });
      this.emit('state_change', { previous: previousState, current: newState });
      this.emit(newState, data);
    }
  };

  /** @private */
  prototype.shouldRetry = function() {
    return this.state === "connecting" || this.state === "connected";
  };

  Pusher.ConnectionManager = ConnectionManager;
}).call(this);

;(function() {
  /** Really basic interface providing network availability info.
   *
   * Emits:
   * - online - when browser goes online
   * - offline - when browser goes offline
   */
  function NetInfo() {
    Pusher.EventsDispatcher.call(this);

    var self = this;
    // This is okay, as IE doesn't support this stuff anyway.
    if (window.addEventListener !== undefined) {
      window.addEventListener("online", function() {
        self.emit('online');
      }, false);
      window.addEventListener("offline", function() {
        self.emit('offline');
      }, false);
    }
  }
  Pusher.Util.extend(NetInfo.prototype, Pusher.EventsDispatcher.prototype);

  var prototype = NetInfo.prototype;

  /** Returns whether browser is online or not
   *
   * Offline means definitely offline (no connection to router).
   * Inverse does NOT mean definitely online (only currently supported in Safari
   * and even there only means the device has a connection to the router).
   *
   * @return {Boolean}
   */
  prototype.isOnline = function() {
    if (window.navigator.onLine === undefined) {
      return true;
    } else {
      return window.navigator.onLine;
    }
  };

  Pusher.NetInfo = NetInfo;
  Pusher.Network = new NetInfo();
}).call(this);

;(function() {
  /** Represents a collection of members of a presence channel. */
  function Members() {
    this.reset();
  }
  var prototype = Members.prototype;

  /** Returns member's info for given id.
   *
   * Resulting object containts two fields - id and info.
   *
   * @param {Number} id
   * @return {Object} member's info or null
   */
  prototype.get = function(id) {
    if (Object.prototype.hasOwnProperty.call(this.members, id)) {
      return {
        id: id,
        info: this.members[id]
      };
    } else {
      return null;
    }
  };

  /** Calls back for each member in unspecified order.
   *
   * @param  {Function} callback
   */
  prototype.each = function(callback) {
    var self = this;
    Pusher.Util.objectApply(self.members, function(member, id) {
      callback(self.get(id));
    });
  };

  /** Updates the id for connected member. For internal use only. */
  prototype.setMyID = function(id) {
    this.myID = id;
  };

  /** Handles subscription data. For internal use only. */
  prototype.onSubscription = function(subscriptionData) {
    this.members = subscriptionData.presence.hash;
    this.count = subscriptionData.presence.count;
    this.me = this.get(this.myID);
  };

  /** Adds a new member to the collection. For internal use only. */
  prototype.addMember = function(memberData) {
    if (this.get(memberData.user_id) === null) {
      this.count++;
    }
    this.members[memberData.user_id] = memberData.user_info;
    return this.get(memberData.user_id);
  };

  /** Adds a member from the collection. For internal use only. */
  prototype.removeMember = function(memberData) {
    var member = this.get(memberData.user_id);
    if (member) {
      delete this.members[memberData.user_id];
      this.count--;
    }
    return member;
  };

  /** Resets the collection to the initial state. For internal use only. */
  prototype.reset = function() {
    this.members = {};
    this.count = 0;
    this.myID = null;
    this.me = null;
  };

  Pusher.Members = Members;
}).call(this);

;(function() {
  /** Provides base public channel interface with an event emitter.
   *
   * Emits:
   * - pusher:subscription_succeeded - after subscribing successfully
   * - other non-internal events
   *
   * @param {String} name
   * @param {Pusher} pusher
   */
  function Channel(name, pusher) {
    Pusher.EventsDispatcher.call(this, function(event, data) {
      Pusher.debug('No callbacks on ' + name + ' for ' + event);
    });

    this.name = name;
    this.pusher = pusher;
    this.subscribed = false;
  }
  var prototype = Channel.prototype;
  Pusher.Util.extend(prototype, Pusher.EventsDispatcher.prototype);

  /** Skips authorization, since public channels don't require it.
   *
   * @param {Function} callback
   */
  prototype.authorize = function(socketId, callback) {
    return callback(false, {});
  };

  /** Triggers an event */
  prototype.trigger = function(event, data) {
    if (event.indexOf("client-") !== 0) {
      throw new Pusher.Errors.BadEventName(
        "Event '" + event + "' does not start with 'client-'"
      );
    }
    return this.pusher.send_event(event, data, this.name);
  };

  /** Signals disconnection to the channel. For internal use only. */
  prototype.disconnect = function() {
    this.subscribed = false;
  };

  /** Handles an event. For internal use only.
   *
   * @param {String} event
   * @param {*} data
   */
  prototype.handleEvent = function(event, data) {
    if (event.indexOf("pusher_internal:") === 0) {
      if (event === "pusher_internal:subscription_succeeded") {
        this.subscribed = true;
        this.emit("pusher:subscription_succeeded", data);
      }
    } else {
      this.emit(event, data);
    }
  };

  /** Sends a subscription request. For internal use only. */
  prototype.subscribe = function() {
    var self = this;

    self.authorize(self.pusher.connection.socket_id, function(error, data) {
      if (error) {
        self.handleEvent('pusher:subscription_error', data);
      } else {
        self.pusher.send_event('pusher:subscribe', {
          auth: data.auth,
          channel_data: data.channel_data,
          channel: self.name
        });
      }
    });
  };

  /** Sends an unsubscription request. For internal use only. */
  prototype.unsubscribe = function() {
    this.pusher.send_event('pusher:unsubscribe', {
      channel: this.name
    });
  };

  Pusher.Channel = Channel;
}).call(this);

;(function() {
  /** Extends public channels to provide private channel interface.
   *
   * @param {String} name
   * @param {Pusher} pusher
   */
  function PrivateChannel(name, pusher) {
    Pusher.Channel.call(this, name, pusher);
  }
  var prototype = PrivateChannel.prototype;
  Pusher.Util.extend(prototype, Pusher.Channel.prototype);

  /** Authorizes the connection to use the channel.
   *
   * @param  {String} socketId
   * @param  {Function} callback
   */
  prototype.authorize = function(socketId, callback) {
    var authorizer = new Pusher.Channel.Authorizer(this, this.pusher.config);
    return authorizer.authorize(socketId, callback);
  };

  Pusher.PrivateChannel = PrivateChannel;
}).call(this);

;(function() {
  /** Adds presence channel functionality to private channels.
   *
   * @param {String} name
   * @param {Pusher} pusher
   */
  function PresenceChannel(name, pusher) {
    Pusher.PrivateChannel.call(this, name, pusher);
    this.members = new Pusher.Members();
  }
  var prototype = PresenceChannel.prototype;
  Pusher.Util.extend(prototype, Pusher.PrivateChannel.prototype);

  /** Authenticates the connection as a member of the channel.
   *
   * @param  {String} socketId
   * @param  {Function} callback
   */
  prototype.authorize = function(socketId, callback) {
    var _super = Pusher.PrivateChannel.prototype.authorize;
    var self = this;
    _super.call(self, socketId, function(error, authData) {
      if (!error) {
        if (authData.channel_data === undefined) {
          Pusher.warn(
            "Invalid auth response for channel '" +
            self.name +
            "', expected 'channel_data' field"
          );
          callback("Invalid auth response");
          return;
        }
        var channelData = JSON.parse(authData.channel_data);
        self.members.setMyID(channelData.user_id);
      }
      callback(error, authData);
    });
  };

  /** Handles presence and subscription events. For internal use only.
   *
   * @param {String} event
   * @param {*} data
   */
  prototype.handleEvent = function(event, data) {
    switch (event) {
      case "pusher_internal:subscription_succeeded":
        this.members.onSubscription(data);
        this.subscribed = true;
        this.emit("pusher:subscription_succeeded", this.members);
        break;
      case "pusher_internal:member_added":
        var addedMember = this.members.addMember(data);
        this.emit('pusher:member_added', addedMember);
        break;
      case "pusher_internal:member_removed":
        var removedMember = this.members.removeMember(data);
        if (removedMember) {
          this.emit('pusher:member_removed', removedMember);
        }
        break;
      default:
        Pusher.PrivateChannel.prototype.handleEvent.call(this, event, data);
    }
  };

  /** Resets the channel state, including members map. For internal use only. */
  prototype.disconnect = function() {
    this.members.reset();
    Pusher.PrivateChannel.prototype.disconnect.call(this);
  };

  Pusher.PresenceChannel = PresenceChannel;
}).call(this);

;(function() {
  /** Handles a channel map. */
  function Channels() {
    this.channels = {};
  }
  var prototype = Channels.prototype;

  /** Creates or retrieves an existing channel by its name.
   *
   * @param {String} name
   * @param {Pusher} pusher
   * @return {Channel}
   */
  prototype.add = function(name, pusher) {
    if (!this.channels[name]) {
      this.channels[name] = createChannel(name, pusher);
    }
    return this.channels[name];
  };

  /** Returns a list of all channels
   *
   * @return {Array}
   */
  prototype.all = function(name) {
    return Pusher.Util.values(this.channels);
  };

  /** Finds a channel by its name.
   *
   * @param {String} name
   * @return {Channel} channel or null if it doesn't exist
   */
  prototype.find = function(name) {
    return this.channels[name];
  };

  /** Removes a channel from the map.
   *
   * @param {String} name
   */
  prototype.remove = function(name) {
    var channel = this.channels[name];
    delete this.channels[name];
    return channel;
  };

  /** Proxies disconnection signal to all channels. */
  prototype.disconnect = function() {
    Pusher.Util.objectApply(this.channels, function(channel) {
      channel.disconnect();
    });
  };

  function createChannel(name, pusher) {
    if (name.indexOf('private-') === 0) {
      return new Pusher.PrivateChannel(name, pusher);
    } else if (name.indexOf('presence-') === 0) {
      return new Pusher.PresenceChannel(name, pusher);
    } else {
      return new Pusher.Channel(name, pusher);
    }
  }

  Pusher.Channels = Channels;
}).call(this);

;(function() {
  Pusher.Channel.Authorizer = function(channel, options) {
    this.channel = channel;
    this.type = options.authTransport;

    this.options = options;
    this.authOptions = (options || {}).auth || {};
  };

  Pusher.Channel.Authorizer.prototype = {
    composeQuery: function(socketId) {
      var query = 'socket_id=' + encodeURIComponent(socketId) +
        '&channel_name=' + encodeURIComponent(this.channel.name);

      for(var i in this.authOptions.params) {
        query += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(this.authOptions.params[i]);
      }

      return query;
    },

    authorize: function(socketId, callback) {
      return Pusher.authorizers[this.type].call(this, socketId, callback);
    }
  };

  var nextAuthCallbackID = 1;

  Pusher.auth_callbacks = {};
  Pusher.authorizers = {
    ajax: function(socketId, callback){
      var self = this, xhr;

      if (Pusher.XHR) {
        xhr = new Pusher.XHR();
      } else {
        xhr = (window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
      }

      xhr.open("POST", self.options.authEndpoint, true);

      // add request headers
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      for(var headerName in this.authOptions.headers) {
        xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);
      }

      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            var data, parsed = false;

            try {
              data = JSON.parse(xhr.responseText);
              parsed = true;
            } catch (e) {
              callback(true, 'JSON returned from webapp was invalid, yet status code was 200. Data was: ' + xhr.responseText);
            }

            if (parsed) { // prevents double execution.
              callback(false, data);
            }
          } else {
            Pusher.warn("Couldn't get auth info from your webapp", xhr.status);
            callback(true, xhr.status);
          }
        }
      };

      xhr.send(this.composeQuery(socketId));
      return xhr;
    },

    jsonp: function(socketId, callback){
      if(this.authOptions.headers !== undefined) {
        Pusher.warn("Warn", "To send headers with the auth request, you must use AJAX, rather than JSONP.");
      }

      var callbackName = nextAuthCallbackID.toString();
      nextAuthCallbackID++;

      var document = Pusher.Util.getDocument();
      var script = document.createElement("script");
      // Hacked wrapper.
      Pusher.auth_callbacks[callbackName] = function(data) {
        callback(false, data);
      };

      var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
      script.src = this.options.authEndpoint +
        '?callback=' +
        encodeURIComponent(callback_name) +
        '&' +
        this.composeQuery(socketId);

      var head = document.getElementsByTagName("head")[0] || document.documentElement;
      head.insertBefore( script, head.firstChild );
    }
  };
}).call(this);


(function(){
///<reference path="../typings/angularjs/angular.d.ts"/>
/*
 * decorates $compileProvider so that we have access to routing metadata
 */
function compilerProviderDecorator($compileProvider, $$directiveIntrospectorProvider) {
    var directive = $compileProvider.directive;
    $compileProvider.directive = function (name, factory) {
        $$directiveIntrospectorProvider.register(name, factory);
        return directive.apply(this, arguments);
    };
}
/*
 * private service that holds route mappings for each controller
 */
var DirectiveIntrospectorProvider = (function () {
    function DirectiveIntrospectorProvider() {
        this.directiveBuffer = [];
        this.directiveFactoriesByName = {};
        this.onDirectiveRegistered = null;
    }
    DirectiveIntrospectorProvider.prototype.register = function (name, factory) {
        if (angular.isArray(factory)) {
            factory = factory[factory.length - 1];
        }
        this.directiveFactoriesByName[name] = factory;
        if (this.onDirectiveRegistered) {
            this.onDirectiveRegistered(name, factory);
        }
        else {
            this.directiveBuffer.push({ name: name, factory: factory });
        }
    };
    DirectiveIntrospectorProvider.prototype.$get = function () {
        var _this = this;
        var fn = function (newOnControllerRegistered) {
            _this.onDirectiveRegistered = newOnControllerRegistered;
            while (_this.directiveBuffer.length > 0) {
                var directive = _this.directiveBuffer.pop();
                _this.onDirectiveRegistered(directive.name, directive.factory);
            }
        };
        fn.getTypeByName = function (name) { return _this.directiveFactoriesByName[name]; };
        return fn;
    };
    return DirectiveIntrospectorProvider;
})();
/**
 * @name ngOutlet
 *
 * @description
 * An ngOutlet is where resolved content goes.
 *
 * ## Use
 *
 * ```html
 * <div ng-outlet="name"></div>
 * ```
 *
 * The value for the `ngOutlet` attribute is optional.
 */
function ngOutletDirective($animate, $q, $rootRouter) {
    var rootRouter = $rootRouter;
    return {
        restrict: 'AE',
        transclude: 'element',
        terminal: true,
        priority: 400,
        require: ['?^^ngOutlet', 'ngOutlet'],
        link: outletLink,
        controller: (function () {
            function class_1() {
            }
            return class_1;
        })(),
        controllerAs: '$$ngOutlet'
    };
    function outletLink(scope, element, attrs, ctrls, $transclude) {
        var Outlet = (function () {
            function Outlet(controller, router) {
                this.controller = controller;
                this.router = router;
            }
            Outlet.prototype.cleanupLastView = function () {
                var _this = this;
                if (this.previousLeaveAnimation) {
                    $animate.cancel(this.previousLeaveAnimation);
                    this.previousLeaveAnimation = null;
                }
                if (this.currentScope) {
                    this.currentScope.$destroy();
                    this.currentScope = null;
                }
                if (this.currentElement) {
                    this.previousLeaveAnimation = $animate.leave(this.currentElement);
                    this.previousLeaveAnimation.then(function () { return _this.previousLeaveAnimation = null; });
                    this.currentElement = null;
                }
            };
            Outlet.prototype.reuse = function (instruction) {
                var next = $q.when(true);
                var previousInstruction = this.currentInstruction;
                this.currentInstruction = instruction;
                if (this.currentController && this.currentController.$routerOnReuse) {
                    next = $q.when(this.currentController.$routerOnReuse(this.currentInstruction, previousInstruction));
                }
                return next;
            };
            Outlet.prototype.routerCanReuse = function (nextInstruction) {
                var result;
                if (!this.currentInstruction ||
                    this.currentInstruction.componentType !== nextInstruction.componentType) {
                    result = false;
                }
                else if (this.currentController && this.currentController.$routerCanReuse) {
                    result = this.currentController.$routerCanReuse(nextInstruction, this.currentInstruction);
                }
                else {
                    result = nextInstruction === this.currentInstruction ||
                        angular.equals(nextInstruction.params, this.currentInstruction.params);
                }
                return $q.when(result);
            };
            Outlet.prototype.routerCanDeactivate = function (instruction) {
                if (this.currentController && this.currentController.$routerCanDeactivate) {
                    return $q.when(this.currentController.$routerCanDeactivate(instruction, this.currentInstruction));
                }
                return $q.when(true);
            };
            Outlet.prototype.deactivate = function (instruction) {
                if (this.currentController && this.currentController.$routerOnDeactivate) {
                    return $q.when(this.currentController.$routerOnDeactivate(instruction, this.currentInstruction));
                }
                return $q.when();
            };
            Outlet.prototype.activate = function (instruction) {
                var _this = this;
                this.previousInstruction = this.currentInstruction;
                this.currentInstruction = instruction;
                var componentName = this.controller.$$componentName = instruction.componentType;
                if (typeof componentName !== 'string') {
                    throw new Error('Component is not a string for ' + instruction.urlPath);
                }
                this.controller.$$template = '<' + dashCase(componentName) + ' $router="::$$router"></' +
                    dashCase(componentName) + '>';
                this.controller.$$router = this.router.childRouter(instruction.componentType);
                this.controller.$$outlet = this;
                var newScope = scope.$new();
                newScope.$$router = this.controller.$$router;
                this.deferredActivation = $q.defer();
                var clone = $transclude(newScope, function (clone) {
                    $animate.enter(clone, null, _this.currentElement || element);
                    _this.cleanupLastView();
                });
                this.currentElement = clone;
                this.currentScope = newScope;
                return this.deferredActivation.promise;
            };
            return Outlet;
        })();
        var parentCtrl = ctrls[0], myCtrl = ctrls[1], router = (parentCtrl && parentCtrl.$$router) || rootRouter;
        myCtrl.$$currentComponent = null;
        router.registerPrimaryOutlet(new Outlet(myCtrl, router));
    }
}
/**
 * This directive is responsible for compiling the contents of ng-outlet
 */
function ngOutletFillContentDirective($compile) {
    return {
        restrict: 'EA',
        priority: -400,
        require: 'ngOutlet',
        link: function (scope, element, attrs, ctrl) {
            var template = ctrl.$$template;
            element.html(template);
            $compile(element.contents())(scope);
        }
    };
}
function routerTriggerDirective($q) {
    return {
        require: '^ngOutlet',
        priority: -1000,
        link: function (scope, element, attr, ngOutletCtrl) {
            var promise = $q.when();
            var outlet = ngOutletCtrl.$$outlet;
            var currentComponent = outlet.currentController =
                element.controller(ngOutletCtrl.$$componentName);
            if (currentComponent.$routerOnActivate) {
                promise = $q.when(currentComponent.$routerOnActivate(outlet.currentInstruction, outlet.previousInstruction));
            }
            promise.then(outlet.deferredActivation.resolve, outlet.deferredActivation.reject);
        }
    };
}
/**
 * @name ngLink
 * @description
 * Lets you link to different parts of the app, and automatically generates hrefs.
 *
 * ## Use
 * The directive uses a simple syntax: `ng-link="componentName({ param: paramValue })"`
 *
 * ### Example
 *
 * ```js
 * angular.module('myApp', ['ngComponentRouter'])
 *   .controller('AppController', ['$rootRouter', function($rootRouter) {
 *     $rootRouter.config({ path: '/user/:id', component: 'user' });
 *     this.user = { name: 'Brian', id: 123 };
 *   });
 * ```
 *
 * ```html
 * <div ng-controller="AppController as app">
 *   <a ng-link="user({id: app.user.id})">{{app.user.name}}</a>
 * </div>
 * ```
 */
function ngLinkDirective($rootRouter, $parse) {
    return { require: '?^^ngOutlet', restrict: 'A', link: ngLinkDirectiveLinkFn };
    function ngLinkDirectiveLinkFn(scope, element, attrs, ctrl) {
        var router = (ctrl && ctrl.$$router) || $rootRouter;
        if (!router) {
            return;
        }
        var instruction = null;
        var link = attrs.ngLink || '';
        function getLink(params) {
            instruction = router.generate(params);
            return './' + angular.stringifyInstruction(instruction);
        }
        var routeParamsGetter = $parse(link);
        // we can avoid adding a watcher if it's a literal
        if (routeParamsGetter.constant) {
            var params = routeParamsGetter();
            element.attr('href', getLink(params));
        }
        else {
            scope.$watch(function () { return routeParamsGetter(scope); }, function (params) { return element.attr('href', getLink(params)); }, true);
        }
        element.on('click', function (event) {
            if (event.which !== 1 || !instruction) {
                return;
            }
            $rootRouter.navigateByInstruction(instruction);
            event.preventDefault();
        });
    }
}
function dashCase(str) {
    return str.replace(/[A-Z]/g, function (match) { return '-' + match.toLowerCase(); });
}
/*
 * A module for adding new a routing system Angular 1.
 */
angular.module('ngComponentRouter', [])
    .directive('ngOutlet', ['$animate', '$q', '$rootRouter', ngOutletDirective])
    .directive('ngOutlet', ['$compile', ngOutletFillContentDirective])
    .directive('ngLink', ['$rootRouter', '$parse', ngLinkDirective])
    .directive('$router', ['$q', routerTriggerDirective]);
/*
 * A module for inspecting controller constructors
 */
angular.module('ng')
    .provider('$$directiveIntrospector', DirectiveIntrospectorProvider)
    .config(['$compileProvider', '$$directiveIntrospectorProvider', compilerProviderDecorator]);

angular.module('ngComponentRouter').
    value('$route', null). // can be overloaded with ngRouteShim
    // Because Angular 1 has no notion of a root component, we use an object with unique identity
    // to represent this. Can be overloaded with a component name
    value('$routerRootComponent', new Object()).
    factory('$rootRouter', ['$q', '$location', '$$directiveIntrospector', '$browser', '$rootScope', '$injector', '$routerRootComponent', routerFactory]);

function routerFactory($q, $location, $$directiveIntrospector, $browser, $rootScope, $injector, $routerRootComponent) {

  // When this file is processed, the line below is replaced with
  // the contents of `../lib/facades.es5`.
  function CONST() {
  return (function(target) {
    return target;
  });
}

function CONST_EXPR(expr) {
  return expr;
}

function isPresent (x) {
  return !!x;
}

function isBlank (x) {
  return !x;
}

function isString(obj) {
  return typeof obj === 'string';
}

function isType (x) {
  return typeof x === 'function';
}

function isStringMap(obj) {
  return typeof obj === 'object' && obj !== null;
}

function isArray(obj) {
  return Array.isArray(obj);
}

function getTypeNameForDebugging (fn) {
  return fn.name || 'Root';
}

var PromiseWrapper = {
  resolve: function (reason) {
    return $q.when(reason);
  },

  reject: function (reason) {
    return $q.reject(reason);
  },

  catchError: function (promise, fn) {
    return promise.then(null, fn);
  },
  all: function (promises) {
    return $q.all(promises);
  }
};

var RegExpWrapper = {
  create: function(regExpStr, flags) {
    flags = flags ? flags.replace(/g/g, '') : '';
    return new RegExp(regExpStr, flags + 'g');
  },
  firstMatch: function(regExp, input) {
    regExp.lastIndex = 0;
    return regExp.exec(input);
  },
  matcher: function (regExp, input) {
    regExp.lastIndex = 0;
    return { re: regExp, input: input };
  }
};

var reflector = {
  annotations: function (fn) {
    //TODO: implement me
    return fn.annotations || [];
  }
};

var MapWrapper = {
  create: function() {
    return new Map();
  },

  get: function(m, k) {
    return m.get(k);
  },

  set: function(m, k, v) {
    return m.set(k, v);
  },

  contains: function (m, k) {
    return m.has(k);
  },

  forEach: function (m, fn) {
    return m.forEach(fn);
  }
};

var StringMapWrapper = {
  create: function () {
    return {};
  },

  set: function (m, k, v) {
    return m[k] = v;
  },

  get: function (m, k) {
    return m.hasOwnProperty(k) ? m[k] : undefined;
  },

  contains: function (m, k) {
    return m.hasOwnProperty(k);
  },

  keys: function(map) {
    return Object.keys(map);
  },

  isEmpty: function(map) {
    for (var prop in map) {
      if (map.hasOwnProperty(prop)) {
        return false;
      }
    }
    return true;
  },

  delete: function(map, key) {
    delete map[key];
  },

  forEach: function (m, fn) {
    for (var prop in m) {
      if (m.hasOwnProperty(prop)) {
        fn(m[prop], prop);
      }
    }
  },

  equals: function (m1, m2) {
    var k1 = Object.keys(m1);
    var k2 = Object.keys(m2);
    if (k1.length != k2.length) {
      return false;
    }
    var key;
    for (var i = 0; i < k1.length; i++) {
      key = k1[i];
      if (m1[key] !== m2[key]) {
        return false;
      }
    }
    return true;
  },

  merge: function(m1, m2) {
    var m = {};
    for (var attr in m1) {
      if (m1.hasOwnProperty(attr)) {
        m[attr] = m1[attr];
      }
    }
    for (var attr in m2) {
      if (m2.hasOwnProperty(attr)) {
        m[attr] = m2[attr];
      }
    }
    return m;
  }
};

var List = Array;
var ListWrapper = {
  toJSON: function(l) {
    return JSON.stringify(l);
  },

  clear: function (l) {
    l.length = 0;
  },

  create: function () {
    return [];
  },

  push: function (l, v) {
    return l.push(v);
  },

  forEach: function (l, fn) {
    return l.forEach(fn);
  },

  first: function(array) {
    if (!array)
      return null;
    return array[0];
  },

  last: function(array) {
    return (array && array.length) > 0 ? array[array.length - 1] : null;
  },

  map: function (l, fn) {
    return l.map(fn);
  },

  join: function (l, str) {
    return l.join(str);
  },

  reduce: function(list, fn, init) {
    return list.reduce(fn, init);
  },

  filter: function(array, pred) {
    return array.filter(pred);
  },

  concat: function(a, b) {
    return a.concat(b);
  },

  slice: function(l) {
    var from = arguments[1] !== (void 0) ? arguments[1] : 0;
    var to = arguments[2] !== (void 0) ? arguments[2] : null;
    return l.slice(from, to === null ? undefined : to);
  },

  maximum: function(list, predicate) {
    if (list.length == 0) {
      return null;
    }
    var solution = null;
    var maxValue = -Infinity;
    for (var index = 0; index < list.length; index++) {
      var candidate = list[index];
      if (isBlank(candidate)) {
        continue;
      }
      var candidateValue = predicate(candidate);
      if (candidateValue > maxValue) {
        solution = candidate;
        maxValue = candidateValue;
      }
    }
    return solution;
  }
};

var StringWrapper = {
  charCodeAt: function(s, i) {
    return s.charCodeAt(i);
  },

  equals: function (s1, s2) {
    return s1 === s2;
  },

  split: function(s, re) {
    return s.split(re);
  },

  replaceAll: function(s, from, replace) {
    return s.replace(from, replace);
  },

  replaceAllMapped: function(s, from, cb) {
    return s.replace(from, function(matches) {
      // Remove offset & string from the result array
      matches.splice(-2, 2);
      // The callback receives match, p1, ..., pn
      return cb.apply(null, matches);
    });
  },

  contains: function(s, substr) {
    return s.indexOf(substr) != -1;
  }

};

//TODO: implement?
// I think it's too heavy to ask 1.x users to bring in Rx for the router...
function EventEmitter() {}

var BaseException = Error;

var ObservableWrapper = {
  callNext: function(ob, val) {
    ob.fn(val);
  },
  callEmit: function(ob, val) {
    ob.fn(val);
  },

  subscribe: function(ob, fn) {
    ob.fn = fn;
  }
};

// TODO: https://github.com/angular/angular.js/blob/master/src/ng/browser.js#L227-L265
var $__router_47_location__ = {
  Location: Location
};

function Location(){}
Location.prototype.subscribe = function () {
  //TODO: implement
};
Location.prototype.path = function () {
  return $location.url();
};
Location.prototype.go = function (path, query) {
  return $location.url(path + query);
};


  var exports = {
    Injectable: function () {},
    OpaqueToken: function () {},
    Inject: function () {}
  };
  var require = function () {return exports;};

  // When this file is processed, the line below is replaced with
  // the contents of the compiled TypeScript classes.
  var TouchMap = (function () {
    function TouchMap(map) {
        var _this = this;
        this.map = {};
        this.keys = {};
        if (isPresent(map)) {
            StringMapWrapper.forEach(map, function (value, key) {
                _this.map[key] = isPresent(value) ? value.toString() : null;
                _this.keys[key] = true;
            });
        }
    }
    TouchMap.prototype.get = function (key) {
        StringMapWrapper.delete(this.keys, key);
        return this.map[key];
    };
    TouchMap.prototype.getUnused = function () {
        var _this = this;
        var unused = {};
        var keys = StringMapWrapper.keys(this.keys);
        keys.forEach(function (key) { return unused[key] = StringMapWrapper.get(_this.map, key); });
        return unused;
    };
    return TouchMap;
})();
exports.TouchMap = TouchMap;
function normalizeString(obj) {
    if (isBlank(obj)) {
        return null;
    }
    else {
        return obj.toString();
    }
}
exports.normalizeString = normalizeString;
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
function convertUrlParamsToArray(urlParams) {
    var paramsArray = [];
    if (isBlank(urlParams)) {
        return [];
    }
    StringMapWrapper.forEach(urlParams, function (value, key) { paramsArray.push((value === true) ? key : key + '=' + value); });
    return paramsArray;
}
exports.convertUrlParamsToArray = convertUrlParamsToArray;
// Convert an object of url parameters into a string that can be used in an URL
function serializeParams(urlParams, joiner) {
    if (joiner === void 0) { joiner = '&'; }
    return convertUrlParamsToArray(urlParams).join(joiner);
}
exports.serializeParams = serializeParams;
/**
 * This class represents a parsed URL
 */
var Url = (function () {
    function Url(path, child, auxiliary, params) {
        if (child === void 0) { child = null; }
        if (auxiliary === void 0) { auxiliary = CONST_EXPR([]); }
        if (params === void 0) { params = CONST_EXPR({}); }
        this.path = path;
        this.child = child;
        this.auxiliary = auxiliary;
        this.params = params;
    }
    Url.prototype.toString = function () {
        return this.path + this._matrixParamsToString() + this._auxToString() + this._childString();
    };
    Url.prototype.segmentToString = function () { return this.path + this._matrixParamsToString(); };
    /** @internal */
    Url.prototype._auxToString = function () {
        return this.auxiliary.length > 0 ?
            ('(' + this.auxiliary.map(function (sibling) { return sibling.toString(); }).join('//') + ')') :
            '';
    };
    Url.prototype._matrixParamsToString = function () {
        var paramString = serializeParams(this.params, ';');
        if (paramString.length > 0) {
            return ';' + paramString;
        }
        return '';
    };
    /** @internal */
    Url.prototype._childString = function () { return isPresent(this.child) ? ('/' + this.child.toString()) : ''; };
    return Url;
})();
exports.Url = Url;
var RootUrl = (function (_super) {
    __extends(RootUrl, _super);
    function RootUrl(path, child, auxiliary, params) {
        if (child === void 0) { child = null; }
        if (auxiliary === void 0) { auxiliary = CONST_EXPR([]); }
        if (params === void 0) { params = null; }
        _super.call(this, path, child, auxiliary, params);
    }
    RootUrl.prototype.toString = function () {
        return this.path + this._auxToString() + this._childString() + this._queryParamsToString();
    };
    RootUrl.prototype.segmentToString = function () { return this.path + this._queryParamsToString(); };
    RootUrl.prototype._queryParamsToString = function () {
        if (isBlank(this.params)) {
            return '';
        }
        return '?' + serializeParams(this.params);
    };
    return RootUrl;
})(Url);
exports.RootUrl = RootUrl;
function pathSegmentsToUrl(pathSegments) {
    var url = new Url(pathSegments[pathSegments.length - 1]);
    for (var i = pathSegments.length - 2; i >= 0; i -= 1) {
        url = new Url(pathSegments[i], url);
    }
    return url;
}
exports.pathSegmentsToUrl = pathSegmentsToUrl;
var SEGMENT_RE = RegExpWrapper.create('^[^\\/\\(\\)\\?;=&#]+');
function matchUrlSegment(str) {
    var match = RegExpWrapper.firstMatch(SEGMENT_RE, str);
    return isPresent(match) ? match[0] : '';
}
var UrlParser = (function () {
    function UrlParser() {
    }
    UrlParser.prototype.peekStartsWith = function (str) { return this._remaining.startsWith(str); };
    UrlParser.prototype.capture = function (str) {
        if (!this._remaining.startsWith(str)) {
            throw new BaseException("Expected \"" + str + "\".");
        }
        this._remaining = this._remaining.substring(str.length);
    };
    UrlParser.prototype.parse = function (url) {
        this._remaining = url;
        if (url == '' || url == '/') {
            return new Url('');
        }
        return this.parseRoot();
    };
    // segment + (aux segments) + (query params)
    UrlParser.prototype.parseRoot = function () {
        if (this.peekStartsWith('/')) {
            this.capture('/');
        }
        var path = matchUrlSegment(this._remaining);
        this.capture(path);
        var aux = [];
        if (this.peekStartsWith('(')) {
            aux = this.parseAuxiliaryRoutes();
        }
        if (this.peekStartsWith(';')) {
            // TODO: should these params just be dropped?
            this.parseMatrixParams();
        }
        var child = null;
        if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
            this.capture('/');
            child = this.parseSegment();
        }
        var queryParams = null;
        if (this.peekStartsWith('?')) {
            queryParams = this.parseQueryParams();
        }
        return new RootUrl(path, child, aux, queryParams);
    };
    // segment + (matrix params) + (aux segments)
    UrlParser.prototype.parseSegment = function () {
        if (this._remaining.length == 0) {
            return null;
        }
        if (this.peekStartsWith('/')) {
            this.capture('/');
        }
        var path = matchUrlSegment(this._remaining);
        this.capture(path);
        var matrixParams = null;
        if (this.peekStartsWith(';')) {
            matrixParams = this.parseMatrixParams();
        }
        var aux = [];
        if (this.peekStartsWith('(')) {
            aux = this.parseAuxiliaryRoutes();
        }
        var child = null;
        if (this.peekStartsWith('/') && !this.peekStartsWith('//')) {
            this.capture('/');
            child = this.parseSegment();
        }
        return new Url(path, child, aux, matrixParams);
    };
    UrlParser.prototype.parseQueryParams = function () {
        var params = {};
        this.capture('?');
        this.parseParam(params);
        while (this._remaining.length > 0 && this.peekStartsWith('&')) {
            this.capture('&');
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseMatrixParams = function () {
        var params = {};
        while (this._remaining.length > 0 && this.peekStartsWith(';')) {
            this.capture(';');
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseParam = function (params) {
        var key = matchUrlSegment(this._remaining);
        if (isBlank(key)) {
            return;
        }
        this.capture(key);
        var value = true;
        if (this.peekStartsWith('=')) {
            this.capture('=');
            var valueMatch = matchUrlSegment(this._remaining);
            if (isPresent(valueMatch)) {
                value = valueMatch;
                this.capture(value);
            }
        }
        params[key] = value;
    };
    UrlParser.prototype.parseAuxiliaryRoutes = function () {
        var routes = [];
        this.capture('(');
        while (!this.peekStartsWith(')') && this._remaining.length > 0) {
            routes.push(this.parseSegment());
            if (this.peekStartsWith('//')) {
                this.capture('//');
            }
        }
        this.capture(')');
        return routes;
    };
    return UrlParser;
})();
exports.UrlParser = UrlParser;
exports.parser = new UrlParser();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var RouteLifecycleHook = (function () {
    function RouteLifecycleHook(name) {
        this.name = name;
    }
    RouteLifecycleHook = __decorate([
        CONST()
    ], RouteLifecycleHook);
    return RouteLifecycleHook;
})();
exports.RouteLifecycleHook = RouteLifecycleHook;
var CanActivate = (function () {
    function CanActivate(fn) {
        this.fn = fn;
    }
    CanActivate = __decorate([
        CONST()
    ], CanActivate);
    return CanActivate;
})();
exports.CanActivate = CanActivate;
exports.routerCanReuse = CONST_EXPR(new RouteLifecycleHook("routerCanReuse"));
exports.routerCanDeactivate = CONST_EXPR(new RouteLifecycleHook("routerCanDeactivate"));
exports.routerOnActivate = CONST_EXPR(new RouteLifecycleHook("routerOnActivate"));
exports.routerOnReuse = CONST_EXPR(new RouteLifecycleHook("routerOnReuse"));
exports.routerOnDeactivate = CONST_EXPR(new RouteLifecycleHook("routerOnDeactivate"));
var lifecycle_annotations_impl_1 = require('./lifecycle_annotations_impl');
function hasLifecycleHook(e, type) {
    if (!(type instanceof Type))
        return false;
    return e.name in type.prototype;
}
exports.hasLifecycleHook = hasLifecycleHook;
function getCanActivateHook(type) {
    var annotations = reflector.annotations(type);
    for (var i = 0; i < annotations.length; i += 1) {
        var annotation = annotations[i];
        if (annotation instanceof lifecycle_annotations_impl_1.CanActivate) {
            return annotation.fn;
        }
    }
    return null;
}
exports.getCanActivateHook = getCanActivateHook;
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var route_definition_1 = require('../route_definition');
exports.RouteDefinition = route_definition_1.RouteDefinition;
/**
 * The `RouteConfig` decorator defines routes for a given component.
 *
 * It takes an array of {@link RouteDefinition}s.
 */
var RouteConfig = (function () {
    function RouteConfig(configs) {
        this.configs = configs;
    }
    RouteConfig = __decorate([
        CONST()
    ], RouteConfig);
    return RouteConfig;
})();
exports.RouteConfig = RouteConfig;
var AbstractRoute = (function () {
    function AbstractRoute(_a) {
        var name = _a.name, useAsDefault = _a.useAsDefault, path = _a.path, regex = _a.regex, serializer = _a.serializer, data = _a.data;
        this.name = name;
        this.useAsDefault = useAsDefault;
        this.path = path;
        this.regex = regex;
        this.serializer = serializer;
        this.data = data;
    }
    AbstractRoute = __decorate([
        CONST()
    ], AbstractRoute);
    return AbstractRoute;
})();
exports.AbstractRoute = AbstractRoute;
/**
 * `Route` is a type of {@link RouteDefinition} used to route a path to a component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `component` a component type.
 * - `name` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via {@link RouteData}.
 * - `useAsDefault` is a boolean value. If `true`, the child route will be navigated to if no child
 * route is specified during the navigation.
 *
 * ### Example
 * ```
 * import {RouteConfig, Route} from 'angular2/router';
 *
 * @RouteConfig([
 *   new Route({path: '/home', component: HomeCmp, name: 'HomeCmp' })
 * ])
 * class MyApp {}
 * ```
 */
var Route = (function (_super) {
    __extends(Route, _super);
    function Route(_a) {
        var name = _a.name, useAsDefault = _a.useAsDefault, path = _a.path, regex = _a.regex, serializer = _a.serializer, data = _a.data, component = _a.component;
        _super.call(this, {
            name: name,
            useAsDefault: useAsDefault,
            path: path,
            regex: regex,
            serializer: serializer,
            data: data
        });
        this.aux = null;
        this.component = component;
    }
    Route = __decorate([
        CONST()
    ], Route);
    return Route;
})(AbstractRoute);
exports.Route = Route;
/**
 * `AuxRoute` is a type of {@link RouteDefinition} used to define an auxiliary route.
 *
 * It takes an object with the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `component` a component type.
 * - `name` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via {@link RouteData}.
 *
 * ### Example
 * ```
 * import {RouteConfig, AuxRoute} from 'angular2/router';
 *
 * @RouteConfig([
 *   new AuxRoute({path: '/home', component: HomeCmp})
 * ])
 * class MyApp {}
 * ```
 */
var AuxRoute = (function (_super) {
    __extends(AuxRoute, _super);
    function AuxRoute(_a) {
        var name = _a.name, useAsDefault = _a.useAsDefault, path = _a.path, regex = _a.regex, serializer = _a.serializer, data = _a.data, component = _a.component;
        _super.call(this, {
            name: name,
            useAsDefault: useAsDefault,
            path: path,
            regex: regex,
            serializer: serializer,
            data: data
        });
        this.component = component;
    }
    AuxRoute = __decorate([
        CONST()
    ], AuxRoute);
    return AuxRoute;
})(AbstractRoute);
exports.AuxRoute = AuxRoute;
/**
 * `AsyncRoute` is a type of {@link RouteDefinition} used to route a path to an asynchronously
 * loaded component.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `loader` is a function that returns a promise that resolves to a component.
 * - `name` is an optional `CamelCase` string representing the name of the route.
 * - `data` is an optional property of any type representing arbitrary route metadata for the given
 * route. It is injectable via {@link RouteData}.
 * - `useAsDefault` is a boolean value. If `true`, the child route will be navigated to if no child
 * route is specified during the navigation.
 *
 * ### Example
 * ```
 * import {RouteConfig, AsyncRoute} from 'angular2/router';
 *
 * @RouteConfig([
 *   new AsyncRoute({path: '/home', loader: () => Promise.resolve(MyLoadedCmp), name:
 * 'MyLoadedCmp'})
 * ])
 * class MyApp {}
 * ```
 */
var AsyncRoute = (function (_super) {
    __extends(AsyncRoute, _super);
    function AsyncRoute(_a) {
        var name = _a.name, useAsDefault = _a.useAsDefault, path = _a.path, regex = _a.regex, serializer = _a.serializer, data = _a.data, loader = _a.loader;
        _super.call(this, {
            name: name,
            useAsDefault: useAsDefault,
            path: path,
            regex: regex,
            serializer: serializer,
            data: data
        });
        this.aux = null;
        this.loader = loader;
    }
    AsyncRoute = __decorate([
        CONST()
    ], AsyncRoute);
    return AsyncRoute;
})(AbstractRoute);
exports.AsyncRoute = AsyncRoute;
/**
 * `Redirect` is a type of {@link RouteDefinition} used to route a path to a canonical route.
 *
 * It has the following properties:
 * - `path` is a string that uses the route matcher DSL.
 * - `redirectTo` is an array representing the link DSL.
 *
 * Note that redirects **do not** affect how links are generated. For that, see the `useAsDefault`
 * option.
 *
 * ### Example
 * ```
 * import {RouteConfig, Route, Redirect} from 'angular2/router';
 *
 * @RouteConfig([
 *   new Redirect({path: '/', redirectTo: ['/Home'] }),
 *   new Route({path: '/home', component: HomeCmp, name: 'Home'})
 * ])
 * class MyApp {}
 * ```
 */
var Redirect = (function (_super) {
    __extends(Redirect, _super);
    function Redirect(_a) {
        var name = _a.name, useAsDefault = _a.useAsDefault, path = _a.path, regex = _a.regex, serializer = _a.serializer, data = _a.data, redirectTo = _a.redirectTo;
        _super.call(this, {
            name: name,
            useAsDefault: useAsDefault,
            path: path,
            regex: regex,
            serializer: serializer,
            data: data
        });
        this.redirectTo = redirectTo;
    }
    Redirect = __decorate([
        CONST()
    ], Redirect);
    return Redirect;
})(AbstractRoute);
exports.Redirect = Redirect;
var route_config_decorator_1 = require('./route_config_decorator');
/**
 * Given a JS Object that represents a route config, returns a corresponding Route, AsyncRoute,
 * AuxRoute or Redirect object.
 *
 * Also wraps an AsyncRoute's loader function to add the loaded component's route config to the
 * `RouteRegistry`.
 */
function normalizeRouteConfig(config, registry) {
    if (config instanceof route_config_decorator_1.AsyncRoute) {
        var wrappedLoader = wrapLoaderToReconfigureRegistry(config.loader, registry);
        return new route_config_decorator_1.AsyncRoute({
            path: config.path,
            loader: wrappedLoader,
            name: config.name,
            data: config.data,
            useAsDefault: config.useAsDefault
        });
    }
    if (config instanceof route_config_decorator_1.Route || config instanceof route_config_decorator_1.Redirect || config instanceof route_config_decorator_1.AuxRoute) {
        return config;
    }
    if ((+!!config.component) + (+!!config.redirectTo) + (+!!config.loader) != 1) {
        throw new BaseException("Route config should contain exactly one \"component\", \"loader\", or \"redirectTo\" property.");
    }
    if (config.as && config.name) {
        throw new BaseException("Route config should contain exactly one \"as\" or \"name\" property.");
    }
    if (config.as) {
        config.name = config.as;
    }
    if (config.loader) {
        var wrappedLoader = wrapLoaderToReconfigureRegistry(config.loader, registry);
        return new route_config_decorator_1.AsyncRoute({
            path: config.path,
            loader: wrappedLoader,
            name: config.name,
            data: config.data,
            useAsDefault: config.useAsDefault
        });
    }
    if (config.aux) {
        return new route_config_decorator_1.AuxRoute({ path: config.aux, component: config.component, name: config.name });
    }
    if (config.component) {
        if (typeof config.component == 'object') {
            var componentDefinitionObject = config.component;
            if (componentDefinitionObject.type == 'constructor') {
                return new route_config_decorator_1.Route({
                    path: config.path,
                    component: componentDefinitionObject.constructor,
                    name: config.name,
                    data: config.data,
                    useAsDefault: config.useAsDefault
                });
            }
            else if (componentDefinitionObject.type == 'loader') {
                return new route_config_decorator_1.AsyncRoute({
                    path: config.path,
                    loader: componentDefinitionObject.loader,
                    name: config.name,
                    data: config.data,
                    useAsDefault: config.useAsDefault
                });
            }
            else {
                throw new BaseException("Invalid component type \"" + componentDefinitionObject.type + "\". Valid types are \"constructor\" and \"loader\".");
            }
        }
        return new route_config_decorator_1.Route(config);
    }
    if (config.redirectTo) {
        return new route_config_decorator_1.Redirect({ path: config.path, redirectTo: config.redirectTo });
    }
    return config;
}
exports.normalizeRouteConfig = normalizeRouteConfig;
function wrapLoaderToReconfigureRegistry(loader, registry) {
    return function () {
        return loader().then(function (componentType) {
            registry.configFromComponent(componentType);
            return componentType;
        });
    };
}
function assertComponentExists(component, path) {
    if (!isType(component)) {
        throw new BaseException("Component for route \"" + path + "\" is not defined, or is not a class.");
    }
}
exports.assertComponentExists = assertComponentExists;
var instruction_1 = require('../../instruction');
var AsyncRouteHandler = (function () {
    function AsyncRouteHandler(_loader, data) {
        if (data === void 0) { data = null; }
        this._loader = _loader;
        /** @internal */
        this._resolvedComponent = null;
        this.data = isPresent(data) ? new instruction_1.RouteData(data) : instruction_1.BLANK_ROUTE_DATA;
    }
    AsyncRouteHandler.prototype.resolveComponentType = function () {
        var _this = this;
        if (isPresent(this._resolvedComponent)) {
            return this._resolvedComponent;
        }
        return this._resolvedComponent = this._loader().then(function (componentType) {
            _this.componentType = componentType;
            return componentType;
        });
    };
    return AsyncRouteHandler;
})();
exports.AsyncRouteHandler = AsyncRouteHandler;
var instruction_1 = require('../../instruction');
var SyncRouteHandler = (function () {
    function SyncRouteHandler(componentType, data) {
        this.componentType = componentType;
        /** @internal */
        this._resolvedComponent = null;
        this._resolvedComponent = PromiseWrapper.resolve(componentType);
        this.data = isPresent(data) ? new instruction_1.RouteData(data) : instruction_1.BLANK_ROUTE_DATA;
    }
    SyncRouteHandler.prototype.resolveComponentType = function () { return this._resolvedComponent; };
    return SyncRouteHandler;
})();
exports.SyncRouteHandler = SyncRouteHandler;
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var url_parser_1 = require('../url_parser');
var instruction_1 = require('../instruction');
// RouteMatch objects hold information about a match between a rule and a URL
var RouteMatch = (function () {
    function RouteMatch() {
    }
    return RouteMatch;
})();
exports.RouteMatch = RouteMatch;
var PathMatch = (function (_super) {
    __extends(PathMatch, _super);
    function PathMatch(instruction, remaining, remainingAux) {
        _super.call(this);
        this.instruction = instruction;
        this.remaining = remaining;
        this.remainingAux = remainingAux;
    }
    return PathMatch;
})(RouteMatch);
exports.PathMatch = PathMatch;
var RedirectMatch = (function (_super) {
    __extends(RedirectMatch, _super);
    function RedirectMatch(redirectTo, specificity) {
        _super.call(this);
        this.redirectTo = redirectTo;
        this.specificity = specificity;
    }
    return RedirectMatch;
})(RouteMatch);
exports.RedirectMatch = RedirectMatch;
var RedirectRule = (function () {
    function RedirectRule(_pathRecognizer, redirectTo) {
        this._pathRecognizer = _pathRecognizer;
        this.redirectTo = redirectTo;
        this.hash = this._pathRecognizer.hash;
    }
    Object.defineProperty(RedirectRule.prototype, "path", {
        get: function () { return this._pathRecognizer.toString(); },
        set: function (val) { throw new BaseException('you cannot set the path of a RedirectRule directly'); },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns `null` or a `ParsedUrl` representing the new path to match
     */
    RedirectRule.prototype.recognize = function (beginningSegment) {
        var match = null;
        if (isPresent(this._pathRecognizer.matchUrl(beginningSegment))) {
            match = new RedirectMatch(this.redirectTo, this._pathRecognizer.specificity);
        }
        return PromiseWrapper.resolve(match);
    };
    RedirectRule.prototype.generate = function (params) {
        throw new BaseException("Tried to generate a redirect.");
    };
    return RedirectRule;
})();
exports.RedirectRule = RedirectRule;
// represents something like '/foo/:bar'
var RouteRule = (function () {
    // TODO: cache component instruction instances by params and by ParsedUrl instance
    function RouteRule(_routePath, handler) {
        this._routePath = _routePath;
        this.handler = handler;
        this._cache = new Map();
        this.specificity = this._routePath.specificity;
        this.hash = this._routePath.hash;
        this.terminal = this._routePath.terminal;
    }
    Object.defineProperty(RouteRule.prototype, "path", {
        get: function () { return this._routePath.toString(); },
        set: function (val) { throw new BaseException('you cannot set the path of a RouteRule directly'); },
        enumerable: true,
        configurable: true
    });
    RouteRule.prototype.recognize = function (beginningSegment) {
        var _this = this;
        var res = this._routePath.matchUrl(beginningSegment);
        if (isBlank(res)) {
            return null;
        }
        return this.handler.resolveComponentType().then(function (_) {
            var componentInstruction = _this._getInstruction(res.urlPath, res.urlParams, res.allParams);
            return new PathMatch(componentInstruction, res.rest, res.auxiliary);
        });
    };
    RouteRule.prototype.generate = function (params) {
        var generated = this._routePath.generateUrl(params);
        var urlPath = generated.urlPath;
        var urlParams = generated.urlParams;
        return this._getInstruction(urlPath, url_parser_1.convertUrlParamsToArray(urlParams), params);
    };
    RouteRule.prototype.generateComponentPathValues = function (params) {
        return this._routePath.generateUrl(params);
    };
    RouteRule.prototype._getInstruction = function (urlPath, urlParams, params) {
        if (isBlank(this.handler.componentType)) {
            throw new BaseException("Tried to get instruction before the type was loaded.");
        }
        var hashKey = urlPath + '?' + urlParams.join('&');
        if (this._cache.has(hashKey)) {
            return this._cache.get(hashKey);
        }
        var instruction = new instruction_1.ComponentInstruction(urlPath, urlParams, this.handler.data, this.handler.componentType, this.terminal, this.specificity, params);
        this._cache.set(hashKey, instruction);
        return instruction;
    };
    return RouteRule;
})();
exports.RouteRule = RouteRule;
var rules_1 = require('./rules');
var route_config_impl_1 = require('../route_config/route_config_impl');
var async_route_handler_1 = require('./route_handlers/async_route_handler');
var sync_route_handler_1 = require('./route_handlers/sync_route_handler');
var param_route_path_1 = require('./route_paths/param_route_path');
var regex_route_path_1 = require('./route_paths/regex_route_path');
/**
 * A `RuleSet` is responsible for recognizing routes for a particular component.
 * It is consumed by `RouteRegistry`, which knows how to recognize an entire hierarchy of
 * components.
 */
var RuleSet = (function () {
    function RuleSet() {
        this.rulesByName = new Map();
        // map from name to rule
        this.auxRulesByName = new Map();
        // map from starting path to rule
        this.auxRulesByPath = new Map();
        // TODO: optimize this into a trie
        this.rules = [];
        // the rule to use automatically when recognizing or generating from this rule set
        this.defaultRule = null;
    }
    /**
     * Configure additional rules in this rule set from a route definition
     * @returns {boolean} true if the config is terminal
     */
    RuleSet.prototype.config = function (config) {
        var handler;
        if (isPresent(config.name) && config.name[0].toUpperCase() != config.name[0]) {
            var suggestedName = config.name[0].toUpperCase() + config.name.substring(1);
            throw new BaseException("Route \"" + config.path + "\" with name \"" + config.name + "\" does not begin with an uppercase letter. Route names should be CamelCase like \"" + suggestedName + "\".");
        }
        if (config instanceof route_config_impl_1.AuxRoute) {
            handler = new sync_route_handler_1.SyncRouteHandler(config.component, config.data);
            var routePath_1 = this._getRoutePath(config);
            var auxRule = new rules_1.RouteRule(routePath_1, handler);
            this.auxRulesByPath.set(routePath_1.toString(), auxRule);
            if (isPresent(config.name)) {
                this.auxRulesByName.set(config.name, auxRule);
            }
            return auxRule.terminal;
        }
        var useAsDefault = false;
        if (config instanceof route_config_impl_1.Redirect) {
            var routePath_2 = this._getRoutePath(config);
            var redirector = new rules_1.RedirectRule(routePath_2, config.redirectTo);
            this._assertNoHashCollision(redirector.hash, config.path);
            this.rules.push(redirector);
            return true;
        }
        if (config instanceof route_config_impl_1.Route) {
            handler = new sync_route_handler_1.SyncRouteHandler(config.component, config.data);
            useAsDefault = isPresent(config.useAsDefault) && config.useAsDefault;
        }
        else if (config instanceof route_config_impl_1.AsyncRoute) {
            handler = new async_route_handler_1.AsyncRouteHandler(config.loader, config.data);
            useAsDefault = isPresent(config.useAsDefault) && config.useAsDefault;
        }
        var routePath = this._getRoutePath(config);
        var newRule = new rules_1.RouteRule(routePath, handler);
        this._assertNoHashCollision(newRule.hash, config.path);
        if (useAsDefault) {
            if (isPresent(this.defaultRule)) {
                throw new BaseException("Only one route can be default");
            }
            this.defaultRule = newRule;
        }
        this.rules.push(newRule);
        if (isPresent(config.name)) {
            this.rulesByName.set(config.name, newRule);
        }
        return newRule.terminal;
    };
    /**
     * Given a URL, returns a list of `RouteMatch`es, which are partial recognitions for some route.
     */
    RuleSet.prototype.recognize = function (urlParse) {
        var solutions = [];
        this.rules.forEach(function (routeRecognizer) {
            var pathMatch = routeRecognizer.recognize(urlParse);
            if (isPresent(pathMatch)) {
                solutions.push(pathMatch);
            }
        });
        // handle cases where we are routing just to an aux route
        if (solutions.length == 0 && isPresent(urlParse) && urlParse.auxiliary.length > 0) {
            return [PromiseWrapper.resolve(new rules_1.PathMatch(null, null, urlParse.auxiliary))];
        }
        return solutions;
    };
    RuleSet.prototype.recognizeAuxiliary = function (urlParse) {
        var routeRecognizer = this.auxRulesByPath.get(urlParse.path);
        if (isPresent(routeRecognizer)) {
            return [routeRecognizer.recognize(urlParse)];
        }
        return [PromiseWrapper.resolve(null)];
    };
    RuleSet.prototype.hasRoute = function (name) { return this.rulesByName.has(name); };
    RuleSet.prototype.componentLoaded = function (name) {
        return this.hasRoute(name) && isPresent(this.rulesByName.get(name).handler.componentType);
    };
    RuleSet.prototype.loadComponent = function (name) {
        return this.rulesByName.get(name).handler.resolveComponentType();
    };
    RuleSet.prototype.generate = function (name, params) {
        var rule = this.rulesByName.get(name);
        if (isBlank(rule)) {
            return null;
        }
        return rule.generate(params);
    };
    RuleSet.prototype.generateAuxiliary = function (name, params) {
        var rule = this.auxRulesByName.get(name);
        if (isBlank(rule)) {
            return null;
        }
        return rule.generate(params);
    };
    RuleSet.prototype._assertNoHashCollision = function (hash, path) {
        this.rules.forEach(function (rule) {
            if (hash == rule.hash) {
                throw new BaseException("Configuration '" + path + "' conflicts with existing route '" + rule.path + "'");
            }
        });
    };
    RuleSet.prototype._getRoutePath = function (config) {
        if (isPresent(config.regex)) {
            if (isFunction(config.serializer)) {
                return new regex_route_path_1.RegexRoutePath(config.regex, config.serializer);
            }
            else {
                throw new BaseException("Route provides a regex property, '" + config.regex + "', but no serializer property");
            }
        }
        if (isPresent(config.path)) {
            // Auxiliary routes do not have a slash at the start
            var path = (config instanceof route_config_impl_1.AuxRoute && config.path.startsWith('/')) ?
                config.path.substring(1) :
                config.path;
            return new param_route_path_1.ParamRoutePath(path);
        }
        throw new BaseException('Route must provide either a path or regex property');
    };
    return RuleSet;
})();
exports.RuleSet = RuleSet;
var MatchedUrl = (function () {
    function MatchedUrl(urlPath, urlParams, allParams, auxiliary, rest) {
        this.urlPath = urlPath;
        this.urlParams = urlParams;
        this.allParams = allParams;
        this.auxiliary = auxiliary;
        this.rest = rest;
    }
    return MatchedUrl;
})();
exports.MatchedUrl = MatchedUrl;
var GeneratedUrl = (function () {
    function GeneratedUrl(urlPath, urlParams) {
        this.urlPath = urlPath;
        this.urlParams = urlParams;
    }
    return GeneratedUrl;
})();
exports.GeneratedUrl = GeneratedUrl;
var utils_1 = require('../../utils');
var url_parser_1 = require('../../url_parser');
var route_path_1 = require('./route_path');
/**
 * Identified by a `...` URL segment. This indicates that the
 * Route will continue to be matched by child `Router`s.
 */
var ContinuationPathSegment = (function () {
    function ContinuationPathSegment() {
        this.name = '';
        this.specificity = '';
        this.hash = '...';
    }
    ContinuationPathSegment.prototype.generate = function (params) { return ''; };
    ContinuationPathSegment.prototype.match = function (path) { return true; };
    return ContinuationPathSegment;
})();
/**
 * Identified by a string not starting with a `:` or `*`.
 * Only matches the URL segments that equal the segment path
 */
var StaticPathSegment = (function () {
    function StaticPathSegment(path) {
        this.path = path;
        this.name = '';
        this.specificity = '2';
        this.hash = path;
    }
    StaticPathSegment.prototype.match = function (path) { return path == this.path; };
    StaticPathSegment.prototype.generate = function (params) { return this.path; };
    return StaticPathSegment;
})();
/**
 * Identified by a string starting with `:`. Indicates a segment
 * that can contain a value that will be extracted and provided to
 * a matching `Instruction`.
 */
var DynamicPathSegment = (function () {
    function DynamicPathSegment(name) {
        this.name = name;
        this.specificity = '1';
        this.hash = ':';
    }
    DynamicPathSegment.prototype.match = function (path) { return path.length > 0; };
    DynamicPathSegment.prototype.generate = function (params) {
        if (!StringMapWrapper.contains(params.map, this.name)) {
            throw new BaseException("Route generator for '" + this.name + "' was not included in parameters passed.");
        }
        return utils_1.normalizeString(params.get(this.name));
    };
    DynamicPathSegment.paramMatcher = /^:([^\/]+)$/g;
    return DynamicPathSegment;
})();
/**
 * Identified by a string starting with `*` Indicates that all the following
 * segments match this route and that the value of these segments should
 * be provided to a matching `Instruction`.
 */
var StarPathSegment = (function () {
    function StarPathSegment(name) {
        this.name = name;
        this.specificity = '0';
        this.hash = '*';
    }
    StarPathSegment.prototype.match = function (path) { return true; };
    StarPathSegment.prototype.generate = function (params) { return utils_1.normalizeString(params.get(this.name)); };
    StarPathSegment.wildcardMatcher = /^\*([^\/]+)$/g;
    return StarPathSegment;
})();
/**
 * Parses a URL string using a given matcher DSL, and generates URLs from param maps
 */
var ParamRoutePath = (function () {
    /**
     * Takes a string representing the matcher DSL
     */
    function ParamRoutePath(routePath) {
        this.routePath = routePath;
        this.terminal = true;
        this._assertValidPath(routePath);
        this._parsePathString(routePath);
        this.specificity = this._calculateSpecificity();
        this.hash = this._calculateHash();
        var lastSegment = this._segments[this._segments.length - 1];
        this.terminal = !(lastSegment instanceof ContinuationPathSegment);
    }
    ParamRoutePath.prototype.matchUrl = function (url) {
        var nextUrlSegment = url;
        var currentUrlSegment;
        var positionalParams = {};
        var captured = [];
        for (var i = 0; i < this._segments.length; i += 1) {
            var pathSegment = this._segments[i];
            currentUrlSegment = nextUrlSegment;
            if (pathSegment instanceof ContinuationPathSegment) {
                break;
            }
            if (isPresent(currentUrlSegment)) {
                // the star segment consumes all of the remaining URL, including matrix params
                if (pathSegment instanceof StarPathSegment) {
                    positionalParams[pathSegment.name] = currentUrlSegment.toString();
                    captured.push(currentUrlSegment.toString());
                    nextUrlSegment = null;
                    break;
                }
                captured.push(currentUrlSegment.path);
                if (pathSegment instanceof DynamicPathSegment) {
                    positionalParams[pathSegment.name] = currentUrlSegment.path;
                }
                else if (!pathSegment.match(currentUrlSegment.path)) {
                    return null;
                }
                nextUrlSegment = currentUrlSegment.child;
            }
            else if (!pathSegment.match('')) {
                return null;
            }
        }
        if (this.terminal && isPresent(nextUrlSegment)) {
            return null;
        }
        var urlPath = captured.join('/');
        var auxiliary = [];
        var urlParams = [];
        var allParams = positionalParams;
        if (isPresent(currentUrlSegment)) {
            // If this is the root component, read query params. Otherwise, read matrix params.
            var paramsSegment = url instanceof url_parser_1.RootUrl ? url : currentUrlSegment;
            if (isPresent(paramsSegment.params)) {
                allParams = StringMapWrapper.merge(paramsSegment.params, positionalParams);
                urlParams = url_parser_1.convertUrlParamsToArray(paramsSegment.params);
            }
            else {
                allParams = positionalParams;
            }
            auxiliary = currentUrlSegment.auxiliary;
        }
        return new route_path_1.MatchedUrl(urlPath, urlParams, allParams, auxiliary, nextUrlSegment);
    };
    ParamRoutePath.prototype.generateUrl = function (params) {
        var paramTokens = new utils_1.TouchMap(params);
        var path = [];
        for (var i = 0; i < this._segments.length; i++) {
            var segment = this._segments[i];
            if (!(segment instanceof ContinuationPathSegment)) {
                path.push(segment.generate(paramTokens));
            }
        }
        var urlPath = path.join('/');
        var nonPositionalParams = paramTokens.getUnused();
        var urlParams = nonPositionalParams;
        return new route_path_1.GeneratedUrl(urlPath, urlParams);
    };
    ParamRoutePath.prototype.toString = function () { return this.routePath; };
    ParamRoutePath.prototype._parsePathString = function (routePath) {
        // normalize route as not starting with a "/". Recognition will
        // also normalize.
        if (routePath.startsWith("/")) {
            routePath = routePath.substring(1);
        }
        var segmentStrings = routePath.split('/');
        this._segments = [];
        var limit = segmentStrings.length - 1;
        for (var i = 0; i <= limit; i++) {
            var segment = segmentStrings[i], match;
            if (isPresent(match = RegExpWrapper.firstMatch(DynamicPathSegment.paramMatcher, segment))) {
                this._segments.push(new DynamicPathSegment(match[1]));
            }
            else if (isPresent(match = RegExpWrapper.firstMatch(StarPathSegment.wildcardMatcher, segment))) {
                this._segments.push(new StarPathSegment(match[1]));
            }
            else if (segment == '...') {
                if (i < limit) {
                    throw new BaseException("Unexpected \"...\" before the end of the path for \"" + routePath + "\".");
                }
                this._segments.push(new ContinuationPathSegment());
            }
            else {
                this._segments.push(new StaticPathSegment(segment));
            }
        }
    };
    ParamRoutePath.prototype._calculateSpecificity = function () {
        // The "specificity" of a path is used to determine which route is used when multiple routes
        // match
        // a URL. Static segments (like "/foo") are the most specific, followed by dynamic segments
        // (like
        // "/:id"). Star segments add no specificity. Segments at the start of the path are more
        // specific
        // than proceeding ones.
        //
        // The code below uses place values to combine the different types of segments into a single
        // string that we can sort later. Each static segment is marked as a specificity of "2," each
        // dynamic segment is worth "1" specificity, and stars are worth "0" specificity.
        var i, length = this._segments.length, specificity;
        if (length == 0) {
            // a single slash (or "empty segment" is as specific as a static segment
            specificity += '2';
        }
        else {
            specificity = '';
            for (i = 0; i < length; i++) {
                specificity += this._segments[i].specificity;
            }
        }
        return specificity;
    };
    ParamRoutePath.prototype._calculateHash = function () {
        // this function is used to determine whether a route config path like `/foo/:id` collides with
        // `/foo/:name`
        var i, length = this._segments.length;
        var hashParts = [];
        for (i = 0; i < length; i++) {
            hashParts.push(this._segments[i].hash);
        }
        return hashParts.join('/');
    };
    ParamRoutePath.prototype._assertValidPath = function (path) {
        if (StringWrapper.contains(path, '#')) {
            throw new BaseException("Path \"" + path + "\" should not include \"#\". Use \"HashLocationStrategy\" instead.");
        }
        var illegalCharacter = RegExpWrapper.firstMatch(ParamRoutePath.RESERVED_CHARS, path);
        if (isPresent(illegalCharacter)) {
            throw new BaseException("Path \"" + path + "\" contains \"" + illegalCharacter[0] + "\" which is not allowed in a route config.");
        }
    };
    ParamRoutePath.RESERVED_CHARS = RegExpWrapper.create('//|\\(|\\)|;|\\?|=');
    return ParamRoutePath;
})();
exports.ParamRoutePath = ParamRoutePath;
var route_path_1 = require('./route_path');
var RegexRoutePath = (function () {
    function RegexRoutePath(_reString, _serializer) {
        this._reString = _reString;
        this._serializer = _serializer;
        this.terminal = true;
        this.specificity = '2';
        this.hash = this._reString;
        this._regex = RegExpWrapper.create(this._reString);
    }
    RegexRoutePath.prototype.matchUrl = function (url) {
        var urlPath = url.toString();
        var params = {};
        var matcher = RegExpWrapper.matcher(this._regex, urlPath);
        var match = RegExpMatcherWrapper.next(matcher);
        if (isBlank(match)) {
            return null;
        }
        for (var i = 0; i < match.length; i += 1) {
            params[i.toString()] = match[i];
        }
        return new route_path_1.MatchedUrl(urlPath, [], params, [], null);
    };
    RegexRoutePath.prototype.generateUrl = function (params) { return this._serializer(params); };
    RegexRoutePath.prototype.toString = function () { return this._reString; };
    return RegexRoutePath;
})();
exports.RegexRoutePath = RegexRoutePath;
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * `RouteParams` is an immutable map of parameters for the given route
 * based on the url matcher and optional parameters for that route.
 *
 * You can inject `RouteParams` into the constructor of a component to use it.
 *
 * ### Example
 *
 * ```
 * import {Component} from 'angular2/core';
 * import {bootstrap} from 'angular2/platform/browser';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig, RouteParams} from
 * 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {path: '/user/:id', component: UserCmp, name: 'UserCmp'},
 * ])
 * class AppCmp {}
 *
 * @Component({ template: 'user: {{id}}' })
 * class UserCmp {
 *   id: string;
 *   constructor(params: RouteParams) {
 *     this.id = params.get('id');
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var RouteParams = (function () {
    function RouteParams(params) {
        this.params = params;
    }
    RouteParams.prototype.get = function (param) { return normalizeBlank(StringMapWrapper.get(this.params, param)); };
    return RouteParams;
})();
exports.RouteParams = RouteParams;
/**
 * `RouteData` is an immutable map of additional data you can configure in your {@link Route}.
 *
 * You can inject `RouteData` into the constructor of a component to use it.
 *
 * ### Example
 *
 * ```
 * import {Component} from 'angular2/core';
 * import {bootstrap} from 'angular2/platform/browser';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig, RouteData} from
 * 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {path: '/user/:id', component: UserCmp, name: 'UserCmp', data: {isAdmin: true}},
 * ])
 * class AppCmp {}
 *
 * @Component({...})
 * @View({ template: 'user: {{isAdmin}}' })
 * class UserCmp {
 *   string: isAdmin;
 *   constructor(data: RouteData) {
 *     this.isAdmin = data.get('isAdmin');
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var RouteData = (function () {
    function RouteData(data) {
        if (data === void 0) { data = CONST_EXPR({}); }
        this.data = data;
    }
    RouteData.prototype.get = function (key) { return normalizeBlank(StringMapWrapper.get(this.data, key)); };
    return RouteData;
})();
exports.RouteData = RouteData;
exports.BLANK_ROUTE_DATA = new RouteData();
/**
 * `Instruction` is a tree of {@link ComponentInstruction}s with all the information needed
 * to transition each component in the app to a given route, including all auxiliary routes.
 *
 * `Instruction`s can be created using {@link Router#generate}, and can be used to
 * perform route changes with {@link Router#navigateByInstruction}.
 *
 * ### Example
 *
 * ```
 * import {Component} from 'angular2/core';
 * import {bootstrap} from 'angular2/platform/browser';
 * import {Router, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, RouteConfig} from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   constructor(router: Router) {
 *     var instruction = router.generate(['/MyRoute']);
 *     router.navigateByInstruction(instruction);
 *   }
 * }
 *
 * bootstrap(AppCmp, ROUTER_PROVIDERS);
 * ```
 */
var Instruction = (function () {
    function Instruction(component, child, auxInstruction) {
        this.component = component;
        this.child = child;
        this.auxInstruction = auxInstruction;
    }
    Object.defineProperty(Instruction.prototype, "urlPath", {
        get: function () { return isPresent(this.component) ? this.component.urlPath : ''; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "urlParams", {
        get: function () { return isPresent(this.component) ? this.component.urlParams : []; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "specificity", {
        get: function () {
            var total = '';
            if (isPresent(this.component)) {
                total += this.component.specificity;
            }
            if (isPresent(this.child)) {
                total += this.child.specificity;
            }
            return total;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * converts the instruction into a URL string
     */
    Instruction.prototype.toRootUrl = function () { return this.toUrlPath() + this.toUrlQuery(); };
    /** @internal */
    Instruction.prototype._toNonRootUrl = function () {
        return this._stringifyPathMatrixAuxPrefixed() +
            (isPresent(this.child) ? this.child._toNonRootUrl() : '');
    };
    Instruction.prototype.toUrlQuery = function () { return this.urlParams.length > 0 ? ('?' + this.urlParams.join('&')) : ''; };
    /**
     * Returns a new instruction that shares the state of the existing instruction, but with
     * the given child {@link Instruction} replacing the existing child.
     */
    Instruction.prototype.replaceChild = function (child) {
        return new ResolvedInstruction(this.component, child, this.auxInstruction);
    };
    /**
     * If the final URL for the instruction is ``
     */
    Instruction.prototype.toUrlPath = function () {
        return this.urlPath + this._stringifyAux() +
            (isPresent(this.child) ? this.child._toNonRootUrl() : '');
    };
    // default instructions override these
    Instruction.prototype.toLinkUrl = function () {
        return this.urlPath + this._stringifyAux() +
            (isPresent(this.child) ? this.child._toLinkUrl() : '');
    };
    // this is the non-root version (called recursively)
    /** @internal */
    Instruction.prototype._toLinkUrl = function () {
        return this._stringifyPathMatrixAuxPrefixed() +
            (isPresent(this.child) ? this.child._toLinkUrl() : '');
    };
    /** @internal */
    Instruction.prototype._stringifyPathMatrixAuxPrefixed = function () {
        var primary = this._stringifyPathMatrixAux();
        if (primary.length > 0) {
            primary = '/' + primary;
        }
        return primary;
    };
    /** @internal */
    Instruction.prototype._stringifyMatrixParams = function () {
        return this.urlParams.length > 0 ? (';' + this.urlParams.join(';')) : '';
    };
    /** @internal */
    Instruction.prototype._stringifyPathMatrixAux = function () {
        if (isBlank(this.component)) {
            return '';
        }
        return this.urlPath + this._stringifyMatrixParams() + this._stringifyAux();
    };
    /** @internal */
    Instruction.prototype._stringifyAux = function () {
        var routes = [];
        StringMapWrapper.forEach(this.auxInstruction, function (auxInstruction, _) {
            routes.push(auxInstruction._stringifyPathMatrixAux());
        });
        if (routes.length > 0) {
            return '(' + routes.join('//') + ')';
        }
        return '';
    };
    return Instruction;
})();
exports.Instruction = Instruction;
/**
 * a resolved instruction has an outlet instruction for itself, but maybe not for...
 */
var ResolvedInstruction = (function (_super) {
    __extends(ResolvedInstruction, _super);
    function ResolvedInstruction(component, child, auxInstruction) {
        _super.call(this, component, child, auxInstruction);
    }
    ResolvedInstruction.prototype.resolveComponent = function () {
        return PromiseWrapper.resolve(this.component);
    };
    return ResolvedInstruction;
})(Instruction);
exports.ResolvedInstruction = ResolvedInstruction;
/**
 * Represents a resolved default route
 */
var DefaultInstruction = (function (_super) {
    __extends(DefaultInstruction, _super);
    function DefaultInstruction(component, child) {
        _super.call(this, component, child, {});
    }
    DefaultInstruction.prototype.toLinkUrl = function () { return ''; };
    /** @internal */
    DefaultInstruction.prototype._toLinkUrl = function () { return ''; };
    return DefaultInstruction;
})(ResolvedInstruction);
exports.DefaultInstruction = DefaultInstruction;
/**
 * Represents a component that may need to do some redirection or lazy loading at a later time.
 */
var UnresolvedInstruction = (function (_super) {
    __extends(UnresolvedInstruction, _super);
    function UnresolvedInstruction(_resolver, _urlPath, _urlParams) {
        if (_urlPath === void 0) { _urlPath = ''; }
        if (_urlParams === void 0) { _urlParams = CONST_EXPR([]); }
        _super.call(this, null, null, {});
        this._resolver = _resolver;
        this._urlPath = _urlPath;
        this._urlParams = _urlParams;
    }
    Object.defineProperty(UnresolvedInstruction.prototype, "urlPath", {
        get: function () {
            if (isPresent(this.component)) {
                return this.component.urlPath;
            }
            if (isPresent(this._urlPath)) {
                return this._urlPath;
            }
            return '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UnresolvedInstruction.prototype, "urlParams", {
        get: function () {
            if (isPresent(this.component)) {
                return this.component.urlParams;
            }
            if (isPresent(this._urlParams)) {
                return this._urlParams;
            }
            return [];
        },
        enumerable: true,
        configurable: true
    });
    UnresolvedInstruction.prototype.resolveComponent = function () {
        var _this = this;
        if (isPresent(this.component)) {
            return PromiseWrapper.resolve(this.component);
        }
        return this._resolver().then(function (resolution) {
            _this.child = resolution.child;
            return _this.component = resolution.component;
        });
    };
    return UnresolvedInstruction;
})(Instruction);
exports.UnresolvedInstruction = UnresolvedInstruction;
var RedirectInstruction = (function (_super) {
    __extends(RedirectInstruction, _super);
    function RedirectInstruction(component, child, auxInstruction, _specificity) {
        _super.call(this, component, child, auxInstruction);
        this._specificity = _specificity;
    }
    Object.defineProperty(RedirectInstruction.prototype, "specificity", {
        get: function () { return this._specificity; },
        enumerable: true,
        configurable: true
    });
    return RedirectInstruction;
})(ResolvedInstruction);
exports.RedirectInstruction = RedirectInstruction;
/**
 * A `ComponentInstruction` represents the route state for a single component.
 *
 * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed
 * to route lifecycle hooks, like {@link CanActivate}.
 *
 * `ComponentInstruction`s are [hash consed](https://en.wikipedia.org/wiki/Hash_consing). You should
 * never construct one yourself with "new." Instead, rely on {@link Router/RouteRecognizer} to
 * construct `ComponentInstruction`s.
 *
 * You should not modify this object. It should be treated as immutable.
 */
var ComponentInstruction = (function () {
    /**
     * @internal
     */
    function ComponentInstruction(urlPath, urlParams, data, componentType, terminal, specificity, params) {
        if (params === void 0) { params = null; }
        this.urlPath = urlPath;
        this.urlParams = urlParams;
        this.componentType = componentType;
        this.terminal = terminal;
        this.specificity = specificity;
        this.params = params;
        this.reuse = false;
        this.routeData = isPresent(data) ? data : exports.BLANK_ROUTE_DATA;
    }
    return ComponentInstruction;
})();
exports.ComponentInstruction = ComponentInstruction;
var core_1 = require('angular2/core');
var route_config_impl_1 = require('./route_config/route_config_impl');
var rules_1 = require('./rules/rules');
var rule_set_1 = require('./rules/rule_set');
var instruction_1 = require('./instruction');
var route_config_normalizer_1 = require('./route_config/route_config_normalizer');
var url_parser_1 = require('./url_parser');
var _resolveToNull = PromiseWrapper.resolve(null);
// A LinkItemArray is an array, which describes a set of routes
// The items in the array are found in groups:
// - the first item is the name of the route
// - the next items are:
//   - an object containing parameters
//   - or an array describing an aux route
// export type LinkRouteItem = string | Object;
// export type LinkItem = LinkRouteItem | Array<LinkRouteItem>;
// export type LinkItemArray = Array<LinkItem>;
/**
 * Token used to bind the component with the top-level {@link RouteConfig}s for the
 * application.
 *
 * ### Example ([live demo](http://plnkr.co/edit/iRUP8B5OUbxCWQ3AcIDm))
 *
 * ```
 * import {Component} from 'angular2/core';
 * import {
 *   ROUTER_DIRECTIVES,
 *   ROUTER_PROVIDERS,
 *   RouteConfig
 * } from 'angular2/router';
 *
 * @Component({directives: [ROUTER_DIRECTIVES]})
 * @RouteConfig([
 *  {...},
 * ])
 * class AppCmp {
 *   // ...
 * }
 *
 * bootstrap(AppCmp, [ROUTER_PROVIDERS]);
 * ```
 */
exports.ROUTER_PRIMARY_COMPONENT = CONST_EXPR(new core_1.OpaqueToken('RouterPrimaryComponent'));
/**
 * The RouteRegistry holds route configurations for each component in an Angular app.
 * It is responsible for creating Instructions from URLs, and generating URLs based on route and
 * parameters.
 */
var RouteRegistry = (function () {
    function RouteRegistry(_rootComponent) {
        this._rootComponent = _rootComponent;
        this._rules = new Map();
    }
    /**
     * Given a component and a configuration object, add the route to this registry
     */
    RouteRegistry.prototype.config = function (parentComponent, config) {
        config = route_config_normalizer_1.normalizeRouteConfig(config, this);
        // this is here because Dart type guard reasons
        if (config instanceof route_config_impl_1.Route) {
            route_config_normalizer_1.assertComponentExists(config.component, config.path);
        }
        else if (config instanceof route_config_impl_1.AuxRoute) {
            route_config_normalizer_1.assertComponentExists(config.component, config.path);
        }
        var rules = this._rules.get(parentComponent);
        if (isBlank(rules)) {
            rules = new rule_set_1.RuleSet();
            this._rules.set(parentComponent, rules);
        }
        var terminal = rules.config(config);
        if (config instanceof route_config_impl_1.Route) {
            if (terminal) {
                assertTerminalComponent(config.component, config.path);
            }
            else {
                this.configFromComponent(config.component);
            }
        }
    };
    /**
     * Reads the annotations of a component and configures the registry based on them
     */
    RouteRegistry.prototype.configFromComponent = function (component) {
        var _this = this;
        if (!isType(component)) {
            return;
        }
        // Don't read the annotations from a type more than once 
        // this prevents an infinite loop if a component routes recursively.
        if (this._rules.has(component)) {
            return;
        }
        var annotations = reflector.annotations(component);
        if (isPresent(annotations)) {
            for (var i = 0; i < annotations.length; i++) {
                var annotation = annotations[i];
                if (annotation instanceof route_config_impl_1.RouteConfig) {
                    var routeCfgs = annotation.configs;
                    routeCfgs.forEach(function (config) { return _this.config(component, config); });
                }
            }
        }
    };
    /**
     * Given a URL and a parent component, return the most specific instruction for navigating
     * the application into the state specified by the url
     */
    RouteRegistry.prototype.recognize = function (url, ancestorInstructions) {
        var parsedUrl = url_parser_1.parser.parse(url);
        return this._recognize(parsedUrl, []);
    };
    /**
     * Recognizes all parent-child routes, but creates unresolved auxiliary routes
     */
    RouteRegistry.prototype._recognize = function (parsedUrl, ancestorInstructions, _aux) {
        var _this = this;
        if (_aux === void 0) { _aux = false; }
        var parentInstruction = ListWrapper.last(ancestorInstructions);
        var parentComponent = isPresent(parentInstruction) ? parentInstruction.component.componentType :
            this._rootComponent;
        var rules = this._rules.get(parentComponent);
        if (isBlank(rules)) {
            return _resolveToNull;
        }
        // Matches some beginning part of the given URL
        var possibleMatches = _aux ? rules.recognizeAuxiliary(parsedUrl) : rules.recognize(parsedUrl);
        var matchPromises = possibleMatches.map(function (candidate) { return candidate.then(function (candidate) {
            if (candidate instanceof rules_1.PathMatch) {
                var auxParentInstructions = ancestorInstructions.length > 0 ? [ListWrapper.last(ancestorInstructions)] : [];
                var auxInstructions = _this._auxRoutesToUnresolved(candidate.remainingAux, auxParentInstructions);
                var instruction = new instruction_1.ResolvedInstruction(candidate.instruction, null, auxInstructions);
                if (isBlank(candidate.instruction) || candidate.instruction.terminal) {
                    return instruction;
                }
                var newAncestorInstructions = ancestorInstructions.concat([instruction]);
                return _this._recognize(candidate.remaining, newAncestorInstructions)
                    .then(function (childInstruction) {
                    if (isBlank(childInstruction)) {
                        return null;
                    }
                    // redirect instructions are already absolute
                    if (childInstruction instanceof instruction_1.RedirectInstruction) {
                        return childInstruction;
                    }
                    instruction.child = childInstruction;
                    return instruction;
                });
            }
            if (candidate instanceof rules_1.RedirectMatch) {
                var instruction = _this.generate(candidate.redirectTo, ancestorInstructions.concat([null]));
                return new instruction_1.RedirectInstruction(instruction.component, instruction.child, instruction.auxInstruction, candidate.specificity);
            }
        }); });
        if ((isBlank(parsedUrl) || parsedUrl.path == '') && possibleMatches.length == 0) {
            return PromiseWrapper.resolve(this.generateDefault(parentComponent));
        }
        return PromiseWrapper.all(matchPromises).then(mostSpecific);
    };
    RouteRegistry.prototype._auxRoutesToUnresolved = function (auxRoutes, parentInstructions) {
        var _this = this;
        var unresolvedAuxInstructions = {};
        auxRoutes.forEach(function (auxUrl) {
            unresolvedAuxInstructions[auxUrl.path] = new instruction_1.UnresolvedInstruction(function () { return _this._recognize(auxUrl, parentInstructions, true); });
        });
        return unresolvedAuxInstructions;
    };
    /**
     * Given a normalized list with component names and params like: `['user', {id: 3 }]`
     * generates a url with a leading slash relative to the provided `parentComponent`.
     *
     * If the optional param `_aux` is `true`, then we generate starting at an auxiliary
     * route boundary.
     */
    RouteRegistry.prototype.generate = function (linkParams, ancestorInstructions, _aux) {
        if (_aux === void 0) { _aux = false; }
        var params = splitAndFlattenLinkParams(linkParams);
        var prevInstruction;
        // The first segment should be either '.' (generate from parent) or '' (generate from root).
        // When we normalize above, we strip all the slashes, './' becomes '.' and '/' becomes ''.
        if (ListWrapper.first(params) == '') {
            params.shift();
            prevInstruction = ListWrapper.first(ancestorInstructions);
            ancestorInstructions = [];
        }
        else {
            prevInstruction = ancestorInstructions.length > 0 ? ancestorInstructions.pop() : null;
            if (ListWrapper.first(params) == '.') {
                params.shift();
            }
            else if (ListWrapper.first(params) == '..') {
                while (ListWrapper.first(params) == '..') {
                    if (ancestorInstructions.length <= 0) {
                        throw new BaseException("Link \"" + ListWrapper.toJSON(linkParams) + "\" has too many \"../\" segments.");
                    }
                    prevInstruction = ancestorInstructions.pop();
                    params = ListWrapper.slice(params, 1);
                }
            }
            else {
                // we must only peak at the link param, and not consume it
                var routeName = ListWrapper.first(params);
                var parentComponentType = this._rootComponent;
                var grandparentComponentType = null;
                if (ancestorInstructions.length > 1) {
                    var parentComponentInstruction = ancestorInstructions[ancestorInstructions.length - 1];
                    var grandComponentInstruction = ancestorInstructions[ancestorInstructions.length - 2];
                    parentComponentType = parentComponentInstruction.component.componentType;
                    grandparentComponentType = grandComponentInstruction.component.componentType;
                }
                else if (ancestorInstructions.length == 1) {
                    parentComponentType = ancestorInstructions[0].component.componentType;
                    grandparentComponentType = this._rootComponent;
                }
                // For a link with no leading `./`, `/`, or `../`, we look for a sibling and child.
                // If both exist, we throw. Otherwise, we prefer whichever exists.
                var childRouteExists = this.hasRoute(routeName, parentComponentType);
                var parentRouteExists = isPresent(grandparentComponentType) &&
                    this.hasRoute(routeName, grandparentComponentType);
                if (parentRouteExists && childRouteExists) {
                    var msg = "Link \"" + ListWrapper.toJSON(linkParams) + "\" is ambiguous, use \"./\" or \"../\" to disambiguate.";
                    throw new BaseException(msg);
                }
                if (parentRouteExists) {
                    prevInstruction = ancestorInstructions.pop();
                }
            }
        }
        if (params[params.length - 1] == '') {
            params.pop();
        }
        if (params.length > 0 && params[0] == '') {
            params.shift();
        }
        if (params.length < 1) {
            var msg = "Link \"" + ListWrapper.toJSON(linkParams) + "\" must include a route name.";
            throw new BaseException(msg);
        }
        var generatedInstruction = this._generate(params, ancestorInstructions, prevInstruction, _aux, linkParams);
        // we don't clone the first (root) element
        for (var i = ancestorInstructions.length - 1; i >= 0; i--) {
            var ancestorInstruction = ancestorInstructions[i];
            if (isBlank(ancestorInstruction)) {
                break;
            }
            generatedInstruction = ancestorInstruction.replaceChild(generatedInstruction);
        }
        return generatedInstruction;
    };
    /*
     * Internal helper that does not make any assertions about the beginning of the link DSL.
     * `ancestorInstructions` are parents that will be cloned.
     * `prevInstruction` is the existing instruction that would be replaced, but which might have
     * aux routes that need to be cloned.
     */
    RouteRegistry.prototype._generate = function (linkParams, ancestorInstructions, prevInstruction, _aux, _originalLink) {
        var _this = this;
        if (_aux === void 0) { _aux = false; }
        var parentComponentType = this._rootComponent;
        var componentInstruction = null;
        var auxInstructions = {};
        var parentInstruction = ListWrapper.last(ancestorInstructions);
        if (isPresent(parentInstruction) && isPresent(parentInstruction.component)) {
            parentComponentType = parentInstruction.component.componentType;
        }
        if (linkParams.length == 0) {
            var defaultInstruction = this.generateDefault(parentComponentType);
            if (isBlank(defaultInstruction)) {
                throw new BaseException("Link \"" + ListWrapper.toJSON(_originalLink) + "\" does not resolve to a terminal instruction.");
            }
            return defaultInstruction;
        }
        // for non-aux routes, we want to reuse the predecessor's existing primary and aux routes
        // and only override routes for which the given link DSL provides
        if (isPresent(prevInstruction) && !_aux) {
            auxInstructions = StringMapWrapper.merge(prevInstruction.auxInstruction, auxInstructions);
            componentInstruction = prevInstruction.component;
        }
        var rules = this._rules.get(parentComponentType);
        if (isBlank(rules)) {
            throw new BaseException("Component \"" + getTypeNameForDebugging(parentComponentType) + "\" has no route config.");
        }
        var linkParamIndex = 0;
        var routeParams = {};
        // first, recognize the primary route if one is provided
        if (linkParamIndex < linkParams.length && isString(linkParams[linkParamIndex])) {
            var routeName = linkParams[linkParamIndex];
            if (routeName == '' || routeName == '.' || routeName == '..') {
                throw new BaseException("\"" + routeName + "/\" is only allowed at the beginning of a link DSL.");
            }
            linkParamIndex += 1;
            if (linkParamIndex < linkParams.length) {
                var linkParam = linkParams[linkParamIndex];
                if (isStringMap(linkParam) && !isArray(linkParam)) {
                    routeParams = linkParam;
                    linkParamIndex += 1;
                }
            }
            var routeRecognizer = (_aux ? rules.auxRulesByName : rules.rulesByName).get(routeName);
            if (isBlank(routeRecognizer)) {
                throw new BaseException("Component \"" + getTypeNameForDebugging(parentComponentType) + "\" has no route named \"" + routeName + "\".");
            }
            // Create an "unresolved instruction" for async routes
            // we'll figure out the rest of the route when we resolve the instruction and
            // perform a navigation
            if (isBlank(routeRecognizer.handler.componentType)) {
                var generatedUrl = routeRecognizer.generateComponentPathValues(routeParams);
                return new instruction_1.UnresolvedInstruction(function () {
                    return routeRecognizer.handler.resolveComponentType().then(function (_) {
                        return _this._generate(linkParams, ancestorInstructions, prevInstruction, _aux, _originalLink);
                    });
                }, generatedUrl.urlPath, url_parser_1.convertUrlParamsToArray(generatedUrl.urlParams));
            }
            componentInstruction = _aux ? rules.generateAuxiliary(routeName, routeParams) :
                rules.generate(routeName, routeParams);
        }
        // Next, recognize auxiliary instructions.
        // If we have an ancestor instruction, we preserve whatever aux routes are active from it.
        while (linkParamIndex < linkParams.length && isArray(linkParams[linkParamIndex])) {
            var auxParentInstruction = [parentInstruction];
            var auxInstruction = this._generate(linkParams[linkParamIndex], auxParentInstruction, null, true, _originalLink);
            // TODO: this will not work for aux routes with parameters or multiple segments
            auxInstructions[auxInstruction.component.urlPath] = auxInstruction;
            linkParamIndex += 1;
        }
        var instruction = new instruction_1.ResolvedInstruction(componentInstruction, null, auxInstructions);
        // If the component is sync, we can generate resolved child route instructions
        // If not, we'll resolve the instructions at navigation time
        if (isPresent(componentInstruction) && isPresent(componentInstruction.componentType)) {
            var childInstruction = null;
            if (componentInstruction.terminal) {
                if (linkParamIndex >= linkParams.length) {
                }
            }
            else {
                var childAncestorComponents = ancestorInstructions.concat([instruction]);
                var remainingLinkParams = linkParams.slice(linkParamIndex);
                childInstruction = this._generate(remainingLinkParams, childAncestorComponents, null, false, _originalLink);
            }
            instruction.child = childInstruction;
        }
        return instruction;
    };
    RouteRegistry.prototype.hasRoute = function (name, parentComponent) {
        var rules = this._rules.get(parentComponent);
        if (isBlank(rules)) {
            return false;
        }
        return rules.hasRoute(name);
    };
    RouteRegistry.prototype.generateDefault = function (componentCursor) {
        var _this = this;
        if (isBlank(componentCursor)) {
            return null;
        }
        var rules = this._rules.get(componentCursor);
        if (isBlank(rules) || isBlank(rules.defaultRule)) {
            return null;
        }
        var defaultChild = null;
        if (isPresent(rules.defaultRule.handler.componentType)) {
            var componentInstruction = rules.defaultRule.generate({});
            if (!rules.defaultRule.terminal) {
                defaultChild = this.generateDefault(rules.defaultRule.handler.componentType);
            }
            return new instruction_1.DefaultInstruction(componentInstruction, defaultChild);
        }
        return new instruction_1.UnresolvedInstruction(function () {
            return rules.defaultRule.handler.resolveComponentType().then(function (_) { return _this.generateDefault(componentCursor); });
        });
    };
    return RouteRegistry;
})();
exports.RouteRegistry = RouteRegistry;
/*
 * Given: ['/a/b', {c: 2}]
 * Returns: ['', 'a', 'b', {c: 2}]
 */
function splitAndFlattenLinkParams(linkParams) {
    var accumulation = [];
    linkParams.forEach(function (item) {
        if (isString(item)) {
            var strItem = item;
            accumulation = accumulation.concat(strItem.split('/'));
        }
        else {
            accumulation.push(item);
        }
    });
    return accumulation;
}
/*
 * Given a list of instructions, returns the most specific instruction
 */
function mostSpecific(instructions) {
    instructions = instructions.filter(function (instruction) { return isPresent(instruction); });
    if (instructions.length == 0) {
        return null;
    }
    if (instructions.length == 1) {
        return instructions[0];
    }
    var first = instructions[0];
    var rest = instructions.slice(1);
    return rest.reduce(function (instruction, contender) {
        if (compareSpecificityStrings(contender.specificity, instruction.specificity) == -1) {
            return contender;
        }
        return instruction;
    }, first);
}
/*
 * Expects strings to be in the form of "[0-2]+"
 * Returns -1 if string A should be sorted above string B, 1 if it should be sorted after,
 * or 0 if they are the same.
 */
function compareSpecificityStrings(a, b) {
    var l = Math.min(a.length, b.length);
    for (var i = 0; i < l; i += 1) {
        var ai = StringWrapper.charCodeAt(a, i);
        var bi = StringWrapper.charCodeAt(b, i);
        var difference = bi - ai;
        if (difference != 0) {
            return difference;
        }
    }
    return a.length - b.length;
}
function assertTerminalComponent(component, path) {
    if (!isType(component)) {
        return;
    }
    var annotations = reflector.annotations(component);
    if (isPresent(annotations)) {
        for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            if (annotation instanceof route_config_impl_1.RouteConfig) {
                throw new BaseException("Child routes are not allowed for \"" + path + "\". Use \"...\" on the parent's route path.");
            }
        }
    }
}
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var route_lifecycle_reflector_1 = require('./lifecycle/route_lifecycle_reflector');
var _resolveToTrue = PromiseWrapper.resolve(true);
var _resolveToFalse = PromiseWrapper.resolve(false);
/**
 * The `Router` is responsible for mapping URLs to components.
 *
 * You can see the state of the router by inspecting the read-only field `router.navigating`.
 * This may be useful for showing a spinner, for instance.
 *
 * ## Concepts
 *
 * Routers and component instances have a 1:1 correspondence.
 *
 * The router holds reference to a number of {@link RouterOutlet}.
 * An outlet is a placeholder that the router dynamically fills in depending on the current URL.
 *
 * When the router navigates from a URL, it must first recognize it and serialize it into an
 * `Instruction`.
 * The router uses the `RouteRegistry` to get an `Instruction`.
 */
var Router = (function () {
    function Router(registry, parent, hostComponent) {
        this.registry = registry;
        this.parent = parent;
        this.hostComponent = hostComponent;
        this.navigating = false;
        this._currentInstruction = null;
        this._currentNavigation = _resolveToTrue;
        this._outlet = null;
        this._auxRouters = new Map();
        this._subject = new EventEmitter();
    }
    /**
     * Constructs a child router. You probably don't need to use this unless you're writing a reusable
     * component.
     */
    Router.prototype.childRouter = function (hostComponent) {
        return this._childRouter = new ChildRouter(this, hostComponent);
    };
    /**
     * Constructs a child router. You probably don't need to use this unless you're writing a reusable
     * component.
     */
    Router.prototype.auxRouter = function (hostComponent) { return new ChildRouter(this, hostComponent); };
    /**
     * Register an outlet to be notified of primary route changes.
     *
     * You probably don't need to use this unless you're writing a reusable component.
     */
    Router.prototype.registerPrimaryOutlet = function (outlet) {
        if (isPresent(outlet.name)) {
            throw new BaseException("registerPrimaryOutlet expects to be called with an unnamed outlet.");
        }
        if (isPresent(this._outlet)) {
            throw new BaseException("Primary outlet is already registered.");
        }
        this._outlet = outlet;
        if (isPresent(this._currentInstruction)) {
            return this.commit(this._currentInstruction, false);
        }
        return _resolveToTrue;
    };
    /**
     * Unregister an outlet (because it was destroyed, etc).
     *
     * You probably don't need to use this unless you're writing a custom outlet implementation.
     */
    Router.prototype.unregisterPrimaryOutlet = function (outlet) {
        if (isPresent(outlet.name)) {
            throw new BaseException("registerPrimaryOutlet expects to be called with an unnamed outlet.");
        }
        this._outlet = null;
    };
    /**
     * Register an outlet to notified of auxiliary route changes.
     *
     * You probably don't need to use this unless you're writing a reusable component.
     */
    Router.prototype.registerAuxOutlet = function (outlet) {
        var outletName = outlet.name;
        if (isBlank(outletName)) {
            throw new BaseException("registerAuxOutlet expects to be called with an outlet with a name.");
        }
        var router = this.auxRouter(this.hostComponent);
        this._auxRouters.set(outletName, router);
        router._outlet = outlet;
        var auxInstruction;
        if (isPresent(this._currentInstruction) &&
            isPresent(auxInstruction = this._currentInstruction.auxInstruction[outletName])) {
            return router.commit(auxInstruction);
        }
        return _resolveToTrue;
    };
    /**
     * Given an instruction, returns `true` if the instruction is currently active,
     * otherwise `false`.
     */
    Router.prototype.isRouteActive = function (instruction) {
        var router = this;
        while (isPresent(router.parent) && isPresent(instruction.child)) {
            router = router.parent;
            instruction = instruction.child;
        }
        return isPresent(this._currentInstruction) &&
            this._currentInstruction.component == instruction.component;
    };
    /**
     * Dynamically update the routing configuration and trigger a navigation.
     *
     * ### Usage
     *
     * ```
     * router.config([
     *   { 'path': '/', 'component': IndexComp },
     *   { 'path': '/user/:id', 'component': UserComp },
     * ]);
     * ```
     */
    Router.prototype.config = function (definitions) {
        var _this = this;
        definitions.forEach(function (routeDefinition) { _this.registry.config(_this.hostComponent, routeDefinition); });
        return this.renavigate();
    };
    /**
     * Navigate based on the provided Route Link DSL. It's preferred to navigate with this method
     * over `navigateByUrl`.
     *
     * ### Usage
     *
     * This method takes an array representing the Route Link DSL:
     * ```
     * ['./MyCmp', {param: 3}]
     * ```
     * See the {@link RouterLink} directive for more.
     */
    Router.prototype.navigate = function (linkParams) {
        var instruction = this.generate(linkParams);
        return this.navigateByInstruction(instruction, false);
    };
    /**
     * Navigate to a URL. Returns a promise that resolves when navigation is complete.
     * It's preferred to navigate with `navigate` instead of this method, since URLs are more brittle.
     *
     * If the given URL begins with a `/`, router will navigate absolutely.
     * If the given URL does not begin with `/`, the router will navigate relative to this component.
     */
    Router.prototype.navigateByUrl = function (url, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        return this._currentNavigation = this._currentNavigation.then(function (_) {
            _this.lastNavigationAttempt = url;
            _this._startNavigating();
            return _this._afterPromiseFinishNavigating(_this.recognize(url).then(function (instruction) {
                if (isBlank(instruction)) {
                    return false;
                }
                return _this._navigate(instruction, _skipLocationChange);
            }));
        });
    };
    /**
     * Navigate via the provided instruction. Returns a promise that resolves when navigation is
     * complete.
     */
    Router.prototype.navigateByInstruction = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        if (isBlank(instruction)) {
            return _resolveToFalse;
        }
        return this._currentNavigation = this._currentNavigation.then(function (_) {
            _this._startNavigating();
            return _this._afterPromiseFinishNavigating(_this._navigate(instruction, _skipLocationChange));
        });
    };
    /** @internal */
    Router.prototype._settleInstruction = function (instruction) {
        var _this = this;
        return instruction.resolveComponent().then(function (_) {
            var unsettledInstructions = [];
            if (isPresent(instruction.component)) {
                instruction.component.reuse = false;
            }
            if (isPresent(instruction.child)) {
                unsettledInstructions.push(_this._settleInstruction(instruction.child));
            }
            StringMapWrapper.forEach(instruction.auxInstruction, function (instruction, _) {
                unsettledInstructions.push(_this._settleInstruction(instruction));
            });
            return PromiseWrapper.all(unsettledInstructions);
        });
    };
    /** @internal */
    Router.prototype._navigate = function (instruction, _skipLocationChange) {
        var _this = this;
        return this._settleInstruction(instruction)
            .then(function (_) { return _this._routerCanReuse(instruction); })
            .then(function (_) { return _this._canActivate(instruction); })
            .then(function (result) {
            if (!result) {
                return false;
            }
            return _this._routerCanDeactivate(instruction)
                .then(function (result) {
                if (result) {
                    return _this.commit(instruction, _skipLocationChange)
                        .then(function (_) {
                        _this._emitNavigationFinish(instruction.toRootUrl());
                        return true;
                    });
                }
            });
        });
    };
    Router.prototype._emitNavigationFinish = function (url) { ObservableWrapper.callEmit(this._subject, url); };
    Router.prototype._afterPromiseFinishNavigating = function (promise) {
        var _this = this;
        return PromiseWrapper.catchError(promise.then(function (_) { return _this._finishNavigating(); }), function (err) {
            _this._finishNavigating();
            throw err;
        });
    };
    /*
     * Recursively set reuse flags
     */
    /** @internal */
    Router.prototype._routerCanReuse = function (instruction) {
        var _this = this;
        if (isBlank(this._outlet)) {
            return _resolveToFalse;
        }
        if (isBlank(instruction.component)) {
            return _resolveToTrue;
        }
        return this._outlet.routerCanReuse(instruction.component)
            .then(function (result) {
            instruction.component.reuse = result;
            if (result && isPresent(_this._childRouter) && isPresent(instruction.child)) {
                return _this._childRouter._routerCanReuse(instruction.child);
            }
        });
    };
    Router.prototype._canActivate = function (nextInstruction) {
        return canActivateOne(nextInstruction, this._currentInstruction);
    };
    Router.prototype._routerCanDeactivate = function (instruction) {
        var _this = this;
        if (isBlank(this._outlet)) {
            return _resolveToTrue;
        }
        var next;
        var childInstruction = null;
        var reuse = false;
        var componentInstruction = null;
        if (isPresent(instruction)) {
            childInstruction = instruction.child;
            componentInstruction = instruction.component;
            reuse = isBlank(instruction.component) || instruction.component.reuse;
        }
        if (reuse) {
            next = _resolveToTrue;
        }
        else {
            next = this._outlet.routerCanDeactivate(componentInstruction);
        }
        // TODO: aux route lifecycle hooks
        return next.then(function (result) {
            if (result == false) {
                return false;
            }
            if (isPresent(_this._childRouter)) {
                return _this._childRouter._routerCanDeactivate(childInstruction);
            }
            return true;
        });
    };
    /**
     * Updates this router and all descendant routers according to the given instruction
     */
    Router.prototype.commit = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        this._currentInstruction = instruction;
        var next = _resolveToTrue;
        if (isPresent(this._outlet) && isPresent(instruction.component)) {
            var componentInstruction = instruction.component;
            if (componentInstruction.reuse) {
                next = this._outlet.reuse(componentInstruction);
            }
            else {
                next =
                    this.deactivate(instruction).then(function (_) { return _this._outlet.activate(componentInstruction); });
            }
            if (isPresent(instruction.child)) {
                next = next.then(function (_) {
                    if (isPresent(_this._childRouter)) {
                        return _this._childRouter.commit(instruction.child);
                    }
                });
            }
        }
        var promises = [];
        this._auxRouters.forEach(function (router, name) {
            if (isPresent(instruction.auxInstruction[name])) {
                promises.push(router.commit(instruction.auxInstruction[name]));
            }
        });
        return next.then(function (_) { return PromiseWrapper.all(promises); });
    };
    /** @internal */
    Router.prototype._startNavigating = function () { this.navigating = true; };
    /** @internal */
    Router.prototype._finishNavigating = function () { this.navigating = false; };
    /**
     * Subscribe to URL updates from the router
     */
    Router.prototype.subscribe = function (onNext) {
        return ObservableWrapper.subscribe(this._subject, onNext);
    };
    /**
     * Removes the contents of this router's outlet and all descendant outlets
     */
    Router.prototype.deactivate = function (instruction) {
        var _this = this;
        var childInstruction = null;
        var componentInstruction = null;
        if (isPresent(instruction)) {
            childInstruction = instruction.child;
            componentInstruction = instruction.component;
        }
        var next = _resolveToTrue;
        if (isPresent(this._childRouter)) {
            next = this._childRouter.deactivate(childInstruction);
        }
        if (isPresent(this._outlet)) {
            next = next.then(function (_) { return _this._outlet.deactivate(componentInstruction); });
        }
        // TODO: handle aux routes
        return next;
    };
    /**
     * Given a URL, returns an instruction representing the component graph
     */
    Router.prototype.recognize = function (url) {
        var ancestorComponents = this._getAncestorInstructions();
        return this.registry.recognize(url, ancestorComponents);
    };
    Router.prototype._getAncestorInstructions = function () {
        var ancestorInstructions = [this._currentInstruction];
        var ancestorRouter = this;
        while (isPresent(ancestorRouter = ancestorRouter.parent)) {
            ancestorInstructions.unshift(ancestorRouter._currentInstruction);
        }
        return ancestorInstructions;
    };
    /**
     * Navigates to either the last URL successfully navigated to, or the last URL requested if the
     * router has yet to successfully navigate.
     */
    Router.prototype.renavigate = function () {
        if (isBlank(this.lastNavigationAttempt)) {
            return this._currentNavigation;
        }
        return this.navigateByUrl(this.lastNavigationAttempt);
    };
    /**
     * Generate an `Instruction` based on the provided Route Link DSL.
     */
    Router.prototype.generate = function (linkParams) {
        var ancestorInstructions = this._getAncestorInstructions();
        return this.registry.generate(linkParams, ancestorInstructions);
    };
    return Router;
})();
exports.Router = Router;
var RootRouter = (function (_super) {
    __extends(RootRouter, _super);
    function RootRouter(registry, location, primaryComponent) {
        var _this = this;
        _super.call(this, registry, null, primaryComponent);
        this._location = location;
        this._locationSub = this._location.subscribe(function (change) {
            // we call recognize ourselves
            _this.recognize(change['url'])
                .then(function (instruction) {
                _this.navigateByInstruction(instruction, isPresent(change['pop']))
                    .then(function (_) {
                    // this is a popstate event; no need to change the URL
                    if (isPresent(change['pop']) && change['type'] != 'hashchange') {
                        return;
                    }
                    var emitPath = instruction.toUrlPath();
                    var emitQuery = instruction.toUrlQuery();
                    if (emitPath.length > 0 && emitPath[0] != '/') {
                        emitPath = '/' + emitPath;
                    }
                    // Because we've opted to use All hashchange events occur outside Angular.
                    // However, apps that are migrating might have hash links that operate outside
                    // angular to which routing must respond.
                    // To support these cases where we respond to hashchanges and redirect as a
                    // result, we need to replace the top item on the stack.
                    if (change['type'] == 'hashchange') {
                        if (instruction.toRootUrl() != _this._location.path()) {
                            _this._location.replaceState(emitPath, emitQuery);
                        }
                    }
                    else {
                        _this._location.go(emitPath, emitQuery);
                    }
                });
            });
        });
        this.registry.configFromComponent(primaryComponent);
        this.navigateByUrl(location.path());
    }
    RootRouter.prototype.commit = function (instruction, _skipLocationChange) {
        var _this = this;
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        var emitPath = instruction.toUrlPath();
        var emitQuery = instruction.toUrlQuery();
        if (emitPath.length > 0 && emitPath[0] != '/') {
            emitPath = '/' + emitPath;
        }
        var promise = _super.prototype.commit.call(this, instruction);
        if (!_skipLocationChange) {
            promise = promise.then(function (_) { _this._location.go(emitPath, emitQuery); });
        }
        return promise;
    };
    RootRouter.prototype.dispose = function () {
        if (isPresent(this._locationSub)) {
            ObservableWrapper.dispose(this._locationSub);
            this._locationSub = null;
        }
    };
    return RootRouter;
})(Router);
exports.RootRouter = RootRouter;
var ChildRouter = (function (_super) {
    __extends(ChildRouter, _super);
    function ChildRouter(parent, hostComponent) {
        _super.call(this, parent.registry, parent, hostComponent);
        this.parent = parent;
    }
    ChildRouter.prototype.navigateByUrl = function (url, _skipLocationChange) {
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        // Delegate navigation to the root router
        return this.parent.navigateByUrl(url, _skipLocationChange);
    };
    ChildRouter.prototype.navigateByInstruction = function (instruction, _skipLocationChange) {
        if (_skipLocationChange === void 0) { _skipLocationChange = false; }
        // Delegate navigation to the root router
        return this.parent.navigateByInstruction(instruction, _skipLocationChange);
    };
    return ChildRouter;
})(Router);
function canActivateOne(nextInstruction, prevInstruction) {
    var next = _resolveToTrue;
    if (isBlank(nextInstruction.component)) {
        return next;
    }
    if (isPresent(nextInstruction.child)) {
        next = canActivateOne(nextInstruction.child, isPresent(prevInstruction) ? prevInstruction.child : null);
    }
    return next.then(function (result) {
        if (result == false) {
            return false;
        }
        if (nextInstruction.component.reuse) {
            return true;
        }
        var hook = route_lifecycle_reflector_1.getCanActivateHook(nextInstruction.component.componentType);
        if (isPresent(hook)) {
            return hook(nextInstruction.component, isPresent(prevInstruction) ? prevInstruction.component : null);
        }
        return true;
    });
}


  //TODO: this is a hack to replace the exiting implementation at run-time
  exports.getCanActivateHook = function (directiveName) {
    var factory = $$directiveIntrospector.getTypeByName(directiveName);
    return factory && factory.$canActivate && function (next, prev) {
      return $injector.invoke(factory.$canActivate, null, {
        $nextInstruction: next,
        $prevInstruction: prev
      });
    };
  };

  // This hack removes assertions about the type of the "component"
  // property in a route config
  exports.assertComponentExists = function () {};

  angular.stringifyInstruction = function (instruction) {
    return instruction.toRootUrl();
  };

  var RouteRegistry = exports.RouteRegistry;
  var RootRouter = exports.RootRouter;

  var registry = new RouteRegistry($routerRootComponent);
  var location = new Location();

  $$directiveIntrospector(function (name, factory) {
    if (angular.isArray(factory.$routeConfig)) {
      factory.$routeConfig.forEach(function (config) {
        registry.config(name, config);
      });
    }
  });

  var router = new RootRouter(registry, location, $routerRootComponent);
  $rootScope.$watch(function () { return $location.url(); }, function (path) {
    if (router.lastNavigationAttempt !== path) {
      router.navigateByUrl(path);
    }
  });

  router.subscribe(function () {
    $rootScope.$broadcast('$routeChangeSuccess', {});
  });

  return router;
}

}());

/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.14.3 - 2015-10-23
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        function expand() {
          element.removeClass('collapse')
            .addClass('collapsing')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false);

          if ($animateCss) {
            $animateCss(element, {
              addClass: 'in',
              easing: 'ease',
              to: { height: element[0].scrollHeight + 'px' }
            }).start().finally(expandDone);
          } else {
            $animate.addClass(element, 'in', {
              to: { height: element[0].scrollHeight + 'px' }
            }).then(expandDone);
          }
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css({height: 'auto'});
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          element
            // IMPORTANT: The height must be set before adding "collapsing" class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + 'px'})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass('collapse')
            .addClass('collapsing')
            .attr('aria-expanded', false)
            .attr('aria-hidden', true);

          if ($animateCss) {
            $animateCss(element, {
              removeClass: 'in',
              to: {height: '0'}
            }).start().finally(collapseDone);
          } else {
            $animate.removeClass(element, 'in', {
              to: {height: '0'}
            }).then(collapseDone);
          }
        }

        function collapseDone() {
          element.css({height: '0'}); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
        }

        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

/* Deprecated collapse below */

angular.module('ui.bootstrap.collapse')

  .value('$collapseSuppressWarning', false)

  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        if (!$collapseSuppressWarning) {
          $log.warn('collapse is now deprecated. Use uib-collapse instead.');
        }

        function expand() {
          element.removeClass('collapse')
            .addClass('collapsing')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false);

          if ($animateCss) {
            $animateCss(element, {
              easing: 'ease',
              to: { height: element[0].scrollHeight + 'px' }
            }).start().done(expandDone);
          } else {
            $animate.animate(element, {}, {
              height: element[0].scrollHeight + 'px'
            }).then(expandDone);
          }
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse in')
            .css({height: 'auto'});
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          element
            // IMPORTANT: The height must be set before adding "collapsing" class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + 'px'})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass('collapse in')
            .addClass('collapsing')
            .attr('aria-expanded', false)
            .attr('aria-hidden', true);

          if ($animateCss) {
            $animateCss(element, {
              to: {height: '0'}
            }).start().done(collapseDone);
          } else {
            $animate.animate(element, {}, {
              height: '0'
            }).then(collapseDone);
          }
        }

        function collapseDone() {
          element.css({height: '0'}); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
        }

        scope.$watch(attrs.collapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function(event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function() {
  return {
    controller: 'UibAccordionController',
    controllerAs: 'accordion',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/accordion/accordion.html';
    }
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function() {
  return {
    require: '^uibAccordion',         // We need this directive to be inside an accordion
    transclude: true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/accordion/accordion-group.html';
    },
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || 'panel-open';
      scope.panelClass = attrs.panelClass;
      scope.$watch('isOpen', function(value) {
        element.toggleClass(scope.openClass, !!value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function() {
  return {
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function() {
  return {
    require: ['?^uibAccordionGroup', '?^accordionGroup'],
    link: function(scope, element, attrs, controller) {
      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation
      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
        if (heading) {
          element.find('span').html('');
          element.find('span').append(heading);
        }
      });
    }
  };
});

/* Deprecated accordion below */

angular.module('ui.bootstrap.accordion')

  .value('$accordionSuppressWarning', false)

  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {
    if (!$accordionSuppressWarning) {
      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');
    }

    angular.extend(this, $controller('UibAccordionController', {
      $scope: $scope,
      $attrs: $attrs
    }));
  }])

  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      restrict: 'EA',
      controller: 'AccordionController',
      controllerAs: 'accordion',
      transclude: true,
      replace: false,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'template/accordion/accordion.html';
      },
      link: function() {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion is now deprecated. Use uib-accordion instead.');
        }
      }
    };
  }])

  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      require: '^accordion',         // We need this directive to be inside an accordion
      restrict: 'EA',
      transclude: true,              // It transcludes the contents of the directive into the template
      replace: true,                // The element containing the directive will be replaced with the template
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'template/accordion/accordion-group.html';
      },
      scope: {
        heading: '@',               // Interpolate the heading attribute onto this scope
        isOpen: '=?',
        isDisabled: '=?'
      },
      controller: function() {
        this.setHeading = function(element) {
          this.heading = element;
        };
      },
      link: function(scope, element, attrs, accordionCtrl) {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');
        }

        accordionCtrl.addGroup(scope);

        scope.openClass = attrs.openClass || 'panel-open';
        scope.panelClass = attrs.panelClass;
        scope.$watch('isOpen', function(value) {
          element.toggleClass(scope.openClass, !!value);
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
        });

        scope.toggleOpen = function($event) {
          if (!scope.isDisabled) {
            if (!$event || $event.which === 32) {
              scope.isOpen = !scope.isOpen;
            }
          }
        };
      }
    };
  }])

  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      restrict: 'EA',
      transclude: true,   // Grab the contents to be used as the heading
      template: '',       // In effect remove this element!
      replace: true,
      require: '^accordionGroup',
      link: function(scope, element, attr, accordionGroupCtrl, transclude) {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');
        }
        // Pass the heading to the accordion-group controller
        // so that it can be transcluded into the right place in the template
        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
      }
    };
  }])

  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      require: '^accordionGroup',
      link: function(scope, element, attr, controller) {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');
        }

        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
          if (heading) {
            element.find('span').html('');
            element.find('span').append(heading);
          }
        });
      }
    };
  }]);


angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
    $timeout(function() {
      $scope.close();
    }, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
    controller: 'UibAlertController',
    controllerAs: 'alert',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/alert/alert.html';
    },
    transclude: true,
    replace: true,
    scope: {
      type: '@',
      close: '&'
    }
  };
});

/* Deprecated alert below */

angular.module('ui.bootstrap.alert')

  .value('$alertSuppressWarning', false)

  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {
    if (!$alertSuppressWarning) {
      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');
    }

    angular.extend(this, $controller('UibAlertController', {
      $scope: $scope,
      $attrs: $attrs
    }));
  }])

  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {
    return {
      controller: 'AlertController',
      controllerAs: 'alert',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'template/alert/alert.html';
      },
      transclude: true,
      replace: true,
      scope: {
        type: '@',
        close: '&'
      },
      link: function() {
        if (!$alertSuppressWarning) {
          $log.warn('alert is now deprecated. Use uib-alert instead.');
        }
      }
    };
  }]);

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', function() {
  return {
    require: ['uibBtnRadio', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'buttons',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
})

.directive('uibBtnCheckbox', function() {
  return {
    require: ['uibBtnCheckbox', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'button',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attribute, defaultValue) {
        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

/* Deprecated buttons below */

angular.module('ui.bootstrap.buttons')

  .value('$buttonsSuppressWarning', false)

  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {
    if (!$buttonsSuppressWarning) {
      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');
    }

    angular.extend(this, $controller('UibButtonsController'));
  }])

  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {
    return {
      require: ['btnRadio', 'ngModel'],
      controller: 'ButtonsController',
      controllerAs: 'buttons',
      link: function(scope, element, attrs, ctrls) {
        if (!$buttonsSuppressWarning) {
          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');
        }

        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

        element.find('input').css({display: 'none'});

        //model -> UI
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
        };

        //ui->model
        element.bind(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }

          var isActive = element.hasClass(buttonsCtrl.activeClass);

          if (!isActive || angular.isDefined(attrs.uncheckable)) {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
              ngModelCtrl.$render();
            });
          }
        });
      }
    };
  }])

  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {
    return {
      require: ['btnCheckbox', 'ngModel'],
      controller: 'ButtonsController',
      controllerAs: 'button',
      link: function(scope, element, attrs, ctrls) {
        if (!$buttonsSuppressWarning) {
          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');
        }

        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

        element.find('input').css({display: 'none'});

        function getTrueValue() {
          return getCheckboxValue(attrs.btnCheckboxTrue, true);
        }

        function getFalseValue() {
          return getCheckboxValue(attrs.btnCheckboxFalse, false);
        }

        function getCheckboxValue(attributeValue, defaultValue) {
          var val = scope.$eval(attributeValue);
          return angular.isDefined(val) ? val : defaultValue;
        }

        //model -> UI
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
        };

        //ui->model
        element.bind(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }

          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });

        //accessibility
        element.on('keypress', function(e) {
          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
            return;
          }

          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });
      }
    };
  }]);


/**
 * @ngdoc overview
 * @name ui.bootstrap.carousel
 *
 * @description
 * AngularJS version of an image carousel.
 *
 */
angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    NEW_ANIMATE = angular.version.minor >= 4,
    NO_TRANSITION = 'uib-noTransition',
    SLIDE_DIRECTION = 'uib-slideDirection',
    currentIndex = -1,
    currentInterval, isPlaying;
  self.currentSlide = null;

  var destroyed = false;
  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = $scope.indexOfSlide(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
    }
    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
      goNext(nextSlide, nextIndex, direction);
    }
  };

  function goNext(slide, index, direction) {
    // Scope has been destroyed, stop here.
    if (destroyed) { return; }

    angular.extend(slide, {direction: direction, active: true});
    angular.extend(self.currentSlide || {}, {direction: direction, active: false});
    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&
      slide.$element && self.slides.length > 1) {
      slide.$element.data(SLIDE_DIRECTION, slide.direction);
      if (self.currentSlide && self.currentSlide.$element) {
        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
      }

      $scope.$currentTransition = true;
      if (NEW_ANIMATE) {
        $animate.on('addClass', slide.$element, function(element, phase) {
          if (phase === 'close') {
            $scope.$currentTransition = null;
            $animate.off('addClass', element);
          }
        });
      } else {
        slide.$element.one('$animate:close', function closeFn() {
          $scope.$currentTransition = null;
        });
      }
    }

    self.currentSlide = slide;
    currentIndex = index;

    //every time you change slides, reset the timer
    restartTimer();
  }

  $scope.$on('$destroy', function() {
    destroyed = true;
  });

  function getSlideByIndex(index) {
    if (angular.isUndefined(slides[index].index)) {
      return slides[index];
    }
    var i, len = slides.length;
    for (i = 0; i < slides.length; ++i) {
      if (slides[i].index == index) {
        return slides[i];
      }
    }
  }

  self.getCurrentIndex = function() {
    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
      return +self.currentSlide.index;
    }
    return currentIndex;
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 && $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(getSlideByIndex(newIndex), 'next');
  };

  $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() && newIndex === slides.length - 1) {
      $scope.pause();
      return;
    }

    return self.select(getSlideByIndex(newIndex), 'prev');
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.$watch('interval', restartTimer);
  $scope.$watchCollection('slides', resetTransition);
  $scope.$on('$destroy', resetTimer);

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval > 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }

  function resetTransition(slides) {
    if (!slides.length) {
      $scope.$currentTransition = null;
    }
  }

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if (slides.length === 1 || slide.active) {
      self.select(slides[slides.length - 1]);
      if (slides.length === 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    if (angular.isDefined(slide.index)) {
      slides.sort(function(a, b) {
        return +a.index > +b.index;
      });
    }
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index - 1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }

    //clean the currentSlide when no more slide
    if (slides.length === 0) {
      self.currentSlide = null;
    }
  };

  $scope.$watch('noTransition', function(noTransition) {
    $element.data(NO_TRANSITION, noTransition);
  });

}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <uib-carousel>
      <uib-slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </uib-slide>
      <uib-slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </uib-slide>
    </uib-carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('uibCarousel', [function() {
  return {
    transclude: true,
    replace: true,
    controller: 'UibCarouselController',
    controllerAs: 'carousel',
    require: 'carousel',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/carousel.html';
    },
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <uib-carousel>
    <uib-slide ng-repeat="slide in slides" active="slide.active" index="$index">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </uib-slide>
  </uib-carousel>
  Interval, in milliseconds: <input type="number" ng-model="myInterval">
  <br />Enter a negative number to stop the interval.
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('uibSlide', function() {
  return {
    require: '^uibCarousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/slide.html';
    },
    scope: {
      active: '=?',
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
})

.animation('.item', [
         '$injector', '$animate',
function ($injector, $animate) {
  var NO_TRANSITION = 'uib-noTransition',
    SLIDE_DIRECTION = 'uib-slideDirection',
    $animateCss = null;

  if ($injector.has('$animateCss')) {
    $animateCss = $injector.get('$animateCss');
  }

  function removeClass(element, className, callback) {
    element.removeClass(className);
    if (callback) {
      callback();
    }
  }

  return {
    beforeAddClass: function(element, className, done) {
      // Due to transclusion, noTransition property is on parent's scope
      if (className == 'active' && element.parent() && element.parent().parent() &&
          !element.parent().parent().data(NO_TRANSITION)) {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction == 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element,
          directionClass + ' ' + direction, done);
        element.addClass(direction);

        if ($animateCss) {
          $animateCss(element, {addClass: directionClass})
            .start()
            .done(removeClassFn);
        } else {
          $animate.addClass(element, directionClass).then(function () {
            if (!stopped) {
              removeClassFn();
            }
            done();
          });
        }

        return function () {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent's scope
      if (className === 'active' && element.parent() && element.parent().parent() &&
          !element.parent().parent().data(NO_TRANSITION)) {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction == 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element, directionClass, done);

        if ($animateCss) {
          $animateCss(element, {addClass: directionClass})
            .start()
            .done(removeClassFn);
        } else {
          $animate.addClass(element, directionClass).then(function() {
            if (!stopped) {
              removeClassFn();
            }
            done();
          });
        }
        return function() {
          stopped = true;
        };
      }
      done();
    }
  };
}]);

/* deprecated carousel below */

angular.module('ui.bootstrap.carousel')

.value('$carouselSuppressWarning', false)

.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {
  if (!$carouselSuppressWarning) {
    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');
  }

  angular.extend(this, $controller('UibCarouselController', {
    $scope: $scope,
    $element: $element
  }));
}])

.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
  return {
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    controllerAs: 'carousel',
    require: 'carousel',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/carousel.html';
    },
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    },
    link: function() {
      if (!$carouselSuppressWarning) {
        $log.warn('carousel is now deprecated. Use uib-carousel instead.');
      }
    }
  };
}])

.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
  return {
    require: '^carousel',
    transclude: true,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/slide.html';
    },
    scope: {
      active: '=?',
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      if (!$carouselSuppressWarning) {
        $log.warn('slide is now deprecated. Use uib-slide instead.');
      }

      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  var localeId;
  var formatCodeToRegex;

  this.init = function() {
    localeId = $locale.id;

    this.parsers = {};

    formatCodeToRegex = {
      'yyyy': {
        regex: '\\d{4}',
        apply: function(value) { this.year = +value; }
      },
      'yy': {
        regex: '\\d{2}',
        apply: function(value) { this.year = +value + 2000; }
      },
      'y': {
        regex: '\\d{1,4}',
        apply: function(value) { this.year = +value; }
      },
      'MMMM': {
        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
      },
      'MMM': {
        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
      },
      'MM': {
        regex: '0[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; }
      },
      'M': {
        regex: '[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; }
      },
      'dd': {
        regex: '[0-2][0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; }
      },
      'd': {
        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; }
      },
      'EEEE': {
        regex: $locale.DATETIME_FORMATS.DAY.join('|')
      },
      'EEE': {
        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
      },
      'HH': {
        regex: '(?:0|1)[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; }
      },
      'hh': {
        regex: '0[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; }
      },
      'H': {
        regex: '1?[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; }
      },
      'h': {
        regex: '[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; }
      },
      'mm': {
        regex: '[0-5][0-9]',
        apply: function(value) { this.minutes = +value; }
      },
      'm': {
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.minutes = +value; }
      },
      'sss': {
        regex: '[0-9][0-9][0-9]',
        apply: function(value) { this.milliseconds = +value; }
      },
      'ss': {
        regex: '[0-5][0-9]',
        apply: function(value) { this.seconds = +value; }
      },
      's': {
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.seconds = +value; }
      },
      'a': {
        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
        apply: function(value) {
          if (this.hours === 12) {
            this.hours = 0;
          }

          if (value === 'PM') {
            this.hours += 12;
          }
        }
      }
    };
  };

  this.init();

  function createParser(format) {
    var map = [], regex = format.split('');

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if (results && results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn('dateparser:', 'baseDate is not a valid date');
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i-1];
        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if (isValid(fields.year, fields.month, fields.date)) {
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
          dt = new Date(baseDate);
          dt.setFullYear(fields.year, fields.month, fields.date,
            fields.hours, fields.minutes, fields.seconds,
            fields.milliseconds || 0);
        } else {
          dt = new Date(fields.year, fields.month, fields.date,
            fields.hours, fields.minutes, fields.seconds,
            fields.milliseconds || 0);
        }
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if (month === 1 && date > 28) {
      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }
}]);

/* Deprecated dateparser below */

angular.module('ui.bootstrap.dateparser')

.value('$dateParserSuppressWarning', false)

.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {
  if (!$dateParserSuppressWarning) {
    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');
  }

  angular.extend(this, uibDateParser);
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function(element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function(element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
        var positionStrParts = positionStr.split('-');
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop('offsetWidth');
        targetElHeight = targetEl.prop('offsetHeight');

        var shiftWidth = {
          center: function() {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function() {
            return hostElPos.left;
          },
          right: function() {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function() {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function() {
            return hostElPos.top;
          },
          bottom: function() {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case 'right':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case 'left':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case 'bottom':
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

/* Deprecated position below */

angular.module('ui.bootstrap.position')

.value('$positionSuppressWarning', false)

.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {
  if (!$positionSuppressWarning) {
    $log.warn('$position is now deprecated. Use $uibPosition instead.');
  }

  angular.extend(this, $uibPosition);
}]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])

.value('$datepickerSuppressError', false)

.constant('uibDatepickerConfig', {
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  datepickerMode: 'day',
  minMode: 'day',
  maxMode: 'year',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null,
  shortcutPropagation: false
})

.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  // Configuration attributes
  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach(['minDate', 'maxDate'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  angular.forEach(['minMode', 'maxMode'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = angular.isDefined(value) ? value : $attrs[key];
        $scope[key] = self[key];
        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
          $scope.datepickerMode = self[key];
        }
      });
    } else {
      self[key] = datepickerConfig[key] || null;
      $scope[key] = self[key];
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  if (angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate = new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function(date) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  this.step = { months: 1 };
  this.element = $element;
  function getDaysInMonth(year, month) {
    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
  }

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    scope.showWeeks = ctrl.showWeeks;
    ctrl.refreshView();
  };

  this.getDates = function(startDate, n) {
    var dates = new Array(n), current = new Date(startDate), i = 0, date;
    while (i < n) {
      date = new Date(current);
      dates[i++] = date;
      current.setDate(current.getDate() + 1);
    }
    return dates;
  };

  this._refreshView = function() {
    var year = this.activeDate.getFullYear(),
      month = this.activeDate.getMonth(),
      firstDayOfMonth = new Date(this.activeDate);

    firstDayOfMonth.setFullYear(year, month, 1);

    var difference = this.startingDay - firstDayOfMonth.getDay(),
      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
      firstDate = new Date(firstDayOfMonth);

    if (numDisplayedFromPreviousMonth > 0) {
      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
    }

    // 42 is the number of days on a six-month calendar
    var days = this.getDates(firstDate, 42);
    for (var i = 0; i < 42; i ++) {
      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
        secondary: days[i].getMonth() !== month,
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.labels = new Array(7);
    for (var j = 0; j < 7; j++) {
      scope.labels[j] = {
        abbr: dateFilter(days[j].date, this.formatDayHeader),
        full: dateFilter(days[j].date, 'EEEE')
      };
    }

    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
    scope.rows = this.split(days, 7);

    if (scope.showWeeks) {
      scope.weekNumbers = [];
      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
        scope.weekNumbers.push(
          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
      }
    }
  };

  this.compare = function(date1, date2) {
    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
  };

  function getISO8601WeekNumber(date) {
    var checkDate = new Date(date);
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
    var time = checkDate.getTime();
    checkDate.setMonth(0); // Compare with Jan 1
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  }

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getDate();

    if (key === 'left') {
      date = date - 1;   // up
    } else if (key === 'up') {
      date = date - 7;   // down
    } else if (key === 'right') {
      date = date + 1;   // down
    } else if (key === 'down') {
      date = date + 7;
    } else if (key === 'pageup' || key === 'pagedown') {
      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setMonth(month, 1);
      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
    } else if (key === 'home') {
      date = 1;
    } else if (key === 'end') {
      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
    }
    this.activeDate.setDate(date);
  };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  this.step = { years: 1 };
  this.element = $element;

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    ctrl.refreshView();
  };

  this._refreshView = function() {
    var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;

    for (var i = 0; i < 12; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(year, i, 1);
      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
    scope.rows = this.split(months, 3);
  };

  this.compare = function(date1, date2) {
    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getMonth();

    if (key === 'left') {
      date = date - 1;   // up
    } else if (key === 'up') {
      date = date - 3;   // down
    } else if (key === 'right') {
      date = date + 1;   // down
    } else if (key === 'down') {
      date = date + 3;
    } else if (key === 'pageup' || key === 'pagedown') {
      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setFullYear(year);
    } else if (key === 'home') {
      date = 0;
    } else if (key === 'end') {
      date = 11;
    }
    this.activeDate.setMonth(date);
  };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var range;
  this.element = $element;

  function getStartingYear(year) {
    return parseInt((year - 1) / range, 10) * range + 1;
  }

  this.yearpickerInit = function() {
    range = this.yearRange;
    this.step = { years: range };
  };

  this._refreshView = function() {
    var years = new Array(range), date;

    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(start + i, 0, 1);
      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = [years[0].label, years[range - 1].label].join(' - ');
    scope.rows = this.split(years, 5);
  };

  this.compare = function(date1, date2) {
    return date1.getFullYear() - date2.getFullYear();
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getFullYear();

    if (key === 'left') {
      date = date - 1;   // up
    } else if (key === 'up') {
      date = date - 5;   // down
    } else if (key === 'right') {
      date = date + 1;   // down
    } else if (key === 'down') {
      date = date + 5;
    } else if (key === 'pageup' || key === 'pagedown') {
      date += (key === 'pageup' ? - 1 : 1) * this.step.years;
    } else if (key === 'home') {
      date = getStartingYear(this.activeDate.getFullYear());
    } else if (key === 'end') {
      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
    }
    this.activeDate.setFullYear(date);
  };
}])

.directive('uibDatepicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/datepicker.html';
    },
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&',
      customClass: '&',
      shortcutPropagation: '&?'
    },
    require: ['uibDatepicker', '^ngModel'],
    controller: 'UibDatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive('uibDaypicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/day.html';
    },
    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0] || ctrls[2],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibMonthpicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/month.html';
    },
    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0] || ctrls[2],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibYearpicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/year.html';
    },
    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      var ctrl = ctrls[0] || ctrls[2];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
})

.constant('uibDatepickerPopupConfig', {
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
  datepickerTemplateUrl: 'template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  currentText: 'Today',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true,
  onOpenFocus: true
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',
function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
  var self = this;
  var cache = {},
    isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,
    ngModel, $popup;

  scope.watchData = {};

  this.init = function(_ngModel_) {
    ngModel = _ngModel_;
    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;

    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

    if (datepickerPopupConfig.html5Types[attrs.type]) {
      dateFormat = datepickerPopupConfig.html5Types[attrs.type];
      isHtml5DateInput = true;
    } else {
      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
          // Invalidate the $modelValue to ensure that formatters re-run
          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
          if (newDateFormat !== dateFormat) {
            dateFormat = newDateFormat;
            ngModel.$modelValue = null;

            if (!dateFormat) {
              throw new Error('uibDatepickerPopup must have a date format specified.');
            }
          }
      });
    }

    if (!dateFormat) {
      throw new Error('uibDatepickerPopup must have a date format specified.');
    }

    if (isHtml5DateInput && attrs.datepickerPopup) {
      throw new Error('HTML5 date input types do not support custom formats.');
    }

    // popup element used to display calendar
    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
    popupEl.attr({
      'ng-model': 'date',
      'ng-change': 'dateSelection(date)',
      'template-url': datepickerPopupTemplateUrl
    });

    // datepicker element
    datepickerEl = angular.element(popupEl.children()[0]);
    datepickerEl.attr('template-url', datepickerTemplateUrl);

    if (isHtml5DateInput) {
      if (attrs.type === 'month') {
        datepickerEl.attr('datepicker-mode', '"month"');
        datepickerEl.attr('min-mode', 'month');
      }
    }

    if (attrs.datepickerOptions) {
      var options = scope.$parent.$eval(attrs.datepickerOptions);
      if (options && options.initDate) {
        scope.initDate = options.initDate;
        datepickerEl.attr('init-date', 'initDate');
        delete options.initDate;
      }
      angular.forEach(options, function(value, option) {
        datepickerEl.attr(cameltoDash(option), value);
      });
    }

    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
      if (attrs[key]) {
        var getAttribute = $parse(attrs[key]);
        scope.$parent.$watch(getAttribute, function(value) {
          scope.watchData[key] = value;
          if (key === 'minDate' || key === 'maxDate') {
            cache[key] = new Date(value);
          }
        });
        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

        // Propagate changes from datepicker to outside
        if (key === 'datepickerMode') {
          var setAttribute = getAttribute.assign;
          scope.$watch('watchData.' + key, function(value, oldvalue) {
            if (angular.isFunction(setAttribute) && value !== oldvalue) {
              setAttribute(scope.$parent, value);
            }
          });
        }
      }
    });
    if (attrs.dateDisabled) {
      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
    }

    if (attrs.showWeeks) {
      datepickerEl.attr('show-weeks', attrs.showWeeks);
    }

    if (attrs.customClass) {
      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
    }

    if (!isHtml5DateInput) {
      // Internal API to maintain the correct ng-invalid-[key] class
      ngModel.$$parserName = 'date';
      ngModel.$validators.date = validator;
      ngModel.$parsers.unshift(parseDate);
      ngModel.$formatters.push(function(value) {
        scope.date = value;
        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
      });
    } else {
      ngModel.$formatters.push(function(value) {
        scope.date = value;
        return value;
      });
    }

    // Detect changes in the view from the text box
    ngModel.$viewChangeListeners.push(function() {
      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
    });

    element.bind('keydown', inputKeydownBind);

    $popup = $compile(popupEl)(scope);
    // Prevent jQuery cache memory leak (template is now redundant after linking)
    popupEl.remove();

    if (appendToBody) {
      $document.find('body').append($popup);
    } else {
      element.after($popup);
    }

    scope.$on('$destroy', function() {
      if (scope.isOpen === true) {
        if (!$rootScope.$$phase) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      }

      $popup.remove();
      element.unbind('keydown', inputKeydownBind);
      $document.unbind('click', documentClickBind);
    });
  };

  scope.getText = function(key) {
    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  scope.isDisabled = function(date) {
    if (date === 'today') {
      date = new Date();
    }

    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||
      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
  };

  scope.compare = function(date1, date2) {
    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
  };

  // Inner change
  scope.dateSelection = function(dt) {
    if (angular.isDefined(dt)) {
      scope.date = dt;
    }
    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
    element.val(date);
    ngModel.$setViewValue(date);

    if (closeOnDateSelection) {
      scope.isOpen = false;
      element[0].focus();
    }
  };

  scope.keydown = function(evt) {
    if (evt.which === 27) {
      scope.isOpen = false;
      element[0].focus();
    }
  };

  scope.select = function(date) {
    if (date === 'today') {
      var today = new Date();
      if (angular.isDate(scope.date)) {
        date = new Date(scope.date);
        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
      } else {
        date = new Date(today.setHours(0, 0, 0, 0));
      }
    }
    scope.dateSelection(date);
  };

  scope.close = function() {
    scope.isOpen = false;
    element[0].focus();
  };

  scope.$watch('isOpen', function(value) {
    if (value) {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top = scope.position.top + element.prop('offsetHeight');

      $timeout(function() {
        if (onOpenFocus) {
          scope.$broadcast('uib:datepicker.focus');
        }
        $document.bind('click', documentClickBind);
      }, 0, false);
    } else {
      $document.unbind('click', documentClickBind);
    }
  });

  function cameltoDash(string) {
    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDate(viewValue) {
    if (angular.isNumber(viewValue)) {
      // presumably timestamp to date object
      viewValue = new Date(viewValue);
    }

    if (!viewValue) {
      return null;
    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
      return viewValue;
    } else if (angular.isString(viewValue)) {
      var date = dateParser.parse(viewValue, dateFormat, scope.date);
      if (isNaN(date)) {
        return undefined;
      } else {
        return date;
      }
    } else {
      return undefined;
    }
  }

  function validator(modelValue, viewValue) {
    var value = modelValue || viewValue;

    if (!attrs.ngRequired && !value) {
      return true;
    }

    if (angular.isNumber(value)) {
      value = new Date(value);
    }
    if (!value) {
      return true;
    } else if (angular.isDate(value) && !isNaN(value)) {
      return true;
    } else if (angular.isString(value)) {
      var date = dateParser.parse(value, dateFormat);
      return !isNaN(date);
    } else {
      return false;
    }
  }

  function documentClickBind(event) {
    var popup = $popup[0];
    var dpContainsTarget = element[0].contains(event.target);
    // The popup node may not be an element node
    // In some browsers (IE) only element nodes have the 'contains' function
    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
      scope.$apply(function() {
        scope.isOpen = false;
      });
    }
  }

  function inputKeydownBind(evt) {
    if (evt.which === 27 && scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      scope.$apply(function() {
        scope.isOpen = false;
      });
      element[0].focus();
    } else if (evt.which === 40 && !scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      scope.$apply(function() {
        scope.isOpen = true;
      });
    }
  }
}])

.directive('uibDatepickerPopup', function() {
  return {
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&',
      customClass: '&'
    },
    link: function(scope, element, attrs, ctrls) {
      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/popup.html';
    }
  };
});

/* Deprecated datepicker below */

angular.module('ui.bootstrap.datepicker')

.value('$datepickerSuppressWarning', false)

.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {
  if (!$datepickerSuppressWarning) {
    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');
  }

  var self = this,
    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  this.modes = ['day', 'month', 'year'];

  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  angular.forEach(['minDate', 'maxDate'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  angular.forEach(['minMode', 'maxMode'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = angular.isDefined(value) ? value : $attrs[key];
        $scope[key] = self[key];
        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
          $scope.datepickerMode = self[key];
        }
      });
    } else {
      self[key] = datepickerConfig[key] || null;
      $scope[key] = self[key];
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  if (angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate = new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
        isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function(date) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  this.fixTimeZone = function(date) {
    var hours = date.getHours();
    date.setHours(hours === 23 ? hours + 2 : 0);
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
      month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/datepicker.html';
    },
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&',
      customClass: '&',
      shortcutPropagation: '&?'
    },
    require: ['datepicker', '^ngModel'],
    controller: 'DatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');
      }

      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
}])

.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: 'template/datepicker/day.html',
    require: ['^datepicker', 'daypicker'],
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');
      }

      var datepickerCtrl = ctrls[0],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
}])

.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: 'template/datepicker/month.html',
    require: ['^datepicker', 'monthpicker'],
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');
      }

      var datepickerCtrl = ctrls[0],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
}])

.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: 'template/datepicker/year.html',
    require: ['^datepicker', 'yearpicker'],
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');
      }

      var ctrl = ctrls[0];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
}])

.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    require: ['ngModel', 'datepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&',
      customClass: '&'
    },
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');
      }

      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
}])

.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/popup.html';
    },
    link: function() {
      if (!$datepickerSuppressWarning) {
        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');
      }
    }
  };
}]);

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('uibDropdownConfig', {
  openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
  var openScope = null;

  this.open = function(dropdownScope) {
    if (!openScope) {
      $document.bind('click', closeDropdown);
      $document.bind('keydown', keybindFilter);
    }

    if (openScope && openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function(dropdownScope) {
    if (openScope === dropdownScope) {
      openScope = null;
      $document.unbind('click', closeDropdown);
      $document.unbind('keydown', keybindFilter);
    }
  };

  var closeDropdown = function(evt) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope) { return; }

    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }

    var toggleElement = openScope.getToggleElement();
    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    if (evt && openScope.getAutoClose() === 'outsideClick' &&
      dropdownElement && dropdownElement[0].contains(evt.target)) {
      return;
    }

    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  var keybindFilter = function(evt) {
    if (evt.which === 27) {
      openScope.focusToggleElement();
      closeDropdown();
    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      openScope.focusDropdownEntry(evt.which);
    }
  };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    appendToBody = false,
    keynavEnabled =false,
    selectedOption = null;


  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);

    if (appendToBody && self.dropdownMenu) {
      $document.find('body').append(self.dropdownMenu);
      $element.on('$destroy', function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function(open) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      (angular.element(self.dropdownMenu).find('a')) :
      (angular.element($element).find('ul').eq(0).find('a'));

    switch (keyCode) {
      case (40): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = (self.selectedOption === elems.length - 1 ?
            self.selectedOption :
            self.selectedOption + 1);
        }
        break;
      }
      case (38): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    if (appendToBody && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
      var css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
      }

      self.dropdownMenu.css(css);
    }

    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
        toggleInvoker($scope, { open: !!isOpen });
      }
    });

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          });
        });
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope);
    } else {
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      uibDropdownService.close(scope);
      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });

  $scope.$on('$locationChangeSuccess', function() {
    if (scope.getAutoClose() !== 'disabled') {
      scope.isOpen = false;
    }
  });

  var offDestroy = $scope.$on('$destroy', function() {
    scope.$destroy();
  });
  scope.$on('$destroy', offDestroy);
}])

.directive('uibDropdown', function() {
  return {
    controller: 'UibDropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init();
    }
  };
})

.directive('uibDropdownMenu', function() {
  return {
    restrict: 'AC',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
})

.directive('uibKeyboardNav', function() {
  return {
    restrict: 'A',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      element.bind('keydown', function(e) {
        if ([38, 40].indexOf(e.which) !== -1) {
          e.preventDefault();
          e.stopPropagation();

          var elems = dropdownCtrl.dropdownMenu.find('a');

          switch (e.which) {
            case (40): { // Down
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = 0;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
              }
              break;
            }
            case (38): { // Up
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = elems.length - 1;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
                  0 : dropdownCtrl.selectedOption - 1;
              }
              break;
            }
          }
          elems[dropdownCtrl.selectedOption].focus();
        }
      });
    }
  };
})

.directive('uibDropdownToggle', function() {
  return {
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
});

/* Deprecated dropdown below */

angular.module('ui.bootstrap.dropdown')

.value('$dropdownSuppressWarning', false)

.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {
  if (!$dropdownSuppressWarning) {
    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');
  }

  angular.extend(this, uibDropdownService);
}])

.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {
  if (!$dropdownSuppressWarning) {
    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');
  }

  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    appendToBody = false,
    keynavEnabled =false,
    selectedOption = null;


  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);

    if (appendToBody && self.dropdownMenu) {
      $document.find('body').append(self.dropdownMenu);
      $element.on('$destroy', function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function(open) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      (angular.element(self.dropdownMenu).find('a')) :
      (angular.element($element).find('ul').eq(0).find('a'));

    switch (keyCode) {
      case (40): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = (self.selectedOption === elems.length -1 ?
            self.selectedOption :
          self.selectedOption + 1);
        }
        break;
      }
      case (38): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    if (appendToBody && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
      var css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
      }

      self.dropdownMenu.css(css);
    }

    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
        toggleInvoker($scope, { open: !!isOpen });
      }
    });

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          });
        });
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope);
    } else {
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      uibDropdownService.close(scope);
      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });

  $scope.$on('$locationChangeSuccess', function() {
    if (scope.getAutoClose() !== 'disabled') {
      scope.isOpen = false;
    }
  });

  var offDestroy = $scope.$on('$destroy', function() {
    scope.$destroy();
  });
  scope.$on('$destroy', offDestroy);
}])

.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    controller: 'DropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!$dropdownSuppressWarning) {
        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');
      }

      dropdownCtrl.init();
    }
  };
}])

.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    restrict: 'AC',
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      if (!$dropdownSuppressWarning) {
        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
}])

.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    restrict: 'A',
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!$dropdownSuppressWarning) {
        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');
      }

      element.bind('keydown', function(e) {
        if ([38, 40].indexOf(e.which) !== -1) {
          e.preventDefault();
          e.stopPropagation();

          var elems = dropdownCtrl.dropdownMenu.find('a');

          switch (e.which) {
            case (40): { // Down
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = 0;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
              }
              break;
            }
            case (38): { // Up
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = elems.length - 1;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
                  0 : dropdownCtrl.selectedOption - 1;
              }
              break;
            }
          }
          elems[dropdownCtrl.selectedOption].focus();
        }
      });
    }
  };
}])

.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!$dropdownSuppressWarning) {
        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');
      }

      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
}]);

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];

        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};

        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }

            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];

            if (!values) {
              return;
            }

            var idx = values.indexOf(value);

            if (idx !== -1) {
              values.splice(idx, 1);
            }

            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', [
           '$animate', '$injector', '$uibModalStack',
  function($animate ,  $injector,   $modalStack) {
    var $animateCss = null;

    if ($injector.has('$animateCss')) {
      $animateCss = $injector.get('$animateCss');
    }

    return {
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      // Temporary fix for prefixing
      element.addClass('modal-backdrop');

      if (attrs.modalInClass) {
        if ($animateCss) {
          $animateCss(element, {
            addClass: attrs.modalInClass
          }).start();
        } else {
          $animate.addClass(element, attrs.modalInClass);
        }

        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if ($animateCss) {
            $animateCss(element, {
              removeClass: attrs.modalInClass
            }).start().then(done);
          } else {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          }
        });
      }
    }
  }])

  .directive('uibModalWindow', [
           '$uibModalStack', '$q', '$animate', '$injector',
  function($modalStack ,  $q ,  $animate,   $injector) {
    var $animateCss = null;

    if ($injector.has('$animateCss')) {
      $animateCss = $injector.get('$animateCss');
    }

    return {
      scope: {
        index: '@'
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'template/modal/window.html';
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowClass || '');
        element.addClass(attrs.windowTopClass || '');
        scope.size = attrs.size;

        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };

        // moved from template to fix issue #2280
        element.on('click', scope.close);

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is render.
        var modalRenderDeferObj = $q.defer();
        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
        attrs.$observe('modalRender', function(value) {
          if (value == 'true') {
            modalRenderDeferObj.resolve();
          }
        });

        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;

          if (attrs.modalInClass) {
            if ($animateCss) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass
              }).start();
            } else {
              animationPromise = $animate.addClass(element, attrs.modalInClass);
            }

            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: attrs.modalInClass
                }).start().then(done);
              } else {
                $animate.removeClass(element, attrs.modalInClass).then(done);
              }
            });
          }


          $q.when(animationPromise).then(function() {
            var inputWithAutofocus = element[0].querySelector('[autofocus]');
            /**
             * Auto-focusing of a freshly-opened modal element causes any child elements
             * with the autofocus attribute to lose focus. This is an issue on touch
             * based devices which will show and then hide the onscreen keyboard.
             * Attempts to refocus the autofocus element via JavaScript will not reopen
             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
             * the modal element if the modal does not contain an autofocus element.
             */
            if (inputWithAutofocus) {
              inputWithAutofocus.focus();
            } else {
              element[0].focus();
            }
          });

          // Notify {@link $modalStack} that modal is rendered.
          var modal = $modalStack.getTop();
          if (modal) {
            $modalStack.modalRendered(modal.key);
          }
        });
      }
    };
  }])

  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })

  .directive('uibModalTransclude', function() {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  })

  .factory('$uibModalStack', [
             '$animate', '$timeout', '$document', '$compile', '$rootScope',
             '$q',
             '$injector',
             '$$multiMap',
             '$$stackedMap',
    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
              $q,
              $injector,
              $$multiMap,
              $$stackedMap) {
      var $animateCss = null;

      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }

      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };

      //Modal focus behavior
      var focusableElementList;
      var focusIndex = 0;
      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
        'iframe, object, embed, *[tabindex], *[contenteditable=true]';

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find('body').eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
          toggleTopWindowClass(true);
        });
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else {
          body.focus();
        }
      }

      // Add or remove "windowTopClass" from the top window in the stack
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() == -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it's intentional that asyncPromise might be null.
        // That's when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          if ($animateCss) {
            $animateCss(domEl, {
              event: 'leave'
            }).start().then(function() {
              domEl.remove();
            });
          } else {
            $animate.leave(domEl);
          }
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }

      $document.bind('keydown', function(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal && modal.value.keyboard) {
          switch (evt.which) {
            case 27: {
              evt.preventDefault();
              $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, 'escape key press');
              });
              break;
            }
            case 9: {
              $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt)) {
                  focusChanged = $modalStack.focusLastFocusableElement();
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt)) {
                  focusChanged = $modalStack.focusFirstFocusableElement();
                }
              }

              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }
              break;
            }
          }
        }
      });

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var body = $document.find('body').eq(0),
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr('modal-animation', 'true');
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }

        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(modalBodyClass);

        $modalStack.clearFocusListCache();
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[focusableElementList.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) == focusableElementList[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
        }
        return false;
      };

      $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length) {
          if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
            }
          }
        }
      };

      return $modalStack;
    }])

  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',
        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promisesArr.push($q.when($injector.get(value)));
              } else {
                promisesArr.push($q.when(value));
              }
            });
            return promisesArr;
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {

                var modalScope = (modalOptions.scope || $rootScope).$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;

                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });

                var ctrlInstance, ctrlLocals = {};
                var resolveIter = 1;

                //controllers
                if (modalOptions.controller) {
                  ctrlLocals.$scope = modalScope;
                  ctrlLocals.$uibModalInstance = modalInstance;
                  Object.defineProperty(ctrlLocals, '$modalInstance', {
                    get: function() {
                      if (!$modalSuppressWarning) {
                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');
                      }

                      return modalInstance;
                    }
                  });
                  angular.forEach(modalOptions.resolve, function(value, key) {
                    ctrlLocals[key] = tplAndVars[resolveIter++];
                  });

                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                  if (modalOptions.controllerAs) {
                    if (modalOptions.bindToController) {
                      angular.extend(ctrlInstance, modalScope);
                    }

                    modalScope[modalOptions.controllerAs] = ctrlInstance;
                  }
                }

                $modalStack.open(modalInstance, {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  content: tplAndVars[0],
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass
                });
                modalOpenedDeferred.resolve(true);

            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })
            .finally(function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }
      ]
    };

    return $modalProvider;
  });

/* deprecated modal below */

angular.module('ui.bootstrap.modal')

  .value('$modalSuppressWarning', false)

  /**
   * A helper directive for the $modal service. It creates a backdrop element.
   */
  .directive('modalBackdrop', [
    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',
    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {
      var $animateCss = null;

      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }

      return {
        replace: true,
        templateUrl: 'template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };

      function linkFn(scope, element, attrs) {
        if (!$modalSuppressWarning) {
          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');
        }
        element.addClass('modal-backdrop');

        if (attrs.modalInClass) {
          if ($animateCss) {
            $animateCss(element, {
              addClass: attrs.modalInClass
            }).start();
          } else {
            $animate.addClass(element, attrs.modalInClass);
          }

          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if ($animateCss) {
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            } else {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            }
          });
        }
      }
    }])

  .directive('modalWindow', [
    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',
    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {
      var $animateCss = null;

      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }

      return {
        scope: {
          index: '@'
        },
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');
          }
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;

          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };

          // moved from template to fix issue #2280
          element.on('click', scope.close);

          // This property is only added to the scope for the purpose of detecting when this directive is rendered.
          // We can detect that by using this property in the template associated with this directive and then use
          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
          scope.$isRendered = true;

          // Deferred object that will be resolved when this modal is render.
          var modalRenderDeferObj = $q.defer();
          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
          attrs.$observe('modalRender', function(value) {
            if (value == 'true') {
              modalRenderDeferObj.resolve();
            }
          });

          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;

            if (attrs.modalInClass) {
              if ($animateCss) {
                animationPromise = $animateCss(element, {
                  addClass: attrs.modalInClass
                }).start();
              } else {
                animationPromise = $animate.addClass(element, attrs.modalInClass);
              }

              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                  $animateCss(element, {
                    removeClass: attrs.modalInClass
                  }).start().then(done);
                } else {
                  $animate.removeClass(element, attrs.modalInClass).then(done);
                }
              });
            }


            $q.when(animationPromise).then(function() {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              /**
               * Auto-focusing of a freshly-opened modal element causes any child elements
               * with the autofocus attribute to lose focus. This is an issue on touch
               * based devices which will show and then hide the onscreen keyboard.
               * Attempts to refocus the autofocus element via JavaScript will not reopen
               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
               * the modal element if the modal does not contain an autofocus element.
               */
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            });

            // Notify {@link $modalStack} that modal is rendered.
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }])

  .directive('modalAnimationClass', [
    '$log', '$modalSuppressWarning',
    function ($log, $modalSuppressWarning) {
      return {
        compile: function(tElement, tAttrs) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');
          }
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }
      };
    }])

  .directive('modalTransclude', [
    '$log', '$modalSuppressWarning',
    function ($log, $modalSuppressWarning) {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        if (!$modalSuppressWarning) {
          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');
        }
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  }])

  .service('$modalStack', [
    '$animate', '$timeout', '$document', '$compile', '$rootScope',
    '$q',
    '$injector',
    '$$multiMap',
    '$$stackedMap',
    '$uibModalStack',
    '$log',
    '$modalSuppressWarning',
    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
             $q,
             $injector,
             $$multiMap,
             $$stackedMap,
             $uibModalStack,
             $log,
             $modalSuppressWarning) {
      if (!$modalSuppressWarning) {
        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');
      }

      angular.extend(this, $uibModalStack);
    }])

  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {
    angular.extend(this, $uibModalProvider);

    this.$get = ['$injector', '$log', '$modalSuppressWarning',
      function ($injector, $log, $modalSuppressWarning) {
        if (!$modalSuppressWarning) {
          $log.warn('$modal is now deprecated. Use $uibModal instead.');
        }

        return $injector.invoke($uibModalProvider.$get);
      }];
  }]);

angular.module('ui.bootstrap.pagination', [])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch('totalItems', function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch('totalPages', function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page > value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if (evt) {
      evt.preventDefault();
    }

    var clickAllowed = !$scope.ngDisabled || !evt;
    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      if (evt && evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };

  $scope.noPrevious = function() {
    return $scope.page === 1;
  };

  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['uibPagination', '?ngModel'],
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pagination.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && ! rotate) {
          if (startPage > 1) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if (endPage < totalPages) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: ' Previous',
  nextText: 'Next ',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['uibPager', '?ngModel'],
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pager.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/* Deprecated Pagination Below */

angular.module('ui.bootstrap.pagination')
.value('$paginationSuppressWarning', false)
.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {
  if (!$paginationSuppressWarning) {
    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');
  }

  var self = this,
    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch('totalItems', function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch('totalPages', function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page > value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if (evt) {
      evt.preventDefault();
    }

    var clickAllowed = !$scope.ngDisabled || !evt;
    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      if (evt && evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };

  $scope.noPrevious = function() {
    return $scope.page === 1;
  };

  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])
.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['pagination', '?ngModel'],
    controller: 'PaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pagination.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      if (!$paginationSuppressWarning) {
        $log.warn('pagination is now deprecated. Use uib-pagination instead.');
      }
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && ! rotate) {
          if (startPage > 1) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if (endPage < totalPages) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['pager', '?ngModel'],
    controller: 'PaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pager.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      if (!$paginationSuppressWarning) {
        $log.warn('pager is now deprecated. Use uib-pager instead.');
      }
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function() {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0,
    popupCloseDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur',
    'none': ''
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
    var openedTooltips = $$stackedMap.createNew();
    $document.on('keypress', function(e) {
      if (e.which === 27) {
        var last = openedTooltips.top();
        if (last) {
          last.value.close();
          openedTooltips.removeTop();
          last = null;
        }
      }
    });

    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
      options = angular.extend({}, defaultOptions, globalOptions, options);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
        var hide = show.map(function(trigger) {
          return triggerMap[trigger] || trigger;
        });
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(ttType);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        '<div '+ directiveName + '-popup '+
          'title="' + startSym + 'title' + endSym + '" '+
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'placement="' + startSym + 'placement' + endSym + '" '+
          'popup-class="' + startSym + 'popupClass' + endSym + '" '+
          'animation="animation" ' +
          'is-open="isOpen"' +
          'origin-scope="origScope" ' +
          'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' +
          '>' +
        '</div>';

      return {
        compile: function(tElem, tAttrs) {
          var tooltipLinker = $compile(template);

          return function link(scope, element, attrs, tooltipCtrl) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var showTimeout;
            var hideTimeout;
            var positionTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
            var ttScope = scope.$new(true);
            var repositionScheduled = false;
            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
            var observers = [];

            var positionTooltip = function() {
              // check if tooltip exists and is not empty
              if (!tooltip || !tooltip.html()) { return; }

              if (!positionTimeout) {
                positionTimeout = $timeout(function() {
                  // Reset the positioning.
                  tooltip.css({ top: 0, left: 0 });

                  // Now set the calculated positioning.
                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  ttCss.top += 'px';
                  ttCss.left += 'px';
                  ttCss.visibility = 'visible';
                  tooltip.css(ttCss);

                  positionTimeout = null;
                }, 0, false);
              }
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;
            openedTooltips.add(ttScope, {
              close: hide
            });

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                return;
              }

              cancelHide();
              prepareTooltip();

              if (ttScope.popupDelay) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!showTimeout) {
                  showTimeout = $timeout(show, ttScope.popupDelay, false);
                }
              } else {
                show();
              }
            }

            function hideTooltipBind() {
              cancelShow();

              if (ttScope.popupCloseDelay) {
                if (!hideTimeout) {
                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                }
              } else {
                hide();
              }
            }

            // Show the tooltip popup element.
            function show() {
              cancelShow();
              cancelHide();

              // Don't show empty tooltips.
              if (!ttScope.content) {
                return angular.noop;
              }

              createTooltip();

              // And show the tooltip.
              ttScope.$evalAsync(function() {
                ttScope.isOpen = true;
                assignIsOpen(true);
                positionTooltip();
              });
            }

            function cancelShow() {
              if (showTimeout) {
                $timeout.cancel(showTimeout);
                showTimeout = null;
              }

              if (positionTimeout) {
                $timeout.cancel(positionTimeout);
                positionTimeout = null;
              }
            }

            // Hide the tooltip popup element.
            function hide() {
              cancelShow();
              cancelHide();

              if (!ttScope) {
                return;
              }

              // First things first: we don't show it anymore.
              ttScope.$evalAsync(function() {
                ttScope.isOpen = false;
                assignIsOpen(false);
                // And now we remove it from the DOM. However, if we have animation, we
                // need to wait for it to expire beforehand.
                // FIXME: this is a placeholder for a port of the transitions library.
                // The fade transition in TWBS is 150ms.
                if (ttScope.animation) {
                  if (!transitionTimeout) {
                    transitionTimeout = $timeout(removeTooltip, 150, false);
                  }
                } else {
                  removeTooltip();
                }
              });
            }

            function cancelHide() {
              if (hideTimeout) {
                $timeout.cancel(hideTimeout);
                hideTimeout = null;
              }
              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                return;
              }

              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });

              prepObservers();
            }

            function removeTooltip() {
              unregisterObservers();

              transitionTimeout = null;
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            /**
             * Set the inital scope values. Once
             * the tooltip is created, the observers
             * will be added to keep things in synch.
             */
            function prepareTooltip() {
              ttScope.title = attrs[prefix + 'Title'];
              if (contentParse) {
                ttScope.content = contentParse(scope);
              } else {
                ttScope.content = attrs[ttType];
              }

              ttScope.popupClass = attrs[prefix + 'Class'];
              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;

              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
            }

            function assignIsOpen(isOpen) {
              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                isOpenParse.assign(scope, isOpen);
              }
            }

            ttScope.contentExp = function() {
              return ttScope.content;
            };

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe('disabled', function(val) {
              if (val) {
                cancelShow();
              }

              if (val && ttScope.isOpen) {
                hide();
              }
            });

            if (isOpenParse) {
              scope.$watch(isOpenParse, function(val) {
                /*jshint -W018 */
                if (ttScope && !val === ttScope.isOpen) {
                  toggleTooltipBind();
                }
                /*jshint +W018 */
              });
            }

            function prepObservers() {
              observers.length = 0;

              if (contentParse) {
                observers.push(
                  scope.$watch(contentParse, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  })
                );

                observers.push(
                  tooltipLinkedScope.$watch(function() {
                    if (!repositionScheduled) {
                      repositionScheduled = true;
                      tooltipLinkedScope.$$postDigest(function() {
                        repositionScheduled = false;
                        if (ttScope && ttScope.isOpen) {
                          positionTooltip();
                        }
                      });
                    }
                  })
                );
              } else {
                observers.push(
                  attrs.$observe(ttType, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    } else {
                      positionTooltip();
                    }
                  })
                );
              }

              observers.push(
                attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );

              observers.push(
                attrs.$observe(prefix + 'Placement', function(val) {
                  ttScope.placement = val ? val : options.placement;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );
            }

            function unregisterObservers() {
              if (observers.length) {
                angular.forEach(observers, function(observer) {
                  observer();
                });
                observers.length = 0;
              }
            }

            var unregisterTriggers = function() {
              triggers.show.forEach(function(trigger) {
                element.unbind(trigger, showTooltipBind);
              });
              triggers.hide.forEach(function(trigger) {
                trigger.split(' ').forEach(function(hideTrigger) {
                  element[0].removeEventListener(hideTrigger, hideTooltipBind);
                });
              });
            };

            function prepTriggers() {
              var val = attrs[prefix + 'Trigger'];
              unregisterTriggers();

              triggers = getTriggers(val);

              if (triggers.show !== 'none') {
                triggers.show.forEach(function(trigger, idx) {
                  // Using raw addEventListener due to jqLite/jQuery bug - #4060
                  if (trigger === triggers.hide[idx]) {
                    element[0].addEventListener(trigger, toggleTooltipBind);
                  } else if (trigger) {
                    element[0].addEventListener(trigger, showTooltipBind);
                    triggers.hide[idx].split(' ').forEach(function(trigger) {
                      element[0].addEventListener(trigger, hideTooltipBind);
                    });
                  }

                  element.on('keypress', function(e) {
                    if (e.which === 27) {
                      hideTooltipBind();
                    }
                  });
                });
              }
            }

            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // if a tooltip is attached to <body> we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if (appendToBody) {
              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                if (ttScope.isOpen) {
                  hide();
                }
              });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              cancelShow();
              cancelHide();
              unregisterTriggers();
              removeTooltip();
              openedTooltips.remove(ttScope);
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate ,  $sce ,  $compile ,  $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }

        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }

        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', function() {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      if (scope.placement) {
        element.addClass(scope.placement);
      }

      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }

      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
})

.directive('uibTooltipPopup', function() {
  return {
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html',
    link: function(scope, element) {
      element.addClass('tooltip');
    }
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/tooltip/tooltip-template-popup.html',
    link: function(scope, element) {
      element.addClass('tooltip');
    }
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-popup.html',
    link: function(scope, element) {
      element.addClass('tooltip');
    }
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/* Deprecated tooltip below */

angular.module('ui.bootstrap.tooltip')

.value('$tooltipSuppressWarning', false)

.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {
  angular.extend(this, $uibTooltipProvider);

  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {
    if (!$tooltipSuppressWarning) {
      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');
    }

    return $injector.invoke($uibTooltipProvider.$get);
  }];
}])

// This is mostly ngInclude code but with a custom scope
.directive('tooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',
function ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {
  return {
    link: function(scope, elem, attrs) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');
      }

      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }
        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }
        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');
      }

      if (scope.placement) {
        element.addClass(scope.placement);
      }
      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }
      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
}])

.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html',
    link: function(scope, element) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');
      }

      element.addClass('tooltip');
    }
  };
}])

.directive('tooltip', ['$tooltip', function($tooltip) {
  return $tooltip('tooltip', 'tooltip', 'mouseenter');
}])

.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/tooltip/tooltip-template-popup.html',
    link: function(scope, element) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');
      }

      element.addClass('tooltip');
    }
  };
}])

.directive('tooltipTemplate', ['$tooltip', function($tooltip) {
  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-popup.html',
    link: function(scope, element) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');
      }

      element.addClass('tooltip');
    }
  };
}])

.directive('tooltipHtml', ['$tooltip', function($tooltip) {
  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
    replace: true,
    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/popover/popover-template.html',
    link: function(scope, element) {
      element.addClass('popover');
    }
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover-html.html',
    link: function(scope, element) {
      element.addClass('popover');
    }
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
    replace: true,
    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html',
    link: function(scope, element) {
      element.addClass('popover');
    }
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

/* Deprecated popover below */

angular.module('ui.bootstrap.popover')

.value('$popoverSuppressWarning', false)

.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
  return {
    replace: true,
    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/popover/popover-template.html',
    link: function(scope, element) {
      if (!$popoverSuppressWarning) {
        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');
      }

      element.addClass('popover');
    }
  };
}])

.directive('popoverTemplate', ['$tooltip', function($tooltip) {
  return $tooltip('popoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
  return {
    replace: true,
    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover-html.html',
    link: function(scope, element) {
      if (!$popoverSuppressWarning) {
        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');
      }

      element.addClass('popover');
    }
  };
}])

.directive('popoverHtml', ['$tooltip', function($tooltip) {
  return $tooltip('popoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
  return {
    replace: true,
    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html',
    link: function(scope, element) {
      if (!$popoverSuppressWarning) {
        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');
      }

      element.addClass('popover');
    }
  };
}])

.directive('popover', ['$tooltip', function($tooltip) {

  return $tooltip('popover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = $scope.max;
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      var totalPercentage = self.bars.reduce(function(total, bar) {
        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
    this.bars.forEach(function (bar) {
      bar.recalculatePercentage();
    });
  };

  $scope.$watch('max', function(max) {
    self.bars.forEach(function(bar) {
      bar.max = $scope.max;
      bar.recalculatePercentage();
    });
  });
}])

.directive('uibProgress', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    require: 'uibProgress',
    scope: {
      max: '=?'
    },
    templateUrl: 'template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
    replace: true,
    transclude: true,
    require: '^uibProgress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element, attrs);
    }
  };
})

.directive('uibProgressbar', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    scope: {
      value: '=',
      max: '=?',
      type: '@'
    },
    templateUrl: 'template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
});

/* Deprecated progressbar below */

angular.module('ui.bootstrap.progressbar')

.value('$progressSuppressWarning', false)

.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {
  if (!$progressSuppressWarning) {
    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');
  }

  var self = this,
    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = $scope.max;
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      bar.percent = +(100 * bar.value / bar.max).toFixed(2);

      var totalPercentage = self.bars.reduce(function(total, bar) {
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
  };

  $scope.$watch('max', function(max) {
    self.bars.forEach(function(bar) {
      bar.max = $scope.max;
      bar.recalculatePercentage();
    });
  });
}])

.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    controller: 'ProgressController',
    require: 'progress',
    scope: {
      max: '=?',
      title: '@?'
    },
    templateUrl: 'template/progressbar/progress.html',
    link: function() {
      if (!$progressSuppressWarning) {
        $log.warn('progress is now deprecated. Use uib-progress instead.');
      }
    }
  };
}])

.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    require: '^progress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      if (!$progressSuppressWarning) {
        $log.warn('bar is now deprecated. Use uib-bar instead.');
      }
      progressCtrl.addBar(scope, element);
    }
  };
}])

.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    controller: 'ProgressController',
    scope: {
      value: '=',
      max: '=?',
      type: '@'
    },
    templateUrl: 'template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      if (!$progressSuppressWarning) {
        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');
      }
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
}]);

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  titles : ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl  = { $setViewValue: angular.noop };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) && value << 0 !== value) {
        value = Math.round(value);
      }
      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;
    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
      tmpTitles : ratingConfig.titles;

    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };

  this.getTitle = function(index) {
    if (index >= this.titles.length) {
      return index + 1;
    } else {
      return this.titles[index];
    }
  };

  $scope.rate = function(value) {
    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
  };
}])

.directive('uibRating', function() {
  return {
    require: ['uibRating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'UibRatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
});

/* Deprecated rating below */

angular.module('ui.bootstrap.rating')

.value('$ratingSuppressWarning', false)

.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {
  if (!$ratingSuppressWarning) {
    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');
  }

  angular.extend(this, $controller('UibRatingController', {
    $scope: $scope,
    $attrs: $attrs
  }));
}])

.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {
  return {
    require: ['rating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      if (!$ratingSuppressWarning) {
        $log.warn('rating is now deprecated. Use uib-rating instead.');
      }
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
}]);


/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active && tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
        selectedTab.selectCalled = false;
      }
    });
    selectedTab.active = true;
    // only call select if it has not already been called
    if (!selectedTab.selectCalled) {
      selectedTab.onSelect();
      selectedTab.selectCalled = true;
    }
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can't run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1 && tab.active !== false) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    } else {
      tab.active = false;
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active && tabs.length > 1 && !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <uib-tabset>
      <uib-tab heading="Tab 1"><b>First</b> Content!</uib-tab>
      <uib-tab heading="Tab 2"><i>Second</i> Content!</uib-tab>
    </uib-tabset>
    <hr />
    <uib-tabset vertical="true">
      <uib-tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</uib-tab>
      <uib-tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</uib-tab>
    </uib-tabset>
    <uib-tabset justified="true">
      <uib-tab heading="Justified Tab 1"><b>First</b> Justified Content!</uib-tab>
      <uib-tab heading="Justified Tab 2"><i>Second</i> Justified Content!</uib-tab>
    </uib-tabset>
  </file>
</example>
 */
.directive('uibTabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {
      type: '@'
    },
    controller: 'UibTabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <uib-tabset>
        <uib-tab heading="Tab 1">First Tab</uib-tab>
        <uib-tab select="alertMe()">
          <uib-tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </uib-tab>
        <uib-tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </uib-tab>
      </uib-tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <uib-tabset>
      <uib-tab>
        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </uib-tab>
      <uib-tab>
        <uib-tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </uib-tab>
    </uib-tabset>
  </file>
</example>
 */
.directive('uibTab', ['$parse', function($parse) {
  return {
    require: '^uibTabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      active: '=?',
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.$watch('active', function(active) {
        if (active) {
          tabsetCtrl.select(scope);
        }
      });

      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      scope.select = function() {
        if (!scope.disabled) {
          scope.active = true;
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we're inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal
    link: function(scope, elm) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('uibTabContentTransclude', function() {
  return {
    restrict: 'A',
    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.uibTabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName && (
      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal
      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal
      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal
      node.hasAttribute('uib-tab-heading') ||
      node.hasAttribute('data-uib-tab-heading') ||
      node.hasAttribute('x-uib-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal
      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal
      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal
      node.tagName.toLowerCase() === 'uib-tab-heading' ||
      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'x-uib-tab-heading'
    );
  }
});

/* deprecated tabs below */

angular.module('ui.bootstrap.tabs')

  .value('$tabsSuppressWarning', false)

  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {
    if (!$tabsSuppressWarning) {
      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');
    }

    angular.extend(this, $controller('UibTabsetController', {
      $scope: $scope
    }));
  }])

  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
    return {
      restrict: 'EA',
      transclude: true,
      replace: true,
      scope: {
        type: '@'
      },
      controller: 'TabsetController',
      templateUrl: 'template/tabs/tabset.html',
      link: function(scope, element, attrs) {

        if (!$tabsSuppressWarning) {
          $log.warn('tabset is now deprecated. Use uib-tabset instead.');
        }
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
      }
    };
  }])

  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {
    return {
      require: '^tabset',
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/tabs/tab.html',
      transclude: true,
      scope: {
        active: '=?',
        heading: '@',
        onSelect: '&select', //This callback is called in contentHeadingTransclude
        //once it inserts the tab's content into the dom
        onDeselect: '&deselect'
      },
      controller: function() {
        //Empty controller so other directives can require being 'under' a tab
      },
      link: function(scope, elm, attrs, tabsetCtrl, transclude) {
        if (!$tabsSuppressWarning) {
          $log.warn('tab is now deprecated. Use uib-tab instead.');
        }

        scope.$watch('active', function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });

        scope.disabled = false;
        if (attrs.disable) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !!value;
          });
        }

        scope.select = function() {
          if (!scope.disabled) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });

        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      }
    };
  }])

  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
    return {
      restrict: 'A',
      require: '^tab',
      link: function(scope, elm) {
        if (!$tabsSuppressWarning) {
          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');
        }

        scope.$watch('headingElement', function updateHeadingElement(heading) {
          if (heading) {
            elm.html('');
            elm.append(heading);
          }
        });
      }
    };
  }])

  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
    return {
      restrict: 'A',
      require: '^tabset',
      link: function(scope, elm, attrs) {
        if (!$tabsSuppressWarning) {
          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');
        }

        var tab = scope.$eval(attrs.tabContentTransclude);

        //Now our tab is ready to be transcluded: both the tab heading area
        //and the tab content area are loaded.  Transclude 'em both.
        tab.$transcludeFn(tab.$parent, function(contents) {
          angular.forEach(contents, function(node) {
            if (isTabHeading(node)) {
              //Let tabHeadingTransclude know.
              tab.headingElement = node;
            }
            else {
              elm.append(node);
            }
          });
        });
      }
    };

    function isTabHeading(node) {
      return node.tagName && (
          node.hasAttribute('tab-heading') ||
          node.hasAttribute('data-tab-heading') ||
          node.hasAttribute('x-tab-heading') ||
          node.tagName.toLowerCase() === 'tab-heading' ||
          node.tagName.toLowerCase() === 'data-tab-heading' ||
          node.tagName.toLowerCase() === 'x-tab-heading'
        );
    }
  }]);

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = parseInt(value, 10);
    });
  }

  var min;
  $scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  });

  var max;
  $scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  });

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return incrementedSelected > max ||
      (incrementedSelected < selected && incrementedSelected < min);
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return decrementedSelected < min ||
      (decrementedSelected > selected && decrementedSelected > max);
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return incrementedSelected > max ||
      (incrementedSelected < selected && incrementedSelected < min);
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return decrementedSelected < min ||
      (decrementedSelected > selected && decrementedSelected > max);
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() < 13) {
      return addMinutes(selected, 12 * 60) > max;
    } else {
      return addMinutes(selected, -12 * 60) < min;
    }
  };

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = parseInt($scope.hours, 10);
    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
    if (!valid) {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return (minutes >= 0 && minutes < 60) ? minutes : undefined;
  }

  function pad(value) {
    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
      return (e.detail || delta > 0);
    };

    hoursInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      e.preventDefault();
    });

  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
    hoursInputEl.bind('keydown', function(e) {
      if (e.which === 38) { // up
        e.preventDefault();
        $scope.incrementHours();
        $scope.$apply();
      } else if (e.which === 40) { // down
        e.preventDefault();
        $scope.decrementHours();
        $scope.$apply();
      }
    });

    minutesInputEl.bind('keydown', function(e) {
      if (e.which === 38) { // up
        e.preventDefault();
        $scope.incrementMinutes();
        $scope.$apply();
      } else if (e.which === 40) { // down
        e.preventDefault();
        $scope.decrementMinutes();
        $scope.$apply();
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
        selected.setHours(hours);
        if (selected < min || selected > max) {
          invalidate(true);
        } else {
          refresh('h');
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function(e) {
      if (!$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(undefined, true);
        } else {
          refresh('m');
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function(e) {
      if (!$scope.invalidMinutes && $scope.minutes < 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }

      if (selected < min || selected > max) {
        ngModelCtrl.$setValidity('time', false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate(keyboardChange) {
    var hours = selected.getHours(), minutes = selected.getMinutes();

    if ($scope.showMeridian) {
      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
    if (keyboardChange !== 'm') {
      $scope.minutes = pad(minutes);
    }
    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
  }

  function addMinutes(date, minutes) {
    var dt = new Date(date.getTime() + minutes * 60000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes());
    return newDate;
  }

  function addMinutesToSelected(minutes) {
    selected = addMinutes(selected, minutes);
    refresh();
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addMinutesToSelected(hourStep * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addMinutesToSelected(-hourStep * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addMinutesToSelected(minuteStep);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addMinutesToSelected(-minuteStep);
    }
  };

  $scope.toggleMeridian = function() {
    if (!$scope.noToggleMeridian()) {
      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
    }
  };
}])

.directive('uibTimepicker', function() {
  return {
    restrict: 'EA',
    require: ['uibTimepicker', '?^ngModel'],
    controller: 'UibTimepickerController',
    controllerAs: 'timepicker',
    replace: true,
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/timepicker/timepicker.html';
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
});

/* Deprecated timepicker below */

angular.module('ui.bootstrap.timepicker')

.value('$timepickerSuppressWarning', false)

.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {
  if (!$timepickerSuppressWarning) {
    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');
  }

  angular.extend(this, $controller('UibTimepickerController', {
    $scope: $scope,
    $element: $element,
    $attrs: $attrs
  }));
}])

.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {
  return {
    restrict: 'EA',
    require: ['timepicker', '?^ngModel'],
    controller: 'TimepickerController',
    controllerAs: 'timepicker',
    replace: true,
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/timepicker/timepicker.html';
    },
    link: function(scope, element, attrs, ctrls) {
      if (!$timepickerSuppressWarning) {
        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');
      }
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    //                      00000111000000000000022200000000000000003333333333333330000000000044000
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
              ' but got "' + input + '".');
        }

        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    var modelCtrl, ngModelOptions;
    //SUPPORTED ATTRIBUTES (OPTIONS)

    //minimal no of characters that needs to be entered before typeahead kicks-in
    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
    if (!minLength && minLength !== 0) {
      minLength = 1;
    }

    //minimal wait time after last character typed before typeahead kicks-in
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

    //should it restrict model values to the ones selected from the popup only?
    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

    //binding to a variable that indicates if matches are being retrieved asynchronously
    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

    //a callback executed when a match is selected
    var onSelectCallback = $parse(attrs.typeaheadOnSelect);

    //should it select highlighted popup value when losing focus?
    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

    //binding to a variable that indicates if there were no results after the query is completed
    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

    var appendToElementId =  attrs.typeaheadAppendToElementId || false;

    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

    //If input matches an item of the list exactly, select it automatically
    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

    //INTERNAL VARIABLES

    //model setter executed upon match selection
    var parsedModel = $parse(attrs.ngModel);
    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
    var $setModelValue = function(scope, newValue) {
      if (angular.isFunction(parsedModel(originalScope)) &&
        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
        return invokeModelSetter(scope, {$$$p: newValue});
      } else {
        return parsedModel.assign(scope, newValue);
      }
    };

    //expressions used by typeahead
    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

    var hasFocus;

    //Used to avoid bug in iOS webview where iOS keyboard does not fire
    //mousedown & mouseup events
    //Issue #3699
    var selected;

    //create a child scope for the typeahead directive so we are not polluting original scope
    //with typeahead-specific data (matches, query etc.)
    var scope = originalScope.$new();
    var offDestroy = originalScope.$on('$destroy', function() {
      scope.$destroy();
    });
    scope.$on('$destroy', offDestroy);

    // WAI-ARIA
    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
    element.attr({
      'aria-autocomplete': 'list',
      'aria-expanded': false,
      'aria-owns': popupId
    });

    //pop-up element used to display matches
    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
    popUpEl.attr({
      id: popupId,
      matches: 'matches',
      active: 'activeIdx',
      select: 'select(activeIdx)',
      'move-in-progress': 'moveInProgress',
      query: 'query',
      position: 'position'
    });
    //custom item template
    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
    }

    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
    }

    var resetMatches = function() {
      scope.matches = [];
      scope.activeIdx = -1;
      element.attr('aria-expanded', false);
    };

    var getMatchId = function(index) {
      return popupId + '-option-' + index;
    };

    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
    // This attribute is added or removed automatically when the `activeIdx` changes.
    scope.$watch('activeIdx', function(index) {
      if (index < 0) {
        element.removeAttr('aria-activedescendant');
      } else {
        element.attr('aria-activedescendant', getMatchId(index));
      }
    });

    var inputIsExactMatch = function(inputValue, index) {
      if (scope.matches.length > index && inputValue) {
        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
      }

      return false;
    };

    var getMatchesAsync = function(inputValue) {
      var locals = {$viewValue: inputValue};
      isLoadingSetter(originalScope, true);
      isNoResultsSetter(originalScope, false);
      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
        //it might happen that several async queries were in progress if a user were typing fast
        //but we are interested only in responses that correspond to the current view value
        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
        if (onCurrentRequest && hasFocus) {
          if (matches && matches.length > 0) {
            scope.activeIdx = focusFirst ? 0 : -1;
            isNoResultsSetter(originalScope, false);
            scope.matches.length = 0;

            //transform labels
            for (var i = 0; i < matches.length; i++) {
              locals[parserResult.itemName] = matches[i];
              scope.matches.push({
                id: getMatchId(i),
                label: parserResult.viewMapper(scope, locals),
                model: matches[i]
              });
            }

            scope.query = inputValue;
            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
            //due to other elements being rendered
            recalculatePosition();

            element.attr('aria-expanded', true);

            //Select the single remaining option if user input matches
            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
              scope.select(0);
            }
          } else {
            resetMatches();
            isNoResultsSetter(originalScope, true);
          }
        }
        if (onCurrentRequest) {
          isLoadingSetter(originalScope, false);
        }
      }, function() {
        resetMatches();
        isLoadingSetter(originalScope, false);
        isNoResultsSetter(originalScope, true);
      });
    };

    // bind events only if appendToBody params exist - performance feature
    if (appendToBody) {
      angular.element($window).bind('resize', fireRecalculating);
      $document.find('body').bind('scroll', fireRecalculating);
    }

    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
    var timeoutEventPromise;

    // Default progress type
    scope.moveInProgress = false;

    function fireRecalculating() {
      if (!scope.moveInProgress) {
        scope.moveInProgress = true;
        scope.$digest();
      }

      // Cancel previous timeout
      if (timeoutEventPromise) {
        $timeout.cancel(timeoutEventPromise);
      }

      // Debounced executing recalculate after events fired
      timeoutEventPromise = $timeout(function() {
        // if popup is visible
        if (scope.matches.length) {
          recalculatePosition();
        }

        scope.moveInProgress = false;
      }, eventDebounceTime);
    }

    // recalculate actual position and set new values to scope
    // after digest loop is popup in right position
    function recalculatePosition() {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top += element.prop('offsetHeight');
    }

    //we need to propagate user's query so we can higlight matches
    scope.query = undefined;

    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
    var timeoutPromise;

    var scheduleSearchWithTimeout = function(inputValue) {
      timeoutPromise = $timeout(function() {
        getMatchesAsync(inputValue);
      }, waitTime);
    };

    var cancelPreviousTimeout = function() {
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }
    };

    resetMatches();

    scope.select = function(activeIdx) {
      //called from within the $digest() cycle
      var locals = {};
      var model, item;

      selected = true;
      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
      model = parserResult.modelMapper(originalScope, locals);
      $setModelValue(originalScope, model);
      modelCtrl.$setValidity('editable', true);
      modelCtrl.$setValidity('parse', true);

      onSelectCallback(originalScope, {
        $item: item,
        $model: model,
        $label: parserResult.viewMapper(originalScope, locals)
      });

      resetMatches();

      //return focus to the input element if a match was selected via a mouse click event
      // use timeout to avoid $rootScope:inprog error
      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
        $timeout(function() { element[0].focus(); }, 0, false);
      }
    };

    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
    element.bind('keydown', function(evt) {
      //typeahead is open and an "interesting" key was pressed
      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
        return;
      }

      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
        resetMatches();
        scope.$digest();
        return;
      }

      evt.preventDefault();

      if (evt.which === 40) {
        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
        scope.$digest();
      } else if (evt.which === 38) {
        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
        scope.$digest();
      } else if (evt.which === 13 || evt.which === 9) {
        scope.$apply(function () {
          scope.select(scope.activeIdx);
        });
      } else if (evt.which === 27) {
        evt.stopPropagation();

        resetMatches();
        scope.$digest();
      }
    });

    element.bind('blur', function() {
      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
        selected = true;
        scope.$apply(function() {
          scope.select(scope.activeIdx);
        });
      }
      hasFocus = false;
      selected = false;
    });

    // Keep reference to click handler to unbind it.
    var dismissClickHandler = function(evt) {
      // Issue #3973
      // Firefox treats right click as a click on document
      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
        resetMatches();
        if (!$rootScope.$$phase) {
          scope.$digest();
        }
      }
    };

    $document.bind('click', dismissClickHandler);

    originalScope.$on('$destroy', function() {
      $document.unbind('click', dismissClickHandler);
      if (appendToBody || appendToElementId) {
        $popup.remove();
      }

      if (appendToBody) {
        angular.element($window).unbind('resize', fireRecalculating);
        $document.find('body').unbind('scroll', fireRecalculating);
      }
      // Prevent jQuery cache memory leak
      popUpEl.remove();
    });

    var $popup = $compile(popUpEl)(scope);

    if (appendToBody) {
      $document.find('body').append($popup);
    } else if (appendToElementId !== false) {
      angular.element($document[0].getElementById(appendToElementId)).append($popup);
    } else {
      element.after($popup);
    }

    this.init = function(_modelCtrl, _ngModelOptions) {
      modelCtrl = _modelCtrl;
      ngModelOptions = _ngModelOptions;

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function(inputValue) {
        hasFocus = true;

        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return null;
          } else {
            modelCtrl.$setValidity('editable', false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function(modelValue) {
        var candidateViewValue, emptyViewValue;
        var locals = {};

        // The validity may be set to false via $parsers (see above) if
        // the model is restricted to selected values. If the model
        // is set manually it is considered to be valid.
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }

        if (inputFormatter) {
          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        } else {
          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        }
      });
    };
  }])

  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[2].init(ctrls[0], ctrls[1]);
      }
    };
  })

  .directive('uibTypeaheadPopup', function() {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          return scope.matches.length > 0;
        };

        scope.isActive = function(matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link:function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement) {
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is "a" the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
      }
      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }
      return matchItem;
    };
  }]);

/* Deprecated typeahead below */
  
angular.module('ui.bootstrap.typeahead')
  .value('$typeaheadSuppressWarning', false)
  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {
    if (!$typeaheadSuppressWarning) {
      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');
    }

    return uibTypeaheadParser;
  }])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',
    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    return {
      require: ['ngModel', '^?ngModelOptions'],
      link: function(originalScope, element, attrs, ctrls) {
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');
        }
        var modelCtrl = ctrls[0];
        var ngModelOptions = ctrls[1];
        //SUPPORTED ATTRIBUTES (OPTIONS)

        //minimal no of characters that needs to be entered before typeahead kicks-in
        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
        if (!minLength && minLength !== 0) {
          minLength = 1;
        }

        //minimal wait time after last character typed before typeahead kicks-in
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

        //should it restrict model values to the ones selected from the popup only?
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

        //binding to a variable that indicates if matches are being retrieved asynchronously
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

        //a callback executed when a match is selected
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);

        //should it select highlighted popup value when losing focus?
        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

        //binding to a variable that indicates if there were no results after the query is completed
        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

        var appendToElementId =  attrs.typeaheadAppendToElementId || false;

        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

        //If input matches an item of the list exactly, select it automatically
        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

        //INTERNAL VARIABLES

        //model setter executed upon match selection
        var parsedModel = $parse(attrs.ngModel);
        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
        var $setModelValue = function(scope, newValue) {
          if (angular.isFunction(parsedModel(originalScope)) &&
            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
            return invokeModelSetter(scope, {$$$p: newValue});
          } else {
            return parsedModel.assign(scope, newValue);
          }
        };

        //expressions used by typeahead
        var parserResult = typeaheadParser.parse(attrs.typeahead);

        var hasFocus;

        //Used to avoid bug in iOS webview where iOS keyboard does not fire
        //mousedown & mouseup events
        //Issue #3699
        var selected;

        //create a child scope for the typeahead directive so we are not polluting original scope
        //with typeahead-specific data (matches, query etc.)
        var scope = originalScope.$new();
        var offDestroy = originalScope.$on('$destroy', function() {
			    scope.$destroy();
        });
        scope.$on('$destroy', offDestroy);

        // WAI-ARIA
        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        element.attr({
          'aria-autocomplete': 'list',
          'aria-expanded': false,
          'aria-owns': popupId
        });

        //pop-up element used to display matches
        var popUpEl = angular.element('<div typeahead-popup></div>');
        popUpEl.attr({
          id: popupId,
          matches: 'matches',
          active: 'activeIdx',
          select: 'select(activeIdx)',
          'move-in-progress': 'moveInProgress',
          query: 'query',
          position: 'position'
        });
        //custom item template
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
        }

        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
        }

        var resetMatches = function() {
          scope.matches = [];
          scope.activeIdx = -1;
          element.attr('aria-expanded', false);
        };

        var getMatchId = function(index) {
          return popupId + '-option-' + index;
        };

        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
        // This attribute is added or removed automatically when the `activeIdx` changes.
        scope.$watch('activeIdx', function(index) {
          if (index < 0) {
            element.removeAttr('aria-activedescendant');
          } else {
            element.attr('aria-activedescendant', getMatchId(index));
          }
        });

        var inputIsExactMatch = function(inputValue, index) {
          if (scope.matches.length > index && inputValue) {
            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
          }

          return false;
        };

        var getMatchesAsync = function(inputValue) {
          var locals = {$viewValue: inputValue};
          isLoadingSetter(originalScope, true);
          isNoResultsSetter(originalScope, false);
          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            //it might happen that several async queries were in progress if a user were typing fast
            //but we are interested only in responses that correspond to the current view value
            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
            if (onCurrentRequest && hasFocus) {
              if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1;
                isNoResultsSetter(originalScope, false);
                scope.matches.length = 0;

                //transform labels
                for (var i = 0; i < matches.length; i++) {
                  locals[parserResult.itemName] = matches[i];
                  scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                  });
                }

                scope.query = inputValue;
                //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                //due to other elements being rendered
                recalculatePosition();

                element.attr('aria-expanded', true);

                //Select the single remaining option if user input matches
                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                  scope.select(0);
                }
              } else {
                resetMatches();
                isNoResultsSetter(originalScope, true);
              }
            }
            if (onCurrentRequest) {
              isLoadingSetter(originalScope, false);
            }
          }, function() {
            resetMatches();
            isLoadingSetter(originalScope, false);
            isNoResultsSetter(originalScope, true);
          });
        };

        // bind events only if appendToBody params exist - performance feature
        if (appendToBody) {
          angular.element($window).bind('resize', fireRecalculating);
          $document.find('body').bind('scroll', fireRecalculating);
        }

        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutEventPromise;

        // Default progress type
        scope.moveInProgress = false;

        function fireRecalculating() {
          if (!scope.moveInProgress) {
            scope.moveInProgress = true;
            scope.$digest();
          }

          // Cancel previous timeout
          if (timeoutEventPromise) {
            $timeout.cancel(timeoutEventPromise);
          }

          // Debounced executing recalculate after events fired
          timeoutEventPromise = $timeout(function() {
            // if popup is visible
            if (scope.matches.length) {
              recalculatePosition();
            }

            scope.moveInProgress = false;
          }, eventDebounceTime);
        }

        // recalculate actual position and set new values to scope
        // after digest loop is popup in right position
        function recalculatePosition() {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top += element.prop('offsetHeight');
        }

        resetMatches();

        //we need to propagate user's query so we can higlight matches
        scope.query = undefined;

        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutPromise;

        var scheduleSearchWithTimeout = function(inputValue) {
          timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
          }, waitTime);
        };

        var cancelPreviousTimeout = function() {
          if (timeoutPromise) {
            $timeout.cancel(timeoutPromise);
          }
        };

        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;

          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }

          if (isEditable) {
            return inputValue;
          } else {
            if (!inputValue) {
              // Reset in case user had typed something previously.
              modelCtrl.$setValidity('editable', true);
              return null;
            } else {
              modelCtrl.$setValidity('editable', false);
              return undefined;
            }
          }
        });

        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};

          // The validity may be set to false via $parsers (see above) if
          // the model is restricted to selected values. If the model
          // is set manually it is considered to be valid.
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }

          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          } else {
            //it might happen that we don't have enough info to properly render input value
            //we need to check for this situation and simply return model value if we can't apply custom formatting
            locals[parserResult.itemName] = modelValue;
            candidateViewValue = parserResult.viewMapper(originalScope, locals);
            locals[parserResult.itemName] = undefined;
            emptyViewValue = parserResult.viewMapper(originalScope, locals);

            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
          }
        });

        scope.select = function(activeIdx) {
          //called from within the $digest() cycle
          var locals = {};
          var model, item;

          selected = true;
          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
          model = parserResult.modelMapper(originalScope, locals);
          $setModelValue(originalScope, model);
          modelCtrl.$setValidity('editable', true);
          modelCtrl.$setValidity('parse', true);

          onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals)
          });

          resetMatches();

          //return focus to the input element if a match was selected via a mouse click event
          // use timeout to avoid $rootScope:inprog error
          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
            $timeout(function() { element[0].focus(); }, 0, false);
          }
        };

        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
        element.bind('keydown', function(evt) {
          //typeahead is open and an "interesting" key was pressed
          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
            return;
          }

          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
            resetMatches();
            scope.$digest();
            return;
          }

          evt.preventDefault();

          if (evt.which === 40) {
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
          } else if (evt.which === 38) {
            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
          } else if (evt.which === 13 || evt.which === 9) {
            scope.$apply(function () {
              scope.select(scope.activeIdx);
            });
          } else if (evt.which === 27) {
            evt.stopPropagation();

            resetMatches();
            scope.$digest();
          }
        });

        element.bind('blur', function() {
          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
            selected = true;
            scope.$apply(function() {
              scope.select(scope.activeIdx);
            });
          }
          hasFocus = false;
          selected = false;
        });

        // Keep reference to click handler to unbind it.
        var dismissClickHandler = function(evt) {
          // Issue #3973
          // Firefox treats right click as a click on document
          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
            resetMatches();
            if (!$rootScope.$$phase) {
              scope.$digest();
            }
          }
        };

        $document.bind('click', dismissClickHandler);

        originalScope.$on('$destroy', function() {
          $document.unbind('click', dismissClickHandler);
          if (appendToBody || appendToElementId) {
            $popup.remove();
          }

          if (appendToBody) {
            angular.element($window).unbind('resize', fireRecalculating);
            $document.find('body').unbind('scroll', fireRecalculating);
          }
          // Prevent jQuery cache memory leak
          popUpEl.remove();
        });

        var $popup = $compile(popUpEl)(scope);

        if (appendToBody) {
          $document.find('body').append($popup);
        } else if (appendToElementId !== false) {
          angular.element($document[0].getElementById(appendToElementId)).append($popup);
        } else {
          element.after($popup);
        }
      }
    };
  }])
  
  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');
        }
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          return scope.matches.length > 0;
        };

        scope.isActive = function(matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  }])
  
  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {
    return {
      restrict: 'EA',
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link:function(scope, element, attrs) {
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');
        }

        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement) {
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])
  
  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is "a" the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!$typeaheadSuppressWarning) {
        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');
      }

      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
      }

      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }

      return matchItem;
    };
  }]);
!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');if(typeof module!=='undefined')module.exports='ui.bootstrap';
/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.14.3 - 2015-10-23
 * License: MIT
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.stackedMap","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-popup.html","template/tooltip/tooltip-popup.html","template/tooltip/tooltip-template-popup.html","template/popover/popover-html.html","template/popover/popover-template.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('uibCollapse', ['$animate', '$injector', function($animate, $injector) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        function expand() {
          element.removeClass('collapse')
            .addClass('collapsing')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false);

          if ($animateCss) {
            $animateCss(element, {
              addClass: 'in',
              easing: 'ease',
              to: { height: element[0].scrollHeight + 'px' }
            }).start().finally(expandDone);
          } else {
            $animate.addClass(element, 'in', {
              to: { height: element[0].scrollHeight + 'px' }
            }).then(expandDone);
          }
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse')
            .css({height: 'auto'});
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          element
            // IMPORTANT: The height must be set before adding "collapsing" class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + 'px'})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass('collapse')
            .addClass('collapsing')
            .attr('aria-expanded', false)
            .attr('aria-hidden', true);

          if ($animateCss) {
            $animateCss(element, {
              removeClass: 'in',
              to: {height: '0'}
            }).start().finally(collapseDone);
          } else {
            $animate.removeClass(element, 'in', {
              to: {height: '0'}
            }).then(collapseDone);
          }
        }

        function collapseDone() {
          element.css({height: '0'}); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
        }

        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

/* Deprecated collapse below */

angular.module('ui.bootstrap.collapse')

  .value('$collapseSuppressWarning', false)

  .directive('collapse', ['$animate', '$injector', '$log', '$collapseSuppressWarning', function($animate, $injector, $log, $collapseSuppressWarning) {
    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
    return {
      link: function(scope, element, attrs) {
        if (!$collapseSuppressWarning) {
          $log.warn('collapse is now deprecated. Use uib-collapse instead.');
        }

        function expand() {
          element.removeClass('collapse')
            .addClass('collapsing')
            .attr('aria-expanded', true)
            .attr('aria-hidden', false);

          if ($animateCss) {
            $animateCss(element, {
              easing: 'ease',
              to: { height: element[0].scrollHeight + 'px' }
            }).start().done(expandDone);
          } else {
            $animate.animate(element, {}, {
              height: element[0].scrollHeight + 'px'
            }).then(expandDone);
          }
        }

        function expandDone() {
          element.removeClass('collapsing')
            .addClass('collapse in')
            .css({height: 'auto'});
        }

        function collapse() {
          if (!element.hasClass('collapse') && !element.hasClass('in')) {
            return collapseDone();
          }

          element
            // IMPORTANT: The height must be set before adding "collapsing" class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + 'px'})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass('collapse in')
            .addClass('collapsing')
            .attr('aria-expanded', false)
            .attr('aria-hidden', true);

          if ($animateCss) {
            $animateCss(element, {
              to: {height: '0'}
            }).start().done(collapseDone);
          } else {
            $animate.animate(element, {}, {
              height: '0'
            }).then(collapseDone);
          }
        }

        function collapseDone() {
          element.css({height: '0'}); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing')
            .addClass('collapse');
        }

        scope.$watch(attrs.collapse, function(shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('uibAccordionConfig', {
  closeOthers: true
})

.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {
  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ?
      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if (closeOthers) {
      angular.forEach(this.groups, function(group) {
        if (group !== openGroup) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function(event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if (index !== -1) {
      this.groups.splice(index, 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('uibAccordion', function() {
  return {
    controller: 'UibAccordionController',
    controllerAs: 'accordion',
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/accordion/accordion.html';
    }
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('uibAccordionGroup', function() {
  return {
    require: '^uibAccordion',         // We need this directive to be inside an accordion
    transclude: true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/accordion/accordion-group.html';
    },
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.openClass = attrs.openClass || 'panel-open';
      scope.panelClass = attrs.panelClass;
      scope.$watch('isOpen', function(value) {
        element.toggleClass(scope.openClass, !!value);
        if (value) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function($event) {
        if (!scope.isDisabled) {
          if (!$event || $event.which === 32) {
            scope.isOpen = !scope.isOpen;
          }
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
.directive('uibAccordionHeading', function() {
  return {
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^uibAccordionGroup',
    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
.directive('uibAccordionTransclude', function() {
  return {
    require: ['?^uibAccordionGroup', '?^accordionGroup'],
    link: function(scope, element, attrs, controller) {
      controller = controller[0] ? controller[0] : controller[1]; // Delete after we remove deprecation
      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {
        if (heading) {
          element.find('span').html('');
          element.find('span').append(heading);
        }
      });
    }
  };
});

/* Deprecated accordion below */

angular.module('ui.bootstrap.accordion')

  .value('$accordionSuppressWarning', false)

  .controller('AccordionController', ['$scope', '$attrs', '$controller', '$log', '$accordionSuppressWarning', function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {
    if (!$accordionSuppressWarning) {
      $log.warn('AccordionController is now deprecated. Use UibAccordionController instead.');
    }

    angular.extend(this, $controller('UibAccordionController', {
      $scope: $scope,
      $attrs: $attrs
    }));
  }])

  .directive('accordion', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      restrict: 'EA',
      controller: 'AccordionController',
      controllerAs: 'accordion',
      transclude: true,
      replace: false,
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'template/accordion/accordion.html';
      },
      link: function() {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion is now deprecated. Use uib-accordion instead.');
        }
      }
    };
  }])

  .directive('accordionGroup', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      require: '^accordion',         // We need this directive to be inside an accordion
      restrict: 'EA',
      transclude: true,              // It transcludes the contents of the directive into the template
      replace: true,                // The element containing the directive will be replaced with the template
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'template/accordion/accordion-group.html';
      },
      scope: {
        heading: '@',               // Interpolate the heading attribute onto this scope
        isOpen: '=?',
        isDisabled: '=?'
      },
      controller: function() {
        this.setHeading = function(element) {
          this.heading = element;
        };
      },
      link: function(scope, element, attrs, accordionCtrl) {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion-group is now deprecated. Use uib-accordion-group instead.');
        }

        accordionCtrl.addGroup(scope);

        scope.openClass = attrs.openClass || 'panel-open';
        scope.panelClass = attrs.panelClass;
        scope.$watch('isOpen', function(value) {
          element.toggleClass(scope.openClass, !!value);
          if (value) {
            accordionCtrl.closeOthers(scope);
          }
        });

        scope.toggleOpen = function($event) {
          if (!scope.isDisabled) {
            if (!$event || $event.which === 32) {
              scope.isOpen = !scope.isOpen;
            }
          }
        };
      }
    };
  }])

  .directive('accordionHeading', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      restrict: 'EA',
      transclude: true,   // Grab the contents to be used as the heading
      template: '',       // In effect remove this element!
      replace: true,
      require: '^accordionGroup',
      link: function(scope, element, attr, accordionGroupCtrl, transclude) {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion-heading is now deprecated. Use uib-accordion-heading instead.');
        }
        // Pass the heading to the accordion-group controller
        // so that it can be transcluded into the right place in the template
        // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
        accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
      }
    };
  }])

  .directive('accordionTransclude', ['$log', '$accordionSuppressWarning', function($log, $accordionSuppressWarning) {
    return {
      require: '^accordionGroup',
      link: function(scope, element, attr, controller) {
        if (!$accordionSuppressWarning) {
          $log.warn('accordion-transclude is now deprecated. Use uib-accordion-transclude instead.');
        }

        scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
          if (heading) {
            element.find('span').html('');
            element.find('span').append(heading);
          }
        });
      }
    };
  }]);


angular.module('ui.bootstrap.alert', [])

.controller('UibAlertController', ['$scope', '$attrs', '$interpolate', '$timeout', function($scope, $attrs, $interpolate, $timeout) {
  $scope.closeable = !!$attrs.close;

  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?
    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;

  if (dismissOnTimeout) {
    $timeout(function() {
      $scope.close();
    }, parseInt(dismissOnTimeout, 10));
  }
}])

.directive('uibAlert', function() {
  return {
    controller: 'UibAlertController',
    controllerAs: 'alert',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/alert/alert.html';
    },
    transclude: true,
    replace: true,
    scope: {
      type: '@',
      close: '&'
    }
  };
});

/* Deprecated alert below */

angular.module('ui.bootstrap.alert')

  .value('$alertSuppressWarning', false)

  .controller('AlertController', ['$scope', '$attrs', '$controller', '$log', '$alertSuppressWarning', function($scope, $attrs, $controller, $log, $alertSuppressWarning) {
    if (!$alertSuppressWarning) {
      $log.warn('AlertController is now deprecated. Use UibAlertController instead.');
    }

    angular.extend(this, $controller('UibAlertController', {
      $scope: $scope,
      $attrs: $attrs
    }));
  }])

  .directive('alert', ['$log', '$alertSuppressWarning', function($log, $alertSuppressWarning) {
    return {
      controller: 'AlertController',
      controllerAs: 'alert',
      templateUrl: function(element, attrs) {
        return attrs.templateUrl || 'template/alert/alert.html';
      },
      transclude: true,
      replace: true,
      scope: {
        type: '@',
        close: '&'
      },
      link: function() {
        if (!$alertSuppressWarning) {
          $log.warn('alert is now deprecated. Use uib-alert instead.');
        }
      }
    };
  }]);

angular.module('ui.bootstrap.buttons', [])

.constant('uibButtonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('uibBtnRadio', function() {
  return {
    require: ['uibBtnRadio', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'buttons',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function() {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
})

.directive('uibBtnCheckbox', function() {
  return {
    require: ['uibBtnCheckbox', 'ngModel'],
    controller: 'UibButtonsController',
    controllerAs: 'button',
    link: function(scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      element.find('input').css({display: 'none'});

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attribute, defaultValue) {
        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function() {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.on(buttonsCtrl.toggleEvent, function() {
        if (attrs.disabled) {
          return;
        }

        scope.$apply(function() {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

/* Deprecated buttons below */

angular.module('ui.bootstrap.buttons')

  .value('$buttonsSuppressWarning', false)

  .controller('ButtonsController', ['$controller', '$log', '$buttonsSuppressWarning', function($controller, $log, $buttonsSuppressWarning) {
    if (!$buttonsSuppressWarning) {
      $log.warn('ButtonsController is now deprecated. Use UibButtonsController instead.');
    }

    angular.extend(this, $controller('UibButtonsController'));
  }])

  .directive('btnRadio', ['$log', '$buttonsSuppressWarning', function($log, $buttonsSuppressWarning) {
    return {
      require: ['btnRadio', 'ngModel'],
      controller: 'ButtonsController',
      controllerAs: 'buttons',
      link: function(scope, element, attrs, ctrls) {
        if (!$buttonsSuppressWarning) {
          $log.warn('btn-radio is now deprecated. Use uib-btn-radio instead.');
        }

        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

        element.find('input').css({display: 'none'});

        //model -> UI
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
        };

        //ui->model
        element.bind(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }

          var isActive = element.hasClass(buttonsCtrl.activeClass);

          if (!isActive || angular.isDefined(attrs.uncheckable)) {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
              ngModelCtrl.$render();
            });
          }
        });
      }
    };
  }])

  .directive('btnCheckbox', ['$document', '$log', '$buttonsSuppressWarning', function($document, $log, $buttonsSuppressWarning) {
    return {
      require: ['btnCheckbox', 'ngModel'],
      controller: 'ButtonsController',
      controllerAs: 'button',
      link: function(scope, element, attrs, ctrls) {
        if (!$buttonsSuppressWarning) {
          $log.warn('btn-checkbox is now deprecated. Use uib-btn-checkbox instead.');
        }

        var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

        element.find('input').css({display: 'none'});

        function getTrueValue() {
          return getCheckboxValue(attrs.btnCheckboxTrue, true);
        }

        function getFalseValue() {
          return getCheckboxValue(attrs.btnCheckboxFalse, false);
        }

        function getCheckboxValue(attributeValue, defaultValue) {
          var val = scope.$eval(attributeValue);
          return angular.isDefined(val) ? val : defaultValue;
        }

        //model -> UI
        ngModelCtrl.$render = function() {
          element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
        };

        //ui->model
        element.bind(buttonsCtrl.toggleEvent, function() {
          if (attrs.disabled) {
            return;
          }

          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });

        //accessibility
        element.on('keypress', function(e) {
          if (attrs.disabled || e.which !== 32 || $document[0].activeElement !== element[0]) {
            return;
          }

          scope.$apply(function() {
            ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
            ngModelCtrl.$render();
          });
        });
      }
    };
  }]);


/**
 * @ngdoc overview
 * @name ui.bootstrap.carousel
 *
 * @description
 * AngularJS version of an image carousel.
 *
 */
angular.module('ui.bootstrap.carousel', [])

.controller('UibCarouselController', ['$scope', '$element', '$interval', '$animate', function($scope, $element, $interval, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    NEW_ANIMATE = angular.version.minor >= 4,
    NO_TRANSITION = 'uib-noTransition',
    SLIDE_DIRECTION = 'uib-slideDirection',
    currentIndex = -1,
    currentInterval, isPlaying;
  self.currentSlide = null;

  var destroyed = false;
  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = $scope.indexOfSlide(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
    }
    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition) {
      goNext(nextSlide, nextIndex, direction);
    }
  };

  function goNext(slide, index, direction) {
    // Scope has been destroyed, stop here.
    if (destroyed) { return; }

    angular.extend(slide, {direction: direction, active: true});
    angular.extend(self.currentSlide || {}, {direction: direction, active: false});
    if ($animate.enabled() && !$scope.noTransition && !$scope.$currentTransition &&
      slide.$element && self.slides.length > 1) {
      slide.$element.data(SLIDE_DIRECTION, slide.direction);
      if (self.currentSlide && self.currentSlide.$element) {
        self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction);
      }

      $scope.$currentTransition = true;
      if (NEW_ANIMATE) {
        $animate.on('addClass', slide.$element, function(element, phase) {
          if (phase === 'close') {
            $scope.$currentTransition = null;
            $animate.off('addClass', element);
          }
        });
      } else {
        slide.$element.one('$animate:close', function closeFn() {
          $scope.$currentTransition = null;
        });
      }
    }

    self.currentSlide = slide;
    currentIndex = index;

    //every time you change slides, reset the timer
    restartTimer();
  }

  $scope.$on('$destroy', function() {
    destroyed = true;
  });

  function getSlideByIndex(index) {
    if (angular.isUndefined(slides[index].index)) {
      return slides[index];
    }
    var i, len = slides.length;
    for (i = 0; i < slides.length; ++i) {
      if (slides[i].index == index) {
        return slides[i];
      }
    }
  }

  self.getCurrentIndex = function() {
    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
      return +self.currentSlide.index;
    }
    return currentIndex;
  };

  /* Allow outside people to call indexOf on slides array */
  $scope.indexOfSlide = function(slide) {
    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    if (newIndex === 0 && $scope.noWrap()) {
      $scope.pause();
      return;
    }

    return self.select(getSlideByIndex(newIndex), 'next');
  };

  $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    if ($scope.noWrap() && newIndex === slides.length - 1) {
      $scope.pause();
      return;
    }

    return self.select(getSlideByIndex(newIndex), 'prev');
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.$watch('interval', restartTimer);
  $scope.$watchCollection('slides', resetTransition);
  $scope.$on('$destroy', resetTimer);

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval > 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }

  function resetTransition(slides) {
    if (!slides.length) {
      $scope.$currentTransition = null;
    }
  }

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if (slides.length === 1 || slide.active) {
      self.select(slides[slides.length - 1]);
      if (slides.length === 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    if (angular.isDefined(slide.index)) {
      slides.sort(function(a, b) {
        return +a.index > +b.index;
      });
    }
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index - 1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }

    //clean the currentSlide when no more slide
    if (slides.length === 0) {
      self.currentSlide = null;
    }
  };

  $scope.$watch('noTransition', function(noTransition) {
    $element.data(NO_TRANSITION, noTransition);
  });

}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <uib-carousel>
      <uib-slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </uib-slide>
      <uib-slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </uib-slide>
    </uib-carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('uibCarousel', [function() {
  return {
    transclude: true,
    replace: true,
    controller: 'UibCarouselController',
    controllerAs: 'carousel',
    require: 'carousel',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/carousel.html';
    },
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <uib-carousel>
    <uib-slide ng-repeat="slide in slides" active="slide.active" index="$index">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </uib-slide>
  </uib-carousel>
  Interval, in milliseconds: <input type="number" ng-model="myInterval">
  <br />Enter a negative number to stop the interval.
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('uibSlide', function() {
  return {
    require: '^uibCarousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/slide.html';
    },
    scope: {
      active: '=?',
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
})

.animation('.item', [
         '$injector', '$animate',
function ($injector, $animate) {
  var NO_TRANSITION = 'uib-noTransition',
    SLIDE_DIRECTION = 'uib-slideDirection',
    $animateCss = null;

  if ($injector.has('$animateCss')) {
    $animateCss = $injector.get('$animateCss');
  }

  function removeClass(element, className, callback) {
    element.removeClass(className);
    if (callback) {
      callback();
    }
  }

  return {
    beforeAddClass: function(element, className, done) {
      // Due to transclusion, noTransition property is on parent's scope
      if (className == 'active' && element.parent() && element.parent().parent() &&
          !element.parent().parent().data(NO_TRANSITION)) {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction == 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element,
          directionClass + ' ' + direction, done);
        element.addClass(direction);

        if ($animateCss) {
          $animateCss(element, {addClass: directionClass})
            .start()
            .done(removeClassFn);
        } else {
          $animate.addClass(element, directionClass).then(function () {
            if (!stopped) {
              removeClassFn();
            }
            done();
          });
        }

        return function () {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent's scope
      if (className === 'active' && element.parent() && element.parent().parent() &&
          !element.parent().parent().data(NO_TRANSITION)) {
        var stopped = false;
        var direction = element.data(SLIDE_DIRECTION);
        var directionClass = direction == 'next' ? 'left' : 'right';
        var removeClassFn = removeClass.bind(this, element, directionClass, done);

        if ($animateCss) {
          $animateCss(element, {addClass: directionClass})
            .start()
            .done(removeClassFn);
        } else {
          $animate.addClass(element, directionClass).then(function() {
            if (!stopped) {
              removeClassFn();
            }
            done();
          });
        }
        return function() {
          stopped = true;
        };
      }
      done();
    }
  };
}]);

/* deprecated carousel below */

angular.module('ui.bootstrap.carousel')

.value('$carouselSuppressWarning', false)

.controller('CarouselController', ['$scope', '$element', '$controller', '$log', '$carouselSuppressWarning', function($scope, $element, $controller, $log, $carouselSuppressWarning) {
  if (!$carouselSuppressWarning) {
    $log.warn('CarouselController is now deprecated. Use UibCarouselController instead.');
  }

  angular.extend(this, $controller('UibCarouselController', {
    $scope: $scope,
    $element: $element
  }));
}])

.directive('carousel', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
  return {
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    controllerAs: 'carousel',
    require: 'carousel',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/carousel.html';
    },
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '=',
      noWrap: '&'
    },
    link: function() {
      if (!$carouselSuppressWarning) {
        $log.warn('carousel is now deprecated. Use uib-carousel instead.');
      }
    }
  };
}])

.directive('slide', ['$log', '$carouselSuppressWarning', function($log, $carouselSuppressWarning) {
  return {
    require: '^carousel',
    transclude: true,
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/carousel/slide.html';
    },
    scope: {
      active: '=?',
      actual: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      if (!$carouselSuppressWarning) {
        $log.warn('slide is now deprecated. Use uib-slide instead.');
      }

      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
}]);

angular.module('ui.bootstrap.dateparser', [])

.service('uibDateParser', ['$log', '$locale', 'orderByFilter', function($log, $locale, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  var localeId;
  var formatCodeToRegex;

  this.init = function() {
    localeId = $locale.id;

    this.parsers = {};

    formatCodeToRegex = {
      'yyyy': {
        regex: '\\d{4}',
        apply: function(value) { this.year = +value; }
      },
      'yy': {
        regex: '\\d{2}',
        apply: function(value) { this.year = +value + 2000; }
      },
      'y': {
        regex: '\\d{1,4}',
        apply: function(value) { this.year = +value; }
      },
      'MMMM': {
        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
      },
      'MMM': {
        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
      },
      'MM': {
        regex: '0[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; }
      },
      'M': {
        regex: '[1-9]|1[0-2]',
        apply: function(value) { this.month = value - 1; }
      },
      'dd': {
        regex: '[0-2][0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; }
      },
      'd': {
        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
        apply: function(value) { this.date = +value; }
      },
      'EEEE': {
        regex: $locale.DATETIME_FORMATS.DAY.join('|')
      },
      'EEE': {
        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
      },
      'HH': {
        regex: '(?:0|1)[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; }
      },
      'hh': {
        regex: '0[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; }
      },
      'H': {
        regex: '1?[0-9]|2[0-3]',
        apply: function(value) { this.hours = +value; }
      },
      'h': {
        regex: '[0-9]|1[0-2]',
        apply: function(value) { this.hours = +value; }
      },
      'mm': {
        regex: '[0-5][0-9]',
        apply: function(value) { this.minutes = +value; }
      },
      'm': {
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.minutes = +value; }
      },
      'sss': {
        regex: '[0-9][0-9][0-9]',
        apply: function(value) { this.milliseconds = +value; }
      },
      'ss': {
        regex: '[0-5][0-9]',
        apply: function(value) { this.seconds = +value; }
      },
      's': {
        regex: '[0-9]|[1-5][0-9]',
        apply: function(value) { this.seconds = +value; }
      },
      'a': {
        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
        apply: function(value) {
          if (this.hours === 12) {
            this.hours = 0;
          }

          if (value === 'PM') {
            this.hours += 12;
          }
        }
      }
    };
  };

  this.init();

  function createParser(format) {
    var map = [], regex = format.split('');

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  this.parse = function(input, format, baseDate) {
    if (!angular.isString(input) || !format) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if ($locale.id !== localeId) {
      this.init();
    }

    if (!this.parsers[format]) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if (results && results.length) {
      var fields, dt;
      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        if (baseDate) {
          $log.warn('dateparser:', 'baseDate is not a valid date');
        }
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for (var i = 1, n = results.length; i < n; i++) {
        var mapper = map[i-1];
        if (mapper.apply) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if (isValid(fields.year, fields.month, fields.date)) {
        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
          dt = new Date(baseDate);
          dt.setFullYear(fields.year, fields.month, fields.date,
            fields.hours, fields.minutes, fields.seconds,
            fields.milliseconds || 0);
        } else {
          dt = new Date(fields.year, fields.month, fields.date,
            fields.hours, fields.minutes, fields.seconds,
            fields.milliseconds || 0);
        }
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if (month === 1 && date > 28) {
      return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    }

    if (month === 3 || month === 5 || month === 8 || month === 10) {
      return date < 31;
    }

    return true;
  }
}]);

/* Deprecated dateparser below */

angular.module('ui.bootstrap.dateparser')

.value('$dateParserSuppressWarning', false)

.service('dateParser', ['$log', '$dateParserSuppressWarning', 'uibDateParser', function($log, $dateParserSuppressWarning, uibDateParser) {
  if (!$dateParserSuppressWarning) {
    $log.warn('dateParser is now deprecated. Use uibDateParser instead.');
  }

  angular.extend(this, uibDateParser);
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$uibPosition', ['$document', '$window', function($document, $window) {
    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function(element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function(element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function(element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
        var positionStrParts = positionStr.split('-');
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop('offsetWidth');
        targetElHeight = targetEl.prop('offsetHeight');

        var shiftWidth = {
          center: function() {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function() {
            return hostElPos.left;
          },
          right: function() {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function() {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function() {
            return hostElPos.top;
          },
          bottom: function() {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case 'right':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case 'left':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case 'bottom':
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

/* Deprecated position below */

angular.module('ui.bootstrap.position')

.value('$positionSuppressWarning', false)

.service('$position', ['$log', '$positionSuppressWarning', '$uibPosition', function($log, $positionSuppressWarning, $uibPosition) {
  if (!$positionSuppressWarning) {
    $log.warn('$position is now deprecated. Use $uibPosition instead.');
  }

  angular.extend(this, $uibPosition);
}]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])

.value('$datepickerSuppressError', false)

.constant('uibDatepickerConfig', {
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  datepickerMode: 'day',
  minMode: 'day',
  maxMode: 'year',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null,
  shortcutPropagation: false
})

.controller('UibDatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  // Configuration attributes
  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
                   'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach(['minDate', 'maxDate'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  angular.forEach(['minMode', 'maxMode'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = angular.isDefined(value) ? value : $attrs[key];
        $scope[key] = self[key];
        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
          $scope.datepickerMode = self[key];
        }
      });
    } else {
      self[key] = datepickerConfig[key] || null;
      $scope[key] = self[key];
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  if (angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate = new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
          isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function(date) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  // Listen for focus requests from popup directive
  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  this.step = { months: 1 };
  this.element = $element;
  function getDaysInMonth(year, month) {
    return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
  }

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    scope.showWeeks = ctrl.showWeeks;
    ctrl.refreshView();
  };

  this.getDates = function(startDate, n) {
    var dates = new Array(n), current = new Date(startDate), i = 0, date;
    while (i < n) {
      date = new Date(current);
      dates[i++] = date;
      current.setDate(current.getDate() + 1);
    }
    return dates;
  };

  this._refreshView = function() {
    var year = this.activeDate.getFullYear(),
      month = this.activeDate.getMonth(),
      firstDayOfMonth = new Date(this.activeDate);

    firstDayOfMonth.setFullYear(year, month, 1);

    var difference = this.startingDay - firstDayOfMonth.getDay(),
      numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
      firstDate = new Date(firstDayOfMonth);

    if (numDisplayedFromPreviousMonth > 0) {
      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
    }

    // 42 is the number of days on a six-month calendar
    var days = this.getDates(firstDate, 42);
    for (var i = 0; i < 42; i ++) {
      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
        secondary: days[i].getMonth() !== month,
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.labels = new Array(7);
    for (var j = 0; j < 7; j++) {
      scope.labels[j] = {
        abbr: dateFilter(days[j].date, this.formatDayHeader),
        full: dateFilter(days[j].date, 'EEEE')
      };
    }

    scope.title = dateFilter(this.activeDate, this.formatDayTitle);
    scope.rows = this.split(days, 7);

    if (scope.showWeeks) {
      scope.weekNumbers = [];
      var thursdayIndex = (4 + 7 - this.startingDay) % 7,
          numWeeks = scope.rows.length;
      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
        scope.weekNumbers.push(
          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
      }
    }
  };

  this.compare = function(date1, date2) {
    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
  };

  function getISO8601WeekNumber(date) {
    var checkDate = new Date(date);
    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
    var time = checkDate.getTime();
    checkDate.setMonth(0); // Compare with Jan 1
    checkDate.setDate(1);
    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
  }

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getDate();

    if (key === 'left') {
      date = date - 1;   // up
    } else if (key === 'up') {
      date = date - 7;   // down
    } else if (key === 'right') {
      date = date + 1;   // down
    } else if (key === 'down') {
      date = date + 7;
    } else if (key === 'pageup' || key === 'pagedown') {
      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setMonth(month, 1);
      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
    } else if (key === 'home') {
      date = 1;
    } else if (key === 'end') {
      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
    }
    this.activeDate.setDate(date);
  };
}])

.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  this.step = { years: 1 };
  this.element = $element;

  this.init = function(ctrl) {
    angular.extend(ctrl, this);
    ctrl.refreshView();
  };

  this._refreshView = function() {
    var months = new Array(12),
        year = this.activeDate.getFullYear(),
        date;

    for (var i = 0; i < 12; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(year, i, 1);
      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
    scope.rows = this.split(months, 3);
  };

  this.compare = function(date1, date2) {
    return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getMonth();

    if (key === 'left') {
      date = date - 1;   // up
    } else if (key === 'up') {
      date = date - 3;   // down
    } else if (key === 'right') {
      date = date + 1;   // down
    } else if (key === 'down') {
      date = date + 3;
    } else if (key === 'pageup' || key === 'pagedown') {
      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
      this.activeDate.setFullYear(year);
    } else if (key === 'home') {
      date = 0;
    } else if (key === 'end') {
      date = 11;
    }
    this.activeDate.setMonth(date);
  };
}])

.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {
  var range;
  this.element = $element;

  function getStartingYear(year) {
    return parseInt((year - 1) / range, 10) * range + 1;
  }

  this.yearpickerInit = function() {
    range = this.yearRange;
    this.step = { years: range };
  };

  this._refreshView = function() {
    var years = new Array(range), date;

    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
      date = new Date(this.activeDate);
      date.setFullYear(start + i, 0, 1);
      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
        uid: scope.uniqueId + '-' + i
      });
    }

    scope.title = [years[0].label, years[range - 1].label].join(' - ');
    scope.rows = this.split(years, 5);
  };

  this.compare = function(date1, date2) {
    return date1.getFullYear() - date2.getFullYear();
  };

  this.handleKeyDown = function(key, evt) {
    var date = this.activeDate.getFullYear();

    if (key === 'left') {
      date = date - 1;   // up
    } else if (key === 'up') {
      date = date - 5;   // down
    } else if (key === 'right') {
      date = date + 1;   // down
    } else if (key === 'down') {
      date = date + 5;
    } else if (key === 'pageup' || key === 'pagedown') {
      date += (key === 'pageup' ? - 1 : 1) * this.step.years;
    } else if (key === 'home') {
      date = getStartingYear(this.activeDate.getFullYear());
    } else if (key === 'end') {
      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
    }
    this.activeDate.setFullYear(date);
  };
}])

.directive('uibDatepicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/datepicker.html';
    },
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&',
      customClass: '&',
      shortcutPropagation: '&?'
    },
    require: ['uibDatepicker', '^ngModel'],
    controller: 'UibDatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
})

.directive('uibDaypicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/day.html';
    },
    require: ['^?uibDatepicker', 'uibDaypicker', '^?datepicker'],
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0] || ctrls[2],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibMonthpicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/month.html';
    },
    require: ['^?uibDatepicker', 'uibMonthpicker', '^?datepicker'],
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0] || ctrls[2],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
})

.directive('uibYearpicker', function() {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/year.html';
    },
    require: ['^?uibDatepicker', 'uibYearpicker', '^?datepicker'],
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      var ctrl = ctrls[0] || ctrls[2];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
})

.constant('uibDatepickerPopupConfig', {
  datepickerPopup: 'yyyy-MM-dd',
  datepickerPopupTemplateUrl: 'template/datepicker/popup.html',
  datepickerTemplateUrl: 'template/datepicker/datepicker.html',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  currentText: 'Today',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true,
  onOpenFocus: true
})

.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout',
function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
  var self = this;
  var cache = {},
    isHtml5DateInput = false;
  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,
    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl,
    ngModel, $popup;

  scope.watchData = {};

  this.init = function(_ngModel_) {
    ngModel = _ngModel_;
    closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
    appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
    onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
    datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
    datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;

    scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

    if (datepickerPopupConfig.html5Types[attrs.type]) {
      dateFormat = datepickerPopupConfig.html5Types[attrs.type];
      isHtml5DateInput = true;
    } else {
      dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
      attrs.$observe('uibDatepickerPopup', function(value, oldValue) {
          var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
          // Invalidate the $modelValue to ensure that formatters re-run
          // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
          if (newDateFormat !== dateFormat) {
            dateFormat = newDateFormat;
            ngModel.$modelValue = null;

            if (!dateFormat) {
              throw new Error('uibDatepickerPopup must have a date format specified.');
            }
          }
      });
    }

    if (!dateFormat) {
      throw new Error('uibDatepickerPopup must have a date format specified.');
    }

    if (isHtml5DateInput && attrs.datepickerPopup) {
      throw new Error('HTML5 date input types do not support custom formats.');
    }

    // popup element used to display calendar
    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
    popupEl.attr({
      'ng-model': 'date',
      'ng-change': 'dateSelection(date)',
      'template-url': datepickerPopupTemplateUrl
    });

    // datepicker element
    datepickerEl = angular.element(popupEl.children()[0]);
    datepickerEl.attr('template-url', datepickerTemplateUrl);

    if (isHtml5DateInput) {
      if (attrs.type === 'month') {
        datepickerEl.attr('datepicker-mode', '"month"');
        datepickerEl.attr('min-mode', 'month');
      }
    }

    if (attrs.datepickerOptions) {
      var options = scope.$parent.$eval(attrs.datepickerOptions);
      if (options && options.initDate) {
        scope.initDate = options.initDate;
        datepickerEl.attr('init-date', 'initDate');
        delete options.initDate;
      }
      angular.forEach(options, function(value, option) {
        datepickerEl.attr(cameltoDash(option), value);
      });
    }

    angular.forEach(['minMode', 'maxMode', 'minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function(key) {
      if (attrs[key]) {
        var getAttribute = $parse(attrs[key]);
        scope.$parent.$watch(getAttribute, function(value) {
          scope.watchData[key] = value;
          if (key === 'minDate' || key === 'maxDate') {
            cache[key] = new Date(value);
          }
        });
        datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

        // Propagate changes from datepicker to outside
        if (key === 'datepickerMode') {
          var setAttribute = getAttribute.assign;
          scope.$watch('watchData.' + key, function(value, oldvalue) {
            if (angular.isFunction(setAttribute) && value !== oldvalue) {
              setAttribute(scope.$parent, value);
            }
          });
        }
      }
    });
    if (attrs.dateDisabled) {
      datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
    }

    if (attrs.showWeeks) {
      datepickerEl.attr('show-weeks', attrs.showWeeks);
    }

    if (attrs.customClass) {
      datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
    }

    if (!isHtml5DateInput) {
      // Internal API to maintain the correct ng-invalid-[key] class
      ngModel.$$parserName = 'date';
      ngModel.$validators.date = validator;
      ngModel.$parsers.unshift(parseDate);
      ngModel.$formatters.push(function(value) {
        scope.date = value;
        return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
      });
    } else {
      ngModel.$formatters.push(function(value) {
        scope.date = value;
        return value;
      });
    }

    // Detect changes in the view from the text box
    ngModel.$viewChangeListeners.push(function() {
      scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
    });

    element.bind('keydown', inputKeydownBind);

    $popup = $compile(popupEl)(scope);
    // Prevent jQuery cache memory leak (template is now redundant after linking)
    popupEl.remove();

    if (appendToBody) {
      $document.find('body').append($popup);
    } else {
      element.after($popup);
    }

    scope.$on('$destroy', function() {
      if (scope.isOpen === true) {
        if (!$rootScope.$$phase) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      }

      $popup.remove();
      element.unbind('keydown', inputKeydownBind);
      $document.unbind('click', documentClickBind);
    });
  };

  scope.getText = function(key) {
    return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
  };

  scope.isDisabled = function(date) {
    if (date === 'today') {
      date = new Date();
    }

    return ((scope.watchData.minDate && scope.compare(date, cache.minDate) < 0) ||
      (scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0));
  };

  scope.compare = function(date1, date2) {
    return (new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate()));
  };

  // Inner change
  scope.dateSelection = function(dt) {
    if (angular.isDefined(dt)) {
      scope.date = dt;
    }
    var date = scope.date ? dateFilter(scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function
    element.val(date);
    ngModel.$setViewValue(date);

    if (closeOnDateSelection) {
      scope.isOpen = false;
      element[0].focus();
    }
  };

  scope.keydown = function(evt) {
    if (evt.which === 27) {
      scope.isOpen = false;
      element[0].focus();
    }
  };

  scope.select = function(date) {
    if (date === 'today') {
      var today = new Date();
      if (angular.isDate(scope.date)) {
        date = new Date(scope.date);
        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
      } else {
        date = new Date(today.setHours(0, 0, 0, 0));
      }
    }
    scope.dateSelection(date);
  };

  scope.close = function() {
    scope.isOpen = false;
    element[0].focus();
  };

  scope.$watch('isOpen', function(value) {
    if (value) {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top = scope.position.top + element.prop('offsetHeight');

      $timeout(function() {
        if (onOpenFocus) {
          scope.$broadcast('uib:datepicker.focus');
        }
        $document.bind('click', documentClickBind);
      }, 0, false);
    } else {
      $document.unbind('click', documentClickBind);
    }
  });

  function cameltoDash(string) {
    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
  }

  function parseDate(viewValue) {
    if (angular.isNumber(viewValue)) {
      // presumably timestamp to date object
      viewValue = new Date(viewValue);
    }

    if (!viewValue) {
      return null;
    } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
      return viewValue;
    } else if (angular.isString(viewValue)) {
      var date = dateParser.parse(viewValue, dateFormat, scope.date);
      if (isNaN(date)) {
        return undefined;
      } else {
        return date;
      }
    } else {
      return undefined;
    }
  }

  function validator(modelValue, viewValue) {
    var value = modelValue || viewValue;

    if (!attrs.ngRequired && !value) {
      return true;
    }

    if (angular.isNumber(value)) {
      value = new Date(value);
    }
    if (!value) {
      return true;
    } else if (angular.isDate(value) && !isNaN(value)) {
      return true;
    } else if (angular.isString(value)) {
      var date = dateParser.parse(value, dateFormat);
      return !isNaN(date);
    } else {
      return false;
    }
  }

  function documentClickBind(event) {
    var popup = $popup[0];
    var dpContainsTarget = element[0].contains(event.target);
    // The popup node may not be an element node
    // In some browsers (IE) only element nodes have the 'contains' function
    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
    if (scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
      scope.$apply(function() {
        scope.isOpen = false;
      });
    }
  }

  function inputKeydownBind(evt) {
    if (evt.which === 27 && scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      scope.$apply(function() {
        scope.isOpen = false;
      });
      element[0].focus();
    } else if (evt.which === 40 && !scope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      scope.$apply(function() {
        scope.isOpen = true;
      });
    }
  }
}])

.directive('uibDatepickerPopup', function() {
  return {
    require: ['ngModel', 'uibDatepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&',
      customClass: '&'
    },
    link: function(scope, element, attrs, ctrls) {
      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
})

.directive('uibDatepickerPopupWrap', function() {
  return {
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/popup.html';
    }
  };
});

/* Deprecated datepicker below */

angular.module('ui.bootstrap.datepicker')

.value('$datepickerSuppressWarning', false)

.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerSuppressError', '$datepickerSuppressWarning', function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {
  if (!$datepickerSuppressWarning) {
    $log.warn('DatepickerController is now deprecated. Use UibDatepickerController instead.');
  }

  var self = this,
    ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  this.modes = ['day', 'month', 'year'];

  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
    'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function(key, index) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 6 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  angular.forEach(['minDate', 'maxDate'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  angular.forEach(['minMode', 'maxMode'], function(key) {
    if ($attrs[key]) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = angular.isDefined(value) ? value : $attrs[key];
        $scope[key] = self[key];
        if ((key == 'minMode' && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key])) || (key == 'maxMode' && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key]))) {
          $scope.datepickerMode = self[key];
        }
      });
    } else {
      self[key] = datepickerConfig[key] || null;
      $scope[key] = self[key];
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  if (angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
      if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate = new Date();
  }

  $scope.isActive = function(dateObject) {
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if (ngModelCtrl.$viewValue) {
      var date = new Date(ngModelCtrl.$viewValue),
        isValid = !isNaN(date);

      if (isValid) {
        this.activeDate = date;
      } else if (!$datepickerSuppressError) {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if (this.element) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity('dateDisabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function(date) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

  this.customClass = function(date) {
    return $scope.customClass({date: date, mode: $scope.datepickerMode});
  };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  this.fixTimeZone = function(date) {
    var hours = date.getHours();
    date.setHours(hours === 23 ? hours + 2 : 0);
  };

  $scope.select = function(date) {
    if ($scope.datepickerMode === self.minMode) {
      var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
      ngModelCtrl.$setViewValue(dt);
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }
  };

  $scope.move = function(direction) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
      month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function(direction) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction];
  };

  // Key event mapper
  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };

  var focusElement = function() {
    self.element[0].focus();
  };

  $scope.$on('uib:datepicker.focus', focusElement);

  $scope.keydown = function(evt) {
    var key = $scope.keys[evt.which];

    if (!key || evt.shiftKey || evt.altKey) {
      return;
    }

    evt.preventDefault();
    if (!self.shortcutPropagation) {
      evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if (self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive('datepicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/datepicker.html';
    },
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&',
      customClass: '&',
      shortcutPropagation: '&?'
    },
    require: ['datepicker', '^ngModel'],
    controller: 'DatepickerController',
    controllerAs: 'datepicker',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('datepicker is now deprecated. Use uib-datepicker instead.');
      }

      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      datepickerCtrl.init(ngModelCtrl);
    }
  };
}])

.directive('daypicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: 'template/datepicker/day.html',
    require: ['^datepicker', 'daypicker'],
    controller: 'UibDaypickerController',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('daypicker is now deprecated. Use uib-daypicker instead.');
      }

      var datepickerCtrl = ctrls[0],
        daypickerCtrl = ctrls[1];

      daypickerCtrl.init(datepickerCtrl);
    }
  };
}])

.directive('monthpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: 'template/datepicker/month.html',
    require: ['^datepicker', 'monthpicker'],
    controller: 'UibMonthpickerController',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('monthpicker is now deprecated. Use uib-monthpicker instead.');
      }

      var datepickerCtrl = ctrls[0],
        monthpickerCtrl = ctrls[1];

      monthpickerCtrl.init(datepickerCtrl);
    }
  };
}])

.directive('yearpicker', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    templateUrl: 'template/datepicker/year.html',
    require: ['^datepicker', 'yearpicker'],
    controller: 'UibYearpickerController',
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('yearpicker is now deprecated. Use uib-yearpicker instead.');
      }

      var ctrl = ctrls[0];
      angular.extend(ctrl, ctrls[1]);
      ctrl.yearpickerInit();

      ctrl.refreshView();
    }
  };
}])

.directive('datepickerPopup', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    require: ['ngModel', 'datepickerPopup'],
    controller: 'UibDatepickerPopupController',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&',
      customClass: '&'
    },
    link: function(scope, element, attrs, ctrls) {
      if (!$datepickerSuppressWarning) {
        $log.warn('datepicker-popup is now deprecated. Use uib-datepicker-popup instead.');
      }

      var ngModel = ctrls[0],
        ctrl = ctrls[1];

      ctrl.init(ngModel);
    }
  };
}])

.directive('datepickerPopupWrap', ['$log', '$datepickerSuppressWarning', function($log, $datepickerSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/datepicker/popup.html';
    },
    link: function() {
      if (!$datepickerSuppressWarning) {
        $log.warn('datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.');
      }
    }
  };
}]);

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('uibDropdownConfig', {
  openClass: 'open'
})

.service('uibDropdownService', ['$document', '$rootScope', function($document, $rootScope) {
  var openScope = null;

  this.open = function(dropdownScope) {
    if (!openScope) {
      $document.bind('click', closeDropdown);
      $document.bind('keydown', keybindFilter);
    }

    if (openScope && openScope !== dropdownScope) {
      openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function(dropdownScope) {
    if (openScope === dropdownScope) {
      openScope = null;
      $document.unbind('click', closeDropdown);
      $document.unbind('keydown', keybindFilter);
    }
  };

  var closeDropdown = function(evt) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope) { return; }

    if (evt && openScope.getAutoClose() === 'disabled')  { return ; }

    var toggleElement = openScope.getToggleElement();
    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
      return;
    }

    var dropdownElement = openScope.getDropdownElement();
    if (evt && openScope.getAutoClose() === 'outsideClick' &&
      dropdownElement && dropdownElement[0].contains(evt.target)) {
      return;
    }

    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  var keybindFilter = function(evt) {
    if (evt.which === 27) {
      openScope.focusToggleElement();
      closeDropdown();
    } else if (openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen) {
      evt.preventDefault();
      evt.stopPropagation();
      openScope.focusDropdownEntry(evt.which);
    }
  };
}])

.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    appendToBody = false,
    keynavEnabled =false,
    selectedOption = null;


  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);

    if (appendToBody && self.dropdownMenu) {
      $document.find('body').append(self.dropdownMenu);
      $element.on('$destroy', function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function(open) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      (angular.element(self.dropdownMenu).find('a')) :
      (angular.element($element).find('ul').eq(0).find('a'));

    switch (keyCode) {
      case (40): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = (self.selectedOption === elems.length - 1 ?
            self.selectedOption :
            self.selectedOption + 1);
        }
        break;
      }
      case (38): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    if (appendToBody && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
      var css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
      }

      self.dropdownMenu.css(css);
    }

    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
        toggleInvoker($scope, { open: !!isOpen });
      }
    });

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          });
        });
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope);
    } else {
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      uibDropdownService.close(scope);
      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });

  $scope.$on('$locationChangeSuccess', function() {
    if (scope.getAutoClose() !== 'disabled') {
      scope.isOpen = false;
    }
  });

  var offDestroy = $scope.$on('$destroy', function() {
    scope.$destroy();
  });
  scope.$on('$destroy', offDestroy);
}])

.directive('uibDropdown', function() {
  return {
    controller: 'UibDropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init();
    }
  };
})

.directive('uibDropdownMenu', function() {
  return {
    restrict: 'AC',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
})

.directive('uibKeyboardNav', function() {
  return {
    restrict: 'A',
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      element.bind('keydown', function(e) {
        if ([38, 40].indexOf(e.which) !== -1) {
          e.preventDefault();
          e.stopPropagation();

          var elems = dropdownCtrl.dropdownMenu.find('a');

          switch (e.which) {
            case (40): { // Down
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = 0;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
              }
              break;
            }
            case (38): { // Up
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = elems.length - 1;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
                  0 : dropdownCtrl.selectedOption - 1;
              }
              break;
            }
          }
          elems[dropdownCtrl.selectedOption].focus();
        }
      });
    }
  };
})

.directive('uibDropdownToggle', function() {
  return {
    require: '?^uibDropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
});

/* Deprecated dropdown below */

angular.module('ui.bootstrap.dropdown')

.value('$dropdownSuppressWarning', false)

.service('dropdownService', ['$log', '$dropdownSuppressWarning', 'uibDropdownService', function($log, $dropdownSuppressWarning, uibDropdownService) {
  if (!$dropdownSuppressWarning) {
    $log.warn('dropdownService is now deprecated. Use uibDropdownService instead.');
  }

  angular.extend(this, uibDropdownService);
}])

.controller('DropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', '$log', '$dropdownSuppressWarning', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {
  if (!$dropdownSuppressWarning) {
    $log.warn('DropdownController is now deprecated. Use UibDropdownController instead.');
  }

  var self = this,
    scope = $scope.$new(), // create a child scope so we are not polluting original one
    templateScope,
    openClass = dropdownConfig.openClass,
    getIsOpen,
    setIsOpen = angular.noop,
    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
    appendToBody = false,
    keynavEnabled =false,
    selectedOption = null;


  $element.addClass('dropdown');

  this.init = function() {
    if ($attrs.isOpen) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
    keynavEnabled = angular.isDefined($attrs.uibKeyboardNav);

    if (appendToBody && self.dropdownMenu) {
      $document.find('body').append(self.dropdownMenu);
      $element.on('$destroy', function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function(open) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return $element;
  };

  scope.isKeynavEnabled = function() {
    return keynavEnabled;
  };

  scope.focusDropdownEntry = function(keyCode) {
    var elems = self.dropdownMenu ? //If append to body is used.
      (angular.element(self.dropdownMenu).find('a')) :
      (angular.element($element).find('ul').eq(0).find('a'));

    switch (keyCode) {
      case (40): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = 0;
        } else {
          self.selectedOption = (self.selectedOption === elems.length -1 ?
            self.selectedOption :
          self.selectedOption + 1);
        }
        break;
      }
      case (38): {
        if (!angular.isNumber(self.selectedOption)) {
          self.selectedOption = elems.length - 1;
        } else {
          self.selectedOption = self.selectedOption === 0 ?
            0 : self.selectedOption - 1;
        }
        break;
      }
    }
    elems[self.selectedOption].focus();
  };

  scope.getDropdownElement = function() {
    return self.dropdownMenu;
  };

  scope.focusToggleElement = function() {
    if (self.toggleElement) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function(isOpen, wasOpen) {
    if (appendToBody && self.dropdownMenu) {
      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true);
      var css = {
        top: pos.top + 'px',
        display: isOpen ? 'block' : 'none'
      };

      var rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
      if (!rightalign) {
        css.left = pos.left + 'px';
        css.right = 'auto';
      } else {
        css.left = 'auto';
        css.right = (window.innerWidth - (pos.left + $element.prop('offsetWidth'))) + 'px';
      }

      self.dropdownMenu.css(css);
    }

    $animate[isOpen ? 'addClass' : 'removeClass']($element, openClass).then(function() {
      if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
        toggleInvoker($scope, { open: !!isOpen });
      }
    });

    if (isOpen) {
      if (self.dropdownMenuTemplateUrl) {
        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
          templateScope = scope.$new();
          $compile(tplContent.trim())(templateScope, function(dropdownElement) {
            var newEl = dropdownElement;
            self.dropdownMenu.replaceWith(newEl);
            self.dropdownMenu = newEl;
          });
        });
      }

      scope.focusToggleElement();
      uibDropdownService.open(scope);
    } else {
      if (self.dropdownMenuTemplateUrl) {
        if (templateScope) {
          templateScope.$destroy();
        }
        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
        self.dropdownMenu.replaceWith(newEl);
        self.dropdownMenu = newEl;
      }

      uibDropdownService.close(scope);
      self.selectedOption = null;
    }

    if (angular.isFunction(setIsOpen)) {
      setIsOpen($scope, isOpen);
    }
  });

  $scope.$on('$locationChangeSuccess', function() {
    if (scope.getAutoClose() !== 'disabled') {
      scope.isOpen = false;
    }
  });

  var offDestroy = $scope.$on('$destroy', function() {
    scope.$destroy();
  });
  scope.$on('$destroy', offDestroy);
}])

.directive('dropdown', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    controller: 'DropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!$dropdownSuppressWarning) {
        $log.warn('dropdown is now deprecated. Use uib-dropdown instead.');
      }

      dropdownCtrl.init();
    }
  };
}])

.directive('dropdownMenu', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    restrict: 'AC',
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
        return;
      }

      if (!$dropdownSuppressWarning) {
        $log.warn('dropdown-menu is now deprecated. Use uib-dropdown-menu instead.');
      }

      element.addClass('dropdown-menu');

      var tplUrl = attrs.templateUrl;
      if (tplUrl) {
        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
      }

      if (!dropdownCtrl.dropdownMenu) {
        dropdownCtrl.dropdownMenu = element;
      }
    }
  };
}])

.directive('keyboardNav', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    restrict: 'A',
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!$dropdownSuppressWarning) {
        $log.warn('keyboard-nav is now deprecated. Use uib-keyboard-nav instead.');
      }

      element.bind('keydown', function(e) {
        if ([38, 40].indexOf(e.which) !== -1) {
          e.preventDefault();
          e.stopPropagation();

          var elems = dropdownCtrl.dropdownMenu.find('a');

          switch (e.which) {
            case (40): { // Down
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = 0;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === elems.length -1 ?
                  dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1;
              }
              break;
            }
            case (38): { // Up
              if (!angular.isNumber(dropdownCtrl.selectedOption)) {
                dropdownCtrl.selectedOption = elems.length - 1;
              } else {
                dropdownCtrl.selectedOption = dropdownCtrl.selectedOption === 0 ?
                  0 : dropdownCtrl.selectedOption - 1;
              }
              break;
            }
          }
          elems[dropdownCtrl.selectedOption].focus();
        }
      });
    }
  };
}])

.directive('dropdownToggle', ['$log', '$dropdownSuppressWarning', function($log, $dropdownSuppressWarning) {
  return {
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if (!$dropdownSuppressWarning) {
        $log.warn('dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead.');
      }

      if (!dropdownCtrl) {
        return;
      }

      element.addClass('dropdown-toggle');

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if (!element.hasClass('disabled') && !attrs.disabled) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
}]);

angular.module('ui.bootstrap.stackedMap', [])
/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function() {
    return {
      createNew: function() {
        var stack = [];

        return {
          add: function(key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function(key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function() {
            return stack[stack.length - 1];
          },
          remove: function(key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function() {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function() {
            return stack.length;
          }
        };
      }
    };
  });
angular.module('ui.bootstrap.modal', ['ui.bootstrap.stackedMap'])
/**
 * A helper, internal data structure that stores all references attached to key
 */
  .factory('$$multiMap', function() {
    return {
      createNew: function() {
        var map = {};

        return {
          entries: function() {
            return Object.keys(map).map(function(key) {
              return {
                key: key,
                value: map[key]
              };
            });
          },
          get: function(key) {
            return map[key];
          },
          hasKey: function(key) {
            return !!map[key];
          },
          keys: function() {
            return Object.keys(map);
          },
          put: function(key, value) {
            if (!map[key]) {
              map[key] = [];
            }

            map[key].push(value);
          },
          remove: function(key, value) {
            var values = map[key];

            if (!values) {
              return;
            }

            var idx = values.indexOf(value);

            if (idx !== -1) {
              values.splice(idx, 1);
            }

            if (!values.length) {
              delete map[key];
            }
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('uibModalBackdrop', [
           '$animate', '$injector', '$uibModalStack',
  function($animate ,  $injector,   $modalStack) {
    var $animateCss = null;

    if ($injector.has('$animateCss')) {
      $animateCss = $injector.get('$animateCss');
    }

    return {
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      compile: function(tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      // Temporary fix for prefixing
      element.addClass('modal-backdrop');

      if (attrs.modalInClass) {
        if ($animateCss) {
          $animateCss(element, {
            addClass: attrs.modalInClass
          }).start();
        } else {
          $animate.addClass(element, attrs.modalInClass);
        }

        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
          var done = setIsAsync();
          if ($animateCss) {
            $animateCss(element, {
              removeClass: attrs.modalInClass
            }).start().then(done);
          } else {
            $animate.removeClass(element, attrs.modalInClass).then(done);
          }
        });
      }
    }
  }])

  .directive('uibModalWindow', [
           '$uibModalStack', '$q', '$animate', '$injector',
  function($modalStack ,  $q ,  $animate,   $injector) {
    var $animateCss = null;

    if ($injector.has('$animateCss')) {
      $animateCss = $injector.get('$animateCss');
    }

    return {
      scope: {
        index: '@'
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'template/modal/window.html';
      },
      link: function(scope, element, attrs) {
        element.addClass(attrs.windowClass || '');
        element.addClass(attrs.windowTopClass || '');
        scope.size = attrs.size;

        scope.close = function(evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };

        // moved from template to fix issue #2280
        element.on('click', scope.close);

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is render.
        var modalRenderDeferObj = $q.defer();
        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
        attrs.$observe('modalRender', function(value) {
          if (value == 'true') {
            modalRenderDeferObj.resolve();
          }
        });

        modalRenderDeferObj.promise.then(function() {
          var animationPromise = null;

          if (attrs.modalInClass) {
            if ($animateCss) {
              animationPromise = $animateCss(element, {
                addClass: attrs.modalInClass
              }).start();
            } else {
              animationPromise = $animate.addClass(element, attrs.modalInClass);
            }

            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
              var done = setIsAsync();
              if ($animateCss) {
                $animateCss(element, {
                  removeClass: attrs.modalInClass
                }).start().then(done);
              } else {
                $animate.removeClass(element, attrs.modalInClass).then(done);
              }
            });
          }


          $q.when(animationPromise).then(function() {
            var inputWithAutofocus = element[0].querySelector('[autofocus]');
            /**
             * Auto-focusing of a freshly-opened modal element causes any child elements
             * with the autofocus attribute to lose focus. This is an issue on touch
             * based devices which will show and then hide the onscreen keyboard.
             * Attempts to refocus the autofocus element via JavaScript will not reopen
             * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
             * the modal element if the modal does not contain an autofocus element.
             */
            if (inputWithAutofocus) {
              inputWithAutofocus.focus();
            } else {
              element[0].focus();
            }
          });

          // Notify {@link $modalStack} that modal is rendered.
          var modal = $modalStack.getTop();
          if (modal) {
            $modalStack.modalRendered(modal.key);
          }
        });
      }
    };
  }])

  .directive('uibModalAnimationClass', function() {
    return {
      compile: function(tElement, tAttrs) {
        if (tAttrs.modalAnimation) {
          tElement.addClass(tAttrs.uibModalAnimationClass);
        }
      }
    };
  })

  .directive('uibModalTransclude', function() {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  })

  .factory('$uibModalStack', [
             '$animate', '$timeout', '$document', '$compile', '$rootScope',
             '$q',
             '$injector',
             '$$multiMap',
             '$$stackedMap',
    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
              $q,
              $injector,
              $$multiMap,
              $$stackedMap) {
      var $animateCss = null;

      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }

      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var openedClasses = $$multiMap.createNew();
      var $modalStack = {
        NOW_CLOSING_EVENT: 'modal.stack.now-closing'
      };

      //Modal focus behavior
      var focusableElementList;
      var focusIndex = 0;
      var tababbleSelector = 'a[href], area[href], input:not([disabled]), ' +
        'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' +
        'iframe, object, embed, *[tabindex], *[contenteditable=true]';

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find('body').eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
          openedClasses.remove(modalBodyClass, modalInstance);
          body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass));
          toggleTopWindowClass(true);
        });
        checkRemoveBackdrop();

        //move focus to specified element if available, or else to body
        if (elementToReceiveFocus && elementToReceiveFocus.focus) {
          elementToReceiveFocus.focus();
        } else {
          body.focus();
        }
      }

      // Add or remove "windowTopClass" from the top window in the stack
      function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;

        if (openedWindows.length() > 0) {
          modalWindow = openedWindows.top().value;
          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
        }
      }

      function checkRemoveBackdrop() {
        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() == -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, function() {
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }

      function removeAfterAnimate(domEl, scope, done) {
        var asyncDeferred;
        var asyncPromise = null;
        var setIsAsync = function() {
          if (!asyncDeferred) {
            asyncDeferred = $q.defer();
            asyncPromise = asyncDeferred.promise;
          }

          return function asyncDone() {
            asyncDeferred.resolve();
          };
        };
        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);

        // Note that it's intentional that asyncPromise might be null.
        // That's when setIsAsync has not been called during the
        // NOW_CLOSING_EVENT broadcast.
        return $q.when(asyncPromise).then(afterAnimating);

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          if ($animateCss) {
            $animateCss(domEl, {
              event: 'leave'
            }).start().then(function() {
              domEl.remove();
            });
          } else {
            $animate.leave(domEl);
          }
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }

      $document.bind('keydown', function(evt) {
        if (evt.isDefaultPrevented()) {
          return evt;
        }

        var modal = openedWindows.top();
        if (modal && modal.value.keyboard) {
          switch (evt.which) {
            case 27: {
              evt.preventDefault();
              $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, 'escape key press');
              });
              break;
            }
            case 9: {
              $modalStack.loadFocusElementList(modal);
              var focusChanged = false;
              if (evt.shiftKey) {
                if ($modalStack.isFocusInFirstItem(evt)) {
                  focusChanged = $modalStack.focusLastFocusableElement();
                }
              } else {
                if ($modalStack.isFocusInLastItem(evt)) {
                  focusChanged = $modalStack.focusFirstFocusableElement();
                }
              }

              if (focusChanged) {
                evt.preventDefault();
                evt.stopPropagation();
              }
              break;
            }
          }
        }
      });

      $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement,
          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;

        toggleTopWindowClass(false);

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          openedClass: modal.openedClass,
          windowTopClass: modal.windowTopClass
        });

        openedClasses.put(modalBodyClass, modalInstance);

        var body = $document.find('body').eq(0),
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr('modal-animation', 'true');
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }

        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'window-top-class': modal.windowTopClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(modalBodyClass);

        $modalStack.clearFocusListCache();
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.modalScope.$$uibDestructionScheduled = true;
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance, modalWindow.value.modalOpener);
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function() {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      $modalStack.focusFirstFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[0].focus();
          return true;
        }
        return false;
      };
      $modalStack.focusLastFocusableElement = function() {
        if (focusableElementList.length > 0) {
          focusableElementList[focusableElementList.length - 1].focus();
          return true;
        }
        return false;
      };

      $modalStack.isFocusInFirstItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) == focusableElementList[0];
        }
        return false;
      };

      $modalStack.isFocusInLastItem = function(evt) {
        if (focusableElementList.length > 0) {
          return (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1];
        }
        return false;
      };

      $modalStack.clearFocusListCache = function() {
        focusableElementList = [];
        focusIndex = 0;
      };

      $modalStack.loadFocusElementList = function(modalWindow) {
        if (focusableElementList === undefined || !focusableElementList.length) {
          if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
              focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector);
            }
          }
        }
      };

      return $modalStack;
    }])

  .provider('$uibModal', function() {
    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$uibModalStack', '$modalSuppressWarning', '$log',
        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {
          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function(value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              } else if (angular.isString(value)) {
                promisesArr.push($q.when($injector.get(value)));
              } else {
                promisesArr.push($q.when(value));
              }
            });
            return promisesArr;
          }

          var promiseChain = null;
          $modal.getPromiseChain = function() {
            return promiseChain;
          };

          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));

            function resolveWithTemplate() {
              return templateAndResolvePromise;
            }

            // Wait for the resolution of the existing promise chain.
            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).
            // Then add to $modalStack and resolve opened.
            // Finally clean up the chain variable if no subsequent modal has overwritten it.
            var samePromise;
            samePromise = promiseChain = $q.all([promiseChain])
              .then(resolveWithTemplate, resolveWithTemplate)
              .then(function resolveSuccess(tplAndVars) {

                var modalScope = (modalOptions.scope || $rootScope).$new();
                modalScope.$close = modalInstance.close;
                modalScope.$dismiss = modalInstance.dismiss;

                modalScope.$on('$destroy', function() {
                  if (!modalScope.$$uibDestructionScheduled) {
                    modalScope.$dismiss('$uibUnscheduledDestruction');
                  }
                });

                var ctrlInstance, ctrlLocals = {};
                var resolveIter = 1;

                //controllers
                if (modalOptions.controller) {
                  ctrlLocals.$scope = modalScope;
                  ctrlLocals.$uibModalInstance = modalInstance;
                  Object.defineProperty(ctrlLocals, '$modalInstance', {
                    get: function() {
                      if (!$modalSuppressWarning) {
                        $log.warn('$modalInstance is now deprecated. Use $uibModalInstance instead.');
                      }

                      return modalInstance;
                    }
                  });
                  angular.forEach(modalOptions.resolve, function(value, key) {
                    ctrlLocals[key] = tplAndVars[resolveIter++];
                  });

                  ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                  if (modalOptions.controllerAs) {
                    if (modalOptions.bindToController) {
                      angular.extend(ctrlInstance, modalScope);
                    }

                    modalScope[modalOptions.controllerAs] = ctrlInstance;
                  }
                }

                $modalStack.open(modalInstance, {
                  scope: modalScope,
                  deferred: modalResultDeferred,
                  renderDeferred: modalRenderDeferred,
                  content: tplAndVars[0],
                  animation: modalOptions.animation,
                  backdrop: modalOptions.backdrop,
                  keyboard: modalOptions.keyboard,
                  backdropClass: modalOptions.backdropClass,
                  windowTopClass: modalOptions.windowTopClass,
                  windowClass: modalOptions.windowClass,
                  windowTemplateUrl: modalOptions.windowTemplateUrl,
                  size: modalOptions.size,
                  openedClass: modalOptions.openedClass
                });
                modalOpenedDeferred.resolve(true);

            }, function resolveError(reason) {
              modalOpenedDeferred.reject(reason);
              modalResultDeferred.reject(reason);
            })
            .finally(function() {
              if (promiseChain === samePromise) {
                promiseChain = null;
              }
            });

            return modalInstance;
          };

          return $modal;
        }
      ]
    };

    return $modalProvider;
  });

/* deprecated modal below */

angular.module('ui.bootstrap.modal')

  .value('$modalSuppressWarning', false)

  /**
   * A helper directive for the $modal service. It creates a backdrop element.
   */
  .directive('modalBackdrop', [
    '$animate', '$injector', '$modalStack', '$log', '$modalSuppressWarning',
    function($animate ,  $injector,   $modalStack, $log, $modalSuppressWarning) {
      var $animateCss = null;

      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }

      return {
        replace: true,
        templateUrl: 'template/modal/backdrop.html',
        compile: function(tElement, tAttrs) {
          tElement.addClass(tAttrs.backdropClass);
          return linkFn;
        }
      };

      function linkFn(scope, element, attrs) {
        if (!$modalSuppressWarning) {
          $log.warn('modal-backdrop is now deprecated. Use uib-modal-backdrop instead.');
        }
        element.addClass('modal-backdrop');

        if (attrs.modalInClass) {
          if ($animateCss) {
            $animateCss(element, {
              addClass: attrs.modalInClass
            }).start();
          } else {
            $animate.addClass(element, attrs.modalInClass);
          }

          scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            if ($animateCss) {
              $animateCss(element, {
                removeClass: attrs.modalInClass
              }).start().then(done);
            } else {
              $animate.removeClass(element, attrs.modalInClass).then(done);
            }
          });
        }
      }
    }])

  .directive('modalWindow', [
    '$modalStack', '$q', '$animate', '$injector', '$log', '$modalSuppressWarning',
    function($modalStack ,  $q ,  $animate,   $injector, $log, $modalSuppressWarning) {
      var $animateCss = null;

      if ($injector.has('$animateCss')) {
        $animateCss = $injector.get('$animateCss');
      }

      return {
        scope: {
          index: '@'
        },
        replace: true,
        transclude: true,
        templateUrl: function(tElement, tAttrs) {
          return tAttrs.templateUrl || 'template/modal/window.html';
        },
        link: function(scope, element, attrs) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-window is now deprecated. Use uib-modal-window instead.');
          }
          element.addClass(attrs.windowClass || '');
          element.addClass(attrs.windowTopClass || '');
          scope.size = attrs.size;

          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && (evt.target === evt.currentTarget)) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };

          // moved from template to fix issue #2280
          element.on('click', scope.close);

          // This property is only added to the scope for the purpose of detecting when this directive is rendered.
          // We can detect that by using this property in the template associated with this directive and then use
          // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
          scope.$isRendered = true;

          // Deferred object that will be resolved when this modal is render.
          var modalRenderDeferObj = $q.defer();
          // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
          // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
          attrs.$observe('modalRender', function(value) {
            if (value == 'true') {
              modalRenderDeferObj.resolve();
            }
          });

          modalRenderDeferObj.promise.then(function() {
            var animationPromise = null;

            if (attrs.modalInClass) {
              if ($animateCss) {
                animationPromise = $animateCss(element, {
                  addClass: attrs.modalInClass
                }).start();
              } else {
                animationPromise = $animate.addClass(element, attrs.modalInClass);
              }

              scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                var done = setIsAsync();
                if ($animateCss) {
                  $animateCss(element, {
                    removeClass: attrs.modalInClass
                  }).start().then(done);
                } else {
                  $animate.removeClass(element, attrs.modalInClass).then(done);
                }
              });
            }


            $q.when(animationPromise).then(function() {
              var inputWithAutofocus = element[0].querySelector('[autofocus]');
              /**
               * Auto-focusing of a freshly-opened modal element causes any child elements
               * with the autofocus attribute to lose focus. This is an issue on touch
               * based devices which will show and then hide the onscreen keyboard.
               * Attempts to refocus the autofocus element via JavaScript will not reopen
               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
               * the modal element if the modal does not contain an autofocus element.
               */
              if (inputWithAutofocus) {
                inputWithAutofocus.focus();
              } else {
                element[0].focus();
              }
            });

            // Notify {@link $modalStack} that modal is rendered.
            var modal = $modalStack.getTop();
            if (modal) {
              $modalStack.modalRendered(modal.key);
            }
          });
        }
      };
    }])

  .directive('modalAnimationClass', [
    '$log', '$modalSuppressWarning',
    function ($log, $modalSuppressWarning) {
      return {
        compile: function(tElement, tAttrs) {
          if (!$modalSuppressWarning) {
            $log.warn('modal-animation-class is now deprecated. Use uib-modal-animation-class instead.');
          }
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }
      };
    }])

  .directive('modalTransclude', [
    '$log', '$modalSuppressWarning',
    function ($log, $modalSuppressWarning) {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        if (!$modalSuppressWarning) {
          $log.warn('modal-transclude is now deprecated. Use uib-modal-transclude instead.');
        }
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  }])

  .service('$modalStack', [
    '$animate', '$timeout', '$document', '$compile', '$rootScope',
    '$q',
    '$injector',
    '$$multiMap',
    '$$stackedMap',
    '$uibModalStack',
    '$log',
    '$modalSuppressWarning',
    function($animate ,  $timeout ,  $document ,  $compile ,  $rootScope ,
             $q,
             $injector,
             $$multiMap,
             $$stackedMap,
             $uibModalStack,
             $log,
             $modalSuppressWarning) {
      if (!$modalSuppressWarning) {
        $log.warn('$modalStack is now deprecated. Use $uibModalStack instead.');
      }

      angular.extend(this, $uibModalStack);
    }])

  .provider('$modal', ['$uibModalProvider', function($uibModalProvider) {
    angular.extend(this, $uibModalProvider);

    this.$get = ['$injector', '$log', '$modalSuppressWarning',
      function ($injector, $log, $modalSuppressWarning) {
        if (!$modalSuppressWarning) {
          $log.warn('$modal is now deprecated. Use $uibModal instead.');
        }

        return $injector.invoke($uibModalProvider.$get);
      }];
  }]);

angular.module('ui.bootstrap.pagination', [])
.controller('UibPaginationController', ['$scope', '$attrs', '$parse', function($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch('totalItems', function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch('totalPages', function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page > value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if (evt) {
      evt.preventDefault();
    }

    var clickAllowed = !$scope.ngDisabled || !evt;
    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      if (evt && evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };

  $scope.noPrevious = function() {
    return $scope.page === 1;
  };

  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])

.constant('uibPaginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, paginationConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['uibPagination', '?ngModel'],
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pagination.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && ! rotate) {
          if (startPage > 1) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if (endPage < totalPages) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant('uibPagerConfig', {
  itemsPerPage: 10,
  previousText: ' Previous',
  nextText: 'Next ',
  align: true
})

.directive('uibPager', ['uibPagerConfig', function(pagerConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['uibPager', '?ngModel'],
    controller: 'UibPaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pager.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/* Deprecated Pagination Below */

angular.module('ui.bootstrap.pagination')
.value('$paginationSuppressWarning', false)
.controller('PaginationController', ['$scope', '$attrs', '$parse', '$log', '$paginationSuppressWarning', function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {
  if (!$paginationSuppressWarning) {
    $log.warn('PaginationController is now deprecated. Use UibPaginationController instead.');
  }

  var self = this,
    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
    setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch('totalItems', function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch('totalPages', function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page > value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if (evt) {
      evt.preventDefault();
    }

    var clickAllowed = !$scope.ngDisabled || !evt;
    if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      if (evt && evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function(key) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };

  $scope.noPrevious = function() {
    return $scope.page === 1;
  };

  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])
.directive('pagination', ['$parse', 'uibPaginationConfig', '$log', '$paginationSuppressWarning', function($parse, paginationConfig, $log, $paginationSuppressWarning) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      ngDisabled:'='
    },
    require: ['pagination', '?ngModel'],
    controller: 'PaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pagination.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      if (!$paginationSuppressWarning) {
        $log.warn('pagination is now deprecated. Use uib-pagination instead.');
      }
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;

        // recompute if maxSize
        if (isMaxSized) {
          if (rotate) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if (isMaxSized && ! rotate) {
          if (startPage > 1) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if (endPage < totalPages) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.directive('pager', ['uibPagerConfig', '$log', '$paginationSuppressWarning', function(pagerConfig, $log, $paginationSuppressWarning) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@',
      ngDisabled: '='
    },
    require: ['pager', '?ngModel'],
    controller: 'PaginationController',
    controllerAs: 'pagination',
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/pagination/pager.html';
    },
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      if (!$paginationSuppressWarning) {
        $log.warn('pager is now deprecated. Use uib-pager instead.');
      }
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider('$uibTooltip', function() {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0,
    popupCloseDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur',
    'none': ''
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function(value) {
		angular.extend(globalOptions, value);
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers(triggers) {
    angular.extend(triggerMap, triggers);
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name) {
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
    var openedTooltips = $$stackedMap.createNew();
    $document.on('keypress', function(e) {
      if (e.which === 27) {
        var last = openedTooltips.top();
        if (last) {
          last.value.close();
          openedTooltips.removeTop();
          last = null;
        }
      }
    });

    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
      options = angular.extend({}, defaultOptions, globalOptions, options);

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers(trigger) {
        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
        var hide = show.map(function(trigger) {
          return triggerMap[trigger] || trigger;
        });
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case(ttType);

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        '<div '+ directiveName + '-popup '+
          'title="' + startSym + 'title' + endSym + '" '+
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="' + startSym + 'content' + endSym + '" ') +
          'placement="' + startSym + 'placement' + endSym + '" '+
          'popup-class="' + startSym + 'popupClass' + endSym + '" '+
          'animation="animation" ' +
          'is-open="isOpen"' +
          'origin-scope="origScope" ' +
          'style="visibility: hidden; display: block; top: -9999px; left: -9999px;"' +
          '>' +
        '</div>';

      return {
        compile: function(tElem, tAttrs) {
          var tooltipLinker = $compile(template);

          return function link(scope, element, attrs, tooltipCtrl) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var showTimeout;
            var hideTimeout;
            var positionTimeout;
            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
            var triggers = getTriggers(undefined);
            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
            var ttScope = scope.$new(true);
            var repositionScheduled = false;
            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
            var observers = [];

            var positionTooltip = function() {
              // check if tooltip exists and is not empty
              if (!tooltip || !tooltip.html()) { return; }

              if (!positionTimeout) {
                positionTimeout = $timeout(function() {
                  // Reset the positioning.
                  tooltip.css({ top: 0, left: 0 });

                  // Now set the calculated positioning.
                  var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                  ttCss.top += 'px';
                  ttCss.left += 'px';
                  ttCss.visibility = 'visible';
                  tooltip.css(ttCss);

                  positionTimeout = null;
                }, 0, false);
              }
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;
            openedTooltips.add(ttScope, {
              close: hide
            });

            function toggleTooltipBind() {
              if (!ttScope.isOpen) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                return;
              }

              cancelHide();
              prepareTooltip();

              if (ttScope.popupDelay) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!showTimeout) {
                  showTimeout = $timeout(show, ttScope.popupDelay, false);
                }
              } else {
                show();
              }
            }

            function hideTooltipBind() {
              cancelShow();

              if (ttScope.popupCloseDelay) {
                if (!hideTimeout) {
                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                }
              } else {
                hide();
              }
            }

            // Show the tooltip popup element.
            function show() {
              cancelShow();
              cancelHide();

              // Don't show empty tooltips.
              if (!ttScope.content) {
                return angular.noop;
              }

              createTooltip();

              // And show the tooltip.
              ttScope.$evalAsync(function() {
                ttScope.isOpen = true;
                assignIsOpen(true);
                positionTooltip();
              });
            }

            function cancelShow() {
              if (showTimeout) {
                $timeout.cancel(showTimeout);
                showTimeout = null;
              }

              if (positionTimeout) {
                $timeout.cancel(positionTimeout);
                positionTimeout = null;
              }
            }

            // Hide the tooltip popup element.
            function hide() {
              cancelShow();
              cancelHide();

              if (!ttScope) {
                return;
              }

              // First things first: we don't show it anymore.
              ttScope.$evalAsync(function() {
                ttScope.isOpen = false;
                assignIsOpen(false);
                // And now we remove it from the DOM. However, if we have animation, we
                // need to wait for it to expire beforehand.
                // FIXME: this is a placeholder for a port of the transitions library.
                // The fade transition in TWBS is 150ms.
                if (ttScope.animation) {
                  if (!transitionTimeout) {
                    transitionTimeout = $timeout(removeTooltip, 150, false);
                  }
                } else {
                  removeTooltip();
                }
              });
            }

            function cancelHide() {
              if (hideTimeout) {
                $timeout.cancel(hideTimeout);
                hideTimeout = null;
              }
              if (transitionTimeout) {
                $timeout.cancel(transitionTimeout);
                transitionTimeout = null;
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                return;
              }

              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                if (appendToBody) {
                  $document.find('body').append(tooltip);
                } else {
                  element.after(tooltip);
                }
              });

              prepObservers();
            }

            function removeTooltip() {
              unregisterObservers();

              transitionTimeout = null;
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            /**
             * Set the inital scope values. Once
             * the tooltip is created, the observers
             * will be added to keep things in synch.
             */
            function prepareTooltip() {
              ttScope.title = attrs[prefix + 'Title'];
              if (contentParse) {
                ttScope.content = contentParse(scope);
              } else {
                ttScope.content = attrs[ttType];
              }

              ttScope.popupClass = attrs[prefix + 'Class'];
              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;

              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
            }

            function assignIsOpen(isOpen) {
              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                isOpenParse.assign(scope, isOpen);
              }
            }

            ttScope.contentExp = function() {
              return ttScope.content;
            };

            /**
             * Observe the relevant attributes.
             */
            attrs.$observe('disabled', function(val) {
              if (val) {
                cancelShow();
              }

              if (val && ttScope.isOpen) {
                hide();
              }
            });

            if (isOpenParse) {
              scope.$watch(isOpenParse, function(val) {
                /*jshint -W018 */
                if (ttScope && !val === ttScope.isOpen) {
                  toggleTooltipBind();
                }
                /*jshint +W018 */
              });
            }

            function prepObservers() {
              observers.length = 0;

              if (contentParse) {
                observers.push(
                  scope.$watch(contentParse, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    }
                  })
                );

                observers.push(
                  tooltipLinkedScope.$watch(function() {
                    if (!repositionScheduled) {
                      repositionScheduled = true;
                      tooltipLinkedScope.$$postDigest(function() {
                        repositionScheduled = false;
                        if (ttScope && ttScope.isOpen) {
                          positionTooltip();
                        }
                      });
                    }
                  })
                );
              } else {
                observers.push(
                  attrs.$observe(ttType, function(val) {
                    ttScope.content = val;
                    if (!val && ttScope.isOpen) {
                      hide();
                    } else {
                      positionTooltip();
                    }
                  })
                );
              }

              observers.push(
                attrs.$observe(prefix + 'Title', function(val) {
                  ttScope.title = val;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );

              observers.push(
                attrs.$observe(prefix + 'Placement', function(val) {
                  ttScope.placement = val ? val : options.placement;
                  if (ttScope.isOpen) {
                    positionTooltip();
                  }
                })
              );
            }

            function unregisterObservers() {
              if (observers.length) {
                angular.forEach(observers, function(observer) {
                  observer();
                });
                observers.length = 0;
              }
            }

            var unregisterTriggers = function() {
              triggers.show.forEach(function(trigger) {
                element.unbind(trigger, showTooltipBind);
              });
              triggers.hide.forEach(function(trigger) {
                trigger.split(' ').forEach(function(hideTrigger) {
                  element[0].removeEventListener(hideTrigger, hideTooltipBind);
                });
              });
            };

            function prepTriggers() {
              var val = attrs[prefix + 'Trigger'];
              unregisterTriggers();

              triggers = getTriggers(val);

              if (triggers.show !== 'none') {
                triggers.show.forEach(function(trigger, idx) {
                  // Using raw addEventListener due to jqLite/jQuery bug - #4060
                  if (trigger === triggers.hide[idx]) {
                    element[0].addEventListener(trigger, toggleTooltipBind);
                  } else if (trigger) {
                    element[0].addEventListener(trigger, showTooltipBind);
                    triggers.hide[idx].split(' ').forEach(function(trigger) {
                      element[0].addEventListener(trigger, hideTooltipBind);
                    });
                  }

                  element.on('keypress', function(e) {
                    if (e.which === 27) {
                      hideTooltipBind();
                    }
                  });
                });
              }
            }

            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // if a tooltip is attached to <body> we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if (appendToBody) {
              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                if (ttScope.isOpen) {
                  hide();
                }
              });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              cancelShow();
              cancelHide();
              unregisterTriggers();
              removeTooltip();
              openedTooltips.remove(ttScope);
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive('uibTooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate ,  $sce ,  $compile ,  $templateRequest) {
  return {
    link: function(scope, elem, attrs) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }

        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }

        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('uibTooltipClasses', function() {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      if (scope.placement) {
        element.addClass(scope.placement);
      }

      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }

      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
})

.directive('uibTooltipPopup', function() {
  return {
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html',
    link: function(scope, element) {
      element.addClass('tooltip');
    }
  };
})

.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
}])

.directive('uibTooltipTemplatePopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/tooltip/tooltip-template-popup.html',
    link: function(scope, element) {
      element.addClass('tooltip');
    }
  };
})

.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('uibTooltipHtmlPopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-popup.html',
    link: function(scope, element) {
      element.addClass('tooltip');
    }
  };
})

.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/* Deprecated tooltip below */

angular.module('ui.bootstrap.tooltip')

.value('$tooltipSuppressWarning', false)

.provider('$tooltip', ['$uibTooltipProvider', function($uibTooltipProvider) {
  angular.extend(this, $uibTooltipProvider);

  this.$get = ['$log', '$tooltipSuppressWarning', '$injector', function($log, $tooltipSuppressWarning, $injector) {
    if (!$tooltipSuppressWarning) {
      $log.warn('$tooltip is now deprecated. Use $uibTooltip instead.');
    }

    return $injector.invoke($uibTooltipProvider.$get);
  }];
}])

// This is mostly ngInclude code but with a custom scope
.directive('tooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest', '$log', '$tooltipSuppressWarning',
function ($animate ,  $sce ,  $compile ,  $templateRequest,   $log,   $tooltipSuppressWarning) {
  return {
    link: function(scope, elem, attrs) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.');
      }

      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }
        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }
        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

.directive('tooltipClasses', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-classes is now deprecated. Use uib-tooltip-classes instead.');
      }

      if (scope.placement) {
        element.addClass(scope.placement);
      }
      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }
      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
}])

.directive('tooltipPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html',
    link: function(scope, element) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-popup is now deprecated. Use uib-tooltip-popup instead.');
      }

      element.addClass('tooltip');
    }
  };
}])

.directive('tooltip', ['$tooltip', function($tooltip) {
  return $tooltip('tooltip', 'tooltip', 'mouseenter');
}])

.directive('tooltipTemplatePopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/tooltip/tooltip-template-popup.html',
    link: function(scope, element) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead.');
      }

      element.addClass('tooltip');
    }
  };
}])

.directive('tooltipTemplate', ['$tooltip', function($tooltip) {
  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive('tooltipHtmlPopup', ['$log', '$tooltipSuppressWarning', function($log, $tooltipSuppressWarning) {
  return {
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-popup.html',
    link: function(scope, element) {
      if (!$tooltipSuppressWarning) {
        $log.warn('tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead.');
      }

      element.addClass('tooltip');
    }
  };
}])

.directive('tooltipHtml', ['$tooltip', function($tooltip) {
  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, and selector delegatation.
 */
angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])

.directive('uibPopoverTemplatePopup', function() {
  return {
    replace: true,
    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/popover/popover-template.html',
    link: function(scope, element) {
      element.addClass('popover');
    }
  };
})

.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverHtmlPopup', function() {
  return {
    replace: true,
    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover-html.html',
    link: function(scope, element) {
      element.addClass('popover');
    }
  };
})

.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('uibPopoverPopup', function() {
  return {
    replace: true,
    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html',
    link: function(scope, element) {
      element.addClass('popover');
    }
  };
})

.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {
  return $uibTooltip('uibPopover', 'popover', 'click');
}]);

/* Deprecated popover below */

angular.module('ui.bootstrap.popover')

.value('$popoverSuppressWarning', false)

.directive('popoverTemplatePopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
  return {
    replace: true,
    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/popover/popover-template.html',
    link: function(scope, element) {
      if (!$popoverSuppressWarning) {
        $log.warn('popover-template-popup is now deprecated. Use uib-popover-template-popup instead.');
      }

      element.addClass('popover');
    }
  };
}])

.directive('popoverTemplate', ['$tooltip', function($tooltip) {
  return $tooltip('popoverTemplate', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('popoverHtmlPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
  return {
    replace: true,
    scope: { contentExp: '&', title: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover-html.html',
    link: function(scope, element) {
      if (!$popoverSuppressWarning) {
        $log.warn('popover-html-popup is now deprecated. Use uib-popover-html-popup instead.');
      }

      element.addClass('popover');
    }
  };
}])

.directive('popoverHtml', ['$tooltip', function($tooltip) {
  return $tooltip('popoverHtml', 'popover', 'click', {
    useContentExp: true
  });
}])

.directive('popoverPopup', ['$log', '$popoverSuppressWarning', function($log, $popoverSuppressWarning) {
  return {
    replace: true,
    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html',
    link: function(scope, element) {
      if (!$popoverSuppressWarning) {
        $log.warn('popover-popup is now deprecated. Use uib-popover-popup instead.');
      }

      element.addClass('popover');
    }
  };
}])

.directive('popover', ['$tooltip', function($tooltip) {

  return $tooltip('popover', 'popover', 'click');
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('uibProgressConfig', {
  animate: true,
  max: 100
})

.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {
  var self = this,
      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = $scope.max;
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      var totalPercentage = self.bars.reduce(function(total, bar) {
        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
    this.bars.forEach(function (bar) {
      bar.recalculatePercentage();
    });
  };

  $scope.$watch('max', function(max) {
    self.bars.forEach(function(bar) {
      bar.max = $scope.max;
      bar.recalculatePercentage();
    });
  });
}])

.directive('uibProgress', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    require: 'uibProgress',
    scope: {
      max: '=?'
    },
    templateUrl: 'template/progressbar/progress.html'
  };
})

.directive('uibBar', function() {
  return {
    replace: true,
    transclude: true,
    require: '^uibProgress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, element, attrs);
    }
  };
})

.directive('uibProgressbar', function() {
  return {
    replace: true,
    transclude: true,
    controller: 'UibProgressController',
    scope: {
      value: '=',
      max: '=?',
      type: '@'
    },
    templateUrl: 'template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
});

/* Deprecated progressbar below */

angular.module('ui.bootstrap.progressbar')

.value('$progressSuppressWarning', false)

.controller('ProgressController', ['$scope', '$attrs', 'uibProgressConfig', '$log', '$progressSuppressWarning', function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {
  if (!$progressSuppressWarning) {
    $log.warn('ProgressController is now deprecated. Use UibProgressController instead.');
  }

  var self = this,
    animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

  this.bars = [];
  $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

  this.addBar = function(bar, element, attrs) {
    if (!animate) {
      element.css({'transition': 'none'});
    }

    this.bars.push(bar);

    bar.max = $scope.max;
    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';

    bar.$watch('value', function(value) {
      bar.recalculatePercentage();
    });

    bar.recalculatePercentage = function() {
      bar.percent = +(100 * bar.value / bar.max).toFixed(2);

      var totalPercentage = self.bars.reduce(function(total, bar) {
        return total + bar.percent;
      }, 0);

      if (totalPercentage > 100) {
        bar.percent -= totalPercentage - 100;
      }
    };

    bar.$on('$destroy', function() {
      element = null;
      self.removeBar(bar);
    });
  };

  this.removeBar = function(bar) {
    this.bars.splice(this.bars.indexOf(bar), 1);
  };

  $scope.$watch('max', function(max) {
    self.bars.forEach(function(bar) {
      bar.max = $scope.max;
      bar.recalculatePercentage();
    });
  });
}])

.directive('progress', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    controller: 'ProgressController',
    require: 'progress',
    scope: {
      max: '=?',
      title: '@?'
    },
    templateUrl: 'template/progressbar/progress.html',
    link: function() {
      if (!$progressSuppressWarning) {
        $log.warn('progress is now deprecated. Use uib-progress instead.');
      }
    }
  };
}])

.directive('bar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    require: '^progress',
    scope: {
      value: '=',
      type: '@'
    },
    templateUrl: 'template/progressbar/bar.html',
    link: function(scope, element, attrs, progressCtrl) {
      if (!$progressSuppressWarning) {
        $log.warn('bar is now deprecated. Use uib-bar instead.');
      }
      progressCtrl.addBar(scope, element);
    }
  };
}])

.directive('progressbar', ['$log', '$progressSuppressWarning', function($log, $progressSuppressWarning) {
  return {
    replace: true,
    transclude: true,
    controller: 'ProgressController',
    scope: {
      value: '=',
      max: '=?',
      type: '@'
    },
    templateUrl: 'template/progressbar/progressbar.html',
    link: function(scope, element, attrs, progressCtrl) {
      if (!$progressSuppressWarning) {
        $log.warn('progressbar is now deprecated. Use uib-progressbar instead.');
      }
      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});
    }
  };
}]);

angular.module('ui.bootstrap.rating', [])

.constant('uibRatingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null,
  titles : ['one', 'two', 'three', 'four', 'five']
})

.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl  = { $setViewValue: angular.noop };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) && value << 0 !== value) {
        value = Math.round(value);
      }
      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    var tmpTitles = angular.isDefined($attrs.titles)  ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles ;
    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?
      tmpTitles : ratingConfig.titles;

    var ratingStates = angular.isDefined($attrs.ratingStates) ?
      $scope.$parent.$eval($attrs.ratingStates) :
      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);
    }
    return states;
  };

  this.getTitle = function(index) {
    if (index >= this.titles.length) {
      return index + 1;
    } else {
      return this.titles[index];
    }
  };

  $scope.rate = function(value) {
    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
      ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if (!$scope.readonly) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
  };
}])

.directive('uibRating', function() {
  return {
    require: ['uibRating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'UibRatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
});

/* Deprecated rating below */

angular.module('ui.bootstrap.rating')

.value('$ratingSuppressWarning', false)

.controller('RatingController', ['$scope', '$attrs', '$controller', '$log', '$ratingSuppressWarning', function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {
  if (!$ratingSuppressWarning) {
    $log.warn('RatingController is now deprecated. Use UibRatingController instead.');
  }

  angular.extend(this, $controller('UibRatingController', {
    $scope: $scope,
    $attrs: $attrs
  }));
}])

.directive('rating', ['$log', '$ratingSuppressWarning', function($log, $ratingSuppressWarning) {
  return {
    require: ['rating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      if (!$ratingSuppressWarning) {
        $log.warn('rating is now deprecated. Use uib-rating instead.');
      }
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init(ngModelCtrl);
    }
  };
}]);


/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.controller('UibTabsetController', ['$scope', function ($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active && tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
        selectedTab.selectCalled = false;
      }
    });
    selectedTab.active = true;
    // only call select if it has not already been called
    if (!selectedTab.selectCalled) {
      selectedTab.onSelect();
      selectedTab.selectCalled = true;
    }
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can't run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1 && tab.active !== false) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    } else {
      tab.active = false;
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active && tabs.length > 1 && !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <uib-tabset>
      <uib-tab heading="Tab 1"><b>First</b> Content!</uib-tab>
      <uib-tab heading="Tab 2"><i>Second</i> Content!</uib-tab>
    </uib-tabset>
    <hr />
    <uib-tabset vertical="true">
      <uib-tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</uib-tab>
      <uib-tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</uib-tab>
    </uib-tabset>
    <uib-tabset justified="true">
      <uib-tab heading="Justified Tab 1"><b>First</b> Justified Content!</uib-tab>
      <uib-tab heading="Justified Tab 2"><i>Second</i> Justified Content!</uib-tab>
    </uib-tabset>
  </file>
</example>
 */
.directive('uibTabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {
      type: '@'
    },
    controller: 'UibTabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <uib-tabset>
        <uib-tab heading="Tab 1">First Tab</uib-tab>
        <uib-tab select="alertMe()">
          <uib-tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </uib-tab>
        <uib-tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </uib-tab>
      </uib-tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <uib-tabset>
      <uib-tab>
        <uib-tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </uib-tab>
      <uib-tab>
        <uib-tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </uib-tab>
    </uib-tabset>
  </file>
</example>
 */
.directive('uibTab', ['$parse', function($parse) {
  return {
    require: '^uibTabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      active: '=?',
      heading: '@',
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    link: function(scope, elm, attrs, tabsetCtrl, transclude) {
      scope.$watch('active', function(active) {
        if (active) {
          tabsetCtrl.select(scope);
        }
      });

      scope.disabled = false;
      if (attrs.disable) {
        scope.$parent.$watch($parse(attrs.disable), function(value) {
          scope.disabled = !! value;
        });
      }

      scope.select = function() {
        if (!scope.disabled) {
          scope.active = true;
        }
      };

      tabsetCtrl.addTab(scope);
      scope.$on('$destroy', function() {
        tabsetCtrl.removeTab(scope);
      });

      //We need to transclude later, once the content container is ready.
      //when this link happens, we're inside a tab heading.
      scope.$transcludeFn = transclude;
    }
  };
}])

.directive('uibTabHeadingTransclude', function() {
  return {
    restrict: 'A',
    require: ['?^uibTab', '?^tab'], // TODO: change to '^uibTab' after deprecation removal
    link: function(scope, elm) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
})

.directive('uibTabContentTransclude', function() {
  return {
    restrict: 'A',
    require: ['?^uibTabset', '?^tabset'], // TODO: change to '^uibTabset' after deprecation removal
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.uibTabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };

  function isTabHeading(node) {
    return node.tagName && (
      node.hasAttribute('tab-heading') || // TODO: remove after deprecation removal
      node.hasAttribute('data-tab-heading') || // TODO: remove after deprecation removal
      node.hasAttribute('x-tab-heading') || // TODO: remove after deprecation removal
      node.hasAttribute('uib-tab-heading') ||
      node.hasAttribute('data-uib-tab-heading') ||
      node.hasAttribute('x-uib-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' || // TODO: remove after deprecation removal
      node.tagName.toLowerCase() === 'data-tab-heading' || // TODO: remove after deprecation removal
      node.tagName.toLowerCase() === 'x-tab-heading' || // TODO: remove after deprecation removal
      node.tagName.toLowerCase() === 'uib-tab-heading' ||
      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||
      node.tagName.toLowerCase() === 'x-uib-tab-heading'
    );
  }
});

/* deprecated tabs below */

angular.module('ui.bootstrap.tabs')

  .value('$tabsSuppressWarning', false)

  .controller('TabsetController', ['$scope', '$controller', '$log', '$tabsSuppressWarning', function($scope, $controller, $log, $tabsSuppressWarning) {
    if (!$tabsSuppressWarning) {
      $log.warn('TabsetController is now deprecated. Use UibTabsetController instead.');
    }

    angular.extend(this, $controller('UibTabsetController', {
      $scope: $scope
    }));
  }])

  .directive('tabset', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
    return {
      restrict: 'EA',
      transclude: true,
      replace: true,
      scope: {
        type: '@'
      },
      controller: 'TabsetController',
      templateUrl: 'template/tabs/tabset.html',
      link: function(scope, element, attrs) {

        if (!$tabsSuppressWarning) {
          $log.warn('tabset is now deprecated. Use uib-tabset instead.');
        }
        scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
        scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
      }
    };
  }])

  .directive('tab', ['$parse', '$log', '$tabsSuppressWarning', function($parse, $log, $tabsSuppressWarning) {
    return {
      require: '^tabset',
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/tabs/tab.html',
      transclude: true,
      scope: {
        active: '=?',
        heading: '@',
        onSelect: '&select', //This callback is called in contentHeadingTransclude
        //once it inserts the tab's content into the dom
        onDeselect: '&deselect'
      },
      controller: function() {
        //Empty controller so other directives can require being 'under' a tab
      },
      link: function(scope, elm, attrs, tabsetCtrl, transclude) {
        if (!$tabsSuppressWarning) {
          $log.warn('tab is now deprecated. Use uib-tab instead.');
        }

        scope.$watch('active', function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });

        scope.disabled = false;
        if (attrs.disable) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !!value;
          });
        }

        scope.select = function() {
          if (!scope.disabled) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });

        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      }
    };
  }])

  .directive('tabHeadingTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
    return {
      restrict: 'A',
      require: '^tab',
      link: function(scope, elm) {
        if (!$tabsSuppressWarning) {
          $log.warn('tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead.');
        }

        scope.$watch('headingElement', function updateHeadingElement(heading) {
          if (heading) {
            elm.html('');
            elm.append(heading);
          }
        });
      }
    };
  }])

  .directive('tabContentTransclude', ['$log', '$tabsSuppressWarning', function($log, $tabsSuppressWarning) {
    return {
      restrict: 'A',
      require: '^tabset',
      link: function(scope, elm, attrs) {
        if (!$tabsSuppressWarning) {
          $log.warn('tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.');
        }

        var tab = scope.$eval(attrs.tabContentTransclude);

        //Now our tab is ready to be transcluded: both the tab heading area
        //and the tab content area are loaded.  Transclude 'em both.
        tab.$transcludeFn(tab.$parent, function(contents) {
          angular.forEach(contents, function(node) {
            if (isTabHeading(node)) {
              //Let tabHeadingTransclude know.
              tab.headingElement = node;
            }
            else {
              elm.append(node);
            }
          });
        });
      }
    };

    function isTabHeading(node) {
      return node.tagName && (
          node.hasAttribute('tab-heading') ||
          node.hasAttribute('data-tab-heading') ||
          node.hasAttribute('x-tab-heading') ||
          node.tagName.toLowerCase() === 'tab-heading' ||
          node.tagName.toLowerCase() === 'data-tab-heading' ||
          node.tagName.toLowerCase() === 'x-tab-heading'
        );
    }
  }]);

angular.module('ui.bootstrap.timepicker', [])

.constant('uibTimepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  mousewheel: true,
  arrowkeys: true,
  showSpinners: true
})

.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
  $element.removeAttr('tabindex');

  this.init = function(ngModelCtrl_, inputs) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function(modelValue) {
      return modelValue ? new Date(modelValue) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if (mousewheel) {
      this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl);
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents(hoursInputEl, minutesInputEl);
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = parseInt(value, 10);
    });
  }

  var min;
  $scope.$parent.$watch($parse($attrs.min), function(value) {
    var dt = new Date(value);
    min = isNaN(dt) ? undefined : dt;
  });

  var max;
  $scope.$parent.$watch($parse($attrs.max), function(value) {
    var dt = new Date(value);
    max = isNaN(dt) ? undefined : dt;
  });

  $scope.noIncrementHours = function() {
    var incrementedSelected = addMinutes(selected, hourStep * 60);
    return incrementedSelected > max ||
      (incrementedSelected < selected && incrementedSelected < min);
  };

  $scope.noDecrementHours = function() {
    var decrementedSelected = addMinutes(selected, -hourStep * 60);
    return decrementedSelected < min ||
      (decrementedSelected > selected && decrementedSelected > max);
  };

  $scope.noIncrementMinutes = function() {
    var incrementedSelected = addMinutes(selected, minuteStep);
    return incrementedSelected > max ||
      (incrementedSelected < selected && incrementedSelected < min);
  };

  $scope.noDecrementMinutes = function() {
    var decrementedSelected = addMinutes(selected, -minuteStep);
    return decrementedSelected < min ||
      (decrementedSelected > selected && decrementedSelected > max);
  };

  $scope.noToggleMeridian = function() {
    if (selected.getHours() < 13) {
      return addMinutes(selected, 12 * 60) > max;
    } else {
      return addMinutes(selected, -12 * 60) < min;
    }
  };

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if (ngModelCtrl.$error.time) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
          selected.setHours(hours);
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate() {
    var hours = parseInt($scope.hours, 10);
    var valid = $scope.showMeridian ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
    if (!valid) {
      return undefined;
    }

    if ($scope.showMeridian) {
      if (hours === 12) {
        hours = 0;
      }
      if ($scope.meridian === meridians[1]) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return (minutes >= 0 && minutes < 60) ? minutes : undefined;
  }

  function pad(value) {
    return (angular.isDefined(value) && value.toString().length < 2) ? '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
      return (e.detail || delta > 0);
    };

    hoursInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
      e.preventDefault();
    });

  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
    hoursInputEl.bind('keydown', function(e) {
      if (e.which === 38) { // up
        e.preventDefault();
        $scope.incrementHours();
        $scope.$apply();
      } else if (e.which === 40) { // down
        e.preventDefault();
        $scope.decrementHours();
        $scope.$apply();
      }
    });

    minutesInputEl.bind('keydown', function(e) {
      if (e.which === 38) { // up
        e.preventDefault();
        $scope.incrementMinutes();
        $scope.$apply();
      } else if (e.which === 40) { // down
        e.preventDefault();
        $scope.decrementMinutes();
        $scope.$apply();
      }
    });
  };

  this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
    if ($scope.readonlyInput) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue(null);
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate(),
        minutes = getMinutesFromTemplate();

      if (angular.isDefined(hours) && angular.isDefined(minutes)) {
        selected.setHours(hours);
        if (selected < min || selected > max) {
          invalidate(true);
        } else {
          refresh('h');
        }
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function(e) {
      if (!$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply(function() {
          $scope.hours = pad($scope.hours);
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate(),
        hours = getHoursFromTemplate();

      if (angular.isDefined(minutes) && angular.isDefined(hours)) {
        selected.setMinutes(minutes);
        if (selected < min || selected > max) {
          invalidate(undefined, true);
        } else {
          refresh('m');
        }
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function(e) {
      if (!$scope.invalidMinutes && $scope.minutes < 10) {
        $scope.$apply(function() {
          $scope.minutes = pad($scope.minutes);
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if (isNaN(date)) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if (date) {
        selected = date;
      }

      if (selected < min || selected > max) {
        ngModelCtrl.$setValidity('time', false);
        $scope.invalidHours = true;
        $scope.invalidMinutes = true;
      } else {
        makeValid();
      }
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh(keyboardChange) {
    makeValid();
    ngModelCtrl.$setViewValue(new Date(selected));
    updateTemplate(keyboardChange);
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate(keyboardChange) {
    var hours = selected.getHours(), minutes = selected.getMinutes();

    if ($scope.showMeridian) {
      hours = (hours === 0 || hours === 12) ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
    if (keyboardChange !== 'm') {
      $scope.minutes = pad(minutes);
    }
    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
  }

  function addMinutes(date, minutes) {
    var dt = new Date(date.getTime() + minutes * 60000);
    var newDate = new Date(date);
    newDate.setHours(dt.getHours(), dt.getMinutes());
    return newDate;
  }

  function addMinutesToSelected(minutes) {
    selected = addMinutes(selected, minutes);
    refresh();
  }

  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?
    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;

  $scope.incrementHours = function() {
    if (!$scope.noIncrementHours()) {
      addMinutesToSelected(hourStep * 60);
    }
  };

  $scope.decrementHours = function() {
    if (!$scope.noDecrementHours()) {
      addMinutesToSelected(-hourStep * 60);
    }
  };

  $scope.incrementMinutes = function() {
    if (!$scope.noIncrementMinutes()) {
      addMinutesToSelected(minuteStep);
    }
  };

  $scope.decrementMinutes = function() {
    if (!$scope.noDecrementMinutes()) {
      addMinutesToSelected(-minuteStep);
    }
  };

  $scope.toggleMeridian = function() {
    if (!$scope.noToggleMeridian()) {
      addMinutesToSelected(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
    }
  };
}])

.directive('uibTimepicker', function() {
  return {
    restrict: 'EA',
    require: ['uibTimepicker', '?^ngModel'],
    controller: 'UibTimepickerController',
    controllerAs: 'timepicker',
    replace: true,
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/timepicker/timepicker.html';
    },
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
});

/* Deprecated timepicker below */

angular.module('ui.bootstrap.timepicker')

.value('$timepickerSuppressWarning', false)

.controller('TimepickerController', ['$scope', '$element', '$attrs', '$controller', '$log', '$timepickerSuppressWarning', function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {
  if (!$timepickerSuppressWarning) {
    $log.warn('TimepickerController is now deprecated. Use UibTimepickerController instead.');
  }

  angular.extend(this, $controller('UibTimepickerController', {
    $scope: $scope,
    $element: $element,
    $attrs: $attrs
  }));
}])

.directive('timepicker', ['$log', '$timepickerSuppressWarning', function($log, $timepickerSuppressWarning) {
  return {
    restrict: 'EA',
    require: ['timepicker', '?^ngModel'],
    controller: 'TimepickerController',
    controllerAs: 'timepicker',
    replace: true,
    scope: {},
    templateUrl: function(element, attrs) {
      return attrs.templateUrl || 'template/timepicker/timepicker.html';
    },
    link: function(scope, element, attrs, ctrls) {
      if (!$timepickerSuppressWarning) {
        $log.warn('timepicker is now deprecated. Use uib-timepicker instead.');
      }
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (ngModelCtrl) {
        timepickerCtrl.init(ngModelCtrl, element.find('input'));
      }
    }
  };
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('uibTypeaheadParser', ['$parse', function($parse) {
    //                      00000111000000000000022200000000000000003333333333333330000000000044000
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
      parse: function(input) {
        var match = input.match(TYPEAHEAD_REGEXP);
        if (!match) {
          throw new Error(
            'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
              ' but got "' + input + '".');
        }

        return {
          itemName: match[3],
          source: $parse(match[4]),
          viewMapper: $parse(match[2] || match[1]),
          modelMapper: $parse(match[1])
        };
      }
    };
  }])

  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'uibTypeaheadParser',
    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    var modelCtrl, ngModelOptions;
    //SUPPORTED ATTRIBUTES (OPTIONS)

    //minimal no of characters that needs to be entered before typeahead kicks-in
    var minLength = originalScope.$eval(attrs.typeaheadMinLength);
    if (!minLength && minLength !== 0) {
      minLength = 1;
    }

    //minimal wait time after last character typed before typeahead kicks-in
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

    //should it restrict model values to the ones selected from the popup only?
    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

    //binding to a variable that indicates if matches are being retrieved asynchronously
    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

    //a callback executed when a match is selected
    var onSelectCallback = $parse(attrs.typeaheadOnSelect);

    //should it select highlighted popup value when losing focus?
    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

    //binding to a variable that indicates if there were no results after the query is completed
    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

    var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

    var appendToElementId =  attrs.typeaheadAppendToElementId || false;

    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

    //If input matches an item of the list exactly, select it automatically
    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

    //INTERNAL VARIABLES

    //model setter executed upon match selection
    var parsedModel = $parse(attrs.ngModel);
    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
    var $setModelValue = function(scope, newValue) {
      if (angular.isFunction(parsedModel(originalScope)) &&
        ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
        return invokeModelSetter(scope, {$$$p: newValue});
      } else {
        return parsedModel.assign(scope, newValue);
      }
    };

    //expressions used by typeahead
    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);

    var hasFocus;

    //Used to avoid bug in iOS webview where iOS keyboard does not fire
    //mousedown & mouseup events
    //Issue #3699
    var selected;

    //create a child scope for the typeahead directive so we are not polluting original scope
    //with typeahead-specific data (matches, query etc.)
    var scope = originalScope.$new();
    var offDestroy = originalScope.$on('$destroy', function() {
      scope.$destroy();
    });
    scope.$on('$destroy', offDestroy);

    // WAI-ARIA
    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
    element.attr({
      'aria-autocomplete': 'list',
      'aria-expanded': false,
      'aria-owns': popupId
    });

    //pop-up element used to display matches
    var popUpEl = angular.element('<div uib-typeahead-popup></div>');
    popUpEl.attr({
      id: popupId,
      matches: 'matches',
      active: 'activeIdx',
      select: 'select(activeIdx)',
      'move-in-progress': 'moveInProgress',
      query: 'query',
      position: 'position'
    });
    //custom item template
    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
    }

    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
    }

    var resetMatches = function() {
      scope.matches = [];
      scope.activeIdx = -1;
      element.attr('aria-expanded', false);
    };

    var getMatchId = function(index) {
      return popupId + '-option-' + index;
    };

    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
    // This attribute is added or removed automatically when the `activeIdx` changes.
    scope.$watch('activeIdx', function(index) {
      if (index < 0) {
        element.removeAttr('aria-activedescendant');
      } else {
        element.attr('aria-activedescendant', getMatchId(index));
      }
    });

    var inputIsExactMatch = function(inputValue, index) {
      if (scope.matches.length > index && inputValue) {
        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
      }

      return false;
    };

    var getMatchesAsync = function(inputValue) {
      var locals = {$viewValue: inputValue};
      isLoadingSetter(originalScope, true);
      isNoResultsSetter(originalScope, false);
      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
        //it might happen that several async queries were in progress if a user were typing fast
        //but we are interested only in responses that correspond to the current view value
        var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
        if (onCurrentRequest && hasFocus) {
          if (matches && matches.length > 0) {
            scope.activeIdx = focusFirst ? 0 : -1;
            isNoResultsSetter(originalScope, false);
            scope.matches.length = 0;

            //transform labels
            for (var i = 0; i < matches.length; i++) {
              locals[parserResult.itemName] = matches[i];
              scope.matches.push({
                id: getMatchId(i),
                label: parserResult.viewMapper(scope, locals),
                model: matches[i]
              });
            }

            scope.query = inputValue;
            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
            //due to other elements being rendered
            recalculatePosition();

            element.attr('aria-expanded', true);

            //Select the single remaining option if user input matches
            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
              scope.select(0);
            }
          } else {
            resetMatches();
            isNoResultsSetter(originalScope, true);
          }
        }
        if (onCurrentRequest) {
          isLoadingSetter(originalScope, false);
        }
      }, function() {
        resetMatches();
        isLoadingSetter(originalScope, false);
        isNoResultsSetter(originalScope, true);
      });
    };

    // bind events only if appendToBody params exist - performance feature
    if (appendToBody) {
      angular.element($window).bind('resize', fireRecalculating);
      $document.find('body').bind('scroll', fireRecalculating);
    }

    // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
    var timeoutEventPromise;

    // Default progress type
    scope.moveInProgress = false;

    function fireRecalculating() {
      if (!scope.moveInProgress) {
        scope.moveInProgress = true;
        scope.$digest();
      }

      // Cancel previous timeout
      if (timeoutEventPromise) {
        $timeout.cancel(timeoutEventPromise);
      }

      // Debounced executing recalculate after events fired
      timeoutEventPromise = $timeout(function() {
        // if popup is visible
        if (scope.matches.length) {
          recalculatePosition();
        }

        scope.moveInProgress = false;
      }, eventDebounceTime);
    }

    // recalculate actual position and set new values to scope
    // after digest loop is popup in right position
    function recalculatePosition() {
      scope.position = appendToBody ? $position.offset(element) : $position.position(element);
      scope.position.top += element.prop('offsetHeight');
    }

    //we need to propagate user's query so we can higlight matches
    scope.query = undefined;

    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
    var timeoutPromise;

    var scheduleSearchWithTimeout = function(inputValue) {
      timeoutPromise = $timeout(function() {
        getMatchesAsync(inputValue);
      }, waitTime);
    };

    var cancelPreviousTimeout = function() {
      if (timeoutPromise) {
        $timeout.cancel(timeoutPromise);
      }
    };

    resetMatches();

    scope.select = function(activeIdx) {
      //called from within the $digest() cycle
      var locals = {};
      var model, item;

      selected = true;
      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
      model = parserResult.modelMapper(originalScope, locals);
      $setModelValue(originalScope, model);
      modelCtrl.$setValidity('editable', true);
      modelCtrl.$setValidity('parse', true);

      onSelectCallback(originalScope, {
        $item: item,
        $model: model,
        $label: parserResult.viewMapper(originalScope, locals)
      });

      resetMatches();

      //return focus to the input element if a match was selected via a mouse click event
      // use timeout to avoid $rootScope:inprog error
      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
        $timeout(function() { element[0].focus(); }, 0, false);
      }
    };

    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
    element.bind('keydown', function(evt) {
      //typeahead is open and an "interesting" key was pressed
      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
        return;
      }

      // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
      if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
        resetMatches();
        scope.$digest();
        return;
      }

      evt.preventDefault();

      if (evt.which === 40) {
        scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
        scope.$digest();
      } else if (evt.which === 38) {
        scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
        scope.$digest();
      } else if (evt.which === 13 || evt.which === 9) {
        scope.$apply(function () {
          scope.select(scope.activeIdx);
        });
      } else if (evt.which === 27) {
        evt.stopPropagation();

        resetMatches();
        scope.$digest();
      }
    });

    element.bind('blur', function() {
      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
        selected = true;
        scope.$apply(function() {
          scope.select(scope.activeIdx);
        });
      }
      hasFocus = false;
      selected = false;
    });

    // Keep reference to click handler to unbind it.
    var dismissClickHandler = function(evt) {
      // Issue #3973
      // Firefox treats right click as a click on document
      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
        resetMatches();
        if (!$rootScope.$$phase) {
          scope.$digest();
        }
      }
    };

    $document.bind('click', dismissClickHandler);

    originalScope.$on('$destroy', function() {
      $document.unbind('click', dismissClickHandler);
      if (appendToBody || appendToElementId) {
        $popup.remove();
      }

      if (appendToBody) {
        angular.element($window).unbind('resize', fireRecalculating);
        $document.find('body').unbind('scroll', fireRecalculating);
      }
      // Prevent jQuery cache memory leak
      popUpEl.remove();
    });

    var $popup = $compile(popUpEl)(scope);

    if (appendToBody) {
      $document.find('body').append($popup);
    } else if (appendToElementId !== false) {
      angular.element($document[0].getElementById(appendToElementId)).append($popup);
    } else {
      element.after($popup);
    }

    this.init = function(_modelCtrl, _ngModelOptions) {
      modelCtrl = _modelCtrl;
      ngModelOptions = _ngModelOptions;

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function(inputValue) {
        hasFocus = true;

        if (minLength === 0 || inputValue && inputValue.length >= minLength) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return null;
          } else {
            modelCtrl.$setValidity('editable', false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function(modelValue) {
        var candidateViewValue, emptyViewValue;
        var locals = {};

        // The validity may be set to false via $parsers (see above) if
        // the model is restricted to selected values. If the model
        // is set manually it is considered to be valid.
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }

        if (inputFormatter) {
          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);
        } else {
          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
        }
      });
    };
  }])

  .directive('uibTypeahead', function() {
    return {
      controller: 'UibTypeaheadController',
      require: ['ngModel', '^?ngModelOptions', 'uibTypeahead'],
      link: function(originalScope, element, attrs, ctrls) {
        ctrls[2].init(ctrls[0], ctrls[1]);
      }
    };
  })

  .directive('uibTypeaheadPopup', function() {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          return scope.matches.length > 0;
        };

        scope.isActive = function(matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {
    return {
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link:function(scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement) {
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])

  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is "a" the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
      }
      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }
      return matchItem;
    };
  }]);

/* Deprecated typeahead below */
  
angular.module('ui.bootstrap.typeahead')
  .value('$typeaheadSuppressWarning', false)
  .service('typeaheadParser', ['$parse', 'uibTypeaheadParser', '$log', '$typeaheadSuppressWarning', function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {
    if (!$typeaheadSuppressWarning) {
      $log.warn('typeaheadParser is now deprecated. Use uibTypeaheadParser instead.');
    }

    return uibTypeaheadParser;
  }])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$uibPosition', 'typeaheadParser', '$log', '$typeaheadSuppressWarning',
    function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {
    var HOT_KEYS = [9, 13, 27, 38, 40];
    var eventDebounceTime = 200;
    return {
      require: ['ngModel', '^?ngModelOptions'],
      link: function(originalScope, element, attrs, ctrls) {
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeahead is now deprecated. Use uib-typeahead instead.');
        }
        var modelCtrl = ctrls[0];
        var ngModelOptions = ctrls[1];
        //SUPPORTED ATTRIBUTES (OPTIONS)

        //minimal no of characters that needs to be entered before typeahead kicks-in
        var minLength = originalScope.$eval(attrs.typeaheadMinLength);
        if (!minLength && minLength !== 0) {
          minLength = 1;
        }

        //minimal wait time after last character typed before typeahead kicks-in
        var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

        //should it restrict model values to the ones selected from the popup only?
        var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

        //binding to a variable that indicates if matches are being retrieved asynchronously
        var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

        //a callback executed when a match is selected
        var onSelectCallback = $parse(attrs.typeaheadOnSelect);

        //should it select highlighted popup value when losing focus?
        var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;

        //binding to a variable that indicates if there were no results after the query is completed
        var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;

        var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

        var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

        var appendToElementId =  attrs.typeaheadAppendToElementId || false;

        var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

        //If input matches an item of the list exactly, select it automatically
        var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;

        //INTERNAL VARIABLES

        //model setter executed upon match selection
        var parsedModel = $parse(attrs.ngModel);
        var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
        var $setModelValue = function(scope, newValue) {
          if (angular.isFunction(parsedModel(originalScope)) &&
            ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
            return invokeModelSetter(scope, {$$$p: newValue});
          } else {
            return parsedModel.assign(scope, newValue);
          }
        };

        //expressions used by typeahead
        var parserResult = typeaheadParser.parse(attrs.typeahead);

        var hasFocus;

        //Used to avoid bug in iOS webview where iOS keyboard does not fire
        //mousedown & mouseup events
        //Issue #3699
        var selected;

        //create a child scope for the typeahead directive so we are not polluting original scope
        //with typeahead-specific data (matches, query etc.)
        var scope = originalScope.$new();
        var offDestroy = originalScope.$on('$destroy', function() {
			    scope.$destroy();
        });
        scope.$on('$destroy', offDestroy);

        // WAI-ARIA
        var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
        element.attr({
          'aria-autocomplete': 'list',
          'aria-expanded': false,
          'aria-owns': popupId
        });

        //pop-up element used to display matches
        var popUpEl = angular.element('<div typeahead-popup></div>');
        popUpEl.attr({
          id: popupId,
          matches: 'matches',
          active: 'activeIdx',
          select: 'select(activeIdx)',
          'move-in-progress': 'moveInProgress',
          query: 'query',
          position: 'position'
        });
        //custom item template
        if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
          popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
        }

        if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
          popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
        }

        var resetMatches = function() {
          scope.matches = [];
          scope.activeIdx = -1;
          element.attr('aria-expanded', false);
        };

        var getMatchId = function(index) {
          return popupId + '-option-' + index;
        };

        // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
        // This attribute is added or removed automatically when the `activeIdx` changes.
        scope.$watch('activeIdx', function(index) {
          if (index < 0) {
            element.removeAttr('aria-activedescendant');
          } else {
            element.attr('aria-activedescendant', getMatchId(index));
          }
        });

        var inputIsExactMatch = function(inputValue, index) {
          if (scope.matches.length > index && inputValue) {
            return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
          }

          return false;
        };

        var getMatchesAsync = function(inputValue) {
          var locals = {$viewValue: inputValue};
          isLoadingSetter(originalScope, true);
          isNoResultsSetter(originalScope, false);
          $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            //it might happen that several async queries were in progress if a user were typing fast
            //but we are interested only in responses that correspond to the current view value
            var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
            if (onCurrentRequest && hasFocus) {
              if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1;
                isNoResultsSetter(originalScope, false);
                scope.matches.length = 0;

                //transform labels
                for (var i = 0; i < matches.length; i++) {
                  locals[parserResult.itemName] = matches[i];
                  scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                  });
                }

                scope.query = inputValue;
                //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                //due to other elements being rendered
                recalculatePosition();

                element.attr('aria-expanded', true);

                //Select the single remaining option if user input matches
                if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                  scope.select(0);
                }
              } else {
                resetMatches();
                isNoResultsSetter(originalScope, true);
              }
            }
            if (onCurrentRequest) {
              isLoadingSetter(originalScope, false);
            }
          }, function() {
            resetMatches();
            isLoadingSetter(originalScope, false);
            isNoResultsSetter(originalScope, true);
          });
        };

        // bind events only if appendToBody params exist - performance feature
        if (appendToBody) {
          angular.element($window).bind('resize', fireRecalculating);
          $document.find('body').bind('scroll', fireRecalculating);
        }

        // Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutEventPromise;

        // Default progress type
        scope.moveInProgress = false;

        function fireRecalculating() {
          if (!scope.moveInProgress) {
            scope.moveInProgress = true;
            scope.$digest();
          }

          // Cancel previous timeout
          if (timeoutEventPromise) {
            $timeout.cancel(timeoutEventPromise);
          }

          // Debounced executing recalculate after events fired
          timeoutEventPromise = $timeout(function() {
            // if popup is visible
            if (scope.matches.length) {
              recalculatePosition();
            }

            scope.moveInProgress = false;
          }, eventDebounceTime);
        }

        // recalculate actual position and set new values to scope
        // after digest loop is popup in right position
        function recalculatePosition() {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top += element.prop('offsetHeight');
        }

        resetMatches();

        //we need to propagate user's query so we can higlight matches
        scope.query = undefined;

        //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
        var timeoutPromise;

        var scheduleSearchWithTimeout = function(inputValue) {
          timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
          }, waitTime);
        };

        var cancelPreviousTimeout = function() {
          if (timeoutPromise) {
            $timeout.cancel(timeoutPromise);
          }
        };

        //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
        //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
        modelCtrl.$parsers.unshift(function(inputValue) {
          hasFocus = true;

          if (minLength === 0 || inputValue && inputValue.length >= minLength) {
            if (waitTime > 0) {
              cancelPreviousTimeout();
              scheduleSearchWithTimeout(inputValue);
            } else {
              getMatchesAsync(inputValue);
            }
          } else {
            isLoadingSetter(originalScope, false);
            cancelPreviousTimeout();
            resetMatches();
          }

          if (isEditable) {
            return inputValue;
          } else {
            if (!inputValue) {
              // Reset in case user had typed something previously.
              modelCtrl.$setValidity('editable', true);
              return null;
            } else {
              modelCtrl.$setValidity('editable', false);
              return undefined;
            }
          }
        });

        modelCtrl.$formatters.push(function(modelValue) {
          var candidateViewValue, emptyViewValue;
          var locals = {};

          // The validity may be set to false via $parsers (see above) if
          // the model is restricted to selected values. If the model
          // is set manually it is considered to be valid.
          if (!isEditable) {
            modelCtrl.$setValidity('editable', true);
          }

          if (inputFormatter) {
            locals.$model = modelValue;
            return inputFormatter(originalScope, locals);
          } else {
            //it might happen that we don't have enough info to properly render input value
            //we need to check for this situation and simply return model value if we can't apply custom formatting
            locals[parserResult.itemName] = modelValue;
            candidateViewValue = parserResult.viewMapper(originalScope, locals);
            locals[parserResult.itemName] = undefined;
            emptyViewValue = parserResult.viewMapper(originalScope, locals);

            return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
          }
        });

        scope.select = function(activeIdx) {
          //called from within the $digest() cycle
          var locals = {};
          var model, item;

          selected = true;
          locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
          model = parserResult.modelMapper(originalScope, locals);
          $setModelValue(originalScope, model);
          modelCtrl.$setValidity('editable', true);
          modelCtrl.$setValidity('parse', true);

          onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals)
          });

          resetMatches();

          //return focus to the input element if a match was selected via a mouse click event
          // use timeout to avoid $rootScope:inprog error
          if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
            $timeout(function() { element[0].focus(); }, 0, false);
          }
        };

        //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
        element.bind('keydown', function(evt) {
          //typeahead is open and an "interesting" key was pressed
          if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
            return;
          }

          // if there's nothing selected (i.e. focusFirst) and enter or tab is hit, clear the results
          if (scope.activeIdx === -1 && (evt.which === 9 || evt.which === 13)) {
            resetMatches();
            scope.$digest();
            return;
          }

          evt.preventDefault();

          if (evt.which === 40) {
            scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
            scope.$digest();
          } else if (evt.which === 38) {
            scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
            scope.$digest();
          } else if (evt.which === 13 || evt.which === 9) {
            scope.$apply(function () {
              scope.select(scope.activeIdx);
            });
          } else if (evt.which === 27) {
            evt.stopPropagation();

            resetMatches();
            scope.$digest();
          }
        });

        element.bind('blur', function() {
          if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
            selected = true;
            scope.$apply(function() {
              scope.select(scope.activeIdx);
            });
          }
          hasFocus = false;
          selected = false;
        });

        // Keep reference to click handler to unbind it.
        var dismissClickHandler = function(evt) {
          // Issue #3973
          // Firefox treats right click as a click on document
          if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
            resetMatches();
            if (!$rootScope.$$phase) {
              scope.$digest();
            }
          }
        };

        $document.bind('click', dismissClickHandler);

        originalScope.$on('$destroy', function() {
          $document.unbind('click', dismissClickHandler);
          if (appendToBody || appendToElementId) {
            $popup.remove();
          }

          if (appendToBody) {
            angular.element($window).unbind('resize', fireRecalculating);
            $document.find('body').unbind('scroll', fireRecalculating);
          }
          // Prevent jQuery cache memory leak
          popUpEl.remove();
        });

        var $popup = $compile(popUpEl)(scope);

        if (appendToBody) {
          $document.find('body').append($popup);
        } else if (appendToElementId !== false) {
          angular.element($document[0].getElementById(appendToElementId)).append($popup);
        } else {
          element.after($popup);
        }
      }
    };
  }])
  
  .directive('typeaheadPopup', ['$typeaheadSuppressWarning', '$log', function($typeaheadSuppressWarning, $log) {
    return {
      scope: {
        matches: '=',
        query: '=',
        active: '=',
        position: '&',
        moveInProgress: '=',
        select: '&'
      },
      replace: true,
      templateUrl: function(element, attrs) {
        return attrs.popupTemplateUrl || 'template/typeahead/typeahead-popup.html';
      },
      link: function(scope, element, attrs) {
        
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeahead-popup is now deprecated. Use uib-typeahead-popup instead.');
        }
        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function() {
          return scope.matches.length > 0;
        };

        scope.isActive = function(matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function(matchIdx) {
          scope.active = matchIdx;
        };

        scope.selectMatch = function(activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  }])
  
  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', '$typeaheadSuppressWarning', '$log', function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {
    return {
      restrict: 'EA',
      scope: {
        index: '=',
        match: '=',
        query: '='
      },
      link:function(scope, element, attrs) {
        if (!$typeaheadSuppressWarning) {
          $log.warn('typeahead-match is now deprecated. Use uib-typeahead-match instead.');
        }

        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement) {
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])
  
  .filter('typeaheadHighlight', ['$sce', '$injector', '$log', '$typeaheadSuppressWarning', function($sce, $injector, $log, $typeaheadSuppressWarning) {
    var isSanitizePresent;
    isSanitizePresent = $injector.has('$sanitize');

    function escapeRegexp(queryToEscape) {
      // Regex: capture the whole query string and replace it with the string that will be used to match
      // the results, for example if the capture is "a" the result will be \a
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    function containsHtml(matchItem) {
      return /<.*>/g.test(matchItem);
    }

    return function(matchItem, query) {
      if (!$typeaheadSuppressWarning) {
        $log.warn('typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead.');
      }

      if (!isSanitizePresent && containsHtml(matchItem)) {
        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger
      }

      matchItem = query? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a "strong" tag
      if (!isSanitizePresent) {
        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive
      }

      return matchItem;
    };
  }]);

angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion-group.html",
    "<div class=\"panel {{panelClass || 'panel-default'}}\">\n" +
    "  <div class=\"panel-heading\" ng-keypress=\"toggleOpen($event)\">\n" +
    "    <h4 class=\"panel-title\">\n" +
    "      <a href tabindex=\"0\" class=\"accordion-toggle\" ng-click=\"toggleOpen()\" uib-accordion-transclude=\"heading\"><span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span></a>\n" +
    "    </h4>\n" +
    "  </div>\n" +
    "  <div class=\"panel-collapse collapse\" uib-collapse=\"!isOpen\">\n" +
    "	  <div class=\"panel-body\" ng-transclude></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion.html",
    "<div class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/alert/alert.html",
    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissible' : null]\" role=\"alert\">\n" +
    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close({$event: $event})\">\n" +
    "        <span aria-hidden=\"true\">&times;</span>\n" +
    "        <span class=\"sr-only\">Close</span>\n" +
    "    </button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
    "  <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "  <a role=\"button\" href class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\">\n" +
    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-left\"></span>\n" +
    "    <span class=\"sr-only\">previous</span>\n" +
    "  </a>\n" +
    "  <a role=\"button\" href class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\">\n" +
    "    <span aria-hidden=\"true\" class=\"glyphicon glyphicon-chevron-right\"></span>\n" +
    "    <span class=\"sr-only\">next</span>\n" +
    "  </a>\n" +
    "  <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "    <li ng-repeat=\"slide in slides | orderBy:indexOfSlide track by $index\" ng-class=\"{ active: isActive(slide) }\" ng-click=\"select(slide)\">\n" +
    "      <span class=\"sr-only\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\"isActive(slide)\">, currently active</span></span>\n" +
    "    </li>\n" +
    "  </ol>\n" +
    "</div>");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': active\n" +
    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
    "  <uib-daypicker ng-switch-when=\"day\" tabindex=\"0\"></uib-daypicker>\n" +
    "  <uib-monthpicker ng-switch-when=\"month\" tabindex=\"0\"></uib-monthpicker>\n" +
    "  <uib-yearpicker ng-switch-when=\"year\" tabindex=\"0\"></uib-yearpicker>\n" +
    "</div>");
}]);

angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{::5 + showWeeks}}\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-if=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in ::labels track by $index\" class=\"text-center\"><small aria-label=\"{{::label.full}}\">{{::label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-if=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-muted': dt.secondary, 'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" dropdown-nested ng-if=\"isOpen\" style=\"display: block\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\" ng-click=\"$event.stopPropagation()\">\n" +
    "	<li ng-transclude></li>\n" +
    "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
    "		<span class=\"btn-group pull-left\">\n" +
    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\" ng-disabled=\"isDisabled('today')\">{{ getText('current') }}</button>\n" +
    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
    "		</span>\n" +
    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
    "	</li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{::uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"3\"><button id=\"{{::uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{::dt.uid}}\" ng-class=\"::dt.customClass\">\n" +
    "        <button type=\"button\" style=\"min-width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"::{'text-info': dt.current}\">{{::dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/backdrop.html",
    "<div uib-modal-animation-class=\"fade\"\n" +
    "     modal-in-class=\"in\"\n" +
    "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" +
    "></div>\n" +
    "");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/window.html",
    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
    "    uib-modal-animation-class=\"fade\"\n" +
    "    modal-in-class=\"in\"\n" +
    "    ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\">\n" +
    "    <div class=\"modal-dialog\" ng-class=\"size ? 'modal-' + size : ''\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<ul class=\"pager\">\n" +
    "  <li ng-class=\"{disabled: noPrevious()||ngDisabled, previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
    "  <li ng-class=\"{disabled: noNext()||ngDisabled, next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-first\"><a href ng-click=\"selectPage(1, $event)\">{{::getText('first')}}</a></li>\n" +
    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noPrevious()||ngDisabled}\" class=\"pagination-prev\"><a href ng-click=\"selectPage(page - 1, $event)\">{{::getText('previous')}}</a></li>\n" +
    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active,disabled: ngDisabled&&!page.active}\" class=\"pagination-page\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
    "  <li ng-if=\"::directionLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-next\"><a href ng-click=\"selectPage(page + 1, $event)\">{{::getText('next')}}</a></li>\n" +
    "  <li ng-if=\"::boundaryLinks\" ng-class=\"{disabled: noNext()||ngDisabled}\" class=\"pagination-last\"><a href ng-click=\"selectPage(totalPages, $event)\">{{::getText('last')}}</a></li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-popup.html",
    "<div\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-popup.html",
    "<div\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-template-popup.html",
    "<div\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\"\n" +
    "    uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover-html.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover-html.html",
    "<div tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind-html=\"contentExp()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover-template.html",
    "<div tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\"\n" +
    "        uib-tooltip-template-transclude=\"contentExp()\"\n" +
    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover.html",
    "<div tooltip-animation-class=\"fade\"\n" +
    "  uib-tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" style=\"min-width: 0;\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude aria-labelledby=\"{{::title}}\"></div>");
}]);

angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" aria-labelledby=\"{{::title}}\" style=\"min-width: 0;\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
    "    <span ng-repeat-start=\"r in range track by $index\" class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    <i ng-repeat-end ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\" ng-attr-title=\"{{r.title}}\" aria-valuetext=\"{{r.title}}\"></i>\n" +
    "</span>\n" +
    "");
}]);

angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled}\">\n" +
    "  <a href ng-click=\"select()\" uib-tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         uib-tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/timepicker/timepicker.html",
    "<table>\n" +
    "  <tbody>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td><a ng-click=\"incrementHours()\" ng-class=\"{disabled: noIncrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td><a ng-click=\"incrementMinutes()\" ng-class=\"{disabled: noIncrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noIncrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-up\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\">\n" +
    "      </td>\n" +
    "      <td>:</td>\n" +
    "      <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "        <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"::readonlyInput\" maxlength=\"2\" tabindex=\"{{::tabindex}}\">\n" +
    "      </td>\n" +
    "      <td ng-show=\"showMeridian\"><button type=\"button\" ng-class=\"{disabled: noToggleMeridian()}\" class=\"btn btn-default text-center\" ng-click=\"toggleMeridian()\" ng-disabled=\"noToggleMeridian()\" tabindex=\"{{::tabindex}}\">{{meridian}}</button></td>\n" +
    "    </tr>\n" +
    "    <tr class=\"text-center\" ng-show=\"::showSpinners\">\n" +
    "      <td><a ng-click=\"decrementHours()\" ng-class=\"{disabled: noDecrementHours()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementHours()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td>&nbsp;</td>\n" +
    "      <td><a ng-click=\"decrementMinutes()\" ng-class=\"{disabled: noDecrementMinutes()}\" class=\"btn btn-link\" ng-disabled=\"noDecrementMinutes()\" tabindex=\"{{::tabindex}}\"><span class=\"glyphicon glyphicon-chevron-down\"></span></a></td>\n" +
    "      <td ng-show=\"showMeridian\"></td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-match.html",
    "<a href tabindex=\"-1\" ng-bind-html=\"match.label | uibTypeaheadHighlight:query\"></a>\n" +
    "");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-show=\"isOpen() && !moveInProgress\" ng-style=\"{top: position().top+'px', left: position().left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{::match.id}}\">\n" +
    "        <div uib-typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>\n" +
    "");
}]);
!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');if(typeof module!=='undefined')module.exports='ui.bootstrap';
/**
 * @license AngularJS v1.5.5
 * (c) 2010-2016 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/* jshint ignore:start */
var noop        = angular.noop;
var copy        = angular.copy;
var extend      = angular.extend;
var jqLite      = angular.element;
var forEach     = angular.forEach;
var isArray     = angular.isArray;
var isString    = angular.isString;
var isObject    = angular.isObject;
var isUndefined = angular.isUndefined;
var isDefined   = angular.isDefined;
var isFunction  = angular.isFunction;
var isElement   = angular.isElement;

var ELEMENT_NODE = 1;
var COMMENT_NODE = 8;

var ADD_CLASS_SUFFIX = '-add';
var REMOVE_CLASS_SUFFIX = '-remove';
var EVENT_CLASS_PREFIX = 'ng-';
var ACTIVE_CLASS_SUFFIX = '-active';
var PREPARE_CLASS_SUFFIX = '-prepare';

var NG_ANIMATE_CLASSNAME = 'ng-animate';
var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';

// Detect proper transitionend/animationend event names.
var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
  CSS_PREFIX = '-webkit-';
  TRANSITION_PROP = 'WebkitTransition';
  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
} else {
  TRANSITION_PROP = 'transition';
  TRANSITIONEND_EVENT = 'transitionend';
}

if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
  CSS_PREFIX = '-webkit-';
  ANIMATION_PROP = 'WebkitAnimation';
  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
} else {
  ANIMATION_PROP = 'animation';
  ANIMATIONEND_EVENT = 'animationend';
}

var DURATION_KEY = 'Duration';
var PROPERTY_KEY = 'Property';
var DELAY_KEY = 'Delay';
var TIMING_KEY = 'TimingFunction';
var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
var ANIMATION_PLAYSTATE_KEY = 'PlayState';
var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

var isPromiseLike = function(p) {
  return p && p.then ? true : false;
};

var ngMinErr = angular.$$minErr('ng');
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
  }
  return arg;
}

function mergeClasses(a,b) {
  if (!a && !b) return '';
  if (!a) return b;
  if (!b) return a;
  if (isArray(a)) a = a.join(' ');
  if (isArray(b)) b = b.join(' ');
  return a + ' ' + b;
}

function packageStyles(options) {
  var styles = {};
  if (options && (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  var className = '';
  classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
          ? classes.split(/\s+/)
          : [];
  forEach(classes, function(klass, i) {
    if (klass && klass.length > 0) {
      className += (i > 0) ? ' ' : '';
      className += isPrefix ? fix + klass
                            : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  var index = arr.indexOf(val);
  if (val >= 0) {
    arr.splice(index, 1);
  }
}

function stripCommentsFromElement(element) {
  if (element instanceof jqLite) {
    switch (element.length) {
      case 0:
        return [];
        break;

      case 1:
        // there is no point of stripping anything if the element
        // is the only element within the jqLite wrapper.
        // (it's important that we retain the element instance.)
        if (element[0].nodeType === ELEMENT_NODE) {
          return element;
        }
        break;

      default:
        return jqLite(extractElementNode(element));
        break;
    }
  }

  if (element.nodeType === ELEMENT_NODE) {
    return jqLite(element);
  }
}

function extractElementNode(element) {
  if (!element[0]) return element;
  for (var i = 0; i < element.length; i++) {
    var elm = element[i];
    if (elm.nodeType == ELEMENT_NODE) {
      return elm;
    }
  }
}

function $$addClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.addClass(elm, className);
  });
}

function $$removeClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.removeClass(elm, className);
  });
}

function applyAnimationClassesFactory($$jqLite) {
  return function(element, options) {
    if (options.addClass) {
      $$addClass($$jqLite, element, options.addClass);
      options.addClass = null;
    }
    if (options.removeClass) {
      $$removeClass($$jqLite, element, options.removeClass);
      options.removeClass = null;
    }
  }
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    var domOperation = options.domOperation || noop;
    options.domOperation = function() {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = noop;
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationDetails(element, oldAnimation, newAnimation) {
  var target = oldAnimation.options || {};
  var newOptions = newAnimation.options || {};

  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  oldAnimation.addClass = target.addClass;
  oldAnimation.removeClass = target.removeClass;

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  var ADD_CLASS = 1;
  var REMOVE_CLASS = -1;

  var flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  forEach(toAdd, function(value, key) {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  forEach(toRemove, function(value, key) {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  var classes = {
    addClass: '',
    removeClass: ''
  };

  forEach(flags, function(val, klass) {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = 'addClass';
      allow = !existing[klass];
    } else if (val === REMOVE_CLASS) {
      prop = 'removeClass';
      allow = existing[klass];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += ' ';
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }

    var obj = {};
    forEach(classes, function(klass) {
      // sometimes the split leaves empty string values
      // incase extra spaces were applied to the options
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  return classes;
}

function getDomNode(element) {
  return (element instanceof angular.element) ? element[0] : element;
}

function applyGeneratedPreparationClasses(element, event, options) {
  var classes = '';
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
  }
  if (options.removeClass) {
    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.addClass(classes);
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    element.removeClass(options.preparationClasses);
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    element.removeClass(options.activeClasses);
    options.activeClasses = null;
  }
}

function blockTransitions(node, duration) {
  // we use a negative delay value since it performs blocking
  // yet it doesn't kill any existing transitions running on the
  // same element which makes this safe for class-based animations
  var value = duration ? '-' + duration + 's' : '';
  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
  return [TRANSITION_DELAY_PROP, value];
}

function blockKeyframeAnimations(node, applyBlock) {
  var value = applyBlock ? 'paused' : '';
  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  var prop = styleTuple[0];
  var value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a,b) {
  if (!a) return b;
  if (!b) return a;
  return a + ' ' + b;
}

var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
  var queue, cancelFn;

  function scheduler(tasks) {
    // we make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /* waitUntilQuiet does two things:
   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through
   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.
   *
   * The motivation here is that animation code can request more time from the scheduler
   * before the next wave runs. This allows for certain DOM properties such as classes to
   * be resolved in time for the next animation to run.
   */
  scheduler.waitUntilQuiet = function(fn) {
    if (cancelFn) cancelFn();

    cancelFn = $$rAF(function() {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  return scheduler;

  function nextTick() {
    if (!queue.length) return;

    var items = queue.shift();
    for (var i = 0; i < items.length; i++) {
      items[i]();
    }

    if (!cancelFn) {
      $$rAF(function() {
        if (!cancelFn) nextTick();
      });
    }
  }
}];

/**
 * @ngdoc directive
 * @name ngAnimateChildren
 * @restrict AE
 * @element ANY
 *
 * @description
 *
 * ngAnimateChildren allows you to specify that children of this element should animate even if any
 * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`
 * (structural) animation, child elements that also have an active structural animation are not animated.
 *
 * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).
 *
 *
 * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,
 *     then child animations are allowed. If the value is `false`, child animations are not allowed.
 *
 * @example
 * <example module="ngAnimateChildren" name="ngAnimateChildren" deps="angular-animate.js" animations="true">
     <file name="index.html">
       <div ng-controller="mainController as main">
         <label>Show container? <input type="checkbox" ng-model="main.enterElement" /></label>
         <label>Animate children? <input type="checkbox" ng-model="main.animateChildren" /></label>
         <hr>
         <div ng-animate-children="{{main.animateChildren}}">
           <div ng-if="main.enterElement" class="container">
             List of items:
             <div ng-repeat="item in [0, 1, 2, 3]" class="item">Item {{item}}</div>
           </div>
         </div>
       </div>
     </file>
     <file name="animations.css">

      .container.ng-enter,
      .container.ng-leave {
        transition: all ease 1.5s;
      }

      .container.ng-enter,
      .container.ng-leave-active {
        opacity: 0;
      }

      .container.ng-leave,
      .container.ng-enter-active {
        opacity: 1;
      }

      .item {
        background: firebrick;
        color: #FFF;
        margin-bottom: 10px;
      }

      .item.ng-enter,
      .item.ng-leave {
        transition: transform 1.5s ease;
      }

      .item.ng-enter {
        transform: translateX(50px);
      }

      .item.ng-enter-active {
        transform: translateX(0);
      }
    </file>
    <file name="script.js">
      angular.module('ngAnimateChildren', ['ngAnimate'])
        .controller('mainController', function() {
          this.animateChildren = false;
          this.enterElement = false;
        });
    </file>
  </example>
 */
var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
  return {
    link: function(scope, element, attrs) {
      var val = attrs.ngAnimateChildren;
      if (angular.isString(val) && val.length === 0) { //empty attribute
        element.data(NG_ANIMATE_CHILDREN_DATA, true);
      } else {
        // Interpolate and set the value, so that it is available to
        // animations that run right after compilation
        setData($interpolate(val)(scope));
        attrs.$observe('ngAnimateChildren', setData);
      }

      function setData(value) {
        value = value === 'on' || value === 'true';
        element.data(NG_ANIMATE_CHILDREN_DATA, value);
      }
    }
  };
}];

var ANIMATE_TIMER_KEY = '$$animateCss';

/**
 * @ngdoc service
 * @name $animateCss
 * @kind object
 *
 * @description
 * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes
 * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT
 * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or
 * directives to create more complex animations that can be purely driven using CSS code.
 *
 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
 * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).
 *
 * ## Usage
 * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that
 * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,
 * any automatic control over cancelling animations and/or preventing animations from being run on
 * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to
 * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger
 * the CSS animation.
 *
 * The example below shows how we can create a folding animation on an element using `ng-if`:
 *
 * ```html
 * <!-- notice the `fold-animation` CSS class -->
 * <div ng-if="onOff" class="fold-animation">
 *   This element will go BOOM
 * </div>
 * <button ng-click="onOff=true">Fold In</button>
 * ```
 *
 * Now we create the **JavaScript animation** that will trigger the CSS transition:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * ## More Advanced Uses
 *
 * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
 * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.
 *
 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
 * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
 * to provide a working animation that will run in CSS.
 *
 * The example below showcases a more advanced version of the `.fold-animation` from the example above:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         addClass: 'red large-text pulse-twice',
 *         easing: 'ease-out',
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Since we're adding/removing CSS classes then the CSS transition will also pick those up:
 *
 * ```css
 * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/
 * .red { background:red; }
 * .large-text { font-size:20px; }
 *
 * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/
 * .pulse-twice {
 *   animation: 0.5s pulse linear 2;
 *   -webkit-animation: 0.5s pulse linear 2;
 * }
 *
 * @keyframes pulse {
 *   from { transform: scale(0.5); }
 *   to { transform: scale(1.5); }
 * }
 *
 * @-webkit-keyframes pulse {
 *   from { -webkit-transform: scale(0.5); }
 *   to { -webkit-transform: scale(1.5); }
 * }
 * ```
 *
 * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.
 *
 * ## How the Options are handled
 *
 * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
 * styles using the `from` and `to` properties.
 *
 * ```js
 * var animator = $animateCss(element, {
 *   from: { background:'red' },
 *   to: { background:'blue' }
 * });
 * animator.start();
 * ```
 *
 * ```css
 * .rotating-animation {
 *   animation:0.5s rotate linear;
 *   -webkit-animation:0.5s rotate linear;
 * }
 *
 * @keyframes rotate {
 *   from { transform: rotate(0deg); }
 *   to { transform: rotate(360deg); }
 * }
 *
 * @-webkit-keyframes rotate {
 *   from { -webkit-transform: rotate(0deg); }
 *   to { -webkit-transform: rotate(360deg); }
 * }
 * ```
 *
 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is
 * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition
 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied
 * and spread across the transition and keyframe animation.
 *
 * ## What is returned
 *
 * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually
 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
 * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:
 *
 * ```js
 * var animator = $animateCss(element, { ... });
 * ```
 *
 * Now what do the contents of our `animator` variable look like:
 *
 * ```js
 * {
 *   // starts the animation
 *   start: Function,
 *
 *   // ends (aborts) the animation
 *   end: Function
 * }
 * ```
 *
 * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.
 * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been
 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
 * and that changing them will not reconfigure the parameters of the animation.
 *
 * ### runner.done() vs runner.then()
 * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the
 * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.
 * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`
 * unless you really need a digest to kick off afterwards.
 *
 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
 * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).
 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
 *
 * @param {DOMElement} element the element that will be animated
 * @param {object} options the animation-related options that will be applied during the animation
 *
 * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied
 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
 * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and
 * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.
 * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).
 * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).
 * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).
 * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
 * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
 * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.
 * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.
 * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`
 * is provided then the animation will be skipped entirely.
 * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is
 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
 * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same
 * CSS delay value.
 * * `stagger` - A numeric time value representing the delay between successively animated elements
 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
 * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
 *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)
 * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)
 * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once
 *    the animation is closed. This is useful for when the styles are used purely for the sake of
 *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).
 *    By default this value is set to `false`.
 *
 * @return {object} an object with start and end methods and details about the animation.
 *
 * * `start` - The method to start the animation. This will return a `Promise` when called.
 * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.
 */
var ONE_SECOND = 1000;
var BASE_TEN = 10;

var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
var CLOSING_TIME_BUFFER = 1.5;

var DETECT_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
};

var DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, duration + 's'];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
  return [prop, delay + 's'];
}

function computeCssStyles($window, element, properties) {
  var styles = Object.create(null);
  var detectedStyles = $window.getComputedStyle(element) || {};
  forEach(properties, function(formalStyleName, actualStyleName) {
    var val = detectedStyles[formalStyleName];
    if (val) {
      var c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === '-' || c === '+' || c >= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for negative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  var maxValue = 0;
  var values = str.split(/\s*,\s*/);
  forEach(values, function(value) {
    // it's always safe to consider only second values and omit `ms` values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) == 's') {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  var style = TRANSITION_PROP;
  var value = duration + 's';
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += ' linear all';
  }
  return [style, value];
}

function createLocalCacheLookup() {
  var cache = Object.create(null);
  return {
    flush: function() {
      cache = Object.create(null);
    },

    count: function(key) {
      var entry = cache[key];
      return entry ? entry.total : 0;
    },

    get: function(key) {
      var entry = cache[key];
      return entry && entry.value;
    },

    put: function(key, value) {
      if (!cache[key]) {
        cache[key] = { total: 1, value: value };
      } else {
        cache[key].total++;
      }
    }
  };
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the `from` styles.
// We make use of `isDefined` here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// "OR" statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  forEach(properties, function(prop) {
    backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
  });
}

var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
  var gcsLookup = createLocalCacheLookup();
  var gcsStaggerLookup = createLocalCacheLookup();

  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,
                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    var parentCounter = 0;
    function gcsHashFn(node, extraClasses) {
      var KEY = "$$ngAnimateParentKey";
      var parentNode = node.parentNode;
      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
    }

    function computeCachedCssStyles(node, className, cacheKey, properties) {
      var timings = gcsLookup.get(cacheKey);

      if (!timings) {
        timings = computeCssStyles($window, node, properties);
        if (timings.animationIterationCount === 'infinite') {
          timings.animationIterationCount = 1;
        }
      }

      // we keep putting this in multiple times even though the value and the cacheKey are the same
      // because we're keeping an internal tally of how many duplicate animations are detected.
      gcsLookup.put(cacheKey, timings);
      return timings;
    }

    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
      var stagger;

      // if we have one or more existing matches of matching elements
      // containing the same parent + CSS styles (which is how cacheKey works)
      // then staggering is possible
      if (gcsLookup.count(cacheKey) > 0) {
        stagger = gcsStaggerLookup.get(cacheKey);

        if (!stagger) {
          var staggerClassName = pendClasses(className, '-stagger');

          $$jqLite.addClass(node, staggerClassName);

          stagger = computeCssStyles($window, node, properties);

          // force the conversion of a null value to zero incase not set
          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

          $$jqLite.removeClass(node, staggerClassName);

          gcsStaggerLookup.put(cacheKey, stagger);
        }
      }

      return stagger || {};
    }

    var cancelLastRAFRequest;
    var rafWaitQueue = [];
    function waitUntilQuiet(callback) {
      rafWaitQueue.push(callback);
      $$rAFScheduler.waitUntilQuiet(function() {
        gcsLookup.flush();
        gcsStaggerLookup.flush();

        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
        var pageWidth = $$forceReflow();

        // we use a for loop to ensure that if the queue is changed
        // during this looping then it will consider new requests
        for (var i = 0; i < rafWaitQueue.length; i++) {
          rafWaitQueue[i](pageWidth);
        }
        rafWaitQueue.length = 0;
      });
    }

    function computeTimings(node, className, cacheKey) {
      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
      var aD = timings.animationDelay;
      var tD = timings.transitionDelay;
      timings.maxDelay = aD && tD
          ? Math.max(aD, tD)
          : (aD || tD);
      timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration);

      return timings;
    }

    return function init(element, initialOptions) {
      // all of the animation functions should create
      // a copy of the options data, however, if a
      // parent service has already created a copy then
      // we should stick to using that
      var options = initialOptions || {};
      if (!options.$$prepared) {
        options = prepareAnimationOptions(copy(options));
      }

      var restoreStyles = {};
      var node = getDomNode(element);
      if (!node
          || !node.parentNode
          || !$$animateQueue.enabled()) {
        return closeAndReturnNoopAnimator();
      }

      var temporaryStyles = [];
      var classes = element.attr('class');
      var styles = packageStyles(options);
      var animationClosed;
      var animationPaused;
      var animationCompleted;
      var runner;
      var runnerHost;
      var maxDelay;
      var maxDelayTime;
      var maxDuration;
      var maxDurationTime;
      var startTime;
      var events = [];

      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
        return closeAndReturnNoopAnimator();
      }

      var method = options.event && isArray(options.event)
            ? options.event.join(' ')
            : options.event;

      var isStructural = method && options.structural;
      var structuralClassName = '';
      var addRemoveClassName = '';

      if (isStructural) {
        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
      } else if (method) {
        structuralClassName = method;
      }

      if (options.addClass) {
        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
      }

      if (options.removeClass) {
        if (addRemoveClassName.length) {
          addRemoveClassName += ' ';
        }
        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
      }

      // there may be a situation where a structural animation is combined together
      // with CSS classes that need to resolve before the animation is computed.
      // However this means that there is no explicit CSS code to block the animation
      // from happening (by setting 0s none in the class name). If this is the case
      // we need to apply the classes before the first rAF so we know to continue if
      // there actually is a detected transition or keyframe animation
      if (options.applyClassesEarly && addRemoveClassName.length) {
        applyAnimationClasses(element, options);
      }

      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
      var fullClassName = classes + ' ' + preparationClasses;
      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;

      // there is no way we can trigger an animation if no styles and
      // no classes are being applied which would then trigger a transition,
      // unless there a is raw keyframe value that is applied to the element.
      if (!containsKeyframeAnimation
           && !hasToStyles
           && !preparationClasses) {
        return closeAndReturnNoopAnimator();
      }

      var cacheKey, stagger;
      if (options.stagger > 0) {
        var staggerVal = parseFloat(options.stagger);
        stagger = {
          transitionDelay: staggerVal,
          animationDelay: staggerVal,
          transitionDuration: 0,
          animationDuration: 0
        };
      } else {
        cacheKey = gcsHashFn(node, fullClassName);
        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
      }

      if (!options.$$skipPreparationClasses) {
        $$jqLite.addClass(element, preparationClasses);
      }

      var applyOnlyDuration;

      if (options.transitionStyle) {
        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
        applyInlineStyle(node, transitionStyle);
        temporaryStyles.push(transitionStyle);
      }

      if (options.duration >= 0) {
        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

        // we set the duration so that it will be picked up by getComputedStyle later
        applyInlineStyle(node, durationStyle);
        temporaryStyles.push(durationStyle);
      }

      if (options.keyframeStyle) {
        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
        applyInlineStyle(node, keyframeStyle);
        temporaryStyles.push(keyframeStyle);
      }

      var itemIndex = stagger
          ? options.staggerIndex >= 0
              ? options.staggerIndex
              : gcsLookup.count(cacheKey)
          : 0;

      var isFirst = itemIndex === 0;

      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
      // without causing any combination of transitions to kick in. By adding a negative delay value
      // it forces the setup class' transition to end immediately. We later then remove the negative
      // transition delay to allow for the transition to naturally do it's thing. The beauty here is
      // that if there is no transition defined then nothing will happen and this will also allow
      // other transitions to be stacked on top of each other without any chopping them out.
      if (isFirst && !options.skipBlocking) {
        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
      }

      var timings = computeTimings(node, fullClassName, cacheKey);
      var relativeDelay = timings.maxDelay;
      maxDelay = Math.max(relativeDelay, 0);
      maxDuration = timings.maxDuration;

      var flags = {};
      flags.hasTransitions          = timings.transitionDuration > 0;
      flags.hasAnimations           = timings.animationDuration > 0;
      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';
      flags.applyTransitionDuration = hasToStyles && (
                                        (flags.hasTransitions && !flags.hasTransitionAll)
                                         || (flags.hasAnimations && !flags.hasTransitions));
      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;
      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;
      flags.recalculateTimingStyles = addRemoveClassName.length > 0;

      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

        if (flags.applyTransitionDuration) {
          flags.hasTransitions = true;
          timings.transitionDuration = maxDuration;
          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
        }

        if (flags.applyAnimationDuration) {
          flags.hasAnimations = true;
          timings.animationDuration = maxDuration;
          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
        }
      }

      if (maxDuration === 0 && !flags.recalculateTimingStyles) {
        return closeAndReturnNoopAnimator();
      }

      if (options.delay != null) {
        var delayStyle;
        if (typeof options.delay !== "boolean") {
          delayStyle = parseFloat(options.delay);
          // number in options.delay means we have to recalculate the delay for the closing timeout
          maxDelay = Math.max(delayStyle, 0);
        }

        if (flags.applyTransitionDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle));
        }

        if (flags.applyAnimationDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
        }
      }

      // we need to recalculate the delay value since we used a pre-emptive negative
      // delay value and the delay value is required for the final event checking. This
      // property will ensure that this will happen after the RAF phase has passed.
      if (options.duration == null && timings.transitionDuration > 0) {
        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
      }

      maxDelayTime = maxDelay * ONE_SECOND;
      maxDurationTime = maxDuration * ONE_SECOND;
      if (!options.skipBlocking) {
        flags.blockTransition = timings.transitionDuration > 0;
        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
                                       stagger.animationDelay > 0 &&
                                       stagger.animationDuration === 0;
      }

      if (options.from) {
        if (options.cleanupStyles) {
          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
        }
        applyAnimationFromStyles(element, options);
      }

      if (flags.blockTransition || flags.blockKeyframeAnimation) {
        applyBlocking(maxDuration);
      } else if (!options.skipBlocking) {
        blockTransitions(node, false);
      }

      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
      return {
        $$willAnimate: true,
        end: endFn,
        start: function() {
          if (animationClosed) return;

          runnerHost = {
            end: endFn,
            cancel: cancelFn,
            resume: null, //this will be set during the start() phase
            pause: null
          };

          runner = new $$AnimateRunner(runnerHost);

          waitUntilQuiet(start);

          // we don't have access to pause/resume the animation
          // since it hasn't run yet. AnimateRunner will therefore
          // set noop functions for resume and pause and they will
          // later be overridden once the animation is triggered
          return runner;
        }
      };

      function endFn() {
        close();
      }

      function cancelFn() {
        close(true);
      }

      function close(rejected) { // jshint ignore:line
        // if the promise has been called already then we shouldn't close
        // the animation again
        if (animationClosed || (animationCompleted && animationPaused)) return;
        animationClosed = true;
        animationPaused = false;

        if (!options.$$skipPreparationClasses) {
          $$jqLite.removeClass(element, preparationClasses);
        }
        $$jqLite.removeClass(element, activeClasses);

        blockKeyframeAnimations(node, false);
        blockTransitions(node, false);

        forEach(temporaryStyles, function(entry) {
          // There is only one way to remove inline style properties entirely from elements.
          // By using `removeProperty` this works, but we need to convert camel-cased CSS
          // styles down to hyphenated values.
          node.style[entry[0]] = '';
        });

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);

        if (Object.keys(restoreStyles).length) {
          forEach(restoreStyles, function(value, prop) {
            value ? node.style.setProperty(prop, value)
                  : node.style.removeProperty(prop);
          });
        }

        // the reason why we have this option is to allow a synchronous closing callback
        // that is fired as SOON as the animation ends (when the CSS is removed) or if
        // the animation never takes off at all. A good example is a leave animation since
        // the element must be removed just after the animation is over or else the element
        // will appear on screen for one animation frame causing an overbearing flicker.
        if (options.onDone) {
          options.onDone();
        }

        if (events && events.length) {
          // Remove the transitionend / animationend listener(s)
          element.off(events.join(' '), onAnimationProgress);
        }

        //Cancel the fallback closing timeout and remove the timer data
        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
        if (animationTimerData) {
          $timeout.cancel(animationTimerData[0].timer);
          element.removeData(ANIMATE_TIMER_KEY);
        }

        // if the preparation function fails then the promise is not setup
        if (runner) {
          runner.complete(!rejected);
        }
      }

      function applyBlocking(duration) {
        if (flags.blockTransition) {
          blockTransitions(node, duration);
        }

        if (flags.blockKeyframeAnimation) {
          blockKeyframeAnimations(node, !!duration);
        }
      }

      function closeAndReturnNoopAnimator() {
        runner = new $$AnimateRunner({
          end: endFn,
          cancel: cancelFn
        });

        // should flush the cache animation
        waitUntilQuiet(noop);
        close();

        return {
          $$willAnimate: false,
          start: function() {
            return runner;
          },
          end: endFn
        };
      }

      function onAnimationProgress(event) {
        event.stopPropagation();
        var ev = event.originalEvent || event;

        // we now always use `Date.now()` due to the recent changes with
        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
        var timeStamp = ev.$manualTimeStamp || Date.now();

        /* Firefox (or possibly just Gecko) likes to not round values up
         * when a ms measurement is used for the animation */
        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

        /* $manualTimeStamp is a mocked timeStamp value which is set
         * within browserTrigger(). This is only here so that tests can
         * mock animations properly. Real events fallback to event.timeStamp,
         * or, if they don't, then a timeStamp is automatically created for them.
         * We're checking to see if the timeStamp surpasses the expected delay,
         * but we're using elapsedTime instead of the timeStamp on the 2nd
         * pre-condition since animationPauseds sometimes close off early */
        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
          // we set this flag to ensure that if the transition is paused then, when resumed,
          // the animation will automatically close itself since transitions cannot be paused.
          animationCompleted = true;
          close();
        }
      }

      function start() {
        if (animationClosed) return;
        if (!node.parentNode) {
          close();
          return;
        }

        // even though we only pause keyframe animations here the pause flag
        // will still happen when transitions are used. Only the transition will
        // not be paused since that is not possible. If the animation ends when
        // paused then it will not complete until unpaused or cancelled.
        var playPause = function(playAnimation) {
          if (!animationCompleted) {
            animationPaused = !playAnimation;
            if (timings.animationDuration) {
              var value = blockKeyframeAnimations(node, animationPaused);
              animationPaused
                  ? temporaryStyles.push(value)
                  : removeFromArray(temporaryStyles, value);
            }
          } else if (animationPaused && playAnimation) {
            animationPaused = false;
            close();
          }
        };

        // checking the stagger duration prevents an accidentally cascade of the CSS delay style
        // being inherited from the parent. If the transition duration is zero then we can safely
        // rely that the delay value is an intentional stagger delay style.
        var maxStagger = itemIndex > 0
                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                            (timings.animationDuration && stagger.animationDuration === 0))
                         && Math.max(stagger.animationDelay, stagger.transitionDelay);
        if (maxStagger) {
          $timeout(triggerAnimationStart,
                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
                   false);
        } else {
          triggerAnimationStart();
        }

        // this will decorate the existing promise runner with pause/resume methods
        runnerHost.resume = function() {
          playPause(true);
        };

        runnerHost.pause = function() {
          playPause(false);
        };

        function triggerAnimationStart() {
          // just incase a stagger animation kicks in when the animation
          // itself was cancelled entirely
          if (animationClosed) return;

          applyBlocking(false);

          forEach(temporaryStyles, function(entry) {
            var key = entry[0];
            var value = entry[1];
            node.style[key] = value;
          });

          applyAnimationClasses(element, options);
          $$jqLite.addClass(element, activeClasses);

          if (flags.recalculateTimingStyles) {
            fullClassName = node.className + ' ' + preparationClasses;
            cacheKey = gcsHashFn(node, fullClassName);

            timings = computeTimings(node, fullClassName, cacheKey);
            relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;

            if (maxDuration === 0) {
              close();
              return;
            }

            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
          }

          if (flags.applyAnimationDelay) {
            relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

            maxDelay = Math.max(relativeDelay, 0);
            timings.animationDelay = relativeDelay;
            delayStyle = getCssDelayStyle(relativeDelay, true);
            temporaryStyles.push(delayStyle);
            node.style[delayStyle[0]] = delayStyle[1];
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (options.easing) {
            var easeProp, easeVal = options.easing;
            if (flags.hasTransitions) {
              easeProp = TRANSITION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
            if (flags.hasAnimations) {
              easeProp = ANIMATION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
          }

          if (timings.transitionDuration) {
            events.push(TRANSITIONEND_EVENT);
          }

          if (timings.animationDuration) {
            events.push(ANIMATIONEND_EVENT);
          }

          startTime = Date.now();
          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
          var endTime = startTime + timerTime;

          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
          var setupFallbackTimer = true;
          if (animationsData.length) {
            var currentTimerData = animationsData[0];
            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
            if (setupFallbackTimer) {
              $timeout.cancel(currentTimerData.timer);
            } else {
              animationsData.push(close);
            }
          }

          if (setupFallbackTimer) {
            var timer = $timeout(onAnimationExpired, timerTime, false);
            animationsData[0] = {
              timer: timer,
              expectedEndTime: endTime
            };
            animationsData.push(close);
            element.data(ANIMATE_TIMER_KEY, animationsData);
          }

          if (events.length) {
            element.on(events.join(' '), onAnimationProgress);
          }

          if (options.to) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
            }
            applyAnimationToStyles(element, options);
          }
        }

        function onAnimationExpired() {
          var animationsData = element.data(ANIMATE_TIMER_KEY);

          // this will be false in the event that the element was
          // removed from the DOM (via a leave animation or something
          // similar)
          if (animationsData) {
            for (var i = 1; i < animationsData.length; i++) {
              animationsData[i]();
            }
            element.removeData(ANIMATE_TIMER_KEY);
          }
        }
      }
    };
  }];
}];

var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateCssDriver');

  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';

  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

  function isDocumentFragment(node) {
    return node.parentNode && node.parentNode.nodeType === 11;
  }

  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

    // only browsers that support these properties can render animations
    if (!$sniffer.animations && !$sniffer.transitions) return noop;

    var bodyNode = $document[0].body;
    var rootNode = getDomNode($rootElement);

    var rootBodyElement = jqLite(
      // this is to avoid using something that exists outside of the body
      // we also special case the doc fragment case because our unit test code
      // appends the $rootElement to the body after the app has been bootstrapped
      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
    );

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    return function initDriverFn(animationDetails) {
      return animationDetails.from && animationDetails.to
          ? prepareFromToAnchorAnimation(animationDetails.from,
                                         animationDetails.to,
                                         animationDetails.classes,
                                         animationDetails.anchors)
          : prepareRegularAnimation(animationDetails);
    };

    function filterCssClasses(classes) {
      //remove all the `ng-` stuff
      return classes.replace(/\bng-\S+\b/g, '');
    }

    function getUniqueValues(a, b) {
      if (isString(a)) a = a.split(' ');
      if (isString(b)) b = b.split(' ');
      return a.filter(function(val) {
        return b.indexOf(val) === -1;
      }).join(' ');
    }

    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
      var startingClasses = filterCssClasses(getClassVal(clone));

      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

      rootBodyElement.append(clone);

      var animatorIn, animatorOut = prepareOutAnimation();

      // the user may not end up using the `out` animation and
      // only making use of the `in` animation or vice-versa.
      // In either case we should allow this and not assume the
      // animation is over unless both animations are not used.
      if (!animatorOut) {
        animatorIn = prepareInAnimation();
        if (!animatorIn) {
          return end();
        }
      }

      var startingAnimator = animatorOut || animatorIn;

      return {
        start: function() {
          var runner;

          var currentAnimation = startingAnimator.start();
          currentAnimation.done(function() {
            currentAnimation = null;
            if (!animatorIn) {
              animatorIn = prepareInAnimation();
              if (animatorIn) {
                currentAnimation = animatorIn.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  end();
                  runner.complete();
                });
                return currentAnimation;
              }
            }
            // in the event that there is no `in` animation
            end();
            runner.complete();
          });

          runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn
          });

          return runner;

          function endFn() {
            if (currentAnimation) {
              currentAnimation.end();
            }
          }
        }
      };

      function calculateAnchorStyles(anchor) {
        var styles = {};

        var coords = getDomNode(anchor).getBoundingClientRect();

        // we iterate directly since safari messes up and doesn't return
        // all the keys for the coords object when iterated
        forEach(['width','height','top','left'], function(key) {
          var value = coords[key];
          switch (key) {
            case 'top':
              value += bodyNode.scrollTop;
              break;
            case 'left':
              value += bodyNode.scrollLeft;
              break;
          }
          styles[key] = Math.floor(value) + 'px';
        });
        return styles;
      }

      function prepareOutAnimation() {
        var animator = $animateCss(clone, {
          addClass: NG_OUT_ANCHOR_CLASS_NAME,
          delay: true,
          from: calculateAnchorStyles(outAnchor)
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function getClassVal(element) {
        return element.attr('class') || '';
      }

      function prepareInAnimation() {
        var endingClasses = filterCssClasses(getClassVal(inAnchor));
        var toAdd = getUniqueValues(endingClasses, startingClasses);
        var toRemove = getUniqueValues(startingClasses, endingClasses);

        var animator = $animateCss(clone, {
          to: calculateAnchorStyles(inAnchor),
          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
          delay: true
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function end() {
        clone.remove();
        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
      }
    }

    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
      var fromAnimation = prepareRegularAnimation(from, noop);
      var toAnimation = prepareRegularAnimation(to, noop);

      var anchorAnimations = [];
      forEach(anchors, function(anchor) {
        var outElement = anchor['out'];
        var inElement = anchor['in'];
        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
        if (animator) {
          anchorAnimations.push(animator);
        }
      });

      // no point in doing anything when there are no elements to animate
      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;

      return {
        start: function() {
          var animationRunners = [];

          if (fromAnimation) {
            animationRunners.push(fromAnimation.start());
          }

          if (toAnimation) {
            animationRunners.push(toAnimation.start());
          }

          forEach(anchorAnimations, function(animation) {
            animationRunners.push(animation.start());
          });

          var runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
          });

          $$AnimateRunner.all(animationRunners, function(status) {
            runner.complete(status);
          });

          return runner;

          function endFn() {
            forEach(animationRunners, function(runner) {
              runner.end();
            });
          }
        }
      };
    }

    function prepareRegularAnimation(animationDetails) {
      var element = animationDetails.element;
      var options = animationDetails.options || {};

      if (animationDetails.structural) {
        options.event = animationDetails.event;
        options.structural = true;
        options.applyClassesEarly = true;

        // we special case the leave animation since we want to ensure that
        // the element is removed as soon as the animation is over. Otherwise
        // a flicker might appear or the element may not be removed at all
        if (animationDetails.event === 'leave') {
          options.onDone = options.domOperation;
        }
      }

      // We assign the preparationClasses as the actual animation event since
      // the internals of $animateCss will just suffix the event token values
      // with `-active` to trigger the animation.
      if (options.preparationClasses) {
        options.event = concatWithSpace(options.event, options.preparationClasses);
      }

      var animator = $animateCss(element, options);

      // the driver lookup code inside of $$animation attempts to spawn a
      // driver one by one until a driver returns a.$$willAnimate animator object.
      // $animateCss will always return an object, however, it will pass in
      // a flag as a hint as to whether an animation was detected or not
      return animator.$$willAnimate ? animator : null;
    }
  }];
}];

// TODO(matsko): use caching here to speed things up for detection
// TODO(matsko): add documentation
//  by the time...

var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
       function($injector,   $$AnimateRunner,   $$jqLite) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
         // $animateJs(element, 'enter');
    return function(element, event, classes, options) {
      var animationClosed = false;

      // the `classes` argument is optional and if it is not used
      // then the classes will be resolved from the element's className
      // property as well as options.addClass/options.removeClass.
      if (arguments.length === 3 && isObject(classes)) {
        options = classes;
        classes = null;
      }

      options = prepareAnimationOptions(options);
      if (!classes) {
        classes = element.attr('class') || '';
        if (options.addClass) {
          classes += ' ' + options.addClass;
        }
        if (options.removeClass) {
          classes += ' ' + options.removeClass;
        }
      }

      var classesToAdd = options.addClass;
      var classesToRemove = options.removeClass;

      // the lookupAnimations function returns a series of animation objects that are
      // matched up with one or more of the CSS classes. These animation objects are
      // defined via the module.animation factory function. If nothing is detected then
      // we don't return anything which then makes $animation query the next driver.
      var animations = lookupAnimations(classes);
      var before, after;
      if (animations.length) {
        var afterFn, beforeFn;
        if (event == 'leave') {
          beforeFn = 'leave';
          afterFn = 'afterLeave'; // TODO(matsko): get rid of this
        } else {
          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
          afterFn = event;
        }

        if (event !== 'enter' && event !== 'move') {
          before = packageAnimations(element, event, options, animations, beforeFn);
        }
        after  = packageAnimations(element, event, options, animations, afterFn);
      }

      // no matching animations
      if (!before && !after) return;

      function applyOptions() {
        options.domOperation();
        applyAnimationClasses(element, options);
      }

      function close() {
        animationClosed = true;
        applyOptions();
        applyAnimationStyles(element, options);
      }

      var runner;

      return {
        $$willAnimate: true,
        end: function() {
          if (runner) {
            runner.end();
          } else {
            close();
            runner = new $$AnimateRunner();
            runner.complete(true);
          }
          return runner;
        },
        start: function() {
          if (runner) {
            return runner;
          }

          runner = new $$AnimateRunner();
          var closeActiveAnimations;
          var chain = [];

          if (before) {
            chain.push(function(fn) {
              closeActiveAnimations = before(fn);
            });
          }

          if (chain.length) {
            chain.push(function(fn) {
              applyOptions();
              fn(true);
            });
          } else {
            applyOptions();
          }

          if (after) {
            chain.push(function(fn) {
              closeActiveAnimations = after(fn);
            });
          }

          runner.setHost({
            end: function() {
              endAnimations();
            },
            cancel: function() {
              endAnimations(true);
            }
          });

          $$AnimateRunner.chain(chain, onComplete);
          return runner;

          function onComplete(success) {
            close(success);
            runner.complete(success);
          }

          function endAnimations(cancelled) {
            if (!animationClosed) {
              (closeActiveAnimations || noop)(cancelled);
              onComplete(cancelled);
            }
          }
        }
      };

      function executeAnimationFn(fn, element, event, options, onDone) {
        var args;
        switch (event) {
          case 'animate':
            args = [element, options.from, options.to, onDone];
            break;

          case 'setClass':
            args = [element, classesToAdd, classesToRemove, onDone];
            break;

          case 'addClass':
            args = [element, classesToAdd, onDone];
            break;

          case 'removeClass':
            args = [element, classesToRemove, onDone];
            break;

          default:
            args = [element, onDone];
            break;
        }

        args.push(options);

        var value = fn.apply(fn, args);
        if (value) {
          if (isFunction(value.start)) {
            value = value.start();
          }

          if (value instanceof $$AnimateRunner) {
            value.done(onDone);
          } else if (isFunction(value)) {
            // optional onEnd / onCancel callback
            return value;
          }
        }

        return noop;
      }

      function groupEventedAnimations(element, event, options, animations, fnName) {
        var operations = [];
        forEach(animations, function(ani) {
          var animation = ani[fnName];
          if (!animation) return;

          // note that all of these animations will run in parallel
          operations.push(function() {
            var runner;
            var endProgressCb;

            var resolved = false;
            var onAnimationComplete = function(rejected) {
              if (!resolved) {
                resolved = true;
                (endProgressCb || noop)(rejected);
                runner.complete(!rejected);
              }
            };

            runner = new $$AnimateRunner({
              end: function() {
                onAnimationComplete();
              },
              cancel: function() {
                onAnimationComplete(true);
              }
            });

            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
              var cancelled = result === false;
              onAnimationComplete(cancelled);
            });

            return runner;
          });
        });

        return operations;
      }

      function packageAnimations(element, event, options, animations, fnName) {
        var operations = groupEventedAnimations(element, event, options, animations, fnName);
        if (operations.length === 0) {
          var a,b;
          if (fnName === 'beforeSetClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
          } else if (fnName === 'setClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
          }

          if (a) {
            operations = operations.concat(a);
          }
          if (b) {
            operations = operations.concat(b);
          }
        }

        if (operations.length === 0) return;

        // TODO(matsko): add documentation
        return function startAnimation(callback) {
          var runners = [];
          if (operations.length) {
            forEach(operations, function(animateFn) {
              runners.push(animateFn());
            });
          }

          runners.length ? $$AnimateRunner.all(runners, callback) : callback();

          return function endFn(reject) {
            forEach(runners, function(runner) {
              reject ? runner.cancel() : runner.end();
            });
          };
        };
      }
    };

    function lookupAnimations(classes) {
      classes = isArray(classes) ? classes : classes.split(' ');
      var matches = [], flagMap = {};
      for (var i=0; i < classes.length; i++) {
        var klass = classes[i],
            animationFactory = $animateProvider.$$registeredAnimations[klass];
        if (animationFactory && !flagMap[klass]) {
          matches.push($injector.get(animationFactory));
          flagMap[klass] = true;
        }
      }
      return matches;
    }
  }];
}];

var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateJsDriver');
  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
    return function initDriverFn(animationDetails) {
      if (animationDetails.from && animationDetails.to) {
        var fromAnimation = prepareAnimation(animationDetails.from);
        var toAnimation = prepareAnimation(animationDetails.to);
        if (!fromAnimation && !toAnimation) return;

        return {
          start: function() {
            var animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            $$AnimateRunner.all(animationRunners, done);

            var runner = new $$AnimateRunner({
              end: endFnFactory(),
              cancel: endFnFactory()
            });

            return runner;

            function endFnFactory() {
              return function() {
                forEach(animationRunners, function(runner) {
                  // at this point we cannot cancel animations for groups just yet. 1.5+
                  runner.end();
                });
              };
            }

            function done(status) {
              runner.complete(status);
            }
          }
        };
      } else {
        return prepareAnimation(animationDetails);
      }
    };

    function prepareAnimation(animationDetails) {
      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
      var element = animationDetails.element;
      var event = animationDetails.event;
      var options = animationDetails.options;
      var classes = animationDetails.classes;
      return $$animateJs(element, event, classes, options);
    }
  }];
}];

var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
  var PRE_DIGEST_STATE = 1;
  var RUNNING_STATE = 2;
  var ONE_SPACE = ' ';

  var rules = this.rules = {
    skip: [],
    cancel: [],
    join: []
  };

  function makeTruthyCssClassMap(classString) {
    if (!classString) {
      return null;
    }

    var keys = classString.split(ONE_SPACE);
    var map = Object.create(null);

    forEach(keys, function(key) {
      map[key] = true;
    });
    return map;
  }

  function hasMatchingClasses(newClassString, currentClassString) {
    if (newClassString && currentClassString) {
      var currentClassMap = makeTruthyCssClassMap(currentClassString);
      return newClassString.split(ONE_SPACE).some(function(className) {
        return currentClassMap[className];
      });
    }
  }

  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
    return rules[ruleType].some(function(fn) {
      return fn(element, currentAnimation, previousAnimation);
    });
  }

  function hasAnimationClasses(animation, and) {
    var a = (animation.addClass || '').length > 0;
    var b = (animation.removeClass || '').length > 0;
    return and ? a && b : a || b;
  }

  rules.join.push(function(element, newAnimation, currentAnimation) {
    // if the new animation is class-based then we can just tack that on
    return !newAnimation.structural && hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // there is no need to animate anything if no classes are being added and
    // there is no structural animation that will be triggered
    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // why should we trigger a new structural animation if the element will
    // be removed from the DOM anyway?
    return currentAnimation.event == 'leave' && newAnimation.structural;
  });

  rules.skip.push(function(element, newAnimation, currentAnimation) {
    // if there is an ongoing current animation then don't even bother running the class-based animation
    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // there can never be two structural animations running at the same time
    return currentAnimation.structural && newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // if the previous animation is already running, but the new animation will
    // be triggered, but the new animation is structural
    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
  });

  rules.cancel.push(function(element, newAnimation, currentAnimation) {
    // cancel the animation if classes added / removed in both animation cancel each other out,
    // but only if the current animation isn't structural

    if (currentAnimation.structural) return false;

    var nA = newAnimation.addClass;
    var nR = newAnimation.removeClass;
    var cA = currentAnimation.addClass;
    var cR = currentAnimation.removeClass;

    // early detection to save the global CPU shortage :)
    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
      return false;
    }

    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
  });

  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',
               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,
                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {

    var activeAnimationsLookup = new $$HashMap();
    var disabledElementsLookup = new $$HashMap();
    var animationsEnabled = null;

    function postDigestTaskFactory() {
      var postDigestCalled = false;
      return function(fn) {
        // we only issue a call to postDigest before
        // it has first passed. This prevents any callbacks
        // from not firing once the animation has completed
        // since it will be out of the digest cycle.
        if (postDigestCalled) {
          fn();
        } else {
          $rootScope.$$postDigest(function() {
            postDigestCalled = true;
            fn();
          });
        }
      };
    }

    // Wait until all directive and route-related templates are downloaded and
    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
    // all of the remote templates being currently downloaded. If there are no
    // templates currently downloading then the watcher will still fire anyway.
    var deregisterWatch = $rootScope.$watch(
      function() { return $templateRequest.totalPendingRequests === 0; },
      function(isEmpty) {
        if (!isEmpty) return;
        deregisterWatch();

        // Now that all templates have been downloaded, $animate will wait until
        // the post digest queue is empty before enabling animations. By having two
        // calls to $postDigest calls we can ensure that the flag is enabled at the
        // very end of the post digest queue. Since all of the animations in $animate
        // use $postDigest, it's important that the code below executes at the end.
        // This basically means that the page is fully downloaded and compiled before
        // any animations are triggered.
        $rootScope.$$postDigest(function() {
          $rootScope.$$postDigest(function() {
            // we check for null directly in the event that the application already called
            // .enabled() with whatever arguments that it provided it with
            if (animationsEnabled === null) {
              animationsEnabled = true;
            }
          });
        });
      }
    );

    var callbackRegistry = {};

    // remember that the classNameFilter is set during the provider/config
    // stage therefore we can optimize here and setup a helper function
    var classNameFilter = $animateProvider.classNameFilter();
    var isAnimatableClassName = !classNameFilter
              ? function() { return true; }
              : function(className) {
                return classNameFilter.test(className);
              };

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function normalizeAnimationDetails(element, animation) {
      return mergeAnimationDetails(element, animation, {});
    }

    // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
    var contains = window.Node.prototype.contains || function(arg) {
      // jshint bitwise: false
      return this === arg || !!(this.compareDocumentPosition(arg) & 16);
      // jshint bitwise: true
    };

    function findCallbacks(parent, element, event) {
      var targetNode = getDomNode(element);
      var targetParentNode = getDomNode(parent);

      var matches = [];
      var entries = callbackRegistry[event];
      if (entries) {
        forEach(entries, function(entry) {
          if (contains.call(entry.node, targetNode)) {
            matches.push(entry.callback);
          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
            matches.push(entry.callback);
          }
        });
      }

      return matches;
    }

    function filterFromRegistry(list, matchContainer, matchCallback) {
      var containerNode = extractElementNode(matchContainer);
      return list.filter(function(entry) {
        var isMatch = entry.node === containerNode &&
                        (!matchCallback || entry.callback === matchCallback);
        return !isMatch;
      });
    }

    function cleanupEventListeners(phase, element) {
      if (phase === 'close' && !element[0].parentNode) {
        // If the element is not attached to a parentNode, it has been removed by
        // the domOperation, and we can safely remove the event callbacks
        $animate.off(element);
      }
    }

    var $animate = {
      on: function(event, container, callback) {
        var node = extractElementNode(container);
        callbackRegistry[event] = callbackRegistry[event] || [];
        callbackRegistry[event].push({
          node: node,
          callback: callback
        });

        // Remove the callback when the element is removed from the DOM
        jqLite(container).on('$destroy', function() {
          var animationDetails = activeAnimationsLookup.get(node);

          if (!animationDetails) {
            // If there's an animation ongoing, the callback calling code will remove
            // the event listeners. If we'd remove here, the callbacks would be removed
            // before the animation ends
            $animate.off(event, container, callback);
          }
        });
      },

      off: function(event, container, callback) {
        if (arguments.length === 1 && !angular.isString(arguments[0])) {
          container = arguments[0];
          for (var eventType in callbackRegistry) {
            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
          }

          return;
        }

        var entries = callbackRegistry[event];
        if (!entries) return;

        callbackRegistry[event] = arguments.length === 1
            ? null
            : filterFromRegistry(entries, container, callback);
      },

      pin: function(element, parentElement) {
        assertArg(isElement(element), 'element', 'not an element');
        assertArg(isElement(parentElement), 'parentElement', 'not an element');
        element.data(NG_ANIMATE_PIN_DATA, parentElement);
      },

      push: function(element, event, options, domOperation) {
        options = options || {};
        options.domOperation = domOperation;
        return queueAnimation(element, event, options);
      },

      // this method has four signatures:
      //  () - global getter
      //  (bool) - global setter
      //  (element) - element getter
      //  (element, bool) - element setter<F37>
      enabled: function(element, bool) {
        var argCount = arguments.length;

        if (argCount === 0) {
          // () - Global getter
          bool = !!animationsEnabled;
        } else {
          var hasElement = isElement(element);

          if (!hasElement) {
            // (bool) - Global setter
            bool = animationsEnabled = !!element;
          } else {
            var node = getDomNode(element);
            var recordExists = disabledElementsLookup.get(node);

            if (argCount === 1) {
              // (element) - Element getter
              bool = !recordExists;
            } else {
              // (element, bool) - Element setter
              disabledElementsLookup.put(node, !bool);
            }
          }
        }

        return bool;
      }
    };

    return $animate;

    function queueAnimation(element, event, initialOptions) {
      // we always make a copy of the options since
      // there should never be any side effects on
      // the input data when running `$animateCss`.
      var options = copy(initialOptions);

      var node, parent;
      element = stripCommentsFromElement(element);
      if (element) {
        node = getDomNode(element);
        parent = element.parent();
      }

      options = prepareAnimationOptions(options);

      // we create a fake runner with a working promise.
      // These methods will become available after the digest has passed
      var runner = new $$AnimateRunner();

      // this is used to trigger callbacks in postDigest mode
      var runInNextPostDigestOrNow = postDigestTaskFactory();

      if (isArray(options.addClass)) {
        options.addClass = options.addClass.join(' ');
      }

      if (options.addClass && !isString(options.addClass)) {
        options.addClass = null;
      }

      if (isArray(options.removeClass)) {
        options.removeClass = options.removeClass.join(' ');
      }

      if (options.removeClass && !isString(options.removeClass)) {
        options.removeClass = null;
      }

      if (options.from && !isObject(options.from)) {
        options.from = null;
      }

      if (options.to && !isObject(options.to)) {
        options.to = null;
      }

      // there are situations where a directive issues an animation for
      // a jqLite wrapper that contains only comment nodes... If this
      // happens then there is no way we can perform an animation
      if (!node) {
        close();
        return runner;
      }

      var className = [node.className, options.addClass, options.removeClass].join(' ');
      if (!isAnimatableClassName(className)) {
        close();
        return runner;
      }

      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      var documentHidden = $document[0].hidden;

      // this is a hard disable of all animations for the application or on
      // the element itself, therefore  there is no need to continue further
      // past this point if not enabled
      // Animations are also disabled if the document is currently hidden (page is not visible
      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
      var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
      var hasExistingAnimation = !!existingAnimation.state;

      // there is no point in traversing the same collection of parent ancestors if a followup
      // animation will be run on the same element that already did all that checking work
      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
        skipAnimations = !areAnimationsAllowed(element, parent, event);
      }

      if (skipAnimations) {
        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)
        if (documentHidden) notifyProgress(runner, event, 'start');
        close();
        if (documentHidden) notifyProgress(runner, event, 'close');
        return runner;
      }

      if (isStructural) {
        closeChildAnimations(element);
      }

      var newAnimation = {
        structural: isStructural,
        element: element,
        event: event,
        addClass: options.addClass,
        removeClass: options.removeClass,
        close: close,
        options: options,
        runner: runner
      };

      if (hasExistingAnimation) {
        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
        if (skipAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            close();
            return runner;
          } else {
            mergeAnimationDetails(element, existingAnimation, newAnimation);
            return existingAnimation.runner;
          }
        }
        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
        if (cancelAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            // this will end the animation right away and it is safe
            // to do so since the animation is already running and the
            // runner callback code will run in async
            existingAnimation.runner.end();
          } else if (existingAnimation.structural) {
            // this means that the animation is queued into a digest, but
            // hasn't started yet. Therefore it is safe to run the close
            // method which will call the runner methods in async.
            existingAnimation.close();
          } else {
            // this will merge the new animation options into existing animation options
            mergeAnimationDetails(element, existingAnimation, newAnimation);

            return existingAnimation.runner;
          }
        } else {
          // a joined animation means that this animation will take over the existing one
          // so an example would involve a leave animation taking over an enter. Then when
          // the postDigest kicks in the enter will be ignored.
          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
          if (joinAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              normalizeAnimationDetails(element, newAnimation);
            } else {
              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);

              event = newAnimation.event = existingAnimation.event;
              options = mergeAnimationDetails(element, existingAnimation, newAnimation);

              //we return the same runner since only the option values of this animation will
              //be fed into the `existingAnimation`.
              return existingAnimation.runner;
            }
          }
        }
      } else {
        // normalization in this case means that it removes redundant CSS classes that
        // already exist (addClass) or do not exist (removeClass) on the element
        normalizeAnimationDetails(element, newAnimation);
      }

      // when the options are merged and cleaned up we may end up not having to do
      // an animation at all, therefore we should check this before issuing a post
      // digest callback. Structural animations will always run no matter what.
      var isValidAnimation = newAnimation.structural;
      if (!isValidAnimation) {
        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)
                            || hasAnimationClasses(newAnimation);
      }

      if (!isValidAnimation) {
        close();
        clearElementAnimationState(element);
        return runner;
      }

      // the counter keeps track of cancelled animations
      var counter = (existingAnimation.counter || 0) + 1;
      newAnimation.counter = counter;

      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);

      $rootScope.$$postDigest(function() {
        var animationDetails = activeAnimationsLookup.get(node);
        var animationCancelled = !animationDetails;
        animationDetails = animationDetails || {};

        // if addClass/removeClass is called before something like enter then the
        // registered parent element may not be present. The code below will ensure
        // that a final value for parent element is obtained
        var parentElement = element.parent() || [];

        // animate/structural/class-based animations all have requirements. Otherwise there
        // is no point in performing an animation. The parent node must also be set.
        var isValidAnimation = parentElement.length > 0
                                && (animationDetails.event === 'animate'
                                    || animationDetails.structural
                                    || hasAnimationClasses(animationDetails));

        // this means that the previous animation was cancelled
        // even if the follow-up animation is the same event
        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
          // if another animation did not take over then we need
          // to make sure that the domOperation and options are
          // handled accordingly
          if (animationCancelled) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
          }

          // if the event changed from something like enter to leave then we do
          // it, otherwise if it's the same then the end result will be the same too
          if (animationCancelled || (isStructural && animationDetails.event !== event)) {
            options.domOperation();
            runner.end();
          }

          // in the event that the element animation was not cancelled or a follow-up animation
          // isn't allowed to animate from here then we need to clear the state of the element
          // so that any future animations won't read the expired animation data.
          if (!isValidAnimation) {
            clearElementAnimationState(element);
          }

          return;
        }

        // this combined multiple class to addClass / removeClass into a setClass event
        // so long as a structural event did not take over the animation
        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)
            ? 'setClass'
            : animationDetails.event;

        markElementAnimationState(element, RUNNING_STATE);
        var realRunner = $$animation(element, event, animationDetails.options);

        // this will update the runner's flow-control events based on
        // the `realRunner` object.
        runner.setHost(realRunner);
        notifyProgress(runner, event, 'start', {});

        realRunner.done(function(status) {
          close(!status);
          var animationDetails = activeAnimationsLookup.get(node);
          if (animationDetails && animationDetails.counter === counter) {
            clearElementAnimationState(getDomNode(element));
          }
          notifyProgress(runner, event, 'close', {});
        });
      });

      return runner;

      function notifyProgress(runner, event, phase, data) {
        runInNextPostDigestOrNow(function() {
          var callbacks = findCallbacks(parent, element, event);
          if (callbacks.length) {
            // do not optimize this call here to RAF because
            // we don't know how heavy the callback code here will
            // be and if this code is buffered then this can
            // lead to a performance regression.
            $$rAF(function() {
              forEach(callbacks, function(callback) {
                callback(element, phase, data);
              });
              cleanupEventListeners(phase, element);
            });
          } else {
            cleanupEventListeners(phase, element);
          }
        });
        runner.progress(event, phase, data);
      }

      function close(reject) { // jshint ignore:line
        clearGeneratedClasses(element, options);
        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();
        runner.complete(!reject);
      }
    }

    function closeChildAnimations(element) {
      var node = getDomNode(element);
      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
      forEach(children, function(child) {
        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
        var animationDetails = activeAnimationsLookup.get(child);
        if (animationDetails) {
          switch (state) {
            case RUNNING_STATE:
              animationDetails.runner.end();
              /* falls through */
            case PRE_DIGEST_STATE:
              activeAnimationsLookup.remove(child);
              break;
          }
        }
      });
    }

    function clearElementAnimationState(element) {
      var node = getDomNode(element);
      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
      activeAnimationsLookup.remove(node);
    }

    function isMatchingElement(nodeOrElmA, nodeOrElmB) {
      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
    }

    /**
     * This fn returns false if any of the following is true:
     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
     * b) a parent element has an ongoing structural animation, and animateChildren is false
     * c) the element is not a child of the body
     * d) the element is not a child of the $rootElement
     */
    function areAnimationsAllowed(element, parentElement, event) {
      var bodyElement = jqLite($document[0].body);
      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
      var rootElementDetected = isMatchingElement(element, $rootElement);
      var parentAnimationDetected = false;
      var animateChildren;
      var elementDisabled = disabledElementsLookup.get(getDomNode(element));

      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
      if (parentHost) {
        parentElement = parentHost;
      }

      parentElement = getDomNode(parentElement);

      while (parentElement) {
        if (!rootElementDetected) {
          // angular doesn't want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootElementDetected = isMatchingElement(parentElement, $rootElement);
        }

        if (parentElement.nodeType !== ELEMENT_NODE) {
          // no point in inspecting the #document element
          break;
        }

        var details = activeAnimationsLookup.get(parentElement) || {};
        // either an enter, leave or move animation will commence
        // therefore we can't allow any animations to take place
        // but if a parent animation is class-based then that's ok
        if (!parentAnimationDetected) {
          var parentElementDisabled = disabledElementsLookup.get(parentElement);

          if (parentElementDisabled === true && elementDisabled !== false) {
            // disable animations if the user hasn't explicitly enabled animations on the
            // current element
            elementDisabled = true;
            // element is disabled via parent element, no need to check anything else
            break;
          } else if (parentElementDisabled === false) {
            elementDisabled = false;
          }
          parentAnimationDetected = details.structural;
        }

        if (isUndefined(animateChildren) || animateChildren === true) {
          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
          if (isDefined(value)) {
            animateChildren = value;
          }
        }

        // there is no need to continue traversing at this point
        if (parentAnimationDetected && animateChildren === false) break;

        if (!bodyElementDetected) {
          // we also need to ensure that the element is or will be a part of the body element
          // otherwise it is pointless to even issue an animation to be rendered
          bodyElementDetected = isMatchingElement(parentElement, bodyElement);
        }

        if (bodyElementDetected && rootElementDetected) {
          // If both body and root have been found, any other checks are pointless,
          // as no animation data should live outside the application
          break;
        }

        if (!rootElementDetected) {
          // If no rootElement is detected, check if the parentElement is pinned to another element
          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            // The pin target element becomes the next parent element
            parentElement = getDomNode(parentHost);
            continue;
          }
        }

        parentElement = parentElement.parentNode;
      }

      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
      return allowAnimation && rootElementDetected && bodyElementDetected;
    }

    function markElementAnimationState(element, state, details) {
      details = details || {};
      details.state = state;

      var node = getDomNode(element);
      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

      var oldValue = activeAnimationsLookup.get(node);
      var newValue = oldValue
          ? extend(oldValue, details)
          : details;
      activeAnimationsLookup.put(node, newValue);
    }
  }];
}];

var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';

  var drivers = this.drivers = [];

  var RUNNER_STORAGE_KEY = '$$animationRunner';

  function setRunner(element, runner) {
    element.data(RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    element.removeData(RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return element.data(RUNNER_STORAGE_KEY);
  }

  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',
       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {

    var animationQueue = [];
    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function sortAnimations(animations) {
      var tree = { children: [] };
      var i, lookup = new $$HashMap();

      // this is done first beforehand so that the hashmap
      // is filled with a list of the elements that will be animated
      for (i = 0; i < animations.length; i++) {
        var animation = animations[i];
        lookup.put(animation.domNode, animations[i] = {
          domNode: animation.domNode,
          fn: animation.fn,
          children: []
        });
      }

      for (i = 0; i < animations.length; i++) {
        processNode(animations[i]);
      }

      return flatten(tree);

      function processNode(entry) {
        if (entry.processed) return entry;
        entry.processed = true;

        var elementNode = entry.domNode;
        var parentNode = elementNode.parentNode;
        lookup.put(elementNode, entry);

        var parentEntry;
        while (parentNode) {
          parentEntry = lookup.get(parentNode);
          if (parentEntry) {
            if (!parentEntry.processed) {
              parentEntry = processNode(parentEntry);
            }
            break;
          }
          parentNode = parentNode.parentNode;
        }

        (parentEntry || tree).children.push(entry);
        return entry;
      }

      function flatten(tree) {
        var result = [];
        var queue = [];
        var i;

        for (i = 0; i < tree.children.length; i++) {
          queue.push(tree.children[i]);
        }

        var remainingLevelEntries = queue.length;
        var nextLevelEntries = 0;
        var row = [];

        for (i = 0; i < queue.length; i++) {
          var entry = queue[i];
          if (remainingLevelEntries <= 0) {
            remainingLevelEntries = nextLevelEntries;
            nextLevelEntries = 0;
            result.push(row);
            row = [];
          }
          row.push(entry.fn);
          entry.children.forEach(function(childEntry) {
            nextLevelEntries++;
            queue.push(childEntry);
          });
          remainingLevelEntries--;
        }

        if (row.length) {
          result.push(row);
        }

        return result;
      }
    }

    // TODO(matsko): document the signature in a better way
    return function(element, event, options) {
      options = prepareAnimationOptions(options);
      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      // there is no animation at the current moment, however
      // these runner methods will get later updated with the
      // methods leading into the driver's end/cancel methods
      // for now they just stop the animation from starting
      var runner = new $$AnimateRunner({
        end: function() { close(); },
        cancel: function() { close(true); }
      });

      if (!drivers.length) {
        close();
        return runner;
      }

      setRunner(element, runner);

      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
      var tempClasses = options.tempClasses;
      if (tempClasses) {
        classes += ' ' + tempClasses;
        options.tempClasses = null;
      }

      var prepareClassName;
      if (isStructural) {
        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
        $$jqLite.addClass(element, prepareClassName);
      }

      animationQueue.push({
        // this data is used by the postDigest code and passed into
        // the driver step function
        element: element,
        classes: classes,
        event: event,
        structural: isStructural,
        options: options,
        beforeStart: beforeStart,
        close: close
      });

      element.on('$destroy', handleDestroyedElement);

      // we only want there to be one function called within the post digest
      // block. This way we can group animations for all the animations that
      // were apart of the same postDigest flush call.
      if (animationQueue.length > 1) return runner;

      $rootScope.$$postDigest(function() {
        var animations = [];
        forEach(animationQueue, function(entry) {
          // the element was destroyed early on which removed the runner
          // form its storage. This means we can't animate this element
          // at all and it already has been closed due to destruction.
          if (getRunner(entry.element)) {
            animations.push(entry);
          } else {
            entry.close();
          }
        });

        // now any future animations will be in another postDigest
        animationQueue.length = 0;

        var groupedAnimations = groupAnimations(animations);
        var toBeSortedAnimations = [];

        forEach(groupedAnimations, function(animationEntry) {
          toBeSortedAnimations.push({
            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
            fn: function triggerAnimationStart() {
              // it's important that we apply the `ng-animate` CSS class and the
              // temporary classes before we do any driver invoking since these
              // CSS classes may be required for proper CSS detection.
              animationEntry.beforeStart();

              var startAnimationFn, closeFn = animationEntry.close;

              // in the event that the element was removed before the digest runs or
              // during the RAF sequencing then we should not trigger the animation.
              var targetElement = animationEntry.anchors
                  ? (animationEntry.from.element || animationEntry.to.element)
                  : animationEntry.element;

              if (getRunner(targetElement)) {
                var operation = invokeFirstDriver(animationEntry);
                if (operation) {
                  startAnimationFn = operation.start;
                }
              }

              if (!startAnimationFn) {
                closeFn();
              } else {
                var animationRunner = startAnimationFn();
                animationRunner.done(function(status) {
                  closeFn(!status);
                });
                updateAnimationRunners(animationEntry, animationRunner);
              }
            }
          });
        });

        // we need to sort each of the animations in order of parent to child
        // relationships. This ensures that the child classes are applied at the
        // right time.
        $$rAFScheduler(sortAnimations(toBeSortedAnimations));
      });

      return runner;

      // TODO(matsko): change to reference nodes
      function getAnchorNodes(node) {
        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);
        var anchors = [];
        forEach(items, function(node) {
          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
          if (attr && attr.length) {
            anchors.push(node);
          }
        });
        return anchors;
      }

      function groupAnimations(animations) {
        var preparedAnimations = [];
        var refLookup = {};
        forEach(animations, function(animation, index) {
          var element = animation.element;
          var node = getDomNode(element);
          var event = animation.event;
          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

          if (anchorNodes.length) {
            var direction = enterOrMove ? 'to' : 'from';

            forEach(anchorNodes, function(anchor) {
              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
              refLookup[key] = refLookup[key] || {};
              refLookup[key][direction] = {
                animationID: index,
                element: jqLite(anchor)
              };
            });
          } else {
            preparedAnimations.push(animation);
          }
        });

        var usedIndicesLookup = {};
        var anchorGroups = {};
        forEach(refLookup, function(operations, key) {
          var from = operations.from;
          var to = operations.to;

          if (!from || !to) {
            // only one of these is set therefore we can't have an
            // anchor animation since all three pieces are required
            var index = from ? from.animationID : to.animationID;
            var indexKey = index.toString();
            if (!usedIndicesLookup[indexKey]) {
              usedIndicesLookup[indexKey] = true;
              preparedAnimations.push(animations[index]);
            }
            return;
          }

          var fromAnimation = animations[from.animationID];
          var toAnimation = animations[to.animationID];
          var lookupKey = from.animationID.toString();
          if (!anchorGroups[lookupKey]) {
            var group = anchorGroups[lookupKey] = {
              structural: true,
              beforeStart: function() {
                fromAnimation.beforeStart();
                toAnimation.beforeStart();
              },
              close: function() {
                fromAnimation.close();
                toAnimation.close();
              },
              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
              from: fromAnimation,
              to: toAnimation,
              anchors: [] // TODO(matsko): change to reference nodes
            };

            // the anchor animations require that the from and to elements both have at least
            // one shared CSS class which effectively marries the two elements together to use
            // the same animation driver and to properly sequence the anchor animation.
            if (group.classes.length) {
              preparedAnimations.push(group);
            } else {
              preparedAnimations.push(fromAnimation);
              preparedAnimations.push(toAnimation);
            }
          }

          anchorGroups[lookupKey].anchors.push({
            'out': from.element, 'in': to.element
          });
        });

        return preparedAnimations;
      }

      function cssClassesIntersection(a,b) {
        a = a.split(' ');
        b = b.split(' ');
        var matches = [];

        for (var i = 0; i < a.length; i++) {
          var aa = a[i];
          if (aa.substring(0,3) === 'ng-') continue;

          for (var j = 0; j < b.length; j++) {
            if (aa === b[j]) {
              matches.push(aa);
              break;
            }
          }
        }

        return matches.join(' ');
      }

      function invokeFirstDriver(animationDetails) {
        // we loop in reverse order since the more general drivers (like CSS and JS)
        // may attempt more elements, but custom drivers are more particular
        for (var i = drivers.length - 1; i >= 0; i--) {
          var driverName = drivers[i];
          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check

          var factory = $injector.get(driverName);
          var driver = factory(animationDetails);
          if (driver) {
            return driver;
          }
        }
      }

      function beforeStart() {
        element.addClass(NG_ANIMATE_CLASSNAME);
        if (tempClasses) {
          $$jqLite.addClass(element, tempClasses);
        }
        if (prepareClassName) {
          $$jqLite.removeClass(element, prepareClassName);
          prepareClassName = null;
        }
      }

      function updateAnimationRunners(animation, newRunner) {
        if (animation.from && animation.to) {
          update(animation.from.element);
          update(animation.to.element);
        } else {
          update(animation.element);
        }

        function update(element) {
          getRunner(element).setHost(newRunner);
        }
      }

      function handleDestroyedElement() {
        var runner = getRunner(element);
        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
          runner.end();
        }
      }

      function close(rejected) { // jshint ignore:line
        element.off('$destroy', handleDestroyedElement);
        removeRunner(element);

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();

        if (tempClasses) {
          $$jqLite.removeClass(element, tempClasses);
        }

        element.removeClass(NG_ANIMATE_CLASSNAME);
        runner.complete(!rejected);
      }
    };
  }];
}];

/**
 * @ngdoc directive
 * @name ngAnimateSwap
 * @restrict A
 * @scope
 *
 * @description
 *
 * ngAnimateSwap is a animation-oriented directive that allows for the container to
 * be removed and entered in whenever the associated expression changes. A
 * common usecase for this directive is a rotating banner or slider component which
 * contains one image being present at a time. When the active image changes
 * then the old image will perform a `leave` animation and the new element
 * will be inserted via an `enter` animation.
 *
 * @animations
 * | Animation                        | Occurs                               |
 * |----------------------------------|--------------------------------------|
 * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |
 * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |
 *
 * @example
 * <example name="ngAnimateSwap-directive" module="ngAnimateSwapExample"
 *          deps="angular-animate.js"
 *          animations="true" fixBase="true">
 *   <file name="index.html">
 *     <div class="container" ng-controller="AppCtrl">
 *       <div ng-animate-swap="number" class="cell swap-animation" ng-class="colorClass(number)">
 *         {{ number }}
 *       </div>
 *     </div>
 *   </file>
 *   <file name="script.js">
 *     angular.module('ngAnimateSwapExample', ['ngAnimate'])
 *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {
 *         $scope.number = 0;
 *         $interval(function() {
 *           $scope.number++;
 *         }, 1000);
 *
 *         var colors = ['red','blue','green','yellow','orange'];
 *         $scope.colorClass = function(number) {
 *           return colors[number % colors.length];
 *         };
 *       }]);
 *   </file>
 *  <file name="animations.css">
 *  .container {
 *    height:250px;
 *    width:250px;
 *    position:relative;
 *    overflow:hidden;
 *    border:2px solid black;
 *  }
 *  .container .cell {
 *    font-size:150px;
 *    text-align:center;
 *    line-height:250px;
 *    position:absolute;
 *    top:0;
 *    left:0;
 *    right:0;
 *    border-bottom:2px solid black;
 *  }
 *  .swap-animation.ng-enter, .swap-animation.ng-leave {
 *    transition:0.5s linear all;
 *  }
 *  .swap-animation.ng-enter {
 *    top:-250px;
 *  }
 *  .swap-animation.ng-enter-active {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave-active {
 *    top:250px;
 *  }
 *  .red { background:red; }
 *  .green { background:green; }
 *  .blue { background:blue; }
 *  .yellow { background:yellow; }
 *  .orange { background:orange; }
 *  </file>
 * </example>
 */
var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
  return {
    restrict: 'A',
    transclude: 'element',
    terminal: true,
    priority: 600, // we use 600 here to ensure that the directive is caught before others
    link: function(scope, $element, attrs, ctrl, $transclude) {
      var previousElement, previousScope;
      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
        if (previousElement) {
          $animate.leave(previousElement);
        }
        if (previousScope) {
          previousScope.$destroy();
          previousScope = null;
        }
        if (value || value === 0) {
          previousScope = scope.$new();
          $transclude(previousScope, function(element) {
            previousElement = element;
            $animate.enter(element, null, $element);
          });
        }
      });
    }
  };
}];

/* global angularAnimateModule: true,

   ngAnimateSwapDirective,
   $$AnimateAsyncRunFactory,
   $$rAFSchedulerFactory,
   $$AnimateChildrenDirective,
   $$AnimateQueueProvider,
   $$AnimationProvider,
   $AnimateCssProvider,
   $$AnimateCssDriverProvider,
   $$AnimateJsProvider,
   $$AnimateJsDriverProvider,
*/

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
 * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.
 *
 * <div doc-module-components="ngAnimate"></div>
 *
 * # Usage
 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For
 * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within
 * the HTML element that the animation will be triggered on.
 *
 * ## Directive Support
 * The following directives are "animation aware":
 *
 * | Directive                                                                                                | Supported Animations                                                     |
 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
 * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
 * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
 *
 * (More information can be found by visiting each the documentation associated with each directive.)
 *
 * ## CSS-based Animations
 *
 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
 * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.
 *
 * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:
 *
 * ```html
 * <div ng-if="bool" class="fade">
 *    Fade me in out
 * </div>
 * <button ng-click="bool=true">Fade In!</button>
 * <button ng-click="bool=false">Fade Out!</button>
 * ```
 *
 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
 *
 * ```css
 * /&#42; The starting CSS styles for the enter animation &#42;/
 * .fade.ng-enter {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 *
 * /&#42; The finishing CSS styles for the enter animation &#42;/
 * .fade.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * ```
 *
 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two
 * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition
 * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.
 *
 * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
 *
 * ```css
 * /&#42; now the element will fade out before it is removed from the DOM &#42;/
 * .fade.ng-leave {
 *   transition:0.5s linear all;
 *   opacity:1;
 * }
 * .fade.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
 *
 * ```css
 * /&#42; there is no need to define anything inside of the destination
 * CSS class since the keyframe will take charge of the animation &#42;/
 * .fade.ng-leave {
 *   animation: my_fade_animation 0.5s linear;
 *   -webkit-animation: my_fade_animation 0.5s linear;
 * }
 *
 * @keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 *
 * @-webkit-keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 * ```
 *
 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
 *
 * ### CSS Class-based Animations
 *
 * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different
 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
 * and removed.
 *
 * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:
 *
 * ```html
 * <div ng-show="bool" class="fade">
 *   Show and hide me
 * </div>
 * <button ng-click="bool=!bool">Toggle</button>
 *
 * <style>
 * .fade.ng-hide {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 * </style>
 * ```
 *
 * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since
 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
 *
 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
 * with CSS styles.
 *
 * ```html
 * <div ng-class="{on:onOff}" class="highlight">
 *   Highlight this box
 * </div>
 * <button ng-click="onOff=!onOff">Toggle</button>
 *
 * <style>
 * .highlight {
 *   transition:0.5s linear all;
 * }
 * .highlight.on-add {
 *   background:white;
 * }
 * .highlight.on {
 *   background:yellow;
 * }
 * .highlight.on-remove {
 *   background:black;
 * }
 * </style>
 * ```
 *
 * We can also make use of CSS keyframes by placing them within the CSS classes.
 *
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   transition-delay: 0.1s;
 *
 *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate
 *     to not accidentally inherit a delay property from another CSS class &#42;/
 *   transition-duration: 0s;
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * window.requestAnimationFrame(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 *
 *   $scope.$digest();
 * });
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ### The `ng-animate` CSS class
 *
 * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.
 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
 *
 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
 *
 * ```css
 * .zipper.ng-animate {
 *   transition:0.5s linear all;
 * }
 * .zipper.ng-enter {
 *   opacity:0;
 * }
 * .zipper.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * .zipper.ng-leave {
 *   opacity:1;
 * }
 * .zipper.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
 * the CSS class once an animation has completed.)
 *
 *
 * ### The `ng-[event]-prepare` class
 *
 * This is a special class that can be used to prevent unwanted flickering / flash of content before
 * the actual animation starts. The class is added as soon as an animation is initialized, but removed
 * before the actual animation starts (after waiting for a $digest).
 * It is also only added for *structural* animations (`enter`, `move`, and `leave`).
 *
 * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`
 * into elements that have class-based animations such as `ngClass`.
 *
 * ```html
 * <div ng-class="{red: myProp}">
 *   <div ng-class="{blue: myProp}">
 *     <div class="message" ng-if="myProp"></div>
 *   </div>
 * </div>
 * ```
 *
 * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.
 * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:
 *
 * ```css
 * .message.ng-enter-prepare {
 *   opacity: 0;
 * }
 *
 * ```
 *
 * ## JavaScript-based Animations
 *
 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
 * `module.animation()` module function we can register the animation.
 *
 * Let's see an example of a enter/leave animation using `ngRepeat`:
 *
 * ```html
 * <div ng-repeat="item in items" class="slide">
 *   {{ item }}
 * </div>
 * ```
 *
 * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     // make note that other events (like addClass/removeClass)
 *     // have different function input parameters
 *     enter: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *
 *       // remember to call doneFn so that angular
 *       // knows that the animation has concluded
 *     },
 *
 *     move: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *     },
 *
 *     leave: function(element, doneFn) {
 *       jQuery(element).fadeOut(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
 * greensock.js and velocity.js.
 *
 * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define
 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
 *
 * ```html
 * <div ng-class="color" class="colorful">
 *   this box is moody
 * </div>
 * <button ng-click="color='red'">Change to red</button>
 * <button ng-click="color='blue'">Change to blue</button>
 * <button ng-click="color='green'">Change to green</button>
 * ```
 *
 * ```js
 * myModule.animation('.colorful', [function() {
 *   return {
 *     addClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     removeClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     setClass: function(element, addedClass, removedClass, doneFn) {
 *       // do some cool animation and call the doneFn
 *     }
 *   }
 * }]);
 * ```
 *
 * ## CSS + JS Animations Together
 *
 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,
 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
 * charge of the animation**:
 *
 * ```html
 * <div ng-if="bool" class="slide">
 *   Slide in and out
 * </div>
 * ```
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     enter: function(element, doneFn) {
 *       jQuery(element).slideIn(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * ```css
 * .slide.ng-enter {
 *   transition:0.5s linear all;
 *   transform:translateY(-100px);
 * }
 * .slide.ng-enter.ng-enter-active {
 *   transform:translateY(0);
 * }
 * ```
 *
 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
 * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from
 * our own JS-based animation code:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.
 *
 * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
 * data into `$animateCss` directly:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true,
 *         addClass: 'maroon-setting',
 *         from: { height:0 },
 *         to: { height: 200 }
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Now we can fill in the rest via our transition CSS code:
 *
 * ```css
 * /&#42; the transition tells ngAnimate to make the animation happen &#42;/
 * .slide.ng-enter { transition:0.5s linear all; }
 *
 * /&#42; this extra CSS class will be absorbed into the transition
 * since the $animateCss code is adding the class &#42;/
 * .maroon-setting { background:red; }
 * ```
 *
 * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.
 *
 * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
 *
 * ## Animation Anchoring (via `ng-animate-ref`)
 *
 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
 * structural areas of an application (like views) by pairing up elements using an attribute
 * called `ng-animate-ref`.
 *
 * Let's say for example we have two views that are managed by `ng-view` and we want to show
 * that there is a relationship between two components situated in within these views. By using the
 * `ng-animate-ref` attribute we can identify that the two components are paired together and we
 * can then attach an animation, which is triggered when the view changes.
 *
 * Say for example we have the following template code:
 *
 * ```html
 * <!-- index.html -->
 * <div ng-view class="view-animation">
 * </div>
 *
 * <!-- home.html -->
 * <a href="#/banner-page">
 *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * </a>
 *
 * <!-- banner-page.html -->
 * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * ```
 *
 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
 * HTML contents to see if there is a match reference between any components in the view
 * that is leaving and the view that is entering. It will scan both the view which is being
 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
 * contain a matching ref value.
 *
 * The two images match since they share the same ref value. ngAnimate will now create a
 * transport element (which is a clone of the first image element) and it will then attempt
 * to animate to the position of the second image element in the next view. For the animation to
 * work a special CSS class called `ng-anchor` will be added to the transported element.
 *
 * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then
 * ngAnimate will handle the entire transition for us as well as the addition and removal of
 * any changes of CSS classes between the elements:
 *
 * ```css
 * .banner.ng-anchor {
 *   /&#42; this animation will last for 1 second since there are
 *          two phases to the animation (an `in` and an `out` phase) &#42;/
 *   transition:0.5s linear all;
 * }
 * ```
 *
 * We also **must** include animations for the views that are being entered and removed
 * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).
 *
 * ```css
 * .view-animation.ng-enter, .view-animation.ng-leave {
 *   transition:0.5s linear all;
 *   position:fixed;
 *   left:0;
 *   top:0;
 *   width:100%;
 * }
 * .view-animation.ng-enter {
 *   transform:translateX(100%);
 * }
 * .view-animation.ng-leave,
 * .view-animation.ng-enter.ng-enter-active {
 *   transform:translateX(0%);
 * }
 * .view-animation.ng-leave.ng-leave-active {
 *   transform:translateX(-100%);
 * }
 * ```
 *
 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
 * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away
 * from its origin. Once that animation is over then the `in` stage occurs which animates the
 * element to its destination. The reason why there are two animations is to give enough time
 * for the enter animation on the new element to be ready.
 *
 * The example above sets up a transition for both the in and out phases, but we can also target the out or
 * in phases directly via `ng-anchor-out` and `ng-anchor-in`.
 *
 * ```css
 * .banner.ng-anchor-out {
 *   transition: 0.5s linear all;
 *
 *   /&#42; the scale will be applied during the out animation,
 *          but will be animated away when the in animation runs &#42;/
 *   transform: scale(1.2);
 * }
 *
 * .banner.ng-anchor-in {
 *   transition: 1s linear all;
 * }
 * ```
 *
 *
 *
 *
 * ### Anchoring Demo
 *
  <example module="anchoringExample"
           name="anchoringExample"
           id="anchoringExample"
           deps="angular-animate.js;angular-route.js"
           animations="true">
    <file name="index.html">
      <a href="#/">Home</a>
      <hr />
      <div class="view-container">
        <div ng-view class="view"></div>
      </div>
    </file>
    <file name="script.js">
      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])
        .config(['$routeProvider', function($routeProvider) {
          $routeProvider.when('/', {
            templateUrl: 'home.html',
            controller: 'HomeController as home'
          });
          $routeProvider.when('/profile/:id', {
            templateUrl: 'profile.html',
            controller: 'ProfileController as profile'
          });
        }])
        .run(['$rootScope', function($rootScope) {
          $rootScope.records = [
            { id:1, title: "Miss Beulah Roob" },
            { id:2, title: "Trent Morissette" },
            { id:3, title: "Miss Ava Pouros" },
            { id:4, title: "Rod Pouros" },
            { id:5, title: "Abdul Rice" },
            { id:6, title: "Laurie Rutherford Sr." },
            { id:7, title: "Nakia McLaughlin" },
            { id:8, title: "Jordon Blanda DVM" },
            { id:9, title: "Rhoda Hand" },
            { id:10, title: "Alexandrea Sauer" }
          ];
        }])
        .controller('HomeController', [function() {
          //empty
        }])
        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {
          var index = parseInt($routeParams.id, 10);
          var record = $rootScope.records[index - 1];

          this.title = record.title;
          this.id = record.id;
        }]);
    </file>
    <file name="home.html">
      <h2>Welcome to the home page</h1>
      <p>Please click on an element</p>
      <a class="record"
         ng-href="#/profile/{{ record.id }}"
         ng-animate-ref="{{ record.id }}"
         ng-repeat="record in records">
        {{ record.title }}
      </a>
    </file>
    <file name="profile.html">
      <div class="profile record" ng-animate-ref="{{ profile.id }}">
        {{ profile.title }}
      </div>
    </file>
    <file name="animations.css">
      .record {
        display:block;
        font-size:20px;
      }
      .profile {
        background:black;
        color:white;
        font-size:100px;
      }
      .view-container {
        position:relative;
      }
      .view-container > .view.ng-animate {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        min-height:500px;
      }
      .view.ng-enter, .view.ng-leave,
      .record.ng-anchor {
        transition:0.5s linear all;
      }
      .view.ng-enter {
        transform:translateX(100%);
      }
      .view.ng-enter.ng-enter-active, .view.ng-leave {
        transform:translateX(0%);
      }
      .view.ng-leave.ng-leave-active {
        transform:translateX(-100%);
      }
      .record.ng-anchor-out {
        background:red;
      }
    </file>
  </example>
 *
 * ### How is the element transported?
 *
 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
 * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match
 * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied
 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
 * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element
 * will become visible since the shim class will be removed.
 *
 * ### How is the morphing handled?
 *
 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
 * what CSS classes differ between the starting element and the destination element. These different CSS classes
 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
 * the cloned element is placed inside of root element which is likely close to the body element).
 *
 * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.
 *
 *
 * ## Using $animate in your directive code
 *
 * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?
 * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's
 * imagine we have a greeting box that shows and hides itself when the data changes
 *
 * ```html
 * <greeting-box active="onOrOff">Hi there</greeting-box>
 * ```
 *
 * ```js
 * ngModule.directive('greetingBox', ['$animate', function($animate) {
 *   return function(scope, element, attrs) {
 *     attrs.$observe('active', function(value) {
 *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
 *     });
 *   });
 * }]);
 * ```
 *
 * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
 * in our HTML code then we can trigger a CSS or JS animation to happen.
 *
 * ```css
 * /&#42; normally we would create a CSS class to reference on the element &#42;/
 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
 * ```
 *
 * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's
 * possible be sure to visit the {@link ng.$animate $animate service API page}.
 *
 *
 * ## Callbacks and Promises
 *
 * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
 * ended by chaining onto the returned promise that animation method returns.
 *
 * ```js
 * // somewhere within the depths of the directive
 * $animate.enter(element, parent).then(function() {
 *   //the animation has completed
 * });
 * ```
 *
 * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case
 * anymore.)
 *
 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
 * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view
 * routing controller to hook into that:
 *
 * ```js
 * ngModule.controller('HomePageController', ['$animate', function($animate) {
 *   $animate.on('enter', ngViewElement, function(element) {
 *     // the animation for this route has completed
 *   }]);
 * }])
 * ```
 *
 * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)
 */

/**
 * @ngdoc service
 * @name $animate
 * @kind object
 *
 * @description
 * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.
 *
 * Click here {@link ng.$animate to learn more about animations with `$animate`}.
 */
angular.module('ngAnimate', [])
  .directive('ngAnimateSwap', ngAnimateSwapDirective)

  .directive('ngAnimateChildren', $$AnimateChildrenDirective)
  .factory('$$rAFScheduler', $$rAFSchedulerFactory)

  .provider('$$animateQueue', $$AnimateQueueProvider)
  .provider('$$animation', $$AnimationProvider)

  .provider('$animateCss', $AnimateCssProvider)
  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)

  .provider('$$animateJs', $$AnimateJsProvider)
  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);


})(window, window.angular);

(function () {
'use strict';

/*
 * AngularJS Toaster
 * Version: 0.4.12
 *
 * Copyright 2013-2014 Jiri Kavulak.
 * All Rights Reserved.
 * Use, reproduction, distribution, and modification of this code is subject to the terms and
 * conditions of the MIT license, available at http://www.opensource.org/licenses/mit-license.php
 *
 * Author: Jiri Kavulak
 * Related to project of John Papa and Hans Fjllemark
 */

angular.module('toaster', ['ngAnimate'])
.constant('toasterConfig', {
    'limit': 0,                   // limits max number of toasts
    'tap-to-dismiss': true,

    /* Options:
        - Boolean false/true
            'close-button': true      
        - object if not a boolean that allows you to 
          override showing the close button for each
          icon-class value
          'close-button': { 'toast-error': true, 'toast-info': false }
    */
    'close-button': false,

    'newest-on-top': true,
    //'fade-in': 1000,            // done in css
    //'on-fade-in': undefined,    // not implemented
    //'fade-out': 1000,           // done in css
    //'on-fade-out': undefined,   // not implemented
    //'extended-time-out': 1000,  // not implemented
    'time-out': 5000, // Set timeOut and extendedTimeout to 0 to make it sticky
    'icon-classes': {
        error: 'toast-error',
        info: 'toast-info',
        wait: 'toast-wait',
        success: 'toast-success',
        warning: 'toast-warning'
    },
    'body-output-type': '', // Options: '', 'trustedHtml', 'template', 'templateWithData'
    'body-template': 'toasterBodyTmpl.html',
    'icon-class': 'toast-info',
    'position-class': 'toast-top-right', // Options (see CSS):
                                         // 'toast-top-full-width', 'toast-bottom-full-width', 'toast-center',
                                         // 'toast-top-left', 'toast-top-center', 'toast-top-rigt',
                                         // 'toast-bottom-left', 'toast-bottom-center', 'toast-bottom-rigt',
    'title-class': 'toast-title',
    'message-class': 'toast-message',
    'prevent-duplicates': false,
    'mouseover-timer-stop': true // stop timeout on mouseover and restart timer on mouseout
})
.service('toaster', ['$rootScope', 'toasterConfig', function ($rootScope, toasterConfig) {
    this.pop = function (type, title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton) {
        if (angular.isObject(type)) {
            var params = type; // Enable named parameters as pop argument
            this.toast = {
                type: params.type,
                title: params.title,
                body: params.body,
                timeout: params.timeout,
                bodyOutputType: params.bodyOutputType,
                clickHandler: params.clickHandler,
                showCloseButton: params.showCloseButton
            };
            toasterId = params.toasterId;
        } else {
            this.toast = {
                type: type,
                title: title,
                body: body,
                timeout: timeout,
                bodyOutputType: bodyOutputType,
                clickHandler: clickHandler,
                showCloseButton: showCloseButton
            };
        }
        $rootScope.$emit('toaster-newToast', toasterId);
    };

    this.clear = function () {
        $rootScope.$emit('toaster-clearToasts');
    };

    // Create one method per icon class, to allow to call toaster.info() and similar
    for (var type in toasterConfig['icon-classes']) {
        this[type] = (function (toasterType) {
            return function(title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton) {
                if (angular.isString(title)) {
                    this.pop(toasterType, title, body, timeout, bodyOutputType, clickHandler, toasterId, showCloseButton);
                } else { // 'title' is actually an object with options
                    this.pop(angular.extend(title, { type: toasterType }));
                }
            };
        })(type);
    }
}])
.factory('toasterEventRegistry',['$rootScope', function($rootScope) {
    var deregisterNewToast = null,
        deregisterClearToasts = null,
        newToastEventSubscribers = [],
        clearToastsEventSubscribers = [],
        toasterFactory;

    toasterFactory = {
        setup: function () {
            if (!deregisterNewToast) {
                deregisterNewToast = $rootScope.$on('toaster-newToast', function (event, toasterId) {
                    for (var i = 0, len = newToastEventSubscribers.length; i < len; i++) {
                        newToastEventSubscribers[i](event, toasterId);
                    }
                });
            }

            if (!deregisterClearToasts) {
                deregisterClearToasts = $rootScope.$on('toaster-clearToasts', function (event) {
                    for (var i = 0, len = clearToastsEventSubscribers.length; i < len; i++) {
                        clearToastsEventSubscribers[i](event);
                    }
                });
            }
        },

        subscribeToNewToastEvent: function(onNewToast) {
            newToastEventSubscribers.push(onNewToast);
        },
        subscribeToClearToastsEvent: function(onClearToasts) {
            clearToastsEventSubscribers.push(onClearToasts);
        },
        unsubscribeToNewToastEvent: function(onNewToast) {
            var index = newToastEventSubscribers.indexOf(onNewToast);
            if (index >= 0)
                newToastEventSubscribers.splice(index, 1);

            if (newToastEventSubscribers.length === 0) {
                deregisterNewToast();
                deregisterNewToast = null;
            }
        },
        unsubscribeToClearToastsEvent: function(onClearToasts) {
            var index = clearToastsEventSubscribers.indexOf(onClearToasts);
            if (index >= 0)
                clearToastsEventSubscribers.splice(index, 1);

            if (clearToastsEventSubscribers.length === 0) {
                deregisterClearToasts();
                deregisterClearToasts = null;
            }
        }
    };
    return {
        setup: toasterFactory.setup,
        subscribeToNewToastEvent: toasterFactory.subscribeToNewToastEvent,
        subscribeToClearToastsEvent: toasterFactory.subscribeToClearToastsEvent,
        unsubscribeToNewToastEvent: toasterFactory.unsubscribeToNewToastEvent,
        unsubscribeToClearToastsEvent: toasterFactory.unsubscribeToClearToastsEvent
    };
}])
.directive('toasterContainer', ['$parse', '$rootScope', '$interval', '$sce', 'toasterConfig', 'toaster', 'toasterEventRegistry',
function ($parse, $rootScope, $interval, $sce, toasterConfig, toaster, toasterEventRegistry) {
    return {
        replace: true,
        restrict: 'EA',
        scope: true, // creates an internal scope for this directive (one per directive instance)
        link: function (scope, elm, attrs) {
            var id = 0,
                mergedConfig;

            // Merges configuration set in directive with default one
            mergedConfig = angular.extend({}, toasterConfig, scope.$eval(attrs.toasterOptions));

            scope.config = {
                toasterId: mergedConfig['toaster-id'],
                position: mergedConfig['position-class'],
                title: mergedConfig['title-class'],
                message: mergedConfig['message-class'],
                tap: mergedConfig['tap-to-dismiss'],
                closeButton: mergedConfig['close-button'],
                animation: mergedConfig['animation-class'],
                mouseoverTimer: mergedConfig['mouseover-timer-stop']
            };

            scope.$on("$destroy", function () {
                toasterEventRegistry.unsubscribeToNewToastEvent(scope._onNewToast);
                toasterEventRegistry.unsubscribeToClearToastsEvent(scope._onClearToasts);
            });

            function setTimeout(toast, time) {
                toast.timeoutPromise = $interval(function () {
                    scope.removeToast(toast.id);
                }, time, 1);
            }

            scope.configureTimer = function (toast) {
                var timeout = angular.isNumber(toast.timeout) ? toast.timeout : mergedConfig['time-out'];
                if (timeout > 0)
                    setTimeout(toast, timeout);
            };

            function addToast(toast) {
                toast.type = mergedConfig['icon-classes'][toast.type];
                if (!toast.type)
                    toast.type = mergedConfig['icon-class'];

                // Prevent adding duplicate toasts if it's set
                if (mergedConfig['prevent-duplicates'] === true &&
                    scope.toasters.length > 0 &&
                    scope.toasters[scope.toasters.length - 1].body === toast.body)
                    return;

                toast.id = ++id;


                // set the showCloseButton property on the toast so that
                // each template can bind directly to the property to show/hide
                // the close button
                var closeButton = mergedConfig['close-button'];

                // if toast.showCloseButton is a boolean value,
                // it was specifically overriden in the pop arguments
                if (typeof toast.showCloseButton === "boolean") {
                    
                } else if (typeof closeButton === "boolean") {
                    toast.showCloseButton = closeButton;
                } else if (typeof closeButton === "object") {
                    var closeButtonForType = closeButton[toast.type];

                    if (typeof closeButtonForType !== "undefined" && closeButtonForType !== null) {
                        toast.showCloseButton = closeButtonForType;
                    }
                } else {
                    // if an option was not set, default to false.
                    toast.showCloseButton = false;
                }


                // Set the toast.bodyOutputType to the default if it isn't set
                toast.bodyOutputType = toast.bodyOutputType || mergedConfig['body-output-type'];
                switch (toast.bodyOutputType) {
                    case 'trustedHtml':
                        toast.html = $sce.trustAsHtml(toast.body);
                        break;
                    case 'template':
                        toast.bodyTemplate = toast.body || mergedConfig['body-template'];
                        break;
                    case 'templateWithData':
                        var fcGet = $parse(toast.body || mergedConfig['body-template']);
                        var templateWithData = fcGet(scope);
                        toast.bodyTemplate = templateWithData.template;
                        toast.data = templateWithData.data;
                        break;
                }

                scope.configureTimer(toast);

                if (mergedConfig['newest-on-top'] === true) {
                    scope.toasters.unshift(toast);
                    if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {
                        scope.toasters.pop();
                    }
                } else {
                    scope.toasters.push(toast);
                    if (mergedConfig['limit'] > 0 && scope.toasters.length > mergedConfig['limit']) {
                        scope.toasters.shift();
                    }
                }
            }

            scope.removeToast = function (id) {
                var i, len, toast;
                for (i = 0, len = scope.toasters.length; i < len; i++) {
                    if (scope.toasters[i].id === id) {
                        removeToast(i);
                        break;
                    }
                }
            };

            function removeToast(toastIndex) {
                var toast = scope.toasters[toastIndex];
                if (toast) {
                    if (toast.timeoutPromise) {
                        $interval.cancel(toast.timeoutPromise);
                    }
                    scope.toasters.splice(toastIndex, 1);
                }
            }

            function removeAllToasts() {
                for (var i = scope.toasters.length; i >= 0; i--) {
                    removeToast(i);
                }
            }

            scope.toasters = [];

            scope._onNewToast = function (event, toasterId) {
                // Compatibility: if toaster has no toasterId defined, and if call to display
                // hasn't either, then the request is for us
                if (scope.config.toasterId === undefined && toasterId === undefined ||
                        // Otherwise, we check if the event is for this toaster
                        toasterId !== undefined && toasterId === scope.config.toasterId)
                    addToast(toaster.toast);
            };
            scope._onClearToasts = function (event) {
                removeAllToasts();
            };

            toasterEventRegistry.setup();

            toasterEventRegistry.subscribeToNewToastEvent(scope._onNewToast);
            toasterEventRegistry.subscribeToClearToastsEvent(scope._onClearToasts);
        },
        controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
            // Called on mouseover
            $scope.stopTimer = function (toast) {
                if ($scope.config.mouseoverTimer === true) {
                    if (toast.timeoutPromise) {
                        $interval.cancel(toast.timeoutPromise);
                        toast.timeoutPromise = null;
                    }
                }
            };

            // Called on mouseout
            $scope.restartTimer = function (toast) {
                if ($scope.config.mouseoverTimer === true) {
                    if (!toast.timeoutPromise)
                        $scope.configureTimer(toast);
                } else if (toast.timeoutPromise === null) {
                    $scope.removeToast(toast.id);
                }
            };

            $scope.click = function (toast) {
                if ($scope.config.tap === true || toast.showCloseButton === true) {
                    var removeToast = true;
                    if (toast.clickHandler) {
                        if (angular.isFunction(toast.clickHandler)) {
                            removeToast = toast.clickHandler(toast, toast.showCloseButton);
                        } else if (angular.isFunction($scope.$parent.$eval(toast.clickHandler))) {
                            removeToast = $scope.$parent.$eval(toast.clickHandler)(toast, toast.showCloseButton);
                        } else {
                            console.log("TOAST-NOTE: Your click handler is not inside a parent scope of toaster-container.");
                        }
                    }
                    if (removeToast) {
                        $scope.removeToast(toast.id);
                    }
                }
            };
        }],
        template:
        '<div id="toast-container" ng-class="[config.position, config.animation]">' +
          '<div ng-repeat="toaster in toasters" class="toast" ng-class="toaster.type" ng-click="click(toaster)" ng-mouseover="stopTimer(toaster)" ng-mouseout="restartTimer(toaster)">' +
            '<button type="button" class="toast-close-button" ng-show="toaster.showCloseButton" ng-click="click(toaster)">&times;</button>' +
            '<div ng-class="config.title">{{toaster.title}}</div>' +
            '<div ng-class="config.message" ng-switch on="toaster.bodyOutputType">' +
              '<div ng-switch-when="trustedHtml" ng-bind-html="toaster.html"></div>' +
              '<div ng-switch-when="template"><div ng-include="toaster.bodyTemplate"></div></div>' +
              '<div ng-switch-when="templateWithData"><div ng-include="toaster.bodyTemplate"></div></div>' +
              '<div ng-switch-default >{{toaster.body}}</div>' +
            '</div>' +
          '</div>' +
        '</div>'
    };
}]);
})(window, document);
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module unless amdModuleId is set
    define([], function () {
      return (factory());
    });
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    factory();
  }
}(this, function () {
'use strict';
angular.module('tmh.dynamicLocale', []).config(['$provide', function($provide) {
  function makeStateful($delegate) {
    $delegate.$stateful = true;
    return $delegate;
  }

  $provide.decorator('dateFilter', ['$delegate', makeStateful]);
  $provide.decorator('numberFilter', ['$delegate', makeStateful]);
  $provide.decorator('currencyFilter', ['$delegate', makeStateful]);

}])
.constant('tmhDynamicLocale.STORAGE_KEY', 'tmhDynamicLocale.locale')
.provider('tmhDynamicLocale', ['tmhDynamicLocale.STORAGE_KEY', function(STORAGE_KEY) {

  var defaultLocale,
    localeLocationPattern = 'angular/i18n/angular-locale_{{locale}}.js',
    nodeToAppend,
    storageFactory = 'tmhDynamicLocaleStorageCache',
    storage,
    storageKey = STORAGE_KEY,
    promiseCache = {},
    activeLocale,
    extraProperties = {};

  /**
   * Loads a script asynchronously
   *
   * @param {string} url The url for the script
   @ @param {function} callback A function to be called once the script is loaded
   */
  function loadScript(url, callback, errorCallback, $timeout) {
    var script = document.createElement('script'),
      element = nodeToAppend ? nodeToAppend : document.getElementsByTagName("body")[0],
      removed = false;

    script.type = 'text/javascript';
    if (script.readyState) { // IE
      script.onreadystatechange = function () {
        if (script.readyState === 'complete' ||
            script.readyState === 'loaded') {
          script.onreadystatechange = null;
          $timeout(
            function () {
              if (removed) return;
              removed = true;
              element.removeChild(script);
              callback();
            }, 30, false);
        }
      };
    } else { // Others
      script.onload = function () {
        if (removed) return;
        removed = true;
        element.removeChild(script);
        callback();
      };
      script.onerror = function () {
        if (removed) return;
        removed = true;
        element.removeChild(script);
        errorCallback();
      };
    }
    script.src = url;
    script.async = true;
    element.appendChild(script);
  }

  /**
   * Loads a locale and replaces the properties from the current locale with the new locale information
   *
   * @param {string} localeUrl The path to the new locale
   * @param {Object} $locale The locale at the curent scope
   * @param {string} localeId The locale id to load
   * @param {Object} $rootScope The application $rootScope
   * @param {Object} $q The application $q
   * @param {Object} localeCache The current locale cache
   * @param {Object} $timeout The application $timeout
   */
  function loadLocale(localeUrl, $locale, localeId, $rootScope, $q, localeCache, $timeout) {

    function overrideValues(oldObject, newObject) {
      if (activeLocale !== localeId) {
        return;
      }
      angular.forEach(oldObject, function(value, key) {
        if (!newObject[key]) {
          delete oldObject[key];
        } else if (angular.isArray(newObject[key])) {
          oldObject[key].length = newObject[key].length;
        }
      });
      angular.forEach(newObject, function(value, key) {
        if (angular.isArray(newObject[key]) || angular.isObject(newObject[key])) {
          if (!oldObject[key]) {
            oldObject[key] = angular.isArray(newObject[key]) ? [] : {};
          }
          overrideValues(oldObject[key], newObject[key]);
        } else {
          oldObject[key] = newObject[key];
        }
      });
    }


    if (promiseCache[localeId]) {
      activeLocale = localeId;
      return promiseCache[localeId];
    }

    var cachedLocale,
      deferred = $q.defer();
    if (localeId === activeLocale) {
      deferred.resolve($locale);
    } else if ((cachedLocale = localeCache.get(localeId))) {
      activeLocale = localeId;
      $rootScope.$evalAsync(function() {
        overrideValues($locale, cachedLocale);
        storage.put(storageKey, localeId);
        $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);
        deferred.resolve($locale);
      });
    } else {
      activeLocale = localeId;
      promiseCache[localeId] = deferred.promise;
      loadScript(localeUrl, function() {
        // Create a new injector with the new locale
        var localInjector = angular.injector(['ngLocale']),
          externalLocale = localInjector.get('$locale');

        overrideValues($locale, externalLocale);
        localeCache.put(localeId, externalLocale);
        delete promiseCache[localeId];

        $rootScope.$applyAsync(function() {
          storage.put(storageKey, localeId);
          $rootScope.$broadcast('$localeChangeSuccess', localeId, $locale);
          deferred.resolve($locale);
        });
      }, function() {
        delete promiseCache[localeId];

        $rootScope.$applyAsync(function() {
          if (activeLocale === localeId) {
            activeLocale = $locale.id;
          }
          $rootScope.$broadcast('$localeChangeError', localeId);
          deferred.reject(localeId);
        });
      }, $timeout);
    }
    return deferred.promise;
  }

  this.localeLocationPattern = function(value) {
    if (value) {
      localeLocationPattern = value;
      return this;
    } else {
      return localeLocationPattern;
    }
  };

  this.appendScriptTo = function(nodeElement) {
    nodeToAppend = nodeElement;
  };

  this.useStorage = function(storageName) {
    storageFactory = storageName;
  };

  this.useCookieStorage = function() {
    this.useStorage('$cookieStore');
  };

  this.defaultLocale = function(value) {
    defaultLocale = value;
  };

  this.storageKey = function(value) {
    if (value) {
      storageKey = value;
      return this;
    } else {
      return storageKey;
    }
  };

  this.addLocalePatternValue = function(key, value) {
    extraProperties[key] = value;
  };

  this.$get = ['$rootScope', '$injector', '$interpolate', '$locale', '$q', 'tmhDynamicLocaleCache', '$timeout', function($rootScope, $injector, interpolate, locale, $q, tmhDynamicLocaleCache, $timeout) {
    var localeLocation = interpolate(localeLocationPattern);

    storage = $injector.get(storageFactory);
    $rootScope.$evalAsync(function() {
      var initialLocale;
      if ((initialLocale = (storage.get(storageKey) || defaultLocale))) {
        loadLocaleFn(initialLocale);
      }
    });
    return {
      /**
       * @ngdoc method
       * @description
       * @param {string} value Sets the locale to the new locale. Changing the locale will trigger
       *    a background task that will retrieve the new locale and configure the current $locale
       *    instance with the information from the new locale
       */
      set: loadLocaleFn,
      /**
       * @ngdoc method
       * @description Returns the configured locale
       */
      get: function() {
        return activeLocale;
      }
    };

    function loadLocaleFn(localeId) {
      var baseProperties = {locale: localeId, angularVersion: angular.version.full};
      return loadLocale(localeLocation(angular.extend({}, extraProperties, baseProperties)), locale, localeId, $rootScope, $q, tmhDynamicLocaleCache, $timeout);
    }
  }];
}]).provider('tmhDynamicLocaleCache', function() {
  this.$get = ['$cacheFactory', function($cacheFactory) {
    return $cacheFactory('tmh.dynamicLocales');
  }];
}).provider('tmhDynamicLocaleStorageCache', function() {
  this.$get = ['$cacheFactory', function($cacheFactory) {
    return $cacheFactory('tmh.dynamicLocales.store');
  }];
}).run(['tmhDynamicLocale', angular.noop]);

return 'tmh.dynamicLocale';

}));

/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var __extends,wijmo;(function(n){'use strict';function at(){return lt}function a(n,t){return n==null?null:f(t)?h(n.implementsInterface)&&n.implementsInterface(t)?n:null:n instanceof t?n:null}function yt(n){return f(n)||e(n)||l(n)||u(n)}function f(n){return typeof n=='string'}function pt(n){return n==null?!0:n.replace(/\s/g,'').length<1}function e(n){return typeof n=='number'}function b(n){return e(n)&&n==Math.round(n)}function l(n){return typeof n=='boolean'}function h(n){return typeof n=='function'}function wt(n){return typeof n=='undefined'}function u(n){return n instanceof Date&&!isNaN(n.getTime())}function o(n){return n instanceof Array}function v(n){return n!=null&&typeof n=='object'&&!u(n)&&!o(n)}function bt(n){if(n instanceof c)return n;if(n.touches&&n.touches.length>0&&(n=n.touches[0]),e(n.clientX)&&e(n.clientY))return new c(n.clientX+pageXOffset,n.clientY+pageYOffset);throw'Mouse or touch event expected.';}function kt(n){return e(n)?r.Number:l(n)?r.Boolean:u(n)?r.Date:f(n)?r.String:o(n)?r.Array:r.Object}function k(t,i,u){var o,e;if(t!=null){if(f(t))switch(i){case r.Number:return o=n.Globalize.parseFloat(t,u),isNaN(o)?t:o;case r.Date:return e=n.Globalize.parseDate(t,u),e||u||!t||(e=new Date(t)),e&&isFinite(e.getTime())?e:t;case r.Boolean:switch(t.toLowerCase()){case'true':return!0;case'false':return!1}return t}if(i==r.String)return n.Globalize.format(t,u)}return t}function dt(n,t,i){var u,r;return i?(r=n.toString(),u=r.indexOf('.'),u>-1&&(r=r.substr(0,u+1+t),n=parseFloat(r))):(r=n.toFixed(t),n=parseFloat(r)),n}function gt(t,i,r){return t=y(t),t.replace(/\{(.*?)(:(.*?))?\}/g,function(t,u,f,e){var o=t;return u&&u[0]!='{'&&i&&(o=i[u],e&&(o=n.Globalize.format(o,e)),r&&(o=r(i,u,e,o))),o==null?'':o})}function ni(n,t,i){return n!=null&&(i!=null&&n>i&&(n=i),t!=null&&n<t&&(n=t)),n}function d(i,r){var u,f;if(r)for(u in r)u[0]!='_'&&(t(u in i,'Unknown property "'+u+'".'),f=r[u],i._copy&&i._copy(u,f)||(i[u]instanceof n.Event&&h(f)?i[u].addHandler(f):v(f)&&i[u]&&u!='itemsSource'?d(i[u],f):i[u]=f))}function t(n,t){if(!n)throw'** Assertion failed in Wijmo: '+t;}function ti(n,t){console.error('** WARNING: "'+n+'" has been deprecated; please use "'+t+'" instead.')}function y(n,i){return i===void 0&&(i=!0),t(i&&n==null||f(n),'String expected.'),n}function i(n,i,r){if(i===void 0&&(i=!1),r===void 0&&(r=!1),t(i&&n==null||e(n),'Number expected.'),r&&n&&n<0)throw'Positive number expected.';return n}function ii(n,i,r){if(i===void 0&&(i=!1),r===void 0&&(r=!1),t(i&&n==null||b(n),'Integer expected.'),r&&n&&n<0)throw'Positive integer expected.';return n}function g(n,i){return i===void 0&&(i=!1),t(i&&n==null||l(n),'Boolean expected.'),n}function ri(n,i){if(i===void 0&&(i=!1),f(n)){var e=k(n,r.Date,'r');u(e)&&(n=e)}return t(i&&n==null||u(n),'Date expected.'),n}function s(n,i){return i===void 0&&(i=!0),t(i&&n==null||h(n),'Function expected.'),n}function ui(n,i){return i===void 0&&(i=!0),t(i&&n==null||o(n),'Array expected.'),n}function nt(n,i,r){return r===void 0&&(r=!1),n=a(n,i),t(r||n!=null,i+' expected.'),n}function fi(n,i,r){if(r===void 0&&(r=!1),n==null&&r)return null;var u=i[n];return t(u!=null,'Invalid enum value.'),e(u)?u:n}function ei(i,r){if(r===void 0&&(r=!0),i==null&&r)return null;var u=a(i,'ICollectionView');return u!=null?u:(o(i)||t(!1,'Array or ICollectionView expected.'),new n.collections.CollectionView(i))}function oi(n){return n&&n.items&&n.items.length}function si(n){return n&&n.length?n[0].toUpperCase()+n.substr(1).replace(/([a-z])([A-Z])/g,'$1 $2'):''}function hi(n){return f(n)&&(n=n.replace(/[&<>"'\/]/g,function(n){return tt[n]})),n}function p(n,t){if(n&&n.getAttribute){var i=new RegExp('(\\s|^)'+t+'(\\s|$)');return n&&i.test(n.getAttribute('class'))}return!1}function it(n,t){if(n&&t&&n.setAttribute&&p(n,t)){var r=new RegExp('((\\s|^)'+t+'(\\s|$))','g'),i=n.getAttribute('class');i=i.replace(r,' ').replace(/ +/g,' ').trim();n.setAttribute('class',i)}}function rt(n,t){if(n&&t&&n.setAttribute&&!p(n,t)){var i=n.getAttribute('class');n.setAttribute('class',i?i+' '+t:t)}}function ut(n,t,i){i?rt(n,t):it(n,t)}function ci(n,t,r){if(r===void 0&&(r=t),n=nt(n,HTMLInputElement),et(document.body,n)&&!n.disabled&&n.style.display!='none')try{n.focus();n.setSelectionRange(i(t),i(r))}catch(u){}}function ft(){var n=document.activeElement,t;return n&&(t=n.shadowRoot,t&&t.activeElement&&(n=t.activeElement)),n}function li(n,t){for(var f,i,e='input,select,textarea,button,a,div,span',o=n.querySelectorAll(e),r=[],u=0;u<o.length;u++)i=o[u],i.clientHeight>0&&i.tabIndex>-1&&!i.disabled&&!ot(i,'[disabled],.wj-state-disabled')&&!i.querySelector(e)&&r.push(i);f=0;t&&(u=r.indexOf(ft()),u>-1&&(f=(u+t+r.length)%r.length));f<r.length&&(i=r[f],i.focus(),i instanceof HTMLInputElement&&i.select())}function ai(n){return n instanceof Element?n:f(n)?document.querySelector(n):n&&n.jquery?n[0]:null}function vi(n,t){var i=document.createElement('div'),r;return i.innerHTML=n,r=i.removeChild(i.firstChild),t instanceof HTMLElement?t.appendChild(r):r}function yi(n,t){if(t==null){n.hasChildNodes()&&(n.textContent='');return}var i=n.firstChild;n.childNodes.length==1&&i.nodeType==3?i.nodeValue!=t&&(i.nodeValue=t):(i||t)&&(n.textContent=t)}function et(n,t){for(var i=t;i&&n;){if(i===n)return!0;i=i.parentNode||i.host}return!1}function ot(n,t){var i=n?n.matches||n.webkitMatchesSelector||n.mozMatchesSelector||n.msMatchesSelector:null;if(i)for(;n;n=n.parentNode)if(n instanceof Element&&i.call(n,t))return n;return null}function pi(n,t){var r,i,u;for(ut(n,'wj-state-disabled',!t),t?n.removeAttribute('disabled'):n.setAttribute('disabled','true'),r=n.querySelectorAll('input'),i=0;i<r.length;i++)u=r[i],t?u.removeAttribute('disabled'):u.setAttribute('disabled','true')}function wi(n){var t=n.getBoundingClientRect();return new w(t.left+pageXOffset,t.top+pageYOffset,t.width,t.height)}function st(n,t){var u,i,r;if(o(n)){n.forEach(function(n){st(n,t)});return}u=n.style;for(i in t)r=t[i],typeof r=='number'&&i.match(/width|height|left|top|right|bottom|size|padding|margin'/i)&&(r+='px'),u[i]!=r&&(u[i]=r.toString())}function bi(n,t,r){t===void 0&&(t=400);r===void 0&&(r=35);s(n);i(t,!1,!0);i(r,!1,!0);var f=Date.now(),u=setInterval(function(){var i=Math.min(1,(Date.now()-f)/t);i=Math.sin(i*Math.PI/2);i*=i;requestAnimationFrame(function(){n(i)});i>=1&&clearInterval(u)},r);return u}function ki(n,t){var u,e,a,i,o,c;t||(t={});var l=t.method?y(t.method).toUpperCase():'GET',p=t.async!=null?g(t.async):!0,r=t.data;if(r!=null&&l=='GET'){u=[];for(e in r)u.push(e+'='+r[e]);u.length&&(a=n.indexOf('?')<0?'?':'&',n+=a+u.join('&'));r=null}if(i=new XMLHttpRequest,i.URL_DEBUG=n,o=!1,r==null||f(r)||(o=v(r),r=JSON.stringify(r)),i.onload=function(){i.readyState==4&&(i.status<300?t.success&&s(t.success)(i):t.error&&s(t.error)(i),t.complete&&s(t.complete)(i))},i.onerror=function(){if(t.error)s(t.error)(i);else throw'HttpRequest Error: '+i.status+' '+i.statusText;},i.open(l,n,p,t.user,t.password),t.user&&t.password&&i.setRequestHeader('Authorization','Basic '+btoa(t.user+':'+t.password)),o&&i.setRequestHeader('Content-Type','application/json'),t.requestHeaders)for(c in t.requestHeaders)i.setRequestHeader(c,t.requestHeaders[c]);return h(t.beforeSend)&&t.beforeSend(i),i.send(r),i}var lt='5.20163.234',vt,r,tt,c,ht,w,ct;n.getVersion=at,function(n){n[n.Back=8]="Back";n[n.Tab=9]="Tab";n[n.Enter=13]="Enter";n[n.Escape=27]="Escape";n[n.Space=32]="Space";n[n.PageUp=33]="PageUp";n[n.PageDown=34]="PageDown";n[n.End=35]="End";n[n.Home=36]="Home";n[n.Left=37]="Left";n[n.Up=38]="Up";n[n.Right=39]="Right";n[n.Down=40]="Down";n[n.Delete=46]="Delete";n[n.F1=112]="F1";n[n.F2=113]="F2";n[n.F3=114]="F3";n[n.F4=115]="F4";n[n.F5=116]="F5";n[n.F6=117]="F6";n[n.F7=118]="F7";n[n.F8=119]="F8";n[n.F9=120]="F9";n[n.F10=121]="F10";n[n.F11=122]="F11";n[n.F12=123]="F12"}(n.Key||(n.Key={}));vt=n.Key,function(n){n[n.Object=0]="Object";n[n.String=1]="String";n[n.Number=2]="Number";n[n.Boolean=3]="Boolean";n[n.Date=4]="Date";n[n.Array=5]="Array"}(n.DataType||(n.DataType={}));r=n.DataType;n.tryCast=a;n.isPrimitive=yt;n.isString=f;n.isNullOrWhiteSpace=pt;n.isNumber=e;n.isInt=b;n.isBoolean=l;n.isFunction=h;n.isUndefined=wt;n.isDate=u;n.isArray=o;n.isObject=v;n.mouseToPage=bt;n.getType=kt;n.changeType=k;n.toFixed=dt;n.format=gt;n.clamp=ni;n.copy=d;n.assert=t;n._deprecated=ti;n.asString=y;n.asNumber=i;n.asInt=ii;n.asBoolean=g;n.asDate=ri;n.asFunction=s;n.asArray=ui;n.asType=nt;n.asEnum=fi;n.asCollectionView=ei;n.hasItems=oi;n.toHeaderCase=si;n.escapeHtml=hi;tt={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;','/':'&#x2F;'};n.hasClass=p;n.removeClass=it;n.addClass=rt;n.toggleClass=ut;n.setSelectionRange=ci;n.getActiveElement=ft;n.moveFocus=li;n.getElement=ai;n.createElement=vi;n.setText=yi;n.contains=et;n.closest=ot;n.enable=pi;n.getElementRect=wi;n.setCss=st;n.animate=bi;c=function(){function n(n,t){n===void 0&&(n=0);t===void 0&&(t=0);this.x=i(n);this.y=i(t)}return n.prototype.equals=function(t){return t instanceof n&&this.x==t.x&&this.y==t.y},n.prototype.clone=function(){return new n(this.x,this.y)},n}();n.Point=c;ht=function(){function n(n,t){n===void 0&&(n=0);t===void 0&&(t=0);this.width=i(n);this.height=i(t)}return n.prototype.equals=function(t){return t instanceof n&&this.width==t.width&&this.height==t.height},n.prototype.clone=function(){return new n(this.width,this.height)},n}();n.Size=ht;w=function(){function n(n,t,r,u){this.left=i(n);this.top=i(t);this.width=i(r);this.height=i(u)}return Object.defineProperty(n.prototype,"right",{get:function(){return this.left+this.width},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"bottom",{get:function(){return this.top+this.height},enumerable:!0,configurable:!0}),n.prototype.equals=function(t){return t instanceof n&&this.left==t.left&&this.top==t.top&&this.width==t.width&&this.height==t.height},n.prototype.clone=function(){return new n(this.left,this.top,this.width,this.height)},n.fromBoundingRect=function(i){if(i.left!=null)return new n(i.left,i.top,i.width,i.height);if(i.x!=null)return new n(i.x,i.y,i.width,i.height);t(!1,'Invalid source rectangle.')},n.union=function(t,i){var r=Math.min(t.left,i.left),u=Math.min(t.top,i.top),f=Math.max(t.right,i.right),e=Math.max(t.bottom,i.bottom);return new n(r,u,f-r,e-u)},n.intersection=function(t,i){var r=Math.max(t.left,i.left),u=Math.max(t.top,i.top),f=Math.min(t.right,i.right),e=Math.min(t.bottom,i.bottom);return new n(r,u,f-r,e-u)},n.prototype.contains=function(i){if(i instanceof c)return i.x>=this.left&&i.x<=this.right&&i.y>=this.top&&i.y<=this.bottom;if(i instanceof n){var r=i;return r.left>=this.left&&r.right<=this.right&&r.top>=this.top&&r.bottom<=this.bottom}t(!1,'Point or Rect expected.')},n.prototype.inflate=function(t,i){return new n(this.left-t,this.top-i,this.width+2*t,this.height+2*i)},n}();n.Rect=w;ct=function(){function t(){}return t.addDays=function(n,t){return new Date(n.getFullYear(),n.getMonth(),n.getDate()+t)},t.addMonths=function(n,t){return new Date(n.getFullYear(),n.getMonth()+t,n.getDate())},t.addYears=function(n,t){return new Date(n.getFullYear()+t,n.getMonth(),n.getDate())},t.addHours=function(n,t){return new Date(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours()+t)},t.addMinutes=function(n,t){return new Date(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes()+t)},t.addSeconds=function(n,t){return new Date(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds()+t)},t.sameDate=function(n,t){return u(n)&&u(t)&&n.getFullYear()==t.getFullYear()&&n.getMonth()==t.getMonth()&&n.getDate()==t.getDate()},t.sameTime=function(n,t){return u(n)&&u(t)&&n.getHours()==t.getHours()&&n.getMinutes()==t.getMinutes()&&n.getSeconds()==t.getSeconds()},t.equals=function(n,t){return u(n)&&u(t)&&n.getTime()==t.getTime()},t.fromDateTime=function(n,t){return!n&&!t?null:(n||(n=t),t||(t=n),new Date(n.getFullYear(),n.getMonth(),n.getDate(),t.getHours(),t.getMinutes(),t.getSeconds()))},t.toFiscal=function(i,r){var u=n.culture.Globalize.calendar;return o(u.fiscalYearOffsets)?t.addMonths(i,-u.fiscalYearOffsets[r?0:1]):i},t.fromFiscal=function(i,r){var u=n.culture.Globalize.calendar;return o(u.fiscalYearOffsets)?t.addMonths(i,+u.fiscalYearOffsets[r?0:1]):i},t.newDate=function(){var n=new Date;return new Date(n.getFullYear(),n.getMonth(),n.getDate())},t.clone=function(n){return t.fromDateTime(n,n)},t}();n.DateTime=ct;n.httpRequest=ki})(wijmo||(wijmo={})),function(n){'use strict';n.culture={Globalize:{numberFormat:{'.':'.',',':',',percent:{pattern:['-n %','n %']},currency:{decimals:2,symbol:'$',pattern:['($n)','$n']}},calendar:{'/':'/',':':':',firstDay:0,days:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],daysAbbr:['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],months:['January','February','March','April','May','June','July','August','September','October','November','December'],monthsAbbr:['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],am:['AM','A'],pm:['PM','P'],eras:['A.D.','B.C.'],patterns:{d:'M/d/yyyy',D:'dddd, MMMM dd, yyyy',f:'dddd, MMMM dd, yyyy h:mm tt',F:'dddd, MMMM dd, yyyy h:mm:ss tt',t:'h:mm tt',T:'h:mm:ss tt',M:'MMMM d',m:'MMMM d',Y:'MMMM, yyyy',y:'MMMM, yyyy',g:'M/d/yyyy h:mm tt',G:'M/d/yyyy h:mm:ss tt',s:'yyyy"-"MM"-"dd"T"HH":"mm":"ss',o:'yyyy"-"MM"-"dd"T"HH":"mm":"ss"."fffffffK',O:'yyyy"-"MM"-"dd"T"HH":"mm":"ss"."fffffffK',U:'dddd, MMMM dd, yyyy h:mm:ss tt'},fiscalYearOffsets:[-3,-3]}}};var t=function(){function t(){}return t.format=function(i,r,u,f){return n.isString(i)?i:n.isNumber(i)?(r=r||(i==Math.round(i)?'n0':'n2'),t.formatNumber(i,r,u,f)):n.isDate(i)?(r=r||'d',t.formatDate(i,r)):i!=null?i.toString():''},t.formatNumber=function(i,r,u,f){var l,p,a;n.asNumber(i);n.asString(r);var e,s=r?r.match(/([a-z])(\d*)(,*)(.*)/i):null,h=n.culture.Globalize.numberFormat,o=s?s[1].toLowerCase():'n',c=s&&s[2]?parseInt(s[2]):o=='c'?h.currency.decimals:i==Math.round(i)?0:2,w=s&&s[3]?3*s[3].length:0,b=s&&s[4]?s[4]:h.currency.symbol,v=h['.'],y=h[','];if(w&&(i/=Math.pow(10,w)),o=='d'||o=='x'){for(e=Math.round(Math.abs(i)).toString(o=='d'?10:16);e.length<c;)e='0'+e;return i<0&&(e='-'+e),r&&r[0]=='X'&&(e=e.toUpperCase()),e}return o=='p'&&(i=t._mul100(i)),f&&(i=n.toFixed(i,c,!0)),e=o=='c'||o=='p'?Math.abs(i).toFixed(c):i.toFixed(c),(u||o=='g')&&e.indexOf('.')>-1&&(e=e.replace(/(\.[0-9]*?)0+$/g,'$1'),e=e.replace(/\.$/,'')),v!='.'&&(e=e.replace('.',v)),y&&(o=='n'||o=='c'||o=='p')&&(l=e.indexOf(v),p=/\B(?=(\d\d\d)+(?!\d))/g,e=l>-1?e.substr(0,l).replace(p,y)+e.substr(l):e.replace(p,y)),o=='c'&&(a=h.currency.pattern[i<0?0:1],e=a.replace('n',e).replace('$',b)),o=='p'&&(a=h.percent.pattern[i<0?0:1],e=a.replace('n',e)),e},t.formatDate=function(i,r){var f,e,u;i=n.asDate(i);switch(r){case'r':case'R':return i.toUTCString();case'u':return i.toISOString().replace(/\.\d{3}/,'')}for(r=t._expandFormat(r),f=t._parseDateFormat(r),e='',u=0;u<f.length;u++)e+=t._formatDatePart(i,r,f[u]);return e},t.parseInt=function(n,i){return Math.round(t.parseFloat(n,i))},t.parseFloat=function(t,i){var r=t.indexOf('-')>-1||t.indexOf('(')>-1&&t.indexOf(')')>-1?-1:1,u=t.indexOf('%')>-1?.01:1,f=i?i.match(/,+/):null,e=f?f[0].length*3:0;if(i&&(i[0]=='x'||i[0]=='X'))return t=t.replace(/[^0-9a-f]+.*$/gi,''),parseInt(t,16)*r*u*Math.pow(10,e);var o=n.culture.Globalize.numberFormat['.'],s=new RegExp('[^\\d\\'+o+']','g'),h=t.replace(s,'').replace(o,'.');return parseFloat(h)*r*u*Math.pow(10,e)},t.parseDate=function(i,r){var ut,s,e,p,ht,nt;if(i=n.asString(i),!i)return null;if(r=='u')return new Date(i);if(r=='R'||r=='r')return ut=/(([0-9]+)\-([0-9]+)\-([0-9]+))?\s?(([0-9]+):([0-9]+)(:([0-9]+))?)?/,s=i.match(ut),s[1]||s[5]?(e=s[1]?new Date(parseInt(s[2]),parseInt(s[3])-1,parseInt(s[4])):new Date,s[5]&&(e.setHours(parseInt(s[6])),e.setMinutes(parseInt(s[7])),e.setSeconds(s[8]?parseInt(s[9]):0))):e=new Date(i),isNaN(e.getTime())?null:e;r=t._expandFormat(r?r:'d');var h=n.culture.Globalize.calendar,ft=t._CJK,ct=new RegExp('(\\'+h['/']+')|(\\'+h[':']+")|(\\d+)|(["+ft+"\\.]{2,})|(["+ft+']+)','gi'),c=i.match(ct),w=t._parseDateFormat(r),y=0,l=-1,a=0,d=1,o=0,b=0,k=0,et=0,tt=-1,ot,it,st,g,rt;if(!c||!c.length||!w||!w.length)return null;for(p=0;p<w.length&&c;p++){var v=p-y,u=v>-1&&v<c.length?c[v]:'',f=w[p].length;switch(w[p]){case'EEEE':case'EEE':case'EE':case'E':case'eeee':case'eee':case'ee':case'e':rt=w[p];case'yyyy':case'yyy':case'yy':case'y':f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);l=parseInt(u);break;case'MMMM':case'MMM':for(g=!0,ht=u.toLowerCase(),a=-1,nt=0;nt<12;nt++)if(h.months[nt].toLowerCase().indexOf(ht)==0){a=nt;break}if(a>-1)break;case'MM':case'M':g=!0;f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);a=parseInt(u)-1;break;case'dddd':case'ddd':ot=!0;break;case'dd':case'd':f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);d=parseInt(u);it=!0;break;case'hh':case'h':f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);o=parseInt(u);o=o==12?0:o;break;case'HH':f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);o=parseInt(u);break;case'H':o=parseInt(u);break;case'mm':case'm':f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);b=parseInt(u);break;case'ss':case's':f>1&&u.length>f&&(c[v]=u.substr(f),u=u.substr(0,f),y++);k=parseInt(u);break;case'fffffff':case'FFFFFFF':case'ffffff':case'FFFFFF':case'fffff':case'FFFFF':case'ffff':case'FFFF':case'fff':case'FFF':case'ff':case'FF':case'f':case'F':et=parseInt(u)/Math.pow(10,f-3);break;case'tt':case't':u=u.toUpperCase();(h.pm[0]&&u==h.pm[0]&&o<12||h.pm[1]&&u==h.pm[1]&&o<12)&&(o+=12);break;case'q':case'Q':case'u':case'U':st=!0;break;case'ggg':case'gg':case'g':tt=h.eras.length>1?t._getEra(u,h):-1;break;case h['/']:case h[':']:if(u&&u!=w[p])return null;break;case'K':break;default:t._unquote(w[p])!=u&&y++}}if(g&&it&&(isNaN(o)&&(o=0),isNaN(b)&&(b=0),isNaN(k)&&(k=0)),a<0||a>11||isNaN(a)||d<0||d>31||isNaN(d)||o<0||o>24||isNaN(o)||b<0||b>60||isNaN(b)||k<0||k>60||isNaN(k))return null;if(rt){if(!g)return null;e=new Date(l,a);e=n.DateTime.fromFiscal(e,rt[0]=='E');l=e.getFullYear();a=e.getMonth()}return ot&&!it?null:st&&!g?null:(l<0&&(l=(new Date).getFullYear()),tt>-1?l=l+h.eras[tt].start.getFullYear()-1:l<100&&(l+=l>=30?1900:2e3),e=new Date(l,a,d,o,b+0,k,et),isNaN(e.getTime())?null:e)},t.getFirstDayOfWeek=function(){var t=n.culture.Globalize.calendar.firstDay;return t?t:0},t.getNumberDecimalSeparator=function(){var t=n.culture.Globalize.numberFormat['.'];return t?t:'.'},t._unquote=function(n){return n.length>1&&n[0]==n[n.length-1]&&(n[0]=='\''||n[0]=='\"')?n.substr(1,n.length-2):n},t._parseDateFormat=function(n){var u,e,i,r,f;if(n in t._dateFomatParts)return t._dateFomatParts[n];for(u=[],e='',i=0;i>-1&&i<n.length;i++){if(f=n[i],(f=='\''||f=='"')&&(r=n.indexOf(f,i+1),r>-1)){u.push(n.substring(i,r+1));i=r;continue}for(r=i+1;r<n.length;r++)if(n[r]!=f)break;u.push(n.substring(i,r));i=r-1}return t._dateFomatParts[n]=u,u},t._formatDatePart=function(i,r,u){var f=n.culture.Globalize.calendar,o=0,h=0,l=0,c,e=u.length,s;switch(u){case'yyyy':case'yyy':case'yy':case'y':case'EEEE':case'EEE':case'EE':case'E':case'eeee':case'eee':case'ee':case'e':return c=u[0]=='E'?n.DateTime.toFiscal(i,!0):u[0]=='e'?n.DateTime.toFiscal(i,!1):i,h=c.getFullYear(),f.eras.length>1&&r.indexOf('g')>-1&&(o=t._getEra(i,f),o>-1&&(h=h-f.eras[o].start.getFullYear()+1)),t._zeroPad(h,4).substr(4-u.length);case'MMMM':return f.months[i.getMonth()];case'MMM':return f.monthsAbbr[i.getMonth()];case'MM':case'M':return t._zeroPad(i.getMonth()+1,e);case'dddd':return f.days[i.getDay()];case'ddd':return f.daysAbbr[i.getDay()];case'dd':return t._zeroPad(i.getDate(),2);case'd':return i.getDate().toString();case'hh':case'h':return t._zeroPad(t._h12(i),e);case'HH':case'H':return t._zeroPad(i.getHours(),e);case'mm':case'm':return t._zeroPad(i.getMinutes(),e);case'ss':case's':return t._zeroPad(i.getSeconds(),e);case'fffffff':case'FFFFFFF':case'ffffff':case'FFFFFF':case'fffff':case'FFFFF':case'ffff':case'FFFF':case'fff':case'FFF':case'ff':case'FF':case'f':case'F':return l=i.getMilliseconds()*Math.pow(10,e-3),u[0]=='f'?t._zeroPad(l,e):l.toFixed(0);case'tt':return i.getHours()<12?f.am[0]:f.pm[0];case't':return i.getHours()<12?f.am[1]:f.pm[1];case'q':case'Q':return(Math.floor(i.getMonth()/3)+1).toString();case'u':case'U':return c=n.DateTime.toFiscal(i,u=='U'),(Math.floor(c.getMonth()/3)+1).toString();case'ggg':case'gg':case'g':return f.eras.length>1&&(o=t._getEra(i,f),o>-1)?u=='ggg'?f.eras[o].name:u=='gg'?f.eras[o].name[0]:f.eras[o].symbol:f.eras[0];case':':case'/':return f[u];case'K':return s=i.toString().match(/(\+|\-)(\d{2})(\d{2})/),s?s[1]+s[2]+s[3]:''}return e>1&&u[0]==u[e-1]&&(u[0]=='\"'||u[0]=='\'')?u.substr(1,e-2):u},t._getEra=function(t,i){var r;if(n.isDate(t)){for(r=0;r<i.eras.length;r++)if(t>=i.eras[r].start)return r}else if(n.isString(t))for(r=0;r<i.eras.length;r++)if(i.eras[r].name&&(i.eras[r].name.indexOf(t)==0||i.eras[r].symbol.indexOf(t)==0))return r;return-1},t._expandFormat=function(t){var i=n.culture.Globalize.calendar.patterns[t];return i?i:t},t._zeroPad=function(n,t){var i=n.toFixed(0),r=t-i.length+1;return r>0?Array(r).join('0')+i:i},t._h12=function(t){var r=n.culture.Globalize.calendar,i=t.getHours();return r.am&&r.am[0]&&(i=i%12,i==0&&(i=12)),i},t._mul100=function(n){var t=n.toString(),i=t.indexOf('.');return i<0?t+='00':(i+=2,t=t.replace('.','')+'00',t=t.substr(0,i)+'.'+t.substr(i)),parseFloat(t)},t._CJK='a-z'+'u00c0-u017fu3000-u30ffu4e00-u9faf'.replace(/u/g,'\\u')+'u1100-u11ffu3130-u318fua960-ua97fuac00-ud7afud7b0-ud7ff'.replace(/u/g,'\\u'),t._dateFomatParts={},t}();n.Globalize=t}(wijmo||(wijmo={})),function(n){'use strict';var t=function(){function n(n){this.path=n}return Object.defineProperty(n.prototype,"path",{get:function(){return this._path},set:function(n){var t,i,r;for(this._path=n,this._parts=n?n.split('.'):[],t=0;t<this._parts.length;t++)i=this._parts[t],r=i.indexOf('['),r>-1&&(this._parts[t]=i.substr(0,r),this._parts.splice(++t,0,parseInt(i.substr(r+1))));this._key=this._parts.length==1?this._parts[0]:null},enumerable:!0,configurable:!0}),n.prototype.getValue=function(n){if(n){if(this._key)return n[this._key];if(this._path in n)return n[this._path];for(var t=0;t<this._parts.length&&n;t++)n=n[this._parts[t]]}return n},n.prototype.setValue=function(n,t){if(n){if(this._path in n){n[this._path]=t;return}for(var i=0;i<this._parts.length-1;i++)if(n=n[this._parts[i]],n==null)return;n[this._parts[this._parts.length-1]]=t}},n}();n.Binding=t}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){'use strict';var f=function(){function n(n,t){this.handler=n;this.self=t}return n}(),e=function(){function i(){this._handlers=[]}return i.prototype.addHandler=function(t,i){n.asFunction(t);this._handlers.push(new f(t,i))},i.prototype.removeHandler=function(t,i){var r,u;for(n.asFunction(t),r=0;r<this._handlers.length;r++)if(u=this._handlers[r],(u.handler==t||t==null)&&(u.self==i||i==null)&&(this._handlers.splice(r,1),t&&i))break},i.prototype.removeAllHandlers=function(){this._handlers.length=0},i.prototype.raise=function(n,i){var r,u;for(i===void 0&&(i=t.empty),r=0;r<this._handlers.length;r++)u=this._handlers[r],u.handler.call(u.self,n,i)},Object.defineProperty(i.prototype,"hasHandlers",{get:function(){return this._handlers.length>0},enumerable:!0,configurable:!0}),i}(),t,i,r,u;n.Event=e;t=function(){function n(){}return n.empty=new n,n}();n.EventArgs=t;i=function(n){function t(){n.apply(this,arguments);this.cancel=!1}return __extends(t,n),t}(t);n.CancelEventArgs=i;r=function(n){function t(t,i,r){n.call(this);this._name=t;this._oldVal=i;this._newVal=r}return __extends(t,n),Object.defineProperty(t.prototype,"propertyName",{get:function(){return this._name},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"oldValue",{get:function(){return this._oldVal},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"newValue",{get:function(){return this._newVal},enumerable:!0,configurable:!0}),t}(t);n.PropertyChangedEventArgs=r;u=function(n){function t(t){n.call(this);this._xhr=t}return __extends(t,n),Object.defineProperty(t.prototype,"request",{get:function(){return this._xhr},enumerable:!0,configurable:!0}),t}(i);n.RequestErrorEventArgs=u}(wijmo||(wijmo={})),function(n){'use strict';var t=function(){function t(i,r,u){var h=this,f,c,o;if(r===void 0&&(r=null),u===void 0&&(u=!1),this._focus=!1,this._updating=0,this._fullUpdate=!1,this.gotFocus=new n.Event,this.lostFocus=new n.Event,n.assert(t.getControl(i)==null,'Element is already hosting a control.'),f=n.getElement(i),n.assert(f!=null,'Cannot find the host element.'),this._orgOuter=f.outerHTML,this._orgInner=f.innerHTML,this._orgTag=f.tagName,(f.tagName=='INPUT'||f.tagName=='SELECT')&&(f=this._replaceWithDiv(f)),this._e=f,f[t._DATA_KEY]=this,u==!0&&(this._szCtl=new n.Size(f.offsetWidth,f.offsetHeight),c=this._handleResize.bind(this),this.addEventListener(window,'resize',c)),this.addEventListener(f,'focus',function(){setTimeout(function(){h._updateFocusState()})},!0),this.addEventListener(f,'blur',function(){setTimeout(function(){h._updateFocusState()},20)},!0),o=this._handleDisabled.bind(this),this.addEventListener(f,'mousedown',o,!0),this.addEventListener(f,'mouseup',o,!0),this.addEventListener(f,'click',o,!0),this.addEventListener(f,'dblclick',o,!0),this.addEventListener(f,'keydown',o,!0),this.addEventListener(f,'wheel',o,!0),t._touching==null&&(t._touching=!1,'ontouchstart'in window||'onpointerdown'in window)){var e=document.body,l=this._handleTouchStart,s=this._handleTouchEnd;'ontouchstart'in window?(e.addEventListener('touchstart',l),e.addEventListener('touchend',s),e.addEventListener('touchcancel',s),e.addEventListener('touchleave',s)):'onpointerdown'in window&&(e.addEventListener('pointerdown',l),e.addEventListener('pointerup',s),e.addEventListener('pointerout',s),e.addEventListener('pointercancel',s),e.addEventListener('pointerleave',s))}}return t.prototype.getTemplate=function(){for(var t,n=Object.getPrototypeOf(this);n;n=Object.getPrototypeOf(n))if(t=n.constructor.controlTemplate,t)return t;return null},t.prototype.applyTemplate=function(t,i,r,u){var f=this._e,l,o,w,p,s,v,c,h;t&&n.addClass(f,t);l=null;i&&(l=n.createElement(i,f));var b=f.querySelectorAll('input'),e=b.length==1?b[0]:null,a=f.attributes;if(e&&a)for(o=0;o<a.length;o++)a[o].name.match(/name|autofocus|autocomplete|minlength|maxlength|pattern/i)&&e.setAttribute(a[o].name,a[o].value);if(e&&f.id){var k=document.querySelector('label[for="'+f.id+'"]'),d=f.id+'_input',y=d;if(k instanceof HTMLLabelElement){for(o=0;document.getElementById(y)!=null;o++)y=d+o;e.id=y;k.htmlFor=y}}if(e&&(w=document.createEvent('HTMLEvents'),p=e.value,w.initEvent('change',!0,!1),this.addEventListener(e,'input',function(){p=e.value},!0),this.gotFocus.addHandler(function(){p=e.value}),this.lostFocus.addHandler(function(){p!=e.value&&e.dispatchEvent(w)})),f.getAttribute('tabindex')||(f.tabIndex=e!=null?-1:0),this._updateState(),r)for(s in r){if(v=r[s],this[s]=l.querySelector('[wj-part="'+v+'"]'),this[s]==null&&l.getAttribute('wj-part')==v&&(this[s]=l),this[s]==null)throw'Missing template part: "'+v+'"';v==u&&(c='name',h=f.attributes[c],h&&h.value&&this[s].setAttribute(c,h.value),c='accesskey',h=f.attributes[c],h&&h.value&&(this[s].setAttribute(c,h.value),f.removeAttribute(c)))}return l},t.prototype.dispose=function(){for(var e,u,i,r,o=this._e.querySelectorAll('.wj-control'),f=0;f<o.length;f++)e=t.getControl(o[f]),e&&e.dispose();this._toInv&&clearTimeout(this._toInv);this.removeEventListener();for(i in this)i.length>2&&i.indexOf('on')==0&&(r=this[i[2].toLowerCase()+i.substr(3)],r instanceof n.Event&&r.removeAllHandlers());if(u=this.collectionView,u instanceof n.collections.CollectionView)for(i in u)r=u[i],r instanceof n.Event&&r.removeHandler(null,this);this._e.parentNode&&(this._e.outerHTML=this._orgOuter);this._e[t._DATA_KEY]=null;this._e=this._orgOuter=this._orgInner=this._orgTag=null},t.getControl=function(i){var r=n.getElement(i);return r?n.asType(r[t._DATA_KEY],t,!0):null},Object.defineProperty(t.prototype,"hostElement",{get:function(){return this._e},enumerable:!0,configurable:!0}),t.prototype.focus=function(){this._e&&this._e.focus()},t.prototype.containsFocus=function(){var f,i,r,e,u;if(!this._e)return!1;for(f=this._e.querySelectorAll('.wj-control'),i=0;i<f.length;i++)if(r=t.getControl(f[i]),r&&r!=this&&r.containsFocus())return!0;return(e=n.getActiveElement(),u=t.getControl(n.closest(e,'.wj-control.wj-popup')),u&&u.owner&&n.contains(this._e,u.owner))?!0:n.contains(this._e,e)},t.prototype.invalidate=function(n){var i=this;n===void 0&&(n=!0);this._fullUpdate=this._fullUpdate||n;this._toInv&&(clearTimeout(this._toInv),this._toInv=null);this.isUpdating||(this._toInv=setTimeout(function(){i.refresh(i._fullUpdate)},t._REFRESH_INTERVAL))},t.prototype.refresh=function(n){n===void 0&&(n=!0);!this.isUpdating&&this._toInv&&(clearTimeout(this._toInv),this._toInv=null,this._fullUpdate=!1)},t.invalidateAll=function(n){var i,r;if(n||(n=document.body),n.children)for(i=0;i<n.children.length;i++)t.invalidateAll(n.children[i]);r=t.getControl(n);r&&r.invalidate()},t.refreshAll=function(n){var i,r;if(n||(n=document.body),n.children)for(i=0;i<n.children.length;i++)t.refreshAll(n.children[i]);r=t.getControl(n);r&&r.refresh()},t.disposeAll=function(n){var r=t.getControl(n),i;if(r)r.dispose();else if(n.children)for(i=0;i<n.children.length;i++)t.disposeAll(n.children[i])},t.prototype.beginUpdate=function(){this._updating++},t.prototype.endUpdate=function(){this._updating--;this._updating<=0&&this.invalidate()},Object.defineProperty(t.prototype,"isUpdating",{get:function(){return this._updating>0},enumerable:!0,configurable:!0}),t.prototype.deferUpdate=function(n){try{this.beginUpdate();n()}finally{this.endUpdate()}},Object.defineProperty(t.prototype,"isTouching",{get:function(){return t._touching},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isDisabled",{get:function(){return this._e&&this._e.getAttribute('disabled')!=null},set:function(t){t=n.asBoolean(t,!0);t!=this.isDisabled&&n.enable(this._e,!t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"disabled",{get:function(){return n._deprecated('disabled','isDisabled'),this.isDisabled},set:function(t){n._deprecated('disabled','isDisabled');this.isDisabled=t},enumerable:!0,configurable:!0}),t.prototype.initialize=function(t){t&&(this.beginUpdate(),n.copy(this,t),this.endUpdate())},t.prototype.addEventListener=function(n,t,i,r){r===void 0&&(r=!1);n&&(n.addEventListener(t,i,r),this._listeners==null&&(this._listeners=[]),this._listeners.push({target:n,type:t,fn:i,capture:r}))},t.prototype.removeEventListener=function(n,t,i){var f=0,u,r;if(this._listeners)for(u=0;u<this._listeners.length;u++)r=this._listeners[u],(n==null||n==r.target)&&(t==null||t==r.type)&&(i==null||i==r.capture)&&(r.target.removeEventListener(r.type,r.fn,r.capture),this._listeners.splice(u,1),u--,f++);return f},t.prototype.onGotFocus=function(n){this.gotFocus.raise(this,n)},t.prototype.onLostFocus=function(n){this.lostFocus.raise(this,n)},t.prototype._handleResize=function(){if(this._e.parentElement){var t=new n.Size(this._e.offsetWidth,this._e.offsetHeight);t.equals(this._szCtl)||(this._szCtl=t,this.invalidate())}},t.prototype._updateFocusState=function(){var n=this;setTimeout(function(){for(var i,u,r=n._e;r;r=r.parentElement)i=t.getControl(r),i&&(u=i.containsFocus(),u!=i._focus&&(i._focus=u,u?i.onGotFocus():i.onLostFocus(),i._updateState()))})},t.prototype._updateState=function(){var t=this.hostElement,i,r;t&&(n.toggleClass(t,'wj-state-focused',this.containsFocus()),i=t.querySelector('input'),i instanceof HTMLInputElement&&(n.toggleClass(t,'wj-state-empty',i.value.length==0),n.toggleClass(t,'wj-state-readonly',i.readOnly),r=i.validationMessage,n.toggleClass(t,'wj-state-invalid',r&&r.length>0)))},t.prototype._handleTouchStart=function(n){(n.pointerType==null||n.pointerType=='touch')&&(t._touching=!0)},t.prototype._handleTouchEnd=function(n){(n.pointerType==null||n.pointerType=='touch')&&setTimeout(function(){t._touching=!1},400)},t.prototype._handleDisabled=function(n){this.isDisabled&&(n.preventDefault(),n.stopPropagation(),n.stopImmediatePropagation())},t.prototype._replaceWithDiv=function(n){var r=document.createElement('div'),i,t,u;for(n.parentElement.replaceChild(r,n),r.innerHTML=n.innerHTML,i=n.attributes,t=0;t<i.length;t++)u=i[t].name,i[t].name.match(/id|style|class/i)&&r.setAttribute(u,i[t].value);return r},t._DATA_KEY='wj-Control',t._REFRESH_INTERVAL=10,t}();n.Control=t}(wijmo||(wijmo={})),function(n){'use strict';function i(i,r,u){var v=0,f=0,l=0,s=0,h=null,c=null,y=u?new n.Binding(u):null,a,e,o;if(i=n.asEnum(i,t),i==t.CntAll)return r.length;for(a=0;a<r.length;a++)e=r[a],y&&(e=y.getValue(e)),e!=null&&(v++,(h==null||e<h)&&(h=e),(c==null||e>c)&&(c=e),n.isNumber(e)&&!isNaN(e)?(f++,l+=e,s+=e*e):n.isBoolean(e)&&(f++,e==!0&&(l++,s++)));o=f==0?0:l/f;switch(i){case t.Avg:return o;case t.Cnt:return v;case t.Max:return c;case t.Min:return h;case t.Rng:return c-h;case t.Sum:return l;case t.VarPop:return f<=1?0:s/f-o*o;case t.StdPop:return f<=1?0:Math.sqrt(s/f-o*o);case t.Var:return f<=1?0:(s/f-o*o)*f/(f-1);case t.Std:return f<=1?0:Math.sqrt((s/f-o*o)*f/(f-1))}throw'Invalid aggregate type.';}(function(n){n[n.None=0]="None";n[n.Sum=1]="Sum";n[n.Cnt=2]="Cnt";n[n.Avg=3]="Avg";n[n.Max=4]="Max";n[n.Min=5]="Min";n[n.Rng=6]="Rng";n[n.Std=7]="Std";n[n.Var=8]="Var";n[n.StdPop=9]="StdPop";n[n.VarPop=10]="VarPop";n[n.CntAll=11]="CntAll"})(n.Aggregate||(n.Aggregate={}));var t=n.Aggregate;n.getAggregate=i}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i,u,f,e,r,o;(function(n){n[n.Add=0]="Add";n[n.Remove=1]="Remove";n[n.Change=2]="Change";n[n.Reset=3]="Reset"})(t.NotifyCollectionChangedAction||(t.NotifyCollectionChangedAction={}));i=t.NotifyCollectionChangedAction;u=function(n){function t(t,r,u){t===void 0&&(t=i.Reset);r===void 0&&(r=null);u===void 0&&(u=-1);n.call(this);this.action=t;this.item=r;this.index=u}return __extends(t,n),t.reset=new t(i.Reset),t}(n.EventArgs);t.NotifyCollectionChangedEventArgs=u;f=function(){function t(t,i){this._bnd=new n.Binding(t);this._asc=i}return Object.defineProperty(t.prototype,"property",{get:function(){return this._bnd.path},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"ascending",{get:function(){return this._asc},enumerable:!0,configurable:!0}),t}();t.SortDescription=f;e=function(n){function t(t){n.call(this);this.newPageIndex=t}return __extends(t,n),t}(n.CancelEventArgs);t.PageChangingEventArgs=e;r=function(){function n(){}return n.prototype.groupNameFromItem=function(){return''},n.prototype.namesMatch=function(n,t){return n===t},n}();t.GroupDescription=r;o=function(t){function i(i,r){t.call(this);this._bnd=new n.Binding(i);this._converter=r}return __extends(i,t),Object.defineProperty(i.prototype,"propertyName",{get:function(){return this._bnd.path},enumerable:!0,configurable:!0}),i.prototype.groupNameFromItem=function(n){return this._converter?this._converter(n,this.propertyName):this._bnd.getValue(n)},i.prototype.namesMatch=function(n,t){return n===t},i}(r);t.PropertyGroupDescription=o})(t=n.collections||(n.collections={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(){function n(){this.length=0;Array.apply(this,arguments)}return n.prototype.pop=function(){return null},n.prototype.push=function(){for(var t=[],n=0;n<arguments.length;n++)t[+n]=arguments[n];return 0},n.prototype.splice=function(){return null},n.prototype.slice=function(){return null},n.prototype.indexOf=function(){return-1},n.prototype.sort=function(){return null},n}(),r;t.ArrayBase=i;i.prototype=Array.prototype;r=function(i){function r(t){if(i.call(this),this._updating=0,this.collectionChanged=new n.Event,t){t=n.asArray(t);this._updating++;for(var r=0;r<t.length;r++)this.push(t[r]);this._updating--}}return __extends(r,i),r.prototype.push=function(){for(var f,r,n=[],u=0;u<arguments.length;u++)n[+u]=arguments[u];for(f=this.length,r=0;n&&r<n.length;r++)f=i.prototype.push.call(this,n[r]),this._updating||this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Add,n[r],f-1);return f},r.prototype.pop=function(){var n=i.prototype.pop.call(this);return this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Remove,n,this.length),n},r.prototype.splice=function(n,r,u){var f;return r&&u?(f=i.prototype.splice.call(this,n,r,u),r==1?this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Change,u,n):this._raiseCollectionChanged(),f):u?(f=i.prototype.splice.call(this,n,0,u),this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Add,u,n),f):(f=i.prototype.splice.call(this,n,r),r==1?this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Remove,f[0],n):this._raiseCollectionChanged(),f)},r.prototype.slice=function(n,t){return i.prototype.slice.call(this,n,t)},r.prototype.indexOf=function(n,t){return i.prototype.indexOf.call(this,n,t)},r.prototype.sort=function(n){var t=i.prototype.sort.call(this,n);return this._raiseCollectionChanged(),t},r.prototype.insert=function(n,t){this.splice(n,0,t)},r.prototype.remove=function(n){var t=this.indexOf(n);return t>-1?(this.removeAt(t),!0):!1},r.prototype.removeAt=function(n){this.splice(n,1)},r.prototype.setAt=function(n,t){n>this.length&&(this.length=n);this.splice(n,1,t)},r.prototype.clear=function(){this.length!==0&&(this.splice(0,this.length),this._raiseCollectionChanged())},r.prototype.beginUpdate=function(){this._updating++},r.prototype.endUpdate=function(){this._updating>0&&(this._updating--,this._updating==0&&this._raiseCollectionChanged())},Object.defineProperty(r.prototype,"isUpdating",{get:function(){return this._updating>0},enumerable:!0,configurable:!0}),r.prototype.deferUpdate=function(n){try{this.beginUpdate();n()}finally{this.endUpdate()}},r.prototype.implementsInterface=function(n){return n=='INotifyCollectionChanged'},r.prototype.onCollectionChanged=function(n){n===void 0&&(n=t.NotifyCollectionChangedEventArgs.reset);this.isUpdating||this.collectionChanged.raise(this,n)},r.prototype._raiseCollectionChanged=function(n,i,r){if(n===void 0&&(n=t.NotifyCollectionChangedAction.Reset),!this.isUpdating){var u=new t.NotifyCollectionChangedEventArgs(n,i,r);this.onCollectionChanged(u)}},r}(i);t.ObservableArray=r})(t=n.collections||(n.collections={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var r=function(){function r(i,r){var u=this;this._idx=-1;this._srtDsc=new t.ObservableArray;this._grpDesc=new t.ObservableArray;this._newItem=null;this._edtItem=null;this._pgSz=0;this._pgIdx=0;this._updating=0;this._stableSort=!1;this._canFilter=!0;this._canGroup=!0;this._canSort=!0;this._canAddNew=!0;this._canCancelEdit=!0;this._canRemove=!0;this._canChangePage=!0;this._trackChanges=!1;this._chgAdded=new t.ObservableArray;this._chgRemoved=new t.ObservableArray;this._chgEdited=new t.ObservableArray;this.collectionChanged=new n.Event;this.sourceCollectionChanging=new n.Event;this.sourceCollectionChanged=new n.Event;this.currentChanged=new n.Event;this.currentChanging=new n.Event;this.pageChanged=new n.Event;this.pageChanging=new n.Event;this._srtDsc.collectionChanged.addHandler(function(){for(var r=u._srtDsc,i=0;i<r.length;i++)n.assert(r[i]instanceof t.SortDescription,'sortDescriptions array must contain SortDescription objects.');u.canSort&&u.refresh()});this._grpDesc.collectionChanged.addHandler(function(){for(var r=u._grpDesc,i=0;i<r.length;i++)n.assert(r[i]instanceof t.GroupDescription,'groupDescriptions array must contain GroupDescription objects.');u.canGroup&&u.refresh()});this.sourceCollection=i?i:new t.ObservableArray;r&&(this.beginUpdate(),n.copy(this,r),this.endUpdate())}return r.prototype._copy=function(i,r){var e,f,u;if(i=='sortDescriptions'){for(this.sortDescriptions.clear(),e=n.asArray(r),f=0;f<e.length;f++)u=e[f],n.isString(u)&&(u=new t.SortDescription(u,!0)),this.sortDescriptions.push(u);return!0}if(i=='groupDescriptions'){for(this.groupDescriptions.clear(),e=n.asArray(r),f=0;f<e.length;f++)u=e[f],n.isString(u)&&(u=new t.PropertyGroupDescription(u)),this.groupDescriptions.push(u);return!0}return!1},Object.defineProperty(r.prototype,"newItemCreator",{get:function(){return this._itemCreator},set:function(t){this._itemCreator=n.asFunction(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"sortConverter",{get:function(){return this._srtCvt},set:function(t){t!=this._srtCvt&&(this._srtCvt=n.asFunction(t,!0))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"sortComparer",{get:function(){return this._srtCmp},set:function(t){t!=this._srtCmp&&(this._srtCmp=n.asFunction(t,!0))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"useStableSort",{get:function(){return this._stableSort},set:function(t){this._stableSort=n.asBoolean(t)},enumerable:!0,configurable:!0}),r.prototype.getAggregate=function(t,i,r){var u=r?this._pgView:this._view;return n.getAggregate(t,u,i)},Object.defineProperty(r.prototype,"trackChanges",{get:function(){return this._trackChanges},set:function(t){this._trackChanges=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemsAdded",{get:function(){return this._chgAdded},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemsRemoved",{get:function(){return this._chgRemoved},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemsEdited",{get:function(){return this._chgEdited},enumerable:!0,configurable:!0}),r.prototype.clearChanges=function(){this._chgAdded.clear();this._chgRemoved.clear();this._chgEdited.clear()},r.prototype.implementsInterface=function(n){switch(n){case'ICollectionView':case'IEditableCollectionView':case'IPagedCollectionView':case'INotifyCollectionChanged':return!0}return!1},Object.defineProperty(r.prototype,"getError",{get:function(){return this._getError},set:function(t){this._getError=n.asFunction(t)},enumerable:!0,configurable:!0}),r.prototype.onCollectionChanged=function(n){n===void 0&&(n=t.NotifyCollectionChangedEventArgs.reset);this._committing||this._canceling||n.action!=t.NotifyCollectionChangedAction.Change||n.item==this.currentEditItem||this._trackItemChanged(n.item);this.collectionChanged.raise(this,n)},r.prototype._raiseCollectionChanged=function(n,i,r){n===void 0&&(n=t.NotifyCollectionChangedAction.Reset);var u=new t.NotifyCollectionChangedEventArgs(n,i,r);this.onCollectionChanged(u)},r.prototype.onSourceCollectionChanging=function(n){return this.sourceCollectionChanging.raise(this,n),!n.cancel},r.prototype.onSourceCollectionChanged=function(n){this.sourceCollectionChanged.raise(this,n)},Object.defineProperty(r.prototype,"canFilter",{get:function(){return this._canFilter},set:function(t){this._canFilter=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"canGroup",{get:function(){return this._canGroup},set:function(t){this._canGroup=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"canSort",{get:function(){return this._canSort},set:function(t){this._canSort=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"currentItem",{get:function(){return this._pgView&&this._idx>-1&&this._idx<this._pgView.length?this._pgView[this._idx]:null},set:function(n){this.moveCurrentTo(n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"currentPosition",{get:function(){return this._idx},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"filter",{get:function(){return this._filter},set:function(t){this._filter!=t&&(this._filter=n.asFunction(t),this.canFilter&&this.refresh())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"groupDescriptions",{get:function(){return this._grpDesc},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"groups",{get:function(){return this._groups},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isEmpty",{get:function(){return!this._pgView||!this._pgView.length},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"sortDescriptions",{get:function(){return this._srtDsc},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"sourceCollection",{get:function(){return this._src},set:function(t){if(t!=this._src){if(!this.onSourceCollectionChanging(new n.CancelEventArgs))return;var i=this.currentPosition;this.commitEdit();this.commitNew();this._ncc!=null&&this._ncc.collectionChanged.removeHandler(this._sourceChanged);this._src=n.asArray(t,!1);this._ncc=n.tryCast(this._src,'INotifyCollectionChanged');this._ncc&&this._ncc.collectionChanged.addHandler(this._sourceChanged,this);this.clearChanges();this.refresh();this.moveCurrentToFirst();this.onSourceCollectionChanged();this.currentPosition<0&&i>-1&&this.onCurrentChanged()}},enumerable:!0,configurable:!0}),r.prototype._sourceChanged=function(){this._updating<=0&&this.refresh()},r.prototype.contains=function(n){return this._pgView.indexOf(n)>-1},r.prototype.moveCurrentTo=function(n){return this.moveCurrentToPosition(this._pgView.indexOf(n))},r.prototype.moveCurrentToFirst=function(){return this.moveCurrentToPosition(0)},r.prototype.moveCurrentToLast=function(){return this.moveCurrentToPosition(this._pgView.length-1)},r.prototype.moveCurrentToPrevious=function(){return this._idx>0?this.moveCurrentToPosition(this._idx-1):!1},r.prototype.moveCurrentToNext=function(){return this.moveCurrentToPosition(this._idx+1)},r.prototype.moveCurrentToPosition=function(t){if(t>=-1&&t<this._pgView.length){var i=new n.CancelEventArgs;this._idx!=t&&this.onCurrentChanging(i)&&(this._edtItem&&this._pgView[t]!=this._edtItem&&this.commitEdit(),this._newItem&&this._pgView[t]!=this._newItem&&this.commitNew(),this._idx=t,this.onCurrentChanged())}return this._idx==t},r.prototype.refresh=function(){this._updating>0||this._newItem||this._edtItem||(this._performRefresh(),this.onCollectionChanged())},r.prototype._performRefresh=function(){var i=this.currentItem,t;this._view=this._src?this._filter&&this.canFilter?this._performFilter(this._src):this._srtDsc.length>0&&this.canSort?this._src.slice(0):this._src:[];this.canSort&&this._srtDsc.length>0&&this._performSort(this._view);this._groups=this.canGroup?this._createGroups(this._view):null;this._fullGroups=this._groups;this._groups&&(this._view=this._mergeGroupItems(this._groups));this._pgIdx=n.clamp(this._pgIdx,0,this.pageCount-1);this._pgView=this._getPageView();this._groups&&this.pageCount>1&&(this._groups=this._createGroups(this._pgView),this._mergeGroupItems(this._groups));t=this._pgView.indexOf(i);t<0&&(t=Math.min(this._idx,this._pgView.length-1));this._idx=t;this._digest=this._getGroupsDigest(this.groups);this.currentItem!==i&&this.onCurrentChanged()},r.prototype._performSort=function(n){var i,r,t;if(this._stableSort)for(i=n.map(function(n,t){return{item:n,index:t}}),r=this._compareItems(),i.sort(function(n,t){var i=r(n.item,t.item);return i==0?n.index-t.index:i}),t=0;t<n.length;t++)n[t]=i[t].item;else n.sort(this._compareItems())},r.prototype._compareItems=function(){var i=this._srtDsc,t=this._srtCvt,r=this._srtCmp,u=!0,n=0;return function(f,e){for(var l,a,c=0;c<i.length;c++){var h=i[c],o=h._bnd.getValue(f),s=h._bnd.getValue(e);if(t&&(o=t(h,f,o,u),s=t(h,e,s,!1),u=!1),r&&(n=r(o,s),n!=null))return h.ascending?+n:-n;if(o!==o&&(o=null),s!==s&&(s=null),typeof o=='string'&&typeof s=='string'&&(l=o.toLowerCase(),a=s.toLowerCase(),l!=a&&(o=l,s=a)),o!=null&&s==null)return-1;if(o==null&&s!=null)return 1;if(n=o<s?-1:o>s?1:0,n!=0)return h.ascending?+n:-n}return 0}},r.prototype._performFilter=function(n){return this.canFilter&&this._filter?n.filter(this._filter,this):n},r.prototype.onCurrentChanged=function(t){t===void 0&&(t=n.EventArgs.empty);this.currentChanged.raise(this,t)},r.prototype.onCurrentChanging=function(n){return this.currentChanging.raise(this,n),!n.cancel},Object.defineProperty(r.prototype,"items",{get:function(){return this._pgView},enumerable:!0,configurable:!0}),r.prototype.beginUpdate=function(){this._updating++},r.prototype.endUpdate=function(){this._updating--;this._updating<=0&&this.refresh()},Object.defineProperty(r.prototype,"isUpdating",{get:function(){return this._updating>0},enumerable:!0,configurable:!0}),r.prototype.deferUpdate=function(n){try{this.beginUpdate();n()}finally{this.endUpdate()}},Object.defineProperty(r.prototype,"canAddNew",{get:function(){return this._canAddNew},set:function(t){this._canAddNew=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"canCancelEdit",{get:function(){return this._canCancelEdit},set:function(t){this._canCancelEdit=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"canRemove",{get:function(){return this._canRemove},set:function(t){this._canRemove=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"currentAddItem",{get:function(){return this._newItem},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"currentEditItem",{get:function(){return this._edtItem},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isAddingNew",{get:function(){return this._newItem!=null},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isEditingItem",{get:function(){return this._edtItem!=null},enumerable:!0,configurable:!0}),r.prototype.editItem=function(n){n!=this._edtItem&&this.moveCurrentTo(n)&&(this.commitEdit(),this._edtItem=n,this._edtClone={},this._extend(this._edtClone,this._edtItem))},r.prototype.commitEdit=function(){var n=this._edtItem,r,i,u;n!=null&&(this._committing=!0,r=this._sameContent(n,this._edtClone),this._edtItem=null,this._edtClone=null,i=this._pgView.indexOf(n),u=this._digest,this._performRefresh(),r||this._trackItemChanged(n),this._pgView.indexOf(n)==i&&u==this._digest?this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Change,n,i):this._raiseCollectionChanged(),this._committing=!1)},r.prototype.cancelEdit=function(){var r=this._edtItem,i;if(r!=null){if(this._edtItem=null,!this.canCancelEdit){n.assert(!1,'cannot cancel edits (canCancelEdit == false).');return}if(i=this._src.indexOf(r),i<0||!this._edtClone)return;this._extend(this._src[i],this._edtClone);this._edtClone=null;this._canceling=!0;this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Change,r,i);this._canceling=!1}},r.prototype.addNew=function(){var i,u,r;if(arguments.length>0&&n.assert(!1,'addNew does not take any parameters, it creates the new items.'),this.commitEdit(),this.commitNew(),!this.canAddNew)return n.assert(!1,'cannot add items (canAddNew == false).'),null;if(i=null,u=this.sourceCollection,i=this.newItemCreator?this.newItemCreator():u&&u.length?new u[0].constructor:{},i!=null){if(this._newItem=i,this._updating++,this._src.push(i),this._updating--,this._pgView!=this._src&&this._pgView.push(i),this.groups&&this.groups.length)for(r=this.groups[this.groups.length-1],r.items.push(i);r.groups&&r.groups.length;)r=r.groups[r.groups.length-1],r.items.push(i);this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Add,i,this._pgView.length-1);this.moveCurrentTo(i)}return this._newItem},r.prototype.commitNew=function(){var n=this._newItem,i,u,r;n!=null&&(this._newItem=null,i=this._pgView.indexOf(n),u=this._digest,this._performRefresh(),this._trackChanges==!0&&(r=this._chgEdited.indexOf(n),r>-1&&this._chgEdited.removeAt(r),this._chgAdded.indexOf(n)<0&&this._chgAdded.push(n)),this._pgView.indexOf(n)==i&&u==this._digest?this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Change,n,i):this._raiseCollectionChanged())},r.prototype.cancelNew=function(){var n=this._newItem;n!=null&&this.remove(n)},r.prototype.remove=function(i){var e=i==this._newItem,r,o,s,u,f,h,c,l;if(e&&(this._newItem=null),i==this._edtItem&&this.cancelEdit(),!this.canRemove){n.assert(!1,'cannot remove items (canRemove == false).');return}r=this._src.indexOf(i);r>-1&&(o=this.currentItem,this._updating++,this._src.splice(r,1),this._updating--,s=this._digest,this._performRefresh(),this._trackChanges==!0&&(u=this._chgAdded.indexOf(i),u>-1&&this._chgAdded.removeAt(u),f=this._chgEdited.indexOf(i),f>-1&&this._chgEdited.removeAt(f),h=this._chgRemoved.indexOf(i),h<0&&!e&&u<0&&this._chgRemoved.push(i)),c=this.sortDescriptions.length>0,l=this.pageSize>0&&this._pgIdx>-1,c||l||s!=this._getGroupsDigest(this.groups)?this._raiseCollectionChanged():this._raiseCollectionChanged(t.NotifyCollectionChangedAction.Remove,i,r),this.currentItem!==o&&this.onCurrentChanged())},r.prototype.removeAt=function(t){t=n.asInt(t);this.remove(this._pgView[t])},r.prototype._trackItemChanged=function(n){var i,r;if(this._trackChanges)if(i=this._chgEdited.indexOf(n),i<0&&this._chgAdded.indexOf(n)<0)this._chgEdited.push(n);else if(i>-1){r=new t.NotifyCollectionChangedEventArgs(t.NotifyCollectionChangedAction.Change,n,i);this._chgEdited.onCollectionChanged(r)}else if(i=this._chgAdded.indexOf(n),i>-1){r=new t.NotifyCollectionChangedEventArgs(t.NotifyCollectionChangedAction.Change,n,i);this._chgAdded.onCollectionChanged(r)}},r.prototype._extend=function(n,t){for(var i in t)n[i]=t[i]},r.prototype._sameContent=function(n,t){for(var i in t)if(!this._sameValue(n[i],t[i]))return!1;for(i in n)if(!this._sameValue(n[i],t[i]))return!1;return!0},r.prototype._sameValue=function(t,i){return t==i||n.DateTime.equals(t,i)},Object.defineProperty(r.prototype,"canChangePage",{get:function(){return this._canChangePage},set:function(t){this._canChangePage=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isPageChanging",{get:function(){return!1},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemCount",{get:function(){return this._pgView.length},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"pageIndex",{get:function(){return this._pgIdx},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"pageSize",{get:function(){return this._pgSz},set:function(t){t!=this._pgSz&&(this._pgSz=n.asInt(t),this.refresh())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"totalItemCount",{get:function(){return this._view.length},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"pageCount",{get:function(){return this.pageSize?Math.ceil(this.totalItemCount/this.pageSize):1},enumerable:!0,configurable:!0}),r.prototype.moveToFirstPage=function(){return this.moveToPage(0)},r.prototype.moveToLastPage=function(){return this.moveToPage(this.pageCount-1)},r.prototype.moveToNextPage=function(){return this.moveToPage(this.pageIndex+1)},r.prototype.moveToPage=function(i){var r=n.clamp(i,0,this.pageCount-1),u;return r!=this._pgIdx&&(this.canChangePage||n.assert(!1,'cannot change pages (canChangePage == false).'),u=new t.PageChangingEventArgs(r),this.onPageChanging(u)&&(this._pgIdx=r,this._pgView=this._getPageView(),this._idx=0,this.groupDescriptions&&this.groupDescriptions.length!=0?this.refresh():(this.onPageChanged(),this.onCollectionChanged()))),this._pgIdx==i},r.prototype.moveToPreviousPage=function(){return this.moveToPage(this.pageIndex-1)},r.prototype.onPageChanged=function(t){t===void 0&&(t=n.EventArgs.empty);this.pageChanged.raise(this,t)},r.prototype.onPageChanging=function(n){return this.pageChanging.raise(this,n),!n.cancel},r.prototype._getFullGroup=function(n){var t=this._getGroupByPath(this._fullGroups,n.level,n._path);return t!=null&&(n=t),n},r.prototype._getGroupByPath=function(n,t,i){for(var r,u=0;u<n.length;u++)if((r=n[u],r.level==t&&r._path==i)||r.level<t&&i.indexOf(r._path)==0&&(r=this._getGroupByPath(r.groups,t,i),r!=null))return r;return null},r.prototype._getPageView=function(){if(this.pageSize<=0||this._pgIdx<0)return this._view;var n=this._pgSz*this._pgIdx,t=Math.min(n+this._pgSz,this._view.length);return this._view.slice(n,t)},r.prototype._createGroups=function(t){var u,i,e;if(!this._grpDesc||!this._grpDesc.length)return null;var s=[],h={},r=null;for(u=0;u<t.length;u++){var c=t[u],l=s,a=this._grpDesc.length,f='';for(i=0;i<a;i++){var v=this._grpDesc[i],o=v.groupNameFromItem(c,i),y=i==a-1;r=h[f];!r&&n.isPrimitive(o)&&(r={},h[f]=r);e=this._getGroup(v,l,r,o,i,y);f+='/'+o;e._path=f;y&&e.items.push(c);l=e.groups}}return s},r.prototype._getGroupsDigest=function(n){for(var t,i='',r=0;n!=null&&r<n.length;r++)t=n[r],i+='{'+t.name+':'+(t.items?t.items.length:'*'),t.groups.length>0&&(i+=',',i+=this._getGroupsDigest(t.groups)),i+='}';return i},r.prototype._mergeGroupItems=function(n){for(var i,f,t,r,e=[],u=0;u<n.length;u++){if(i=n[u],!i._isBottomLevel)for(f=this._mergeGroupItems(i.groups),t=0,r=f.length;t<r;t++)i._items.push(f[t]);for(t=0,r=i._items.length;t<r;t++)e.push(i._items[t])}return e},r.prototype._getGroup=function(t,r,u,f,e,o){var c,s,h;if(u&&n.isPrimitive(f)){if(c=u[f],c)return c}else for(s=0;s<r.length;s++)if(t.namesMatch(r[s].name,f))return r[s];return h=new i(t,f,e,o),r.push(h),u&&(u[f]=h),h},r}(),i;t.CollectionView=r;i=function(){function t(n,t,i,r){this._gd=n;this._name=t;this._level=i;this._isBottomLevel=r;this._groups=[];this._items=[]}return Object.defineProperty(t.prototype,"name",{get:function(){return this._name},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"level",{get:function(){return this._level},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isBottomLevel",{get:function(){return this._isBottomLevel},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"items",{get:function(){return this._items},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"groups",{get:function(){return this._groups},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"groupDescription",{get:function(){return this._gd},enumerable:!0,configurable:!0}),t.prototype.getAggregate=function(t,i,u){var f=n.tryCast(u,r),e=f?f._getFullGroup(this):this;return n.getAggregate(t,e.items,i)},t}();t.CollectionViewGroup=i})(t=n.collections||(n.collections={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){'use strict';var i=function(){function i(t){this._showAutoTipBnd=this._showAutoTip.bind(this);this._hideAutoTipBnd=this._hideAutoTip.bind(this);this._html=!0;this._gap=6;this._showAtMouse=!1;this._showDelay=500;this._hideDelay=0;this._tips=[];this.popup=new n.Event;n.copy(this,t)}return i.prototype.setTooltip=function(t,i){t=n.getElement(t);i=this._getContent(i);var r=this._indexOf(t);r>-1&&(this._detach(t),this._tips.splice(r,1));i&&(this._attach(t),this._tips.push({element:t,content:i}))},i.prototype.show=function(r,u,f){var e,o;r=n.getElement(r);u=this._getContent(u);f||(f=n.Rect.fromBoundingRect(r.getBoundingClientRect()));e=i._eTip;e||(e=i._eTip=document.createElement('div'),n.addClass(e,'wj-tooltip'),e.style.visibility='none',document.body.appendChild(e));this._setContent(u);o=new t(u);this.onPopup(o);o.content&&!o.cancel&&(this._setContent(o.content),e.style.minWidth='',f=new n.Rect(f.left-(e.offsetWidth-f.width)/2,f.top-this.gap,e.offsetWidth,f.height+2*this.gap),n.showPopup(e,f,!0),document.addEventListener('mousedown',this._hideAutoTipBnd))},i.prototype.hide=function(){i._eTip&&(i._eTip.style.visibility='hidden',i._eTip.innerHTML='');document.removeEventListener('mousedown',this._hideAutoTipBnd)},Object.defineProperty(i.prototype,"isVisible",{get:function(){return i._eTip&&i._eTip.style.visibility!='hidden'},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isContentHtml",{get:function(){return this._html},set:function(t){this._html=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"gap",{get:function(){return this._gap},set:function(t){this._gap=n.asNumber(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"showAtMouse",{get:function(){return this._showAtMouse},set:function(t){this._showAtMouse=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"showDelay",{get:function(){return this._showDelay},set:function(t){this._showDelay=n.asInt(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"hideDelay",{get:function(){return this._hideDelay},set:function(t){this._hideDelay=n.asInt(t)},enumerable:!0,configurable:!0}),i.prototype.onPopup=function(n){this.popup&&this.popup.raise(this,n)},i.prototype._indexOf=function(n){for(var t=0;t<this._tips.length;t++)if(this._tips[t].element==n)return t;return-1},i.prototype._attach=function(n){n.addEventListener('mouseenter',this._showAutoTipBnd);n.addEventListener('mouseleave',this._hideAutoTipBnd);n.addEventListener('click',this._showAutoTipBnd)},i.prototype._detach=function(n){n.removeEventListener('mouseenter',this._showAutoTipBnd);n.removeEventListener('mouseleave',this._hideAutoTipBnd);n.removeEventListener('click',this._showAutoTipBnd)},i.prototype._showAutoTip=function(t){var i=this,r=t.type=='mouseenter'?this._showDelay:0;this._clearTimeouts();this._toShow=setTimeout(function(){var u=i._indexOf(t.target),r,f;u>-1&&(r=i._tips[u],f=i._showAtMouse?new n.Rect(t.clientX,t.clientY,0,0):null,i.show(r.element,r.content,f),i._hideDelay>0&&(i._toHide=setTimeout(function(){i.hide()},i._hideDelay)))},r)},i.prototype._hideAutoTip=function(){this._clearTimeouts();this.hide()},i.prototype._clearTimeouts=function(){this._toShow&&(clearTimeout(this._toShow),this._toShow=null);this._toHide&&(clearTimeout(this._toHide),this._toHide=null)},i.prototype._getContent=function(t){if(t=n.asString(t),t&&t[0]=='#'){var i=n.getElement(t);i&&(t=i.innerHTML)}return t},i.prototype._setContent=function(n){var t=i._eTip;t&&(this.isContentHtml?t.innerHTML=n:t.textContent=n)},i}(),r,t;n.Tooltip=i;r=function(){function n(){}return n}();t=function(t){function i(i){t.call(this);this._content=n.asString(i)}return __extends(i,t),Object.defineProperty(i.prototype,"content",{get:function(){return this._content},set:function(t){this._content=n.asString(t)},enumerable:!0,configurable:!0}),i}(n.CancelEventArgs);n.TooltipEventArgs=t}(wijmo||(wijmo={})),function(n){'use strict';var t=function(){function t(n){this._r=0;this._g=0;this._b=0;this._a=1;n&&this._parse(n)}return Object.defineProperty(t.prototype,"r",{get:function(){return this._r},set:function(t){this._r=n.clamp(n.asNumber(t),0,255)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"g",{get:function(){return this._g},set:function(t){this._g=n.clamp(n.asNumber(t),0,255)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"b",{get:function(){return this._b},set:function(t){this._b=n.clamp(n.asNumber(t),0,255)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"a",{get:function(){return this._a},set:function(t){this._a=n.clamp(n.asNumber(t),0,1)},enumerable:!0,configurable:!0}),t.prototype.equals=function(n){return n instanceof t&&this.r==n.r&&this.g==n.g&&this.b==n.b&&this.a==n.a},t.prototype.toString=function(){var n=Math.round(this.a*100);return n>99?'#'+(16777216+(this.r<<16)+(this.g<<8)+this.b).toString(16).slice(1):'rgba('+this.r+','+this.g+','+this.b+','+n/100+')'},t.fromRgba=function(i,r,u,f){f===void 0&&(f=1);var e=new t(null);return e.r=Math.round(n.clamp(n.asNumber(i),0,255)),e.g=Math.round(n.clamp(n.asNumber(r),0,255)),e.b=Math.round(n.clamp(n.asNumber(u),0,255)),e.a=n.clamp(n.asNumber(f),0,1),e},t.fromHsb=function(i,r,u,f){f===void 0&&(f=1);var e=t._hsbToRgb(n.clamp(n.asNumber(i),0,1),n.clamp(n.asNumber(r),0,1),n.clamp(n.asNumber(u),0,1));return t.fromRgba(e[0],e[1],e[2],f)},t.fromHsl=function(i,r,u,f){f===void 0&&(f=1);var e=t._hslToRgb(n.clamp(n.asNumber(i),0,1),n.clamp(n.asNumber(r),0,1),n.clamp(n.asNumber(u),0,1));return t.fromRgba(e[0],e[1],e[2],f)},t.fromString=function(i){var r=new t(null);return r._parse(n.asString(i))?r:null},t.prototype.getHsb=function(){return t._rgbToHsb(this.r,this.g,this.b)},t.prototype.getHsl=function(){return t._rgbToHsl(this.r,this.g,this.b)},t.interpolate=function(i,r,u){u=n.clamp(n.asNumber(u),0,1);var e=t._rgbToHsl(i.r,i.g,i.b),o=t._rgbToHsl(r.r,r.g,r.b),f=1-u,c=i.a*f+r.a*u,s=[e[0]*f+o[0]*u,e[1]*f+o[1]*u,e[2]*f+o[2]*u],h=t._hslToRgb(s[0],s[1],s[2]);return t.fromRgba(h[0],h[1],h[2],c)},t.toOpaque=function(i,r){if(i=n.isString(i)?t.fromString(i):n.asType(i,t),i.a==1)return i;r=r==null?t.fromRgba(255,255,255,1):n.isString(r)?t.fromString(r):n.asType(r,t);var u=i.a,f=1-u;return t.fromRgba(i.r*u+r.r*f,i.g*u+r.g*f,i.b*u+r.b*f)},t.prototype._parse=function(n){var u,f,r,e,i,o;if(n=n.toLowerCase(),n=='transparent')return this._r=this._g=this._b=this._a=0,!0;if(n&&n.indexOf('#')!=0&&n.indexOf('rgb')!=0&&n.indexOf('hsl')!=0&&(u=document.createElement('div'),u.style.color=n,f=u.style.color,f==n&&(f=window.getComputedStyle(u).color,f||(document.body.appendChild(u),f=window.getComputedStyle(u).color,document.body.removeChild(u))),n=f.toLowerCase()),n.indexOf('#')==0)return n.length==4?(this.r=parseInt(n[1]+n[1],16),this.g=parseInt(n[2]+n[2],16),this.b=parseInt(n[3]+n[3],16),this.a=1,!0):n.length==7?(this.r=parseInt(n.substr(1,2),16),this.g=parseInt(n.substr(3,2),16),this.b=parseInt(n.substr(5,2),16),this.a=1,!0):!1;if(n.indexOf('rgb')==0&&(r=n.indexOf('('),e=n.indexOf(')'),r>-1&&e>-1&&(i=n.substr(r+1,e-(r+1)).split(','),i.length>2)))return this.r=parseInt(i[0]),this.g=parseInt(i[1]),this.b=parseInt(i[2]),this.a=i.length>3?parseFloat(i[3]):1,!0;if(n.indexOf('hsl')==0&&(r=n.indexOf('('),e=n.indexOf(')'),r>-1&&e>-1&&(i=n.substr(r+1,e-(r+1)).split(','),i.length>2))){var c=parseInt(i[0])/360,s=parseInt(i[1]),h=parseInt(i[2]);return i[1].indexOf('%')>-1&&(s/=100),i[2].indexOf('%')>-1&&(h/=100),o=t._hslToRgb(c,s,h),this.r=o[0],this.g=o[1],this.b=o[2],this.a=i.length>3?parseFloat(i[3]):1,!0}return!1},t._hslToRgb=function(i,r,u){var o,s,h,f,e;return n.assert(i>=0&&i<=1&&r>=0&&r<=1&&u>=0&&u<=1,'bad HSL values'),r==0?o=s=h=u:(f=u<.5?u*(1+r):u+r-u*r,e=2*u-f,o=t._hue2rgb(e,f,i+1/3),s=t._hue2rgb(e,f,i),h=t._hue2rgb(e,f,i-1/3)),[Math.round(o*255),Math.round(s*255),Math.round(h*255)]},t._hue2rgb=function(n,t,i){return(i<0&&(i+=1),i>1&&(i-=1),i<1/6)?n+(t-n)*6*i:i<1/2?t:i<2/3?n+(t-n)*(2/3-i)*6:n},t._rgbToHsl=function(t,i,r){var e;n.assert(t>=0&&t<=255&&i>=0&&i<=255&&r>=0&&r<=255,'bad RGB values');t/=255;i/=255;r/=255;var u=Math.max(t,i,r),o=Math.min(t,i,r),f,s,h=(u+o)/2;if(u==o)f=s=0;else{e=u-o;s=h>.5?e/(2-u-o):e/(u+o);switch(u){case t:f=(i-r)/e+(i<r?6:0);break;case i:f=(r-t)/e+2;break;case r:f=(t-i)/e+4}f/=6}return[f,s,h]},t._rgbToHsb=function(i,r,u){n.assert(i>=0&&i<=255&&r>=0&&r<=255&&u>=0&&u<=255,'bad RGB values');var f=t._rgbToHsl(i,r,u);return t._hslToHsb(f[0],f[1],f[2])},t._hsbToRgb=function(n,i,r){var u=t._hsbToHsl(n,i,r);return t._hslToRgb(u[0],u[1],u[2])},t._hsbToHsl=function(t,i,r){n.assert(t>=0&&t<=1&&i>=0&&i<=1&&r>=0&&r<=1,'bad HSB values');var u=n.clamp(r*(2-i)/2,0,1),f=1-Math.abs(2*u-1),e=n.clamp(f>0?r*i/f:i,0,1);return n.assert(!isNaN(u)&&!isNaN(e),'bad conversion to HSL'),[t,e,u]},t._hslToHsb=function(t,i,r){n.assert(t>=0&&t<=1&&i>=0&&i<=1&&r>=0&&r<=1,'bad HSL values');var u=n.clamp(r==1?1:(2*r+i*(1-Math.abs(2*r-1)))/2,0,1),f=n.clamp(u>0?2*(u-r)/u:i,0,1);return n.assert(!isNaN(u)&&!isNaN(f),'bad conversion to HSB'),[t,f,u]},t}();n.Color=t}(wijmo||(wijmo={})),function(n){'use strict';var t=function(){function t(){}return t.copy=function(n){t._copyPasteInternal(n)},t.paste=function(n){t._copyPasteInternal(n)},t._copyPasteInternal=function(t){for(var u=n.getActiveElement(),r=n.closest(u,'.wj-control'),i;r&&n.Control.getControl(r);)r=r.parentElement;r==null&&(r=document.body);r&&(i=document.createElement('textarea'),i.style.position='fixed',i.style.opacity='0',r.appendChild(i),typeof t=='string'&&(i.value=t),i.select(),i.onkeydown=function(n){i.value&&n.preventDefault()},setTimeout(function(){u.focus();var n=i.value;r.removeChild(i);typeof t=='function'&&t(n)},100))},t}();n.Clipboard=t}(wijmo||(wijmo={})),function(n){'use strict';function i(i,r,u,f,e){var h,o,a,tt,w,p,g,it,nt,b,l;if(r===void 0&&(r=null),u===void 0&&(u=!1),f===void 0&&(f=!1),e===void 0&&(e=!0),h=document.body,r instanceof HTMLElement){if(!n.contains(document.body,r))return;for(o=r.parentElement;o;o=o.parentElement)if(getComputedStyle(o).position=='fixed'){h=o;break}}else for(o=n.getActiveElement();o;o=o.parentElement)if(!n.hasClass(o,'wj-popup')&&getComputedStyle(o).position=='fixed'){h=o;break}h.lastChild!=i&&h.appendChild(i);r instanceof HTMLElement&&e&&(a=getComputedStyle(r),tt=new n.Color(a.backgroundColor),tt.a&&n.setCss(i,{color:a.color,backgroundColor:a.backgroundColor,fontFamily:a.fontFamily,fontSize:a.fontSize,fontWeight:a.fontWeight,fontStyle:a.fontStyle}));n.setCss(i,{position:'absolute',visibility:'hidden',display:''});n.Control.refreshAll(i);var y=getComputedStyle(i),rt=parseFloat(y.marginTop)+parseFloat(y.marginBottom),ut=parseFloat(y.marginLeft)+parseFloat(y.marginRight),v=new n.Size(i.offsetWidth+ut,i.offsetHeight+rt),c=new n.Point,s=null;if(r&&r.clientX!=null&&r.clientY!=null&&r.pageX!=null&&r.pageY!=null)r.clientX<=0&&r.clientY<=0&&r.target?s=r.target.getBoundingClientRect():(c.x=Math.max(0,r.pageX-pageXOffset),c.y=Math.max(0,r.pageY-pageYOffset));else if(r instanceof n.Point)c=r;else if(r instanceof HTMLElement)s=r.getBoundingClientRect();else if(r&&r.top!=null&&r.left!=null)s=r;else if(r==null)c.x=Math.max(0,(innerWidth-v.width)/2),c.y=Math.max(0,Math.round((innerHeight-v.height)/2*.7));else throw'Invalid ref parameter.';if(w=parseFloat(y.minWidth),s){var k=s.top,d=innerHeight-s.bottom,ft=getComputedStyle(i).direction=='rtl';c.x=ft?Math.max(0,s.right-v.width):Math.max(0,Math.min(s.left,innerWidth-v.width));c.y=u?k>v.height||k>d?Math.max(0,s.top-v.height):s.bottom:d>v.height||d>k?s.bottom:Math.max(0,s.top-v.height);w=Math.max(w,s.width)}if(p=new n.Point(0,0),r!=null&&(h==document.body?p=new n.Point(-pageXOffset,-pageYOffset):h&&(g=h.getBoundingClientRect(),p=new n.Point(g.left-h.scrollLeft,g.top-h.scrollTop))),it={position:r==null?'fixed':'absolute',left:c.x-p.x,top:c.y-p.y,minWidth:w,display:'',visibility:'',zIndex:1500},f&&(i.style.opacity='0',n.animate(function(n){i.style.opacity=n==1?'':n.toString()})),n.setCss(i,it),nt=r instanceof MouseEvent?r.target:r,nt instanceof HTMLElement)for(l=nt.parentElement;l&&l!=document.body;l=l.parentElement)getComputedStyle(l).overflowY=='auto'&&l.scrollHeight>l.offsetHeight&&(b||(b=new n.Control(document.createElement('div'))),b.addEventListener(l,'scroll',function(){t(i,!0);b.dispose()}))}function r(i,r,u){r===void 0&&(r=!0);u===void 0&&(u=!1);u?n.animate(function(n){i.style.opacity=(1-n).toString();n==1&&(t(i,r),i.style.opacity='')}):t(i,r)}function t(n,t){n.style.display='none';t&&n.parentElement&&n.parentElement.removeChild(n)}n.showPopup=i;n.hidePopup=r}(wijmo||(wijmo={})),function(n){'use strict';var t=function(){function t(t){this._copyCss=!0;t!=null&&n.copy(this,t)}return Object.defineProperty(t.prototype,"title",{get:function(){return this._title},set:function(t){this._title=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"copyCss",{get:function(){return this._copyCss},set:function(t){this._copyCss=n.asBoolean(t)},enumerable:!0,configurable:!0}),t.prototype.addCSS=function(n){this._css||(this._css=[]);this._css.push(n)},t.prototype.append=function(t){var i=this._getDocument();n.isString(t)?i.write(t):t instanceof HTMLElement?i.write(t.outerHTML):n.assert(!1,'child should be an HTML element or a string.')},t.prototype.print=function(){var n=this;this._iframe&&(this._close(),setTimeout(function(){var t=n._iframe.contentWindow,i='onafterprint'in t;i&&(t.onafterprint=function(){document.body.removeChild(n._iframe);n._iframe=null});t.focus();t.print();i||(document.body.removeChild(n._iframe),n._iframe=null)},100))},t.prototype._getDocument=function(){if(!this._iframe){this._iframe=document.createElement('iframe');var n=this._iframe.style;n.position='fixed';n.left='10000px';n.top='10000px';document.body.appendChild(this._iframe)}return this._iframe.contentDocument},t.prototype._close=function(){var i=this._getDocument(),r,e,u,o,t,s,f;if(i.close(),this.title&&(r=i.querySelector('title'),r||(r=i.createElement('title'),i.head.appendChild(r)),r.textContent=this.title),this._copyCss){for(e=document.head.querySelectorAll('LINK'),t=0;t<e.length;t++)u=e[t],u.href.match(/\.css$/i)&&u.rel.match(/stylesheet/i)&&(f=n.httpRequest(u.href,{async:!1}),this._addStyle(f.responseText));for(o=document.head.querySelectorAll('STYLE'),t=0;t<o.length;t++)this._addStyle(o[t].textContent)}if(this._css)for(t=0;t<this._css.length;t++)s=i.createElement('style'),f=n.httpRequest(this._css[t],{async:!1}),s.textContent=f.responseText,i.head.appendChild(s)},t.prototype._addStyle=function(n){var t=this._getDocument(),i=t.createElement('style');i.textContent=n;t.head.appendChild(i)},t}();n.PrintDocument=t}(wijmo||(wijmo={})),function(n){'use strict';var i=function(){function i(n,t,i){t===void 0&&(t=null);i===void 0&&(i='_');this._promptChar='_';this._mskArr=[];this._full=!0;this._hbInput=this._input.bind(this);this._hbKeyDown=this._keydown.bind(this);this._hbKeyPress=this._keypress.bind(this);this._hbCompositionStart=this._compositionstart.bind(this);this._hbCompositionEnd=this._compositionend.bind(this);this.mask=t;this.input=n;this.promptChar=i;this._connect(!0)}return Object.defineProperty(i.prototype,"input",{get:function(){return this._tbx},set:function(n){this._connect(!1);this._tbx=n;this._connect(!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"mask",{get:function(){return this._msk},set:function(t){t!=this._msk&&(this._msk=n.asString(t,!0),this._parseMask(),this._valueChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"promptChar",{get:function(){return this._promptChar},set:function(t){t!=this._promptChar&&(this._promptChar=n.asString(t,!1),n.assert(this._promptChar.length==1,'promptChar must be a string with length 1.'),this._valueChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"maskFull",{get:function(){return this._full},enumerable:!0,configurable:!0}),i.prototype.getMaskRange=function(){return this._mskArr.length?[this._firstPos,this._lastPos]:[0,this._tbx.value.length-1]},i.prototype.getRawValue=function(){var t=this._tbx.value,i='',n;if(!this.mask)return t;for(n=0;n<this._mskArr.length&&n<t.length;n++)this._mskArr[n].literal||t[n]==this._promptChar||(i+=t[n]);return i},i.prototype.refresh=function(){this._parseMask();this._valueChanged()},i.prototype._input=function(){var n=this;this._composing||setTimeout(function(){n._valueChanged()})},i.prototype._keydown=function(t){if(t.keyCode==n.Key.Back){var i=this._tbx.selectionStart,r=this._tbx.selectionEnd;if(i<=this._firstPos&&r==i){t.preventDefault();this._backSpace=!1;return}}this._backSpace=t.keyCode==n.Key.Back},i.prototype._keypress=function(n){n.ctrlKey||n.metaKey||n.altKey||this._composing||!this._preventKey(n.charCode)||n.preventDefault()},i.prototype._compositionstart=function(){this._composing=!0},i.prototype._compositionend=function(){var n=this;this._composing=!1;setTimeout(function(){n._valueChanged()})},i.prototype._preventKey=function(t){var r;if(t&&this._mskArr.length){var u=this._tbx,i=u.selectionStart,f=String.fromCharCode(t);if(i<this._firstPos&&(i=this._firstPos,n.setSelectionRange(u,i)),i>=this._mskArr.length)return!0;if(r=this._mskArr[i],r.literal)this._validatePosition(i);else if(r.wildCard!=f&&!this._isCharValid(r.wildCard,f))return!0}return!1},i.prototype._connect=function(n){var t=this._tbx;t&&(n?(this._autoComplete=t.autocomplete,this._spellCheck=t.spellcheck,t.autocomplete='off',t.spellcheck=!1,t.addEventListener('input',this._hbInput),t.addEventListener('keydown',this._hbKeyDown,!0),t.addEventListener('keypress',this._hbKeyPress,!0),t.addEventListener('compositionstart',this._hbCompositionStart,!0),t.addEventListener('compositionend',this._hbCompositionEnd,!0),this._valueChanged()):(t.autocomplete=this._autoComplete,t.spellcheck=this._spellCheck,t.removeEventListener('input',this._hbInput),t.removeEventListener('keydown',this._hbKeyDown,!0),t.removeEventListener('keypress',this._hbKeyPress,!0),t.removeEventListener('compositionstart',this._hbCompositionStart,!0),t.removeEventListener('compositionend',this._hbCompositionEnd,!0)))},i.prototype._valueChanged=function(){var i;if(this._tbx&&this._msk){var t=this._tbx,n=t.selectionStart,r=n>0?t.value[n-1]:'';t.value=this._applyMask();i=n>0?t.value[n-1]:'';n>0&&i==this._promptChar&&r!=this.promptChar&&n--;this._validatePosition(n)}},i.prototype._applyMask=function(){var t,e,r,f,u,n,i;if((this._full=!0,t=this._tbx.value,!this._msk)||!t&&!this._tbx.required)return t;for(e='',r=0,t=this._handleVagueLiterals(t),f=0;f<this._mskArr.length;f++){if(u=this._mskArr[f],n=u.literal,n&&n==t[r]&&r++,u.wildCard){if(n=this._promptChar,t){for(i=r;i<t.length;i++)if(this._isCharValid(u.wildCard,t[i])){n=t[i];switch(u.charCase){case'>':n=n.toUpperCase();break;case'<':n=n.toLowerCase()}break}r=i+1}n==this._promptChar&&(this._full=!1)}e+=n}return e},i.prototype._handleVagueLiterals=function(n){var i,t,f,r,e,u;if(n.length>this._mskArr.length+1)return n;if(i=n.length-this._mskArr.length,i!=0&&n.length>1){for(t=-1,f=Math.max(0,this._tbx.selectionStart-i),r=f;r<this._mskArr.length;r++)if(this._mskArr[r].vague){t=r;break}if(t>-1)if(i<0)e=Array(1-i).join(this._promptChar),u=t+i,u>-1&&(n=n.substr(0,u)+e+n.substr(u));else{while(t>0&&this._mskArr[t-1].literal)t--;n=n.substr(0,t)+n.substr(t+i)}}return n},i.prototype._isCharValid=function(n,t){var r=this._promptChar;switch(n){case'0':return t>='0'&&t<='9'||t==r;case'9':return t>='0'&&t<='9'||t==' '||t==r;case'#':return t>='0'&&t<='9'||t==' '||t=='+'||t=='-'||t==r;case'L':return t>='a'&&t<='z'||t>='A'&&t<='Z'||t==r;case'l':return t>='a'&&t<='z'||t>='A'&&t<='Z'||t==' '||t==r;case'A':return t>='0'&&t<='9'||t>='a'&&t<='z'||t>='A'&&t<='Z'||t==r;case'a':return t>='0'&&t<='9'||t>='a'&&t<='z'||t>='A'&&t<='Z'||t==' '||t==r;case'\uff19':return t>='\uFF10'&&t<='\uff19'||t==r;case'\uff2a':case'\uff27':return n=='\uff27'&&i._X_DBCS_BIG_HIRA.indexOf(t)>-1?!1:t>='\u3041'&&t<='\u3096'||t==r;case'\uff2b':case'\uff2e':return n=='\uff2e'&&i._X_DBCS_BIG_KATA.indexOf(t)>-1?!1:t>='\u30a1'&&t<='\u30fa'||t==r;case'\uff3a':return t<='\u0021'||t>='\u00ff'||t==r;case'H':return t>='\u0021'&&t<='\u00ff'||t==r;case'K':case'N':return n=='N'&&i._X_SBCS_BIG_KATA.indexOf(t)>-1?!1:t>='\uff66'&&t<='\uff9f'||t==r}return!1},i.prototype._validatePosition=function(t){var i=this._mskArr;if(this._backSpace)while(t>0&&t<i.length&&i[t-1].literal)t--;if(t==0||!this._backSpace)while(t<i.length&&i[t].literal)t++;n.getActiveElement()==this._tbx&&n.setSelectionRange(this._tbx,t);this._backSpace=!1},i.prototype._parseMask=function(){var r,o,f,i,e,u,s;for(this._mskArr=[],this._firstPos=-1,this._lastPos=-1,r=this._msk,o='|',i=0;r&&i<r.length;i++)switch(r[i]){case'0':case'9':case'#':case'A':case'a':case'L':case'l':case'\uff19':case'\uff2a':case'\uff27':case'\uff2b':case'\uff2e':case'\uff3a':case'K':case'N':case'H':this._firstPos<0&&(this._firstPos=this._mskArr.length);this._lastPos=this._mskArr.length;this._mskArr.push(new t(r[i],o));break;case'.':case',':case':':case'/':case'$':switch(r[i]){case'.':case',':f=n.culture.Globalize.numberFormat[r[i]];break;case':':case'/':f=n.culture.Globalize.calendar[r[i]];break;case'$':f=n.culture.Globalize.numberFormat.currency.symbol}for(u=0;u<f.length;u++)this._mskArr.push(new t(f[u]));break;case'<':case'>':case'|':o=r[i];break;case'\\':i<r.length-1&&i++;this._mskArr.push(new t(r[i]));break;default:this._mskArr.push(new t(r[i]))}for(i=0;i<this._mskArr.length;i++)if(e=this._mskArr[i],e.literal)for(u=0;u<i;u++)if(s=this._mskArr[u],s.wildCard&&this._isCharValid(s.wildCard,e.literal)){e.vague=!0;break}},i._X_DBCS_BIG_HIRA='\u3041\u3043\u3045\u3047\u3049\u3063\u3083\u3085\u3087\u308e\u3095\u3096',i._X_DBCS_BIG_KATA='\u30a1\u30a3\u30a5\u30a7\u30a9\u30c3\u30e3\u30e5\u30e7\u30ee\u30f5\u30f6',i._X_SBCS_BIG_KATA='\uff67\uff68\uff69\uff6a\uff6b\uff6c\uff6d\uff6e\uff6f',i}(),t;n._MaskProvider=i;t=function(){function n(n,t){t?(this.wildCard=n,this.charCase=t):this.literal=n}return n}();n._MaskElement=t}(wijmo||(wijmo={})),function(n){'use strict';function u(){return r}function f(){return i}var r=navigator.userAgent.match(/MSIE |Trident\/|Edge\//)!=null,i,t;n.isIE=u;n.isIE9=f;document.doctype&&navigator.appVersion.indexOf('MSIE 9')>-1&&(i=!0,document.addEventListener('mousemove',function(n){if(n.which==1)for(var t=n.target;t;t=t.parentNode)if(t.attributes&&t.attributes.draggable)return t.dragDrop(),!1}));window.requestAnimationFrame||(t=0,window.requestAnimationFrame=function(n){var i=Date.now(),r=16-(i-t),u=r>0?r:0;return t=i+u,setTimeout(function(){n(t)},u)},window.cancelAnimationFrame=clearTimeout)}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var __extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},wijmo;(function(n){var t;(function(t){'use strict';var i=function(t){function i(i){var r=this,o,u,f,e;t.call(this,i,null,!0);this._showBtn=!0;this._autoExpand=!0;this.textChanged=new n.Event;this.isDroppedDownChanging=new n.Event;this.isDroppedDownChanged=new n.Event;o=this.getTemplate();this.applyTemplate('wj-control wj-dropdown wj-content',o,{_tbx:'input',_btn:'btn',_dropDown:'dropdown'},'input');this._elRef=this._tbx;this._createDropDown();this._updateBtn();u=this._dropDown;u&&u.parentElement&&u.parentElement.removeChild(u);f=this._updateFocusState.bind(this);this.addEventListener(this.dropDown,'blur',f,!0);this.addEventListener(this.dropDown,'focus',f);e=this._keydown.bind(this);this.addEventListener(this.hostElement,'keydown',e);this.addEventListener(this.dropDown,'keydown',e);this.addEventListener(this._tbx,'keypress',function(n){n.keyCode==9787&&r._altDown&&n.preventDefault()});this.addEventListener(this._tbx,'input',function(){r._setText(r.text,!1)});this.addEventListener(this._tbx,'click',function(){r._autoExpand&&r._expandSelection()});n.isIE9()&&this.addEventListener(this._tbx,'keyup',function(){r._setText(r.text,!1)});this.addEventListener(this._btn,'click',this._btnclick.bind(this));this.addEventListener(this._dropDown,'click',function(n){n.stopPropagation()})}return __extends(i,t),Object.defineProperty(i.prototype,"text",{get:function(){return this._tbx.value},set:function(n){n!=this.text&&this._setText(n,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"inputElement",{get:function(){return this._tbx},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isReadOnly",{get:function(){return this._tbx.readOnly},set:function(t){this._tbx.readOnly=n.asBoolean(t);n.toggleClass(this.hostElement,'wj-state-readonly',this.isReadOnly)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isRequired",{get:function(){return this._tbx.required},set:function(t){this._tbx.required=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"required",{get:function(){return n._deprecated('required','isRequired'),this.isRequired},set:function(t){n._deprecated('required','isRequired');this.isRequired=t},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"placeholder",{get:function(){return this._tbx.placeholder},set:function(n){this._tbx.placeholder=n},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isDroppedDown",{get:function(){return this._dropDown.style.display!='none'},set:function(t){if(t=n.asBoolean(t)&&!this.isDisabled&&!this.isReadOnly,t!=this.isDroppedDown&&this.onIsDroppedDownChanging(new n.CancelEventArgs)){var i=this._dropDown;t?(i.style.minWidth||(i.style.minWidth=this.hostElement.getBoundingClientRect().width+'px'),i.style.display='block',this._updateDropDown()):(this.containsFocus()&&(this.isTouching&&this.showDropDownButton?this.focus():this.selectAll()),n.hidePopup(i));this._updateFocusState();this.onIsDroppedDownChanged()}},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"dropDown",{get:function(){return this._dropDown},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"dropDownCssClass",{get:function(){return this._cssClass},set:function(t){t!=this._cssClass&&(n.removeClass(this._dropDown,this._cssClass),this._cssClass=n.asString(t),n.addClass(this._dropDown,this._cssClass))},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"showDropDownButton",{get:function(){return this._showBtn},set:function(t){this._showBtn=n.asBoolean(t);this._updateBtn()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"autoExpandSelection",{get:function(){return this._autoExpand},set:function(t){this._autoExpand=n.asBoolean(t)},enumerable:!0,configurable:!0}),i.prototype.selectAll=function(){this._elRef==this._tbx&&n.setSelectionRange(this._tbx,0,this.text.length)},i.prototype.onTextChanged=function(n){this._updateState();this.textChanged.raise(this,n)},i.prototype.onIsDroppedDownChanging=function(n){return this.isDroppedDownChanging.raise(this,n),!n.cancel},i.prototype.onIsDroppedDownChanged=function(t){var i=this;this.removeEventListener(document,'mousedown');this.removeEventListener(document,'keydown');this.isDroppedDown&&!this.containsFocus()&&(this.addEventListener(document,'mousedown',function(t){n.contains(i.dropDown,t.target)||n.contains(i.hostElement,t.target)||(i.isDroppedDown=!1)}),this.addEventListener(document,'keydown',function(){i.containsFocus()||(i.isDroppedDown=!1)}));this.isDroppedDownChanged.raise(this,t)},i.prototype.onGotFocus=function(n){this.isTouching||this.selectAll();t.prototype.onGotFocus.call(this,n)},i.prototype.onLostFocus=function(n){this._commitText();this.containsFocus()||(this.isDroppedDown=!1);t.prototype.onLostFocus.call(this,n)},i.prototype.containsFocus=function(){return t.prototype.containsFocus.call(this)||n.contains(this._dropDown,n.getActiveElement())},i.prototype.dispose=function(){this.isDroppedDown=!1;t.prototype.dispose.call(this)},i.prototype.refresh=function(i){if(i===void 0&&(i=!0),t.prototype.refresh.call(this,i),this.isDroppedDown&&getComputedStyle(this.hostElement).display!='none'){var r=n.getActiveElement();n.showPopup(this._dropDown,this.hostElement,!1,!1,this.dropDownCssClass==null);r instanceof HTMLElement&&r!=n.getActiveElement()&&r.focus()}},i.prototype._handleResize=function(){this.isDroppedDown&&this.refresh()},i.prototype._expandSelection=function(){var r=this._tbx,i=r.value,n=r.selectionStart,t=r.selectionEnd,u;if(i&&n==t&&(u=this._getCharType(i,n),u>-1)){for(;t<i.length;t++)if(this._getCharType(i,t)!=u)break;for(;n>0;n--)if(this._getCharType(i,n-1)!=u)break;n!=t&&r.setSelectionRange(n,t)}},i.prototype._getCharType=function(n,t){var i=n[t];return i>='0'&&i<='9'?0:i>='a'&&i<='z'||i>='A'&&i<='Z'?1:-1},i.prototype._keydown=function(t){if(!t.defaultPrevented){this._altDown=t.altKey;switch(t.keyCode){case n.Key.Tab:case n.Key.Escape:case n.Key.Enter:this.isDroppedDown&&(this.isDroppedDown=!1,t.keyCode==n.Key.Tab||this.containsFocus()||this.focus(),t.preventDefault());break;case n.Key.F4:case n.Key.Down:case n.Key.Up:(t.keyCode==n.Key.F4||t.altKey)&&n.contains(document.body,this.hostElement)&&(this.isDroppedDown=!this.isDroppedDown,this.isDroppedDown||this.focus(),t.preventDefault())}}},i.prototype._btnclick=function(){this.isDroppedDown=!this.isDroppedDown},i.prototype._setText=function(n){n==null&&(n='');n=n.toString();n!=this._tbx.value&&(this._tbx.value=n);n!=this._oldText&&(this._oldText=n,this.onTextChanged())},i.prototype._updateBtn=function(){this._btn.tabIndex=-1;this._btn.style.display=this._showBtn?'':'none'},i.prototype._createDropDown=function(){},i.prototype._commitText=function(){},i.prototype._updateDropDown=function(){this.isDroppedDown&&(this._commitText(),n.showPopup(this._dropDown,this.hostElement,!1,!1,this.dropDownCssClass==null))},i.controlTemplate='<div style="position:relative" class="wj-template"><div class="wj-input"><div class="wj-input-group wj-input-btn-visible"><input wj-part="input" type="text" class="wj-form-control" /><span wj-part="btn" class="wj-input-group-btn" tabindex="-1"><button class="wj-btn wj-btn-default" type="button" tabindex="-1"><span class="wj-glyph-down"><\/span><\/button><\/span><\/div><\/div><div wj-part="dropdown" class="wj-content wj-dropdown-panel" style="display:none;position:absolute;z-index:100"><\/div><\/div>',i}(n.Control);t.DropDown=i})(t=n.input||(n.input={}))})(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';(function(n){n[n.None=0]="None";n[n.Day=1]="Day";n[n.Month=2]="Month"})(t.DateSelectionMode||(t.DateSelectionMode={}));var i=t.DateSelectionMode,r=function(r){function u(t,u){r.call(this,t);this._readOnly=!1;this._selMode=i.Day;this.valueChanged=new n.Event;this.displayMonthChanged=new n.Event;this.formatItem=new n.Event;this._value=n.DateTime.newDate();this._currMonth=this._getMonth(this._value);this._createChildren();this.refresh(!0);this.addEventListener(this.hostElement,'mouseup',this._click.bind(this));this.addEventListener(this.hostElement,'keydown',this._keydown.bind(this));this.initialize(u)}return __extends(u,r),Object.defineProperty(u.prototype,"value",{get:function(){return this._value},set:function(t){t=n.asDate(t,!0);t=this._clamp(t);this._valid(t)&&(this.displayMonth=this._getMonth(t),n.DateTime.equals(this._value,t)||(this._value=t,this.invalidate(!1),this.onValueChanged()))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"min",{get:function(){return this._min},set:function(t){t!=this.min&&(this._min=n.asDate(t,!0),this.refresh())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"max",{get:function(){return this._max},set:function(t){t!=this.max&&(this._max=n.asDate(t,!0),this.refresh())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"selectionMode",{get:function(){return this._selMode},set:function(t){var r,u;t!=this._selMode&&(this._selMode=n.asEnum(t,i),r=this._monthMode(),r&&(this.monthView=!1),u=this._btnMth.querySelector('.wj-glyph-down'),u&&(u.style.display=r?'none':''))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"isReadOnly",{get:function(){return this._readOnly},set:function(t){this._readOnly=n.asBoolean(t);n.toggleClass(this.hostElement,'wj-state-readonly',this.isReadOnly)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"firstDayOfWeek",{get:function(){return this._fdw},set:function(t){if(t!=this._fdw){if(t=n.asNumber(t,!0),t&&(t>6||t<0))throw'firstDayOfWeek must be between 0 and 6 (Sunday to Saturday).';this._fdw=t;this.refresh()}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"displayMonth",{get:function(){return this._currMonth},set:function(t){if(!n.DateTime.equals(this.displayMonth,t)){t=n.asDate(t);var i=this.monthView?this._monthInValidRange(t):this._yearInValidRange(t);i&&(this._currMonth=this._getMonth(this._clamp(t)),this.invalidate(!0),this.onDisplayMonthChanged())}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showHeader",{get:function(){return this._tbHdr.style.display!='none'},set:function(t){this._tbHdr.style.display=n.asBoolean(t)?'':'none'},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"monthView",{get:function(){return this._tbMth.style.display!='none'},set:function(n){n!=this.monthView&&(this._tbMth.style.display=n?'':'none',this._tbYr.style.display=n?'none':'')},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"itemFormatter",{get:function(){return this._itemFormatter},set:function(t){t!=this._itemFormatter&&(this._itemFormatter=n.asFunction(t),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"itemValidator",{get:function(){return this._itemValidator},set:function(t){t!=this._itemValidator&&(this._itemValidator=n.asFunction(t),this.invalidate())},enumerable:!0,configurable:!0}),u.prototype.onValueChanged=function(n){this.valueChanged.raise(this,n)},u.prototype.onDisplayMonthChanged=function(n){this.displayMonthChanged.raise(this,n)},u.prototype.onFormatItem=function(n){this.formatItem.raise(this,n)},u.prototype.refresh=function(i){var o,e,u,s,l,c,a,h,f;for(i===void 0&&(i=!0),s=this.displayMonth,l=this.firstDayOfWeek!=null?this.firstDayOfWeek:n.Globalize.getFirstDayOfWeek(),r.prototype.refresh.call(this,i),this._firstDay=n.DateTime.addDays(s,-(s.getDay()-l+7)%7),n.setText(this._spMth,n.Globalize.format(s,'y')),o=this._tbMth.querySelectorAll('td'),f=0;f<7&&f<o.length;f++)u=n.DateTime.addDays(this._firstDay,f),n.setText(o[f],n.Globalize.format(u,'ddd'));for(f=7;f<o.length;f++)if(e=o[f],u=n.DateTime.addDays(this._firstDay,f-7),n.setText(e,u.getDate().toString()),e.className='',c=!this._valid(u),n.toggleClass(e,'wj-state-invalid',c),n.toggleClass(e,'wj-state-selected',n.DateTime.sameDate(u,this.value)),n.toggleClass(e,'wj-day-today',n.DateTime.sameDate(u,new Date)),n.toggleClass(e,'wj-day-othermonth',c||u.getMonth()!=s.getMonth()||!this._inValidRange(u)),this.itemFormatter&&this.itemFormatter(u,e),this.formatItem.hasHandlers){a=new t.FormatItemEventArgs(f,u,e);this.onFormatItem(a)}for(h=this._tbMth.querySelectorAll('tr'),h.length&&(u=n.DateTime.addDays(this._firstDay,28),h[h.length-2].style.display=u.getMonth()==s.getMonth()?'':'none',u=n.DateTime.addDays(this._firstDay,35),h[h.length-1].style.display=u.getMonth()==s.getMonth()?'':'none'),o=this._tbYr.querySelectorAll('td'),o.length&&n.setText(o[0],s.getFullYear().toString()),f=1;f<o.length;f++)e=o[f],u=new Date(s.getFullYear(),f-1,1),n.setText(e,n.Globalize.format(u,'MMM')),e.className='',n.toggleClass(e,'wj-state-disabled',!this._monthInValidRange(u)),n.toggleClass(e,'wj-state-selected',this._sameMonth(u,this.value))},u.prototype._canChangeValue=function(){return!this._readOnly&&this._selMode!=i.None},u.prototype._valid=function(n){return this.itemValidator&&n?this.itemValidator(n):!0},u.prototype._inValidRange=function(t){return this.min&&t<n.DateTime.fromDateTime(this.min,t)?!1:this.max&&t>n.DateTime.fromDateTime(this.max,t)?!1:!0},u.prototype._monthInValidRange=function(t){var i=t.getFullYear(),r=t.getMonth(),u=new Date(i,r,1),f=n.DateTime.addDays(new Date(i,r+1),-1);return this._inValidRange(u)||this._inValidRange(f)},u.prototype._yearInValidRange=function(t){var i=t.getFullYear(),r=new Date(i,0),u=n.DateTime.addDays(new Date(i+1,0),-1);return this._inValidRange(r)||this._inValidRange(u)},u.prototype._sameMonth=function(t,i){return n.isDate(t)&&n.isDate(i)&&t.getMonth()==i.getMonth()&&t.getFullYear()==i.getFullYear()},u.prototype._clamp=function(t){var i,r;return t&&(this.min&&(i=n.DateTime.fromDateTime(this.min,t),t<i&&(t=i)),this.max&&(r=n.DateTime.fromDateTime(this.max,t),t>r&&(t=r))),t},u.prototype._createChildren=function(){var f=this.getTemplate(),n,i,t,r,u;for(this.applyTemplate('wj-control wj-calendar',f,{_tbHdr:'tbl-header',_btnMth:'btn-month',_spMth:'span-month',_btnPrv:'btn-prev',_btnTdy:'btn-today',_btnNxt:'btn-next',_tbMth:'tbl-month',_tbYr:'tbl-year'}),n=this._createElement('tr',this._tbMth,'wj-header'),t=0;t<7;t++)this._createElement('td',n);for(i=0;i<6;i++)for(n=this._createElement('tr',this._tbMth),t=0;t<7;t++)this._createElement('td',n);for(n=this._createElement('tr',this._tbYr,'wj-header'),this._createElement('td',n).setAttribute('colspan','4'),r=0;r<3;r++)for(n=this._createElement('tr',this._tbYr),u=0;u<4;u++)this._createElement('td',n)},u.prototype._createElement=function(t,i,r){var u=document.createElement(t);return i&&i.appendChild(u),r&&n.addClass(u,r),u},u.prototype._click=function(t){var r=!1,i=t.target,f,u;n.contains(this._btnMth,i)&&!this._monthMode()?(this.monthView=!this.monthView,r=!0):n.contains(this._btnPrv,i)?(this._navigate(-1),r=!0):n.contains(this._btnNxt,i)?(this._navigate(1),r=!0):n.contains(this._btnTdy,i)&&(this._navigate(0),r=!0);i&&!r&&(i=n.closest(i,'TD'),i&&(this.monthView?(f=this._getCellIndex(this._tbMth,i),f>6&&this._canChangeValue()&&(u=n.DateTime.fromDateTime(n.DateTime.addDays(this._firstDay,f-7),this.value),this._inValidRange(u)&&this._valid(u)&&(this.value=u),r=!0)):(f=this._getCellIndex(this._tbYr,i),f>0&&(this.displayMonth=new Date(this.displayMonth.getFullYear(),f-1,1),this._monthMode()?this._canChangeValue()&&(u=n.DateTime.fromDateTime(this.displayMonth,this.value),this._inValidRange(u)&&(this.value=u)):this.monthView=!0,r=!0))));r&&(t.preventDefault(),this.focus())},u.prototype._getCellIndex=function(n,t){for(var r=n.querySelectorAll('TD'),i=0;i<r.length;i++)if(r[i]==t)return i;return-1},u.prototype._keydown=function(t){var u;if(!t.defaultPrevented&&!t.ctrlKey&&!t.shiftKey&&!t.altKey&&!t.metaKey){var r=0,i=0,f=!0;if(this.monthView)switch(t.keyCode){case n.Key.Left:r=-1;break;case n.Key.Right:r=1;break;case n.Key.Up:r=-7;break;case n.Key.Down:r=7;break;case n.Key.PageDown:i=1;break;case n.Key.PageUp:i=-1;break;default:f=!1}else switch(t.keyCode){case n.Key.Left:i=-1;break;case n.Key.Right:i=1;break;case n.Key.Up:i=-4;break;case n.Key.Down:i=4;break;case n.Key.PageDown:i=12;break;case n.Key.PageUp:i=-12;break;case n.Key.Enter:this._monthMode()?f=!1:this.monthView=!0;break;default:f=!1}this.value&&this._canChangeValue()&&(r||i)&&(u=this.value,u=n.DateTime.addDays(u,r),u=n.DateTime.addMonths(u,i),this.value=n.DateTime.fromDateTime(u,this.value));f&&t.preventDefault()}},u.prototype._getMonth=function(n){return n||(n=new Date),new Date(n.getFullYear(),n.getMonth(),1)},u.prototype._monthMode=function(){return this.selectionMode==i.Month},u.prototype._navigate=function(t){var r=this.monthView,i;switch(t){case 0:i=new Date;r?this._canChangeValue()&&(this.value=n.DateTime.fromDateTime(i,this.value)):this._canChangeValue()&&(this.value=this._getMonth(i));this.displayMonth=this._getMonth(i);break;case 1:this.displayMonth=n.DateTime.addMonths(this.displayMonth,r?1:12);break;case-1:this.displayMonth=n.DateTime.addMonths(this.displayMonth,r?-1:-12)}},u.controlTemplate='<div class="wj-calendar-outer wj-content"><div wj-part="tbl-header" class="wj-calendar-header"><div wj-part="btn-month" class="wj-month-select"><span wj-part="span-month"><\/span> <span class="wj-glyph-down"><\/span><\/div><div class="wj-btn-group"><button type="button" wj-part="btn-prev" class="wj-btn wj-btn-default"><span class="wj-glyph-left"><\/span><\/button><button type="button" wj-part="btn-today" class="wj-btn wj-btn-default"><span class="wj-glyph-circle"><\/span><\/button><button type="button" wj-part="btn-next" class="wj-btn wj-btn-default"><span class="wj-glyph-right"><\/span><\/button><\/div><\/div><table wj-part="tbl-month" class="wj-calendar-month"/><table wj-part="tbl-year" class="wj-calendar-year" style="display:none"/><\/div>',u}(n.Control);t.Calendar=r})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(t){function i(r,u){var e=this,f,o,s;t.call(this,r);this._hsb=[.5,1,1];this._alpha=1;this.valueChanged=new n.Event;f=this.getTemplate();this.applyTemplate('wj-control wj-colorpicker wj-content',f,{_eSB:'div-sb',_eHue:'div-hue',_eAlpha:'div-alpha',_ePreview:'div-pv',_ePal:'div-pal',_eText:'div-text'});this._palette='#FFF,#000, #F00,#FFC000,#FFFF00,#92D050,#00B050,#00B0F0,#0070C0,#7030A0'.split(',');this._updatePalette();this._eHue.style.backgroundImage='url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAD4CAIAAACi6hsPAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuM4zml1AAAAGvSURBVDhPXdBPaM9xHMfxz4pWaxcmtoOhpdXSVpiyHWxqmVpDjaU5rK34XfypjTJ/p+ZPay6jhsOsRrKwaJElf9IQq03WIkv4FeMwMq221tfje1ByeFzfvd7PEKWGEKWTQRZLySWfVRRTQjmVbKWGOhLsZT+HaeY0bbTTQSfdXOcWffTzmAFeMcwoYyT5ygS/mA5hNgphip98J8kHRnnNSwZ4yH1uc4OrdHGR87RximYO0cgedlLLdqqoYAPrWMtKVrCcJSxiPmnMJUQp/Bsyk2xyyKOAQooopYwKtlDNDur5G7SBJo7RQiv/B+2hl3s84CkvGGKEOOYnxolj/mYmhBmDJ5ngCx95xxsGecYj4pB3iENeoZMO2mmlhaMcpIE4ZII6aqhmM3HMMkooopB88sghm0wySCeVlCjMCVFIYx4LWUwOeRSwhmLWU84mqqihll3sppEmjnOSs5zjEl1c4yZ99POE5wwxwns+840fTDFLFKaZZIJxkozxlmEGGSC+GF++Sy89dHOZC8Rr4lVnOMERDrCPBPXEX22jko2UEn+/mnxyWUYWC0gnNUQh/AEc0HJs6cex0gAAAABJRU5ErkJggg==)';this._eHue.style.backgroundSize='contain';navigator.appVersion.indexOf('MSIE 9')>-1&&(this._eSB.children[0].style.filter='progid:DXImageTransform.Microsoft.gradient(startColorstr=#ffffffff,endColorstr=#00ffffff,GradientType=1)',this._eSB.children[1].style.filter='progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000,endColorstr=#ff000000,GradientType=0)');f=i._tplCursor;this._cSB=n.createElement(f);this._cHue=n.createElement(f);this._cHue.style.width='100%';this._cAlpha=n.createElement(f);this._cAlpha.style.height='100%';this._eSB.appendChild(this._cSB);this._eHue.appendChild(this._cHue);this._eAlpha.appendChild(this._cAlpha);this.addEventListener(this.hostElement,'mousedown',function(n){document.addEventListener('mousemove',o);document.addEventListener('mouseup',s);e._mouseDown(n)});o=function(n){e._mouseMove(n)};s=function(n){document.removeEventListener('mousemove',o);document.removeEventListener('mouseup',s);e._mouseUp(n)};this.addEventListener(this.hostElement,'click',function(t){var i=t.target,r;i&&i.tagName=='DIV'&&n.contains(e._ePal,i)&&(r=i.style.backgroundColor,r&&(e.value=new n.Color(r).toString()))});this.value='#ffffff';this.initialize(u);this._updatePanels()}return __extends(i,t),Object.defineProperty(i.prototype,"showAlphaChannel",{get:function(){return this._eAlpha.parentElement.style.display!='none'},set:function(t){this._eAlpha.parentElement.style.display=n.asBoolean(t)?'':'none'},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"showColorString",{get:function(){return this._eText.style.display!='none'},set:function(t){this._eText.style.display=n.asBoolean(t)?'':'none'},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"value",{get:function(){return this._value},set:function(t){if(t!=this.value){this._value=n.asString(t);this._eText.innerText=this._value;var r=new n.Color(this._value),i=r.getHsb();(this._hsb[0]!=i[0]||this._hsb[1]!=i[1]||this._hsb[2]!=i[2]||this._alpha!=r.a)&&(i[2]==0?(i[0]=this._hsb[0],i[1]=this._hsb[1]):i[1]==0&&(i[0]=this._hsb[0]),this._hsb=i,this._alpha=r.a,this.onValueChanged())}},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"palette",{get:function(){return this._palette},set:function(t){var i,r;for(t=n.asArray(t),i=0;i<t.length&&i<this._palette.length;i++)r=n.asString(t[i]),this._palette[i]=r;this._updatePalette()},enumerable:!0,configurable:!0}),i.prototype.onValueChanged=function(n){this._updatePanels();this.valueChanged.raise(this,n)},i.prototype._mouseDown=function(n){this._htDown=this._getTargetPanel(n);this._htDown&&(n.preventDefault(),this.focus(),this._mouseMove(n))},i.prototype._mouseMove=function(t){if(this._htDown){var i=this._htDown.getBoundingClientRect();this._htDown==this._eHue?(this._hsb[0]=n.clamp((t.clientY-i.top)/i.height,0,.99),this._updateColor()):this._htDown==this._eSB?(this._hsb[1]=n.clamp((t.clientX-i.left)/i.width,0,1),this._hsb[2]=n.clamp(1-(t.clientY-i.top)/i.height,0,1),this._updateColor()):this._htDown==this._eAlpha&&(this._alpha=n.clamp((t.clientX-i.left)/i.width,0,1),this._updateColor())}},i.prototype._mouseUp=function(){this._htDown=null},i.prototype._updateColor=function(){var t=n.Color.fromHsb(this._hsb[0],this._hsb[1],this._hsb[2],this._alpha);this.value=t.toString();this._updatePanels()},i.prototype._updatePalette=function(){var o=new n.Color('#fff'),s=new n.Color('#000'),r,t,e;for(this._ePal.innerHTML='',r=0;r<this._palette.length;r++){var u=n.createElement('<div style="float:left;width:10%;box-sizing:border-box;padding:1px">'),i=new n.Color(this._palette[r]),f=i.getHsb();for(u.appendChild(this._makePalEntry(i,4)),t=0;t<5;t++)f[1]==0?(e=t*.1+(f[2]>.5?.05:.55),i=n.Color.interpolate(o,s,e)):i=n.Color.fromHsb(f[0],.1+t*.2,1-t*.1),u.appendChild(this._makePalEntry(i,0));this._ePal.appendChild(u)}},i.prototype._makePalEntry=function(t,i){var r=document.createElement('div');return n.setCss(r,{cursor:'pointer',backgroundColor:t.toString(),marginBottom:i?i:''}),r.innerHTML='&nbsp',r},i.prototype._updatePanels=function(){var i=n.Color.fromHsb(this._hsb[0],1,1,1),t=n.Color.fromHsb(this._hsb[0],this._hsb[1],this._hsb[2],1);this._eSB.style.backgroundColor=i.toString();this._eAlpha.style.background='linear-gradient(to right, transparent 0%, '+t.toString()+' 100%)';navigator.appVersion.indexOf('MSIE 9')>-1&&(this._eAlpha.style.filter='progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000,endColorstr='+t.toString()+', GradientType = 1)');this._ePreview.style.backgroundColor=this.value;this._cHue.style.top=(this._hsb[0]*100).toFixed(0)+'%';this._cSB.style.left=(this._hsb[1]*100).toFixed(0)+'%';this._cSB.style.top=(100-this._hsb[2]*100).toFixed(0)+'%';this._cAlpha.style.left=(this._alpha*100).toFixed(0)+'%'},i.prototype._getTargetPanel=function(t){var i=t.target;return n.contains(this._eSB,i)?this._eSB:n.contains(this._eHue,i)?this._eHue:n.contains(this._eAlpha,i)?this._eAlpha:null},i.controlTemplate='<div style="position:relative;width:100%;height:100%"><div style="float:left;width:50%;height:100%;box-sizing:border-box;padding:2px"><div wj-part="div-pal"><div style="float:left;width:10%;box-sizing:border-box;padding:2px"><div style="background-color:black;width:100%">&nbsp;<\/div><div style="height:6px"><\/div><\/div><\/div><div wj-part="div-text" style="position:absolute;bottom:0px;display:none"><\/div><\/div><div style="float:left;width:50%;height:100%;box-sizing:border-box;padding:2px"><div wj-part="div-sb" class="wj-colorbox" style="float:left;width:89%;height:89%"><div style="position:absolute;width:100%;height:100%;background:linear-gradient(to right, white 0%,transparent 100%)"><\/div><div style="position:absolute;width:100%;height:100%;background:linear-gradient(to top, black 0%,transparent 100%)"><\/div><\/div><div style="float:left;width:1%;height:89%"><\/div><div style="float:left;width:10%;height:89%"><div wj-part="div-hue" class="wj-colorbox"><\/div><\/div><div style="float:left;width:89%;height:1%"><\/div><div style="float:left;width:89%;height:10%"><div style="width:100%;height:100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAIAAABLbSncAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuM4zml1AAAAAcSURBVBhXY/iPBBYgAWpKQGkwgMqDAdUk/v8HAM7Mm6GatDUYAAAAAElFTkSuQmCC)"><div wj-part="div-alpha" class="wj-colorbox"><\/div><\/div><\/div><div style="float:left;width:1%;height:10%"><\/div><div style="float:left;width:10%;height:10%"><div wj-part="div-pv" class="wj-colorbox" style="position:static"><\/div><\/div><\/div><\/div>',i._tplCursor='<div style="position:absolute;left:50%;top:50%;width:7px;height:7px;transform:translate(-50%,-50%);border:2px solid #f0f0f0;border-radius:50px;box-shadow:0px 0px 4px 2px #0f0f0f"></div>',i}(n.Control);t.ColorPicker=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var r=function(t){function r(i,r){t.call(this,i);this._pathDisplay=new n.Binding(null);this._pathValue=new n.Binding(null);this._pathChecked=new n.Binding(null);this._html=!1;this._checkedItems=[];this._search='';this.selectedIndexChanged=new n.Event;this.itemsChanged=new n.Event;this.loadingItems=new n.Event;this.loadedItems=new n.Event;this.itemChecked=new n.Event;this.checkedItemsChanged=new n.Event;this.formatItem=new n.Event;this.applyTemplate('wj-control wj-listbox wj-content',null,null);this._orgTag=='SELECT'&&this._populateSelectElement(this.hostElement);var u=this.hostElement;this.addEventListener(u,'click',this._click.bind(this));this.addEventListener(u,'keydown',this._keydown.bind(this));this.addEventListener(u,'keypress',this._keypress.bind(this));this.addEventListener(u,'wheel',function(n){u.scrollHeight>u.offsetHeight&&(n.deltaY<0&&u.scrollTop==0||n.deltaY>0&&u.scrollTop+u.offsetHeight>=u.scrollHeight)&&(n.preventDefault(),n.stopPropagation())});this.initialize(r)}return __extends(r,t),r.prototype.refresh=function(){t.prototype.refresh.call(this);(this.displayMemberPath||!this.checkedMemberPath)&&this._populateList()},Object.defineProperty(r.prototype,"itemsSource",{get:function(){return this._items},set:function(t){this._items!=t&&(this._cv&&(this._cv.currentChanged.removeHandler(this._cvCurrentChanged,this),this._cv.collectionChanged.removeHandler(this._cvCollectionChanged,this),this._cv=null),this._items=t,this._cv=n.asCollectionView(t),this._cv!=null&&(this._cv.currentChanged.addHandler(this._cvCurrentChanged,this),this._cv.collectionChanged.addHandler(this._cvCollectionChanged,this)),this._populateList(),this.onItemsChanged(),this.onSelectedIndexChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"collectionView",{get:function(){return this._cv},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isContentHtml",{get:function(){return this._html},set:function(t){t!=this._html&&(this._html=n.asBoolean(t),this._populateList())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemFormatter",{get:function(){return this._itemFormatter},set:function(t){t!=this._itemFormatter&&(this._itemFormatter=n.asFunction(t),this._populateList())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"displayMemberPath",{get:function(){return this._pathDisplay.path},set:function(t){t!=this.displayMemberPath&&(this._pathDisplay.path=n.asString(t),this._populateList())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedValuePath",{get:function(){return this._pathValue.path},set:function(t){this._pathValue.path=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"checkedMemberPath",{get:function(){return this._pathChecked.path},set:function(t){t!=this.checkedMemberPath&&(this._pathChecked.path=n.asString(t),this._populateList())},enumerable:!0,configurable:!0}),r.prototype.getDisplayValue=function(t){var i=null,r;return t>-1&&n.hasItems(this._cv)&&(i=this._cv.items[t],this.displayMemberPath&&(i=this._pathDisplay.getValue(i))),r=i!=null?i.toString():'',this.itemFormatter&&(r=this.itemFormatter(t,r)),r},r.prototype.getDisplayText=function(n){var t=this.hostElement.children,i=n>-1&&n<t.length?t[n]:null;return i!=null?i.textContent:''},Object.defineProperty(r.prototype,"selectedIndex",{get:function(){return this._cv?this._cv.currentPosition:-1},set:function(t){this._cv&&this._cv.moveCurrentToPosition(n.asNumber(t))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedItem",{get:function(){return this._cv?this._cv.currentItem:null},set:function(n){this._cv&&this._cv.moveCurrentTo(n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedValue",{get:function(){var n=this.selectedItem;return n&&this.selectedValuePath&&(n=this._pathValue.getValue(n)),n},set:function(n){var r=this.selectedValuePath,u=-1,t,i;if(this._cv){for(t=0;t<this._cv.items.length;t++)if(i=this._cv.items[t],r&&this._pathValue.getValue(i)==n||!r&&i==n){u=t;break}this.selectedIndex=u}},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"maxHeight",{get:function(){var n=this.hostElement;return n?parseFloat(n.style.maxHeight):null},set:function(t){var i=this.hostElement;i&&(i.style.maxHeight=n.asNumber(t)+'px')},enumerable:!0,configurable:!0}),r.prototype.showSelection=function(){for(var u,f,i=this.selectedIndex,o=this.hostElement,r=o.children,t,e=0;e<r.length;e++)t=r[e],n.toggleClass(t,'wj-state-selected',e==i);i>-1&&i<r.length&&(t=r[i],u=t.getBoundingClientRect(),f=this.hostElement.getBoundingClientRect(),u.bottom>f.bottom?o.scrollTop+=u.bottom-f.bottom:u.top<f.top&&(o.scrollTop-=f.top-u.top));i>-1&&this.containsFocus()&&(t=r[i],t instanceof HTMLElement&&!n.contains(t,n.getActiveElement())&&t.focus())},r.prototype.getItemChecked=function(t){var r=this._cv.items[t],i;return n.isObject(r)&&this.checkedMemberPath?this._pathChecked.getValue(r):(i=this._getCheckbox(t),i?i.checked:!1)},r.prototype.setItemChecked=function(n,t){this._setItemChecked(n,t,!0)},r.prototype.toggleItemChecked=function(n){this.setItemChecked(n,!this.getItemChecked(n))},Object.defineProperty(r.prototype,"checkedItems",{get:function(){if(this._checkedItems.splice(0,this._checkedItems.length),this._cv)for(var n=0;n<this._cv.items.length;n++)this.getItemChecked(n)&&this._checkedItems.push(this._cv.items[n]);return this._checkedItems},set:function(t){var i=this._cv,u=n.asArray(t,!1),f,r,e;if(i&&u){for(f=i.currentPosition,r=0;r<i.items.length;r++)e=i.items[r],this._setItemChecked(r,u.indexOf(e)>-1,!1);i.moveCurrentToPosition(f);this.onCheckedItemsChanged()}},enumerable:!0,configurable:!0}),r.prototype.onSelectedIndexChanged=function(n){this.selectedIndexChanged.raise(this,n)},r.prototype.onItemsChanged=function(n){this.itemsChanged.raise(this,n)},r.prototype.onLoadingItems=function(n){this.loadingItems.raise(this,n)},r.prototype.onLoadedItems=function(n){this.loadedItems.raise(this,n)},r.prototype.onItemChecked=function(n){this.itemChecked.raise(this,n)},r.prototype.onCheckedItemsChanged=function(n){this.checkedItemsChanged.raise(this,n)},r.prototype.onFormatItem=function(n){this.formatItem.raise(this,n)},r.prototype._setItemChecked=function(t,i,r){var u,f,e;r===void 0&&(r=!0);u=this._cv.items[t];n.isObject(u)&&(f=n.tryCast(this._cv,'IEditableCollectionView'),this._pathChecked.getValue(u)!=i&&(this._checking=!0,f?(f.editItem(u),this._pathChecked.setValue(u,i),f.commitEdit()):(this._pathChecked.setValue(u,i),this._cv.refresh()),this._checking=!1));e=this._getCheckbox(t);e&&e.checked!=i&&(e.checked=i);r&&(this.onItemChecked(),this.onCheckedItemsChanged())},r.prototype._cvCollectionChanged=function(){this._checking||(this._populateList(),this.onItemsChanged())},r.prototype._cvCurrentChanged=function(){this.showSelection();this.onSelectedIndexChanged()},r.prototype._populateList=function(){var f=this.hostElement,e,t,u,o,r,s;if(f){if(e=this.containsFocus(),this.onLoadingItems(),f.innerHTML='',this._cv)for(t=0;t<this._cv.items.length;t++){if(u=this.getDisplayValue(t),this._html!=!0&&(u=n.escapeHtml(u)),this.checkedMemberPath&&(o=this._pathChecked.getValue(this._cv.items[t]),u='<label><input type="checkbox"'+(o?' checked':'')+'> '+u+'</label>'),r=document.createElement('div'),r.innerHTML=u,r.className='wj-listbox-item',n.hasClass(r.firstChild,'wj-separator')&&(r.className+=' wj-separator'),this.formatItem.hasHandlers){s=new i(t,this._cv.items[t],r);this.onFormatItem(s)}f.appendChild(r)}f.children.length==0&&f.appendChild(document.createElement('div'));e&&!this.containsFocus()&&this.focus();this.showSelection();this.onLoadedItems()}},r.prototype._click=function(t){var r,i,u;if(!t.defaultPrevented){for(r=this.hostElement.children,i=0;i<r.length;i++)if(n.contains(r[i],t.target)){this.selectedIndex=i;break}i=this.selectedIndex;this.checkedMemberPath&&i>-1&&(u=this._getCheckbox(i),u==t.target&&this.setItemChecked(i,u.checked))}},r.prototype._keydown=function(t){var i,r,s;if(!t.defaultPrevented&&!t.ctrlKey&&!t.shiftKey&&!t.altKey&&!t.metaKey){var u=this.selectedIndex,o=this.hostElement,f=o.children;switch(t.keyCode){case n.Key.Down:for(t.preventDefault(),i=this.selectedIndex+1;i<f.length;i++)if(this.getDisplayText(i)){this.selectedIndex=i;break}break;case n.Key.Up:for(t.preventDefault(),i=this.selectedIndex-1;i>=0;i--)if(this.getDisplayText(i)){this.selectedIndex=i;break}break;case n.Key.Home:t.preventDefault();this.selectedIndex=0;break;case n.Key.End:t.preventDefault();this.selectedIndex=f.length-1;break;case n.Key.PageDown:if(t.preventDefault(),this.selectedIndex>-1){var u=this.selectedIndex,h=o.offsetHeight,e=0;for(i=u+1;i<this._cv.items.length;i++){if(r=f[i].scrollHeight,e+r>h){this.selectedIndex=i;break}e+=r}this.selectedIndex==u&&this._cv.moveCurrentToLast()}break;case n.Key.PageUp:if(t.preventDefault(),this.selectedIndex>-1){var u=this.selectedIndex,h=o.offsetHeight,e=0;for(i=u-1;i>0;i--){if(r=f[i].scrollHeight,e+r>h){this.selectedIndex=i;break}e+=r}this.selectedIndex==u&&this._cv.moveCurrentToFirst()}break;case n.Key.Space:this.checkedMemberPath&&this.selectedIndex>-1&&(s=this._getCheckbox(this.selectedIndex),s&&(this.hostElement.focus(),this.setItemChecked(this.selectedIndex,!s.checked),t.preventDefault()))}}},r.prototype._keypress=function(n){var i=this,t;n.defaultPrevented||n.target instanceof HTMLInputElement||(n.charCode>32||n.charCode==32&&this._search)&&(n.preventDefault(),this._search+=String.fromCharCode(n.charCode).toLowerCase(),console.log('looking for '+this._search),this._toSearch&&clearTimeout(this._toSearch),this._toSearch=setTimeout(function(){i._toSearch=0;i._search=''},600),t=this._findNext(),t<0&&this._search.length>1&&(this._search=this._search[this._search.length-1],t=this._findNext()),t>-1&&(this.selectedIndex=t))},r.prototype._findNext=function(){var r,n,t,i,u;if(this.hostElement)for(r=this.hostElement.childElementCount,n=this.selectedIndex,(n<0||this._search.length==1)&&n++,t=0;t<r;t++)if(i=(n+t)%r,u=this.getDisplayText(i).trim().toLowerCase(),u.indexOf(this._search)==0)return console.log('match at '+i),i;return-1},r.prototype._getCheckbox=function(n){var t=this.hostElement;return t&&n>-1&&n<t.children.length?t.children[n].querySelector('input[type=checkbox]'):null},r.prototype._populateSelectElement=function(n){for(var t,u=n.children,i=[],f=-1,r=0;r<u.length;r++)t=u[r],t.tagName=='OPTION'&&(t.hasAttribute('selected')&&(f=i.length),t.innerHTML?i.push({hdr:t.innerHTML,val:t.getAttribute('value'),cmdParam:t.getAttribute('cmd-param')}):i.push({hdr:'<div class="wj-separator"/>'}),n.removeChild(t),r--);i&&(this.displayMemberPath='hdr',this.selectedValuePath='val',this.itemsSource=i,this.selectedIndex=f)},r}(n.Control),i;t.ListBox=r;i=function(t){function i(i,r,u){t.call(this);this._index=n.asNumber(i);this._data=r;this._item=n.asType(u,HTMLElement)}return __extends(i,t),Object.defineProperty(i.prototype,"index",{get:function(){return this._index},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"data",{get:function(){return this._data},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"item",{get:function(){return this._item},enumerable:!0,configurable:!0}),i}(n.EventArgs);t.FormatItemEventArgs=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(i){function r(t,r){var u=this;i.call(this,t);this._editable=!1;this._composing=!1;this._deleting=!1;this._settingText=!1;this.selectedIndexChanged=new n.Event;n.addClass(this.hostElement,'wj-combobox');this.autoExpandSelection=!1;this.addEventListener(this._tbx,'compositionstart',function(){u._composing=!0});this.addEventListener(this._tbx,'compositionend',function(){u._composing=!1;setTimeout(function(){u._setText(u.text,!0)})});this.addEventListener(this.hostElement,'wheel',function(t){if(!t.defaultPrevented&&!u.isDroppedDown&&!u.isReadOnly&&u.containsFocus()&&u.selectedIndex>-1){var i=n.clamp(-t.deltaY,-1,1);u.selectedIndex=n.clamp(u.selectedIndex-i,0,u.collectionView.items.length-1);t.preventDefault()}});this._orgTag=='SELECT'&&this._lbx._populateSelectElement(this.hostElement);this.isRequired=!0;this.initialize(r)}return __extends(r,i),Object.defineProperty(r.prototype,"itemsSource",{get:function(){return this._lbx.itemsSource},set:function(n){this._lbx.itemsSource=n;this._updateBtn()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"collectionView",{get:function(){return this._lbx.collectionView},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"displayMemberPath",{get:function(){return this._lbx.displayMemberPath},set:function(n){this._lbx.displayMemberPath=n;var t=this.getDisplayText();this.text!=t&&this._setText(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"headerPath",{get:function(){return this._hdrPath},set:function(t){this._hdrPath=n.asString(t);var i=this.getDisplayText();this.text!=i&&this._setText(i,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedValuePath",{get:function(){return this._lbx.selectedValuePath},set:function(n){this._lbx.selectedValuePath=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isContentHtml",{get:function(){return this._lbx.isContentHtml},set:function(t){if(t!=this.isContentHtml){this._lbx.isContentHtml=n.asBoolean(t);var i=this.getDisplayText();this.text!=i&&this._setText(i,!0)}},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemFormatter",{get:function(){return this._lbx.itemFormatter},set:function(t){this._lbx.itemFormatter=n.asFunction(t);this.selectedIndex=this._lbx.selectedIndex},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedIndex",{get:function(){return this._lbx.selectedIndex},set:function(n){n!=this.selectedIndex&&(this._lbx.selectedIndex=n);var t=this.getDisplayText(n);this.text!=t&&this._setText(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedItem",{get:function(){return this._lbx.selectedItem},set:function(n){this._lbx.selectedItem=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectedValue",{get:function(){return this._lbx.selectedValue},set:function(n){this._lbx.selectedValue=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isEditable",{get:function(){return this._editable},set:function(t){this._editable=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"maxDropDownHeight",{get:function(){return this._lbx.maxHeight},set:function(t){this._lbx.maxHeight=n.asNumber(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"maxDropDownWidth",{get:function(){var n=this._dropDown;return parseInt(n.style.maxWidth)},set:function(t){var i=this._dropDown;i.style.maxWidth=n.asNumber(t)+'px'},enumerable:!0,configurable:!0}),r.prototype.getDisplayText=function(t){if(t===void 0&&(t=this.selectedIndex),this.headerPath&&t>-1&&n.hasItems(this.collectionView)){var r=this.collectionView.items[t][this.headerPath],i=r!=null?r.toString():'';return this.isContentHtml&&(this._cvt||(this._cvt=document.createElement('div')),this._cvt.innerHTML=i,i=this._cvt.textContent),i}return this._lbx.getDisplayText(t)},r.prototype.onSelectedIndexChanged=function(n){this._updateBtn();this.selectedIndexChanged.raise(this,n)},r.prototype.indexOf=function(t,i){var f=this.collectionView,r,u;if(n.hasItems(f)&&t){if(i&&this.selectedIndex>-1&&t==this.getDisplayText(this.selectedIndex))return this.selectedIndex;for(t=t.toString().toLowerCase(),r=0;r<f.items.length;r++)if(u=this.getDisplayText(r).toLowerCase(),i){if(u==t)return r}else if(t&&u.indexOf(t)==0)return r}return-1},Object.defineProperty(r.prototype,"listBox",{get:function(){return this._lbx},enumerable:!0,configurable:!0}),r.prototype.refresh=function(t){i.prototype.refresh.call(this,t);n.hasItems(this.collectionView)&&(this._lbx.refresh(),this.selectedIndex>-1&&(this.selectedIndex=this._lbx.selectedIndex))},r.prototype.onLostFocus=function(t){this.isEditable&&this.isRequired&&!this.text&&n.hasItems(this.collectionView)&&(this.selectedIndex=0);i.prototype.onLostFocus.call(this,t)},r.prototype.onIsDroppedDownChanging=function(t){return n.hasItems(this.collectionView)?i.prototype.onIsDroppedDownChanging.call(this,t):!1},r.prototype.onIsDroppedDownChanged=function(n){i.prototype.onIsDroppedDownChanged.call(this,n);this.isDroppedDown&&(this._lbx.showSelection(),this.isTouching||this.selectAll())},r.prototype._updateBtn=function(){var t=this.collectionView;this._btn.style.display=this._showBtn&&n.hasItems(t)?'':'none'},r.prototype._createDropDown=function(){var n=this;this._lbx=new t.ListBox(this._dropDown);this._lbx.maxHeight=200;this._lbx.selectedIndexChanged.addHandler(function(){n._updateBtn();n.selectedIndex=n._lbx.selectedIndex;n.onSelectedIndexChanged()});this._lbx.itemsChanged.addHandler(function(){n._updateBtn()});this.addEventListener(this._dropDown,'click',this._dropDownClick.bind(this))},r.prototype._dropDownClick=function(n){n.defaultPrevented||n.target!=this._dropDown&&(this.isDroppedDown=!1)},r.prototype._setText=function(t,r){var f;if(!this._composing&&!this._settingText){this._settingText=!0;t==null&&(t='');t=t.toString();var u=this.selectedIndex,o=this.collectionView,e=this._getSelStart(),s=-1;if(this._deleting&&(r=!0),this._deleting?u=this.indexOf(t,!0):(u=this.indexOf(t,r),u<0&&r&&(u=this.indexOf(t,!1)),u<0&&e>0&&(u=this.indexOf(t.substr(0,e),!1))),u<0&&!this.isEditable&&n.hasItems(o)&&(this.isRequired||t))for(u=Math.max(0,this.indexOf(this._oldText,!1)),f=0;f<t.length&&f<this._oldText.length;f++)if(t[f]!=this._oldText[f]){e=f;break}u>-1&&(s=e,t=this.getDisplayText(u));o&&o.moveCurrentToPosition(u);t!=this._tbx.value&&(this._tbx.value=t);s>-1&&this.containsFocus()&&!this.isTouching&&this._setSelRange(s,t.length);i.prototype._setText.call(this,t,r);this._deleting=!1;this._settingText=!1}},r.prototype._findNext=function(n,t){var i,u,f,r;if(this.collectionView)for(n=n.toLowerCase(),i=this.collectionView.items.length,r=1;r<=i;r++)if(u=(this.selectedIndex+r*t+i)%i,f=this.getDisplayText(u).toLowerCase(),f.indexOf(n)==0)return u;return this.selectedIndex},r.prototype._keydown=function(t){var u,r;if((i.prototype._keydown.call(this,t),!t.defaultPrevented)&&this._elRef==this._tbx&&((t.keyCode==n.Key.Back||t.keyCode==n.Key.Delete)&&(this._deleting=!0),u=this.collectionView,u&&u.items))switch(t.keyCode){case n.Key.Up:case n.Key.Down:r=this._getSelStart();r==this.text.length&&(r=0);this.selectedIndex=this._findNext(this.text.substr(0,r),t.keyCode==n.Key.Up?-1:1);n.setSelectionRange(this._tbx,r,this.text.length);t.preventDefault()}},r.prototype._setSelRange=function(t,i){this._elRef==this._tbx&&n.setSelectionRange(this._tbx,t,i)},r.prototype._getSelStart=function(){return this._tbx&&this._tbx.value?this._tbx.selectionStart:0},r}(t.DropDown);t.ComboBox=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(t){function i(i,r){t.call(this,i);this._cssMatch='wj-autocomplete-match';this._minLength=2;this._maxItems=6;this._itemCount=0;this._delay=500;this._query='';this._inCallback=!1;this._srchProps=[];n.addClass(this.hostElement,'wj-autocomplete');this.isEditable=!0;this.isRequired=!1;this.isContentHtml=!0;this.listBox.formatItem.addHandler(this._formatListItem,this);this._itemsSourceFnCallBackBnd=this._itemSourceFunctionCallback.bind(this);this.initialize(r)}return __extends(i,t),Object.defineProperty(i.prototype,"minLength",{get:function(){return this._minLength},set:function(t){this._minLength=n.asNumber(t,!1,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"maxItems",{get:function(){return this._maxItems},set:function(t){this._maxItems=n.asNumber(t,!1,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"delay",{get:function(){return this._delay},set:function(t){this._delay=n.asNumber(t,!1,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"searchMemberPath",{get:function(){return this._srchProp},set:function(t){this._srchProp=n.asString(t);this._srchProps=t?t.trim().split(/\s*,\s*/):[]},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"itemsSourceFunction",{get:function(){return this._itemsSourceFn},set:function(t){this._itemsSourceFn=n.asFunction(t);n.isFunction(this._itemsSourceFn)&&this.itemsSourceFunction(this.text,this.maxItems,this._itemsSourceFnCallBackBnd)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"cssMatch",{get:function(){return this._cssMatch},set:function(t){this._cssMatch=n.asString(t)},enumerable:!0,configurable:!0}),i.prototype._keydown=function(i){if(!i.defaultPrevented&&this.isDroppedDown)switch(i.keyCode){case n.Key.Up:case n.Key.Down:this.selectAll()}t.prototype._keydown.call(this,i)},i.prototype._setText=function(n){var t=this;if(!this._inCallback){if(!n&&this.selectedIndex>-1&&(this.selectedIndex=-1),n!=this._oldText&&(this._tbx.value!=n&&(this._tbx.value=n),this._oldText=n,this.onTextChanged(),!n&&this.collectionView)){this.collectionView.filter=this._query=null;this.isDroppedDown=!1;return}this._toSearch&&clearTimeout(this._toSearch);n!=this.getDisplayText()&&(this._toSearch=setTimeout(function(){t._toSearch=null;var n=t.text.trim().toLowerCase();n.length>=t._minLength&&n!=t._query&&(t._query=n,n=n.replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1"),t._rxMatch=new RegExp('(?=.*'+n.replace(/ /g,')(?=.*')+')','ig'),t._rxHighlight=t.isContentHtml?new RegExp('('+n.replace(/ /g,'|')+')(?![^<]*>|[^<>]* </)','ig'):new RegExp('('+n.replace(/ /g,'|')+')','ig'),t.itemsSourceFunction?t.itemsSourceFunction(n,t.maxItems,t._itemsSourceFnCallBackBnd):t._updateItems())},this._delay))}},i.prototype._itemSourceFunctionCallback=function(t){this._inCallback=!0;var i=n.asCollectionView(t);i&&i.moveCurrentToPosition(-1);this.itemsSource=i;this._inCallback=!1;this.containsFocus()&&(this.isDroppedDown=!0,this.refresh())},i.prototype.onIsDroppedDownChanged=function(n){this.isDroppedDownChanged.raise(this,n);this._query='';this.selectedIndex>-1?(this._setText(this.getDisplayText()),this.isTouching||this.selectAll()):this.isTouching||this._tbx.focus()},i.prototype._updateItems=function(){var n=this.collectionView;n&&(this._inCallback=!0,n.beginUpdate(),this._itemCount=0,n.filter=this._filter.bind(this),n.moveCurrentToPosition(-1),n.endUpdate(),this._inCallback=!1,this.isDroppedDown=n.items.length>0&&this.containsFocus(),n.items.length!=0||this.isEditable||(this.selectedIndex=-1),this.refresh())},i.prototype._filter=function(n){var t,i;if(this._itemCount>=this._maxItems)return!1;if(t=n?n.toString():'',this.displayMemberPath)for(t=n[this.displayMemberPath],i=0;i<this._srchProps.length;i++)t+='\0'+n[this._srchProps[i]];return(this.isContentHtml&&(t=t.replace(/<[^>]*>/g,'')),t.match(this._rxMatch))?(this._itemCount++,!0):!1},i.prototype._formatListItem=function(n,t){if(this._cssMatch){var i='<span class="'+this._cssMatch+'">$1</span>';t.item.innerHTML=t.item.innerHTML.replace(this._rxHighlight,i)}},i}(t.ComboBox);t.AutoComplete=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(t){function i(i,r){var u=this,f;t.call(this,i);this.itemClicked=new n.Event;n.addClass(this.hostElement,'wj-menu');this._tbx.style.display='none';f='<div wj-part="header" class="wj-form-control" style="cursor:default"/>';this._hdr=n.createElement(f);this._tbx.parentElement.insertBefore(this._hdr,this._tbx);this._elRef=this._hdr;this.isRequired=!1;this._orgTag=='SELECT'&&(this.header=this.hostElement.getAttribute('header'),this._lbx.itemsSource&&(this.commandParameterPath='cmdParam'));this.isContentHtml=!0;this.maxDropDownHeight=500;this.addEventListener(this._hdr,'click',function(n){n.defaultPrevented||(u._isButton?(u.isDroppedDown=!1,u._raiseCommand()):u.isDroppedDown=!u.isDroppedDown)});this.initialize(r)}return __extends(i,t),Object.defineProperty(i.prototype,"header",{get:function(){return this._hdr.innerHTML},set:function(t){this._hdr.innerHTML=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"command",{get:function(){return this._command},set:function(n){this._command=n},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"commandPath",{get:function(){return this._cmdPath},set:function(t){this._cmdPath=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"commandParameterPath",{get:function(){return this._cmdParamPath},set:function(t){this._cmdParamPath=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isButton",{get:function(){return this._isButton},set:function(t){this._isButton=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"owner",{get:function(){return this._owner},set:function(t){this._owner=n.asType(t,HTMLElement,!0);this._enableDisableItems()},enumerable:!0,configurable:!0}),i.prototype.onItemClicked=function(n){this.itemClicked.raise(this,n)},i.prototype.onIsDroppedDownChanged=function(n){t.prototype.onIsDroppedDownChanged.call(this,n);this.isDroppedDown?(this._closing=!0,this._defaultItem=this.selectedItem,this.isRequired=!1,this.selectedIndex=-1,this._enableDisableItems(),this._closing=!1,this.dropDown.focus()):this.selectedItem||(this.selectedItem=this._defaultItem)},i.prototype._keydown=function(i){i.defaultPrevented||i.keyCode==n.Key.Enter&&(this.isDroppedDown?this.getDisplayText(this.selectedIndex)&&this._raiseCommand():(this.isDroppedDown=!0,i.preventDefault()));t.prototype._keydown.call(this,i)},i.prototype._dropDownClick=function(n){n.defaultPrevented||this.getDisplayText(this.selectedIndex)&&this._raiseCommand();t.prototype._dropDownClick.call(this,n)},i.prototype._raiseCommand=function(n){var r=this.selectedItem,t=this._getCommand(r),i;if(t){if(i=this._cmdParamPath?r[this._cmdParamPath]:null,!this._canExecuteCommand(t,i))return;this._executeCommand(t,i)}this.onItemClicked(n)},i.prototype._getCommand=function(n){var t=n&&this.commandPath?n[this.commandPath]:null;return t?t:this.command},i.prototype._executeCommand=function(t,i){t&&!n.isFunction(t)&&(t=t.executeCommand);n.isFunction(t)&&t(i)},i.prototype._canExecuteCommand=function(t,i){if(t){var r=t.canExecuteCommand;if(n.isFunction(r))return r(i)}return!0},i.prototype._enableDisableItems=function(){var i,t,r,u,f;if(this.collectionView&&(this.command||this.commandPath))for(i=this.collectionView.items,t=0;t<i.length;t++)r=this._getCommand(i[t]),u=this.commandParameterPath?i[t][this.commandParameterPath]:null,r&&(f=this._lbx.hostElement.children[t],n.toggleClass(f,'wj-state-disabled',!this._canExecuteCommand(r,u)))},i}(t.ComboBox);t.Menu=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)};wijmo.culture.MultiSelect={itemsSelected:'{count:n0} items selected'},function(n){var t;(function(t){'use strict';var i=function(t){function i(i,r){var u=this;t.call(this,i);this._maxHdrItems=2;this._readOnly=!1;this._hdrFmt=n.culture.MultiSelect.itemsSelected;this.checkedItemsChanged=new n.Event;n.addClass(this.hostElement,'wj-multiselect');this._tbx.readOnly=!0;this.checkedMemberPath=null;this.addEventListener(this.inputElement,'click',function(){u.isDroppedDown=!u.isDroppedDown});this.removeEventListener(this.dropDown,'click');this._updateHeader();this.listBox.itemsChanged.addHandler(function(){u._updateHeader()});this.listBox.checkedItemsChanged.addHandler(function(){u._updateHeader();u.onCheckedItemsChanged()});this.initialize(r)}return __extends(i,t),Object.defineProperty(i.prototype,"checkedMemberPath",{get:function(){var n=this.listBox.checkedMemberPath;return n!=i._DEF_CHECKED_PATH?n:null},set:function(t){t=n.asString(t);this.listBox.checkedMemberPath=t?t:i._DEF_CHECKED_PATH},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"maxHeaderItems",{get:function(){return this._maxHdrItems},set:function(t){this._maxHdrItems!=t&&(this._maxHdrItems=n.asNumber(t),this._updateHeader())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"headerFormat",{get:function(){return this._hdrFmt},set:function(t){t!=this._hdrFmt&&(this._hdrFmt=n.asString(t),this._updateHeader())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"headerFormatter",{get:function(){return this._hdrFormatter},set:function(t){t!=this._hdrFormatter&&(this._hdrFormatter=n.asFunction(t),this._updateHeader())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"checkedItems",{get:function(){return this.listBox.checkedItems},set:function(t){this.listBox.checkedItems=n.asArray(t)},enumerable:!0,configurable:!0}),i.prototype.onCheckedItemsChanged=function(n){this.checkedItemsChanged.raise(this,n)},Object.defineProperty(i.prototype,"isReadOnly",{get:function(){return this._readOnly},set:function(t){this._readOnly=n.asBoolean(t);n.toggleClass(this.hostElement,'wj-state-readonly',this.isReadOnly)},enumerable:!0,configurable:!0}),i.prototype.refresh=function(n){n===void 0&&(n=!0);t.prototype.refresh.call(this,n);this._updateHeader()},i.prototype.onIsDroppedDownChanged=function(n){t.prototype.onIsDroppedDownChanged.call(this,n);this.isDroppedDown&&this.dropDown.focus()},i.prototype._setText=function(){},i.prototype._updateHeader=function(){var t,r,i;if(this._hdrFormatter)this.inputElement.value=this._hdrFormatter();else{if(t=this.checkedItems,r='',t.length>0)if(t.length<=this._maxHdrItems){if(this.displayMemberPath)for(i=0;i<t.length;i++)t[i]=t[i][this.displayMemberPath];r=t.join(', ')}else r=n.format(this.headerFormat,{count:t.length});this.inputElement.value=r}this._updateState()},i._DEF_CHECKED_PATH='$checked',i}(t.ComboBox);t.MultiSelect=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';(function(n){n[n.None=0]="None";n[n.Click=1]="Click";n[n.Blur=2]="Blur";n[n.ClickOrBlur=3]="ClickOrBlur"})(t.PopupTrigger||(t.PopupTrigger={}));var i=t.PopupTrigger,r=function(t){function r(r,u){var f=this,e;t.call(this,r,null,!0);this._showTrigger=i.Click;this._hideTrigger=i.Blur;this._fadeIn=!0;this._fadeOut=!0;this._click=this._handleClick.bind(this);this._mousedown=this._handleMouseDown.bind(this);this._visible=!1;this.showing=new n.Event;this.shown=new n.Event;this.hiding=new n.Event;this.hidden=new n.Event;e=this.hostElement;n.addClass(e,'wj-control wj-content wj-popup');e.getAttribute('tabindex')||(e.tabIndex=0);n.hidePopup(e,!1);this.addEventListener(e,'keydown',function(t){if(!t.defaultPrevented&&(t.keyCode==n.Key.Escape&&(t.preventDefault(),f.hide()),t.keyCode==n.Key.Enter)){var i=f.dialogResultEnter;i&&(t.preventDefault(),f._validateAndHide(i))}});this.addEventListener(e,'keydown',function(t){!t.defaultPrevented&&f.modal&&t.keyCode==n.Key.Tab&&(t.preventDefault(),n.moveFocus(f.hostElement,t.shiftKey?-1:1))});this.addEventListener(e,'click',function(n){if(n.target instanceof HTMLElement){var i=n.target,t=i.className.match(/\bwj-hide[\S]*\b/);t&&t.length>0&&(n.preventDefault(),n.stopPropagation(),f.hide(t[0]))}});this.addEventListener(document,'wheel',function(n){if(f.isVisible&&f._modal){for(var t=n.target;t&&t!=document.body;t=t.parentElement)if(t.scrollHeight>t.clientHeight)return;n.preventDefault();n.stopPropagation()}});this.initialize(u)}return __extends(r,t),Object.defineProperty(r.prototype,"owner",{get:function(){return this._owner},set:function(t){this._owner&&(this.removeEventListener(this._owner,'mousedown'),this.removeEventListener(this._owner,'click'));this._owner=t!=null?n.getElement(t):null;this._owner&&(this.addEventListener(this._owner,'mousedown',this._mousedown,!0),this.addEventListener(this._owner,'click',this._click,!0))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"content",{get:function(){return this.hostElement.firstElementChild},set:function(n){n!=this.content&&(this.hostElement.innerHTML='',n instanceof HTMLElement&&this.hostElement.appendChild(n))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"showTrigger",{get:function(){return this._showTrigger},set:function(t){this._showTrigger=n.asEnum(t,i)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"hideTrigger",{get:function(){return this._hideTrigger},set:function(t){this._hideTrigger=n.asEnum(t,i)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"fadeIn",{get:function(){return this._fadeIn},set:function(t){this._fadeIn=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"fadeOut",{get:function(){return this._fadeOut},set:function(t){this._fadeOut=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"modal",{get:function(){return this._modal},set:function(t){this._modal=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"dialogResult",{get:function(){return this._result},set:function(n){this._result=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"dialogResultEnter",{get:function(){return this._resultEnter},set:function(n){this._resultEnter=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isVisible",{get:function(){var n=this.hostElement;return this._visible&&n&&n.style.display!='none'},enumerable:!0,configurable:!0}),r.prototype.show=function(t,i){var r=this,u,f;if(!this.isVisible&&(this.dialogResult=null,this._callback=null,u=new n.CancelEventArgs,this.onShowing(u))){t!=null&&(this.modal=n.asBoolean(t));i!=null&&(this._callback=n.asFunction(i));f=this._owner?this._owner.getBoundingClientRect():null;n.showPopup(this.hostElement,f,!1,this._fadeIn);this._modal&&this._showBackdrop();this._visible=!0;this.onShown(u);setTimeout(function(){if(!r.isTouching){var t=r.hostElement.querySelector('input[autofocus]');t&&t.clientHeight>0&&!t.disabled&&t.tabIndex>-1&&!n.closest(t,'[disabled],.wj-state-disabled')?(t.focus(),t.select()):n.moveFocus(r.hostElement,0)}r.containsFocus()||(r.hostElement.tabIndex=0,r.hostElement.focus())},200)}},r.prototype.hide=function(t){if(this.isVisible){n.isUndefined(t)||(this.dialogResult=t);var i=new n.CancelEventArgs;if(this.onHiding(i)){this._modal&&n.hidePopup(this._bkdrop,!0,this.fadeOut);n.hidePopup(this.hostElement,!0,this.fadeOut);this._visible=!1;this.onHidden(i);this._callback&&this._callback(this)}}},r.prototype.onShowing=function(n){return this.showing.raise(this,n),!n.cancel},r.prototype.onShown=function(n){this.shown.raise(this,n)},r.prototype.onHiding=function(n){return this.hiding.raise(this,n),!n.cancel},r.prototype.onHidden=function(n){this.hidden.raise(this,n)},r.prototype.dispose=function(){this._owner=null;t.prototype.dispose.call(this)},r.prototype.onLostFocus=function(n){this.isVisible&&this._hideTrigger&i.Blur&&(this.containsFocus()||this.hide());t.prototype.onLostFocus.call(this,n)},r.prototype.refresh=function(i){if(i===void 0&&(i=!0),t.prototype.refresh.call(this,i),this.isVisible&&!this._refreshing){this._refreshing=!0;var r=n.getActiveElement(),u=this._owner?this._owner.getBoundingClientRect():null;n.showPopup(this.hostElement,u);this._modal&&r instanceof HTMLElement&&r!=n.getActiveElement()&&r.focus();this._refreshing=!1}},r.prototype._handleResize=function(){this.isVisible&&this.refresh()},r.prototype._handleClick=function(){if(this.isVisible)this._hideTrigger&i.Click&&this.hide();else if(this._showTrigger&i.Click&&!this._wasVisible){var n=this.hostElement;n&&n.style.display=='none'&&this.show()}},r.prototype._handleMouseDown=function(){this._wasVisible=this.isVisible},r.prototype._showBackdrop=function(){var i=this,t;this._bkdrop||(this._bkdrop=document.createElement('div'),this._bkdrop.tabIndex=-1,n.addClass(this._bkdrop,'wj-popup-backdrop'),this.addEventListener(this._bkdrop,'mousedown',function(n){n.preventDefault();n.stopPropagation();i.hostElement.focus()}));this._bkdrop.style.display='';t=this.hostElement;t.parentElement.insertBefore(this._bkdrop,t)},r.prototype._validateAndHide=function(n){var t=this.hostElement.querySelector(':invalid');t?t.focus():this.hide(n)},r}(n.Control);t.Popup=r})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(i){function r(r,u){var f=this,e;i.call(this,r);this._format='d';this.valueChanged=new n.Event;n.addClass(this.hostElement,'wj-inputdate');this._msk=new n._MaskProvider(this._tbx);n.isIE9()||(this._tbx.type='tel');this.addEventListener(this.hostElement,'wheel',function(i){if(!i.defaultPrevented&&!f.isDroppedDown&&f.containsFocus()&&f.value!=null&&f._canChangeValue()){var r=n.clamp(-i.deltaY,-1,1);f.value=f.selectionMode==t.DateSelectionMode.Month?n.DateTime.addMonths(f.value,r):n.DateTime.addDays(f.value,r);f.selectAll();i.preventDefault()}});this.value=n.DateTime.newDate();this._orgTag=='INPUT'&&(e=this._tbx.getAttribute('value'),e&&(this.value=n.Globalize.parseDate(e,'yyyy-MM-dd')));this.isRequired=!0;this.initialize(u)}return __extends(r,i),Object.defineProperty(r.prototype,"value",{get:function(){return this._value},set:function(t){n.DateTime.equals(this._value,t)?this._tbx.value=n.Globalize.format(t,this.format):(t=n.asDate(t,!this.isRequired||t==null&&this._value==null),t=this._clamp(t),this._isValidDate(t)?(this._tbx.value=t?n.Globalize.format(t,this.format):'',t==this._value||n.DateTime.equals(this._value,t)||(this._value=t,this.onValueChanged())):this._tbx.value=t?n.Globalize.format(this.value,this.format):'',this.text!=this._oldText&&this.onTextChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"text",{get:function(){return this._tbx.value},set:function(n){n!=this.text&&(this._setText(n,!0),this._commitText())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"selectionMode",{get:function(){return this.calendar.selectionMode},set:function(n){this.calendar.selectionMode=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"min",{get:function(){return this._calendar.min},set:function(t){this._calendar.min=n.asDate(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"max",{get:function(){return this._calendar.max},set:function(t){this._calendar.max=n.asDate(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"format",{get:function(){return this._format},set:function(t){t!=this.format&&(this._format=n.asString(t),this._tbx.value=n.Globalize.format(this.value,this.format))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"mask",{get:function(){return this._msk.mask},set:function(t){this._msk.mask=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"calendar",{get:function(){return this._calendar},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"inputElement",{get:function(){return this._tbx},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"inputType",{get:function(){return this._tbx.type},set:function(t){this._tbx.type=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemValidator",{get:function(){return this._calendar.itemValidator},set:function(t){t!=this.itemValidator&&(this._calendar.itemValidator=n.asFunction(t),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"itemFormatter",{get:function(){return this.calendar.itemFormatter},set:function(t){t!=this.itemFormatter&&(this.calendar.itemFormatter=n.asFunction(t))},enumerable:!0,configurable:!0}),r.prototype.onValueChanged=function(n){this.valueChanged.raise(this,n)},r.prototype.refresh=function(){this.isDroppedDown=!1;this._msk&&this._msk.refresh();this._calendar&&this._calendar.refresh();this._tbx.value=n.Globalize.format(this.value,this.format)},r.prototype.onIsDroppedDownChanged=function(n){i.prototype.onIsDroppedDownChanged.call(this,n);this.isDroppedDown&&(this._calChanged=!1,this.dropDown.focus())},r.prototype._createDropDown=function(){var i=this;this._calendar=new t.Calendar(this._dropDown);this._dropDown.tabIndex=-1;this._calendar.valueChanged.addHandler(function(){i.value=n.DateTime.fromDateTime(i._calendar.value,i.value);i._calChanged=!0});this.addEventListener(this._dropDown,'mouseup',function(n){i._calChanged?i.isDroppedDown=!1:n.target.getAttribute('wj-part')=='btn-today'&&(i.isDroppedDown=!1)})},r.prototype._updateDropDown=function(){var n,r;this._commitText();n=this._calendar;n.value=this.value;n.min=this.min;n.max=this.max;this.selectionMode!=t.DateSelectionMode.Month&&(n.monthView=!0);r=getComputedStyle(this.hostElement);this._dropDown.style.minWidth=parseFloat(r.fontSize)*18+'px';this._calendar.refresh();i.prototype._updateDropDown.call(this)},r.prototype._keydown=function(r){if(!r.defaultPrevented&&!r.altKey&&!r.ctrlKey&&!r.metaKey)switch(r.keyCode){case n.Key.Enter:this._commitText();this.selectAll();break;case n.Key.Escape:this.text=n.Globalize.format(this.value,this.format);this.selectAll();break;case n.Key.Up:case n.Key.Down:if(!this.isDroppedDown&&this.value&&this._canChangeValue()){var u=r.keyCode==n.Key.Up?1:-1;this.value=this.selectionMode==t.DateSelectionMode.Month?n.DateTime.addMonths(this.value,u):n.DateTime.addDays(this.value,u);this.selectAll();r.preventDefault()}}i.prototype._keydown.call(this,r)},r.prototype._canChangeValue=function(){return!this.isReadOnly&&this.selectionMode!=t.DateSelectionMode.None},r.prototype._clamp=function(n){return this.calendar._clamp(n)},r.prototype._commitText=function(){var i=this._tbx.value,t;i||this.isRequired?(t=n.Globalize.parseDate(i,this.format),t?this.value=n.DateTime.fromDateTime(t,this.value):this._tbx.value=n.Globalize.format(this.value,this.format)):this.value=null},r.prototype._isValidDate=function(n){return n&&(this._clamp(n)!=n||this.itemValidator&&!this.itemValidator(n))?!1:!0},r}(t.DropDown);t.InputDate=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(t){function i(i,r){if(t.call(this,i),this._format='t',this.valueChanged=new n.Event,n.addClass(this.hostElement,'wj-inputtime'),this._value=n.DateTime.newDate(),this._msk=new n._MaskProvider(this._tbx),n.isIE9()||(this._tbx.type='tel'),this._orgTag=='INPUT'){var u=this._tbx.getAttribute('value');u&&(this.value=n.Globalize.parseDate(u,'HH:mm:ss'))}this.step=15;this.autoExpandSelection=!0;this.initialize(r)}return __extends(i,t),Object.defineProperty(i.prototype,"inputElement",{get:function(){return this._tbx},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"inputType",{get:function(){return this._tbx.type},set:function(t){this._tbx.type=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"value",{get:function(){return this._value},set:function(t){t=n.asDate(t,!this.isRequired);t&&(this._min!=null&&this._getTime(t)<this._getTime(this._min)&&(t=n.DateTime.fromDateTime(t,this._min)),this._max!=null&&this._getTime(t)>this._getTime(this._max)&&(t=n.DateTime.fromDateTime(t,this._max)));this._setText(t?n.Globalize.format(t,this.format):'',!0);t==this._value||n.DateTime.equals(t,this._value)||(this._value=t,this.onValueChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"text",{get:function(){return this._tbx.value},set:function(n){n!=this.text&&(this._setText(n,!0),this._commitText())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"min",{get:function(){return this._min},set:function(t){this._min=n.asDate(t,!0);this.isDroppedDown=!1;this._updateItems()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"max",{get:function(){return this._max},set:function(t){this._max=n.asDate(t,!0);this.isDroppedDown=!1;this._updateItems()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"step",{get:function(){return this._step},set:function(t){this._step=n.asNumber(t,!0);this.isDroppedDown=!1;this._updateItems()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"format",{get:function(){return this._format},set:function(t){t!=this.format&&(this._format=n.asString(t),this._tbx.value=n.Globalize.format(this.value,this.format),this.collectionView&&this.collectionView.items.length&&this._updateItems())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"mask",{get:function(){return this._msk.mask},set:function(t){this._msk.mask=n.asString(t)},enumerable:!0,configurable:!0}),i.prototype.onValueChanged=function(n){this.valueChanged.raise(this,n)},i.prototype.refresh=function(){this.isDroppedDown=!1;this._msk.refresh();this._tbx.value=n.Globalize.format(this.value,this.format);this._updateItems()},i.prototype.onSelectedIndexChanged=function(n){this.selectedIndex>-1&&this._commitText();t.prototype.onSelectedIndexChanged.call(this,n)},i.prototype._updateItems=function(){var i=new Date(0,0,0,0,0),r=new Date(0,0,0,23,59,59),u=[],t,f;if(this.min&&i.setHours(this.min.getHours(),this.min.getMinutes(),this.min.getSeconds()),this.max&&r.setHours(this.max.getHours(),this.max.getMinutes(),this.max.getSeconds()),n.isNumber(this.step)&&this.step>0)for(t=i;t<=r;t=n.DateTime.addMinutes(t,this.step))u.push(n.Globalize.format(t,this.format));f=this.text;this.itemsSource=u;this.text=f},i.prototype._getTime=function(n){return n.getHours()*3600+n.getMinutes()*60+n.getSeconds()},i.prototype._keydown=function(i){if(t.prototype._keydown.call(this,i),!i.defaultPrevented)switch(i.keyCode){case n.Key.Enter:this.isDroppedDown||(this._commitText(),this.selectAll());break;case n.Key.Escape:this.text=n.Globalize.format(this.value,this.format);this.selectAll()}},i.prototype._commitText=function(){if(this.text||this.isRequired){var t=n.Globalize.parseDate(this.text,this.format);t?this.value=n.DateTime.fromDateTime(this.value,t):this._tbx.value=n.Globalize.format(this.value,this.format)}else this.value=null},i}(t.ComboBox);t.InputTime=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(i){function r(r,u){var f=this,e,o;i.call(this,r);n.addClass(this.hostElement,'wj-inputdatetime');this._btnTm=this.hostElement.querySelector('[wj-part="btn-tm"]');this._format='g';this._inputTime=new t.InputTime(document.createElement('div'));this._inputTime.valueChanged.addHandler(function(){f.value=n.DateTime.fromDateTime(f.value,f._inputTime.value);f.containsFocus()&&(f.isTouching&&f.showDropDownButton||f.selectAll())});e=this._inputTime.dropDown;o=this._keydown.bind(this);this.addEventListener(e,'keydown',o,!0);this.addEventListener(e,'blur',function(){f._updateFocusState()},!0);this.addEventListener(this._btnTm,'click',this._btnclick.bind(this));this.addEventListener(this._btn,'mousedown',function(){f._setDropdown(f.calendar.hostElement)});this.addEventListener(this._btnTm,'mousedown',function(n){f.isDroppedDown&&f.dropDown==e&&n.preventDefault();f._inputTime.dropDownCssClass=f.dropDownCssClass;f._setDropdown(e)});this.initialize(u)}return __extends(r,i),Object.defineProperty(r.prototype,"timeMin",{get:function(){return this._inputTime.min},set:function(n){this._inputTime.min=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"timeMax",{get:function(){return this._inputTime.max},set:function(n){this._inputTime.max=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"timeFormat",{get:function(){return this._inputTime.format},set:function(n){this._inputTime.format=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"timeStep",{get:function(){return this._inputTime.step},set:function(n){this._inputTime.step=n},enumerable:!0,configurable:!0}),r.prototype.refresh=function(){i.prototype.refresh.call(this);this._inputTime.refresh()},r.prototype._updateBtn=function(){i.prototype._updateBtn.call(this);this._btnTm&&(this._btnTm.tabIndex=this._btn.tabIndex,this._btnTm.parentElement.style.display=this._btn.style.display)},r.prototype._clamp=function(n){return n&&(this.min&&n<this.min&&(n=this.min),this.max&&n>this.max&&(n=this.max)),n},r.prototype._commitText=function(){var i=this._tbx.value,t;i||this.isRequired?(t=n.Globalize.parseDate(i,this.format),t?this.value=t:this._tbx.value=n.Globalize.format(this.value,this.format)):this.value=null},r.prototype._setDropdown=function(n){this._dropDown!=n&&(this.isDroppedDown&&(this.isDroppedDown=!1),this._dropDown=n)},r.prototype._updateDropDown=function(){var n=this._inputTime;this._dropDown==n.dropDown?(this._commitText(),i.prototype._updateDropDown.call(this),n.isRequired=this.isRequired,n.value=this.value,this.isDroppedDown&&n.listBox.showSelection()):i.prototype._updateDropDown.call(this)},r.controlTemplate='<div style="position:relative" class="wj-template"><div class="wj-input"><div class="wj-input-group wj-input-btn-visible"><input wj-part="input" type="text" class="wj-form-control" /><span class="wj-input-group-btn" tabindex="-1"><button wj-part="btn" class="wj-btn wj-btn-default" type="button" tabindex="-1"><span class="wj-glyph-calendar"><\/span><\/button><button wj-part="btn-tm" class="wj-btn wj-btn-default" type="button" tabindex="-1"><span class="wj-glyph-clock"><\/span><\/button><\/span><\/div><\/div><div wj-part="dropdown" class="wj-content wj-dropdown-panel" style="display:none;position:absolute;z-index:100;width:auto"><\/div><\/div>',r}(t.InputDate);t.InputDateTime=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(t){function i(i,r){var u=this,e,f;t.call(this,i);this._showBtn=!0;this._readOnly=!1;this.textChanged=new n.Event;this.valueChanged=new n.Event;e=this.getTemplate();this.applyTemplate('wj-control wj-inputnumber wj-content',e,{_tbx:'input',_btnUp:'btn-inc',_btnDn:'btn-dec'},'input');f=this._tbx;f.autocomplete='off';f.spellcheck=!1;this._updateSymbols();this.addEventListener(this._tbx,'compositionstart',function(){u._composing=!0});this.addEventListener(this._tbx,'compositionend',function(){u._composing=!1;setTimeout(function(){u._setText(u.text)})});this.addEventListener(f,'keypress',this._keypress.bind(this));this.addEventListener(f,'keydown',this._keydown.bind(this));this.addEventListener(f,'input',this._input.bind(this));this.addEventListener(this._btnUp,'click',this._clickSpinner.bind(this));this.addEventListener(this._btnDn,'click',this._clickSpinner.bind(this));this.addEventListener(this.hostElement,'wheel',function(t){if(!t.defaultPrevented&&!u.isReadOnly&&u.containsFocus()&&u.value!=null){var i=n.clamp(-t.deltaY,-1,1);u._increment((u.step||1)*i);setTimeout(function(){return u.selectAll()});t.preventDefault()}});this.value=0;this.isRequired=!0;this.initialize(r)}return __extends(i,t),Object.defineProperty(i.prototype,"inputElement",{get:function(){return this._tbx},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"inputType",{get:function(){return this._tbx.type},set:function(t){this._tbx.type=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"value",{get:function(){return this._value},set:function(t){if(t!=this._value)if(t=n.asNumber(t,!this.isRequired||t==null&&this._value==null),t==null)this._setText('');else if(!isNaN(t)){var i=n.Globalize.format(t,this.format);this._setText(i)}},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isRequired",{get:function(){return this._tbx.required},set:function(t){this._tbx.required=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"required",{get:function(){return n._deprecated('required','isRequired'),this.isRequired},set:function(t){n._deprecated('required','isRequired');this.isRequired=t},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isReadOnly",{get:function(){return this._readOnly},set:function(t){this._readOnly=n.asBoolean(t);this.inputElement.readOnly=this._readOnly;n.toggleClass(this.hostElement,'wj-state-readonly',this.isReadOnly)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"min",{get:function(){return this._min},set:function(t){this._min=n.asNumber(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"max",{get:function(){return this._max},set:function(t){this._max=n.asNumber(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"step",{get:function(){return this._step},set:function(t){this._step=n.asNumber(t,!0);this._updateBtn()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"format",{get:function(){return this._format},set:function(t){t!=this.format&&(this._format=n.asString(t),this.refresh())},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"text",{get:function(){return this._tbx.value},set:function(n){n!=this.text&&(this._oldText=null,this._setText(n))},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"placeholder",{get:function(){return this._tbx.placeholder},set:function(n){this._tbx.placeholder=n},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"showSpinner",{get:function(){return this._showBtn},set:function(t){this._showBtn=n.asBoolean(t);this._updateBtn()},enumerable:!0,configurable:!0}),i.prototype.selectAll=function(){n.setSelectionRange(this._tbx,0,this._tbx.value.length)},i.prototype.onTextChanged=function(n){this._updateState();this.textChanged.raise(this,n)},i.prototype.onValueChanged=function(n){this.valueChanged.raise(this,n)},i.prototype.onGotFocus=function(n){this.isTouching||(this._tbx.focus(),this.selectAll());t.prototype.onGotFocus.call(this,n)},i.prototype.onLostFocus=function(i){var r=this._clamp(this.value),u=n.Globalize.format(r,this.format,!1,!1);this._setText(u);t.prototype.onLostFocus.call(this,i)},i.prototype.refresh=function(){this._updateSymbols();var t=n.Globalize.format(this.value,this.format);this._setText(t)},i.prototype._updateSymbols=function(){var t=n.culture.Globalize.numberFormat;this._decChar=t['.']||'.';this._currChar=t.currency.symbol||'$';this._rxSym=new RegExp('^[%+\\-() '+this._decChar+this._currChar+']*$')},i.prototype._clamp=function(t){return n.clamp(t,this.min,this.max)},i.prototype._isNumeric=function(n,t){t===void 0&&(t=!1);var i=n==this._decChar||n>='0'&&n<='9';return i||t||(i='+-()'.indexOf(n)>-1),i},i.prototype._getInputRange=function(n){var t;n===void 0&&(n=!1);var i=[0,0],r=this.text,u=!1;for(t=0;t<r.length;t++)this._isNumeric(r[t],n)&&(u||(i[0]=t,u=!0),i[1]=t+1);return i},i.prototype._moveToDigit=function(){var t=this._getInputRange(!0);n.setSelectionRange(this._tbx,t[0],t[1])},i.prototype._increment=function(t){if(t){var i=this._clamp(this.value+t),r=n.Globalize.format(i,this.format,!1,!1);this._setText(r)}},i.prototype._getSelStart=function(){return this._tbx&&this._tbx.value?this._tbx.selectionStart:0},i.prototype._updateBtn=function(){this.showSpinner&&this.step&&this.value!=null?(this._btnUp.style.display=this._btnDn.style.display='',n.addClass(this.hostElement,'wj-input-show-spinner')):(this._btnUp.style.display=this._btnDn.style.display='none',n.removeClass(this.hostElement,'wj-input-show-spinner'))},i.prototype._setText=function(t){var u,i,f,r;if(!this._composing){if(!t){if(!this.isRequired){this._tbx.value='';this._value!=null&&(this._value=null,this.onValueChanged());this._oldText&&(this._oldText=t,this.onTextChanged());this._updateBtn();return}t='0'}if(t=='-'||t=='('){this._tbx.value=t;n.setSelectionRange(this._tbx,1);return}if(t.length>1&&t[t.length-1]==')'&&t[0]!='('&&(t=t.substr(0,t.length-1)),this._rxSym.test(t)&&(t='0'),u=this._format||(t.indexOf(this._decChar)>-1?'n2':'n0'),i=n.Globalize.parseFloat(t,u),isNaN(i)){this._tbx.value=this._oldText;return}t.indexOf('%')<0&&u.toLowerCase().indexOf('p')>-1&&(i/=100);f=this._oldText&&t.length==this._oldText.length+1;r=n.Globalize.format(i,u,!1,f);(u=='n'||u[0].toLowerCase()=='g')&&this._tbx.selectionStart==this._tbx.value.length&&(t==r+this._decChar||t==r+this._decChar+'0')&&(r=t);this._tbx.value!=r&&(this._tbx.value=r,i=n.Globalize.parseFloat(r,this.format));i!=this._value&&(this._value=i,this.onValueChanged());this.text!=this._oldText&&(this.onTextChanged(),this._oldText=this.text);this._updateBtn()}},i.prototype._keypress=function(t){var r,u,i;if(!t.defaultPrevented&&!this._composing&&!this._readOnly&&t.charCode&&!t.ctrlKey){r=String.fromCharCode(t.charCode);this._isNumeric(r)?(u=this._getInputRange(!0),this._tbx.selectionStart<u[0]&&n.setSelectionRange(this._tbx,u[0],u[1])):t.preventDefault();switch(r){case'-':this.value?(this.value*=-1,this._moveToDigit()):this._setText('-');t.preventDefault();break;case'+':this.value=Math.abs(this.value);this._moveToDigit();t.preventDefault();break;case this._decChar:i=this._tbx.value.indexOf(r);i>-1&&(this._getSelStart()<=i&&i++,n.setSelectionRange(this._tbx,i),t.preventDefault())}}},i.prototype._keydown=function(t){var r=this,i;if(!t.defaultPrevented&&!this._composing)switch(t.keyCode){case n.Key.Up:case n.Key.Down:this.step&&(this._increment(this.step*(t.keyCode==n.Key.Up?1:-1)),setTimeout(function(){r.selectAll()}),t.preventDefault());break;case n.Key.Back:this._tbx&&this._tbx.selectionStart==this._tbx.selectionEnd&&(i=this._tbx.selectionStart,i>0&&this.text[i-1]==this._decChar&&(setTimeout(function(){n.setSelectionRange(r._tbx,i-1)}),t.preventDefault()));break;case n.Key.Delete:this._tbx&&this._tbx.selectionStart==this._tbx.selectionEnd&&(i=this._tbx.selectionStart,i>0&&this.text[i]==this._decChar&&(setTimeout(function(){n.setSelectionRange(r._tbx,i+1)}),t.preventDefault()))}},i.prototype._input=function(){var t=this;this._composing||setTimeout(function(){var o=t._tbx,r=o.value,i=t._getSelStart(),s=r?r.indexOf(t._decChar):-1,f,u,e;t._setText(r);t.containsFocus()&&(f=o.value,u=f.indexOf(t._decChar),r&&r[0]=='-'&&f&&f[0]!='-'&&(r=null),r?i<=s&&u>-1||s<0&&u<0?i+=f.length-r.length:i==r.length&&s<0&&u>-1&&(i=u):i=u>-1?u:f.match(/[^\d]*$/).index,e=t._getInputRange(),i<e[0]&&(i=e[0]),i>e[1]&&(i=e[1]),n.setSelectionRange(o,i))})},i.prototype._clickSpinner=function(t){var i=this;t.defaultPrevented||this.isReadOnly||!this.step||this.value==null||(this._increment(this.step*(n.contains(this._btnUp,t.target)?1:-1)),this.isTouching||setTimeout(function(){return i.selectAll()}))},i.controlTemplate='<div class="wj-input"><div class="wj-input-group"><span wj-part="btn-dec" class="wj-input-group-btn" tabindex="-1"><button class="wj-btn wj-btn-default" type="button" tabindex="-1">-<\/button><\/span><input type="tel" wj-part="input" class="wj-form-control wj-numeric"/><span wj-part="btn-inc" class="wj-input-group-btn" tabindex="-1"><button class="wj-btn wj-btn-default" type="button" tabindex="-1">+<\/button><\/span><\/div>',i}(n.Control);t.InputNumber=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(t){function i(i,r){var e=this,f,u;t.call(this,i);this.valueChanged=new n.Event;f=this.getTemplate();this.applyTemplate('wj-control wj-inputmask wj-content',f,{_tbx:'input'},'input');this._orgTag=='INPUT'&&(u=this._tbx.getAttribute('value'),u&&(this.value=u));this._msk=new n._MaskProvider(this._tbx);this.isRequired=!0;this.initialize(r);this.addEventListener(this._tbx,'input',function(){setTimeout(function(){e.onValueChanged()})})}return __extends(i,t),Object.defineProperty(i.prototype,"inputElement",{get:function(){return this._tbx},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"value",{get:function(){return this._tbx.value},set:function(t){if(t!=this.value){this._tbx.value=n.asString(t);var i=n.getActiveElement();this._tbx.selectionStart=this._tbx.value.length;i&&i!=n.getActiveElement()&&i.focus();t=this._msk._applyMask();this._tbx.value=t;this.onValueChanged()}},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"rawValue",{get:function(){return this._msk.getRawValue()},set:function(n){this.value=n},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"mask",{get:function(){return this._msk.mask},set:function(t){var i=this.value;this._msk.mask=n.asString(t);this.value!=i&&this.onValueChanged()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"promptChar",{get:function(){return this._msk.promptChar},set:function(n){var t=this.value;this._msk.promptChar=n;this.value!=t&&this.onValueChanged()},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"placeholder",{get:function(){return this._tbx.placeholder},set:function(n){this._tbx.placeholder=n},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"maskFull",{get:function(){return this._msk.maskFull},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isRequired",{get:function(){return this._tbx.required},set:function(t){this._tbx.required=n.asBoolean(t)},enumerable:!0,configurable:!0}),i.prototype.selectAll=function(){var t=this._msk.getMaskRange();n.setSelectionRange(this._tbx,t[0],t[1]+1)},i.prototype.onValueChanged=function(n){this._updateState();this.valueChanged.raise(this,n)},i.prototype.refresh=function(n){t.prototype.refresh.call(this,n);this._msk.refresh()},i.prototype.onGotFocus=function(n){t.prototype.onGotFocus.call(this,n);this.selectAll()},i.controlTemplate='<div class="wj-input"><div class="wj-input-group"><input wj-part="input" class="wj-form-control"/><\/div>',i}(n.Control);t.InputMask=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(i){function r(t,r){var u=this;i.call(this,t);this.valueChanged=new n.Event;n.addClass(this.hostElement,'wj-inputcolor');this._tbx.style.paddingLeft='24px';this._ePreview=n.createElement('<div class="wj-inputcolorbox" style="position:absolute;left:6px;top:6px;width:12px;bottom:6px;border:1px solid black"></div>');this.hostElement.style.position='relative';this.hostElement.appendChild(this._ePreview);this._orgTag=='INPUT'&&(this._tbx.type='',this._commitText());this.value='#ffffff';this.isRequired=!0;this.initialize(r);this.addEventListener(this._colorPicker.hostElement,'click',function(t){var i=t.target,r;i&&i.tagName=='DIV'&&(n.closest(i,'[wj-part="div-pal"]')||n.closest(i,'[wj-part="div-pv"]'))&&(r=i.style.backgroundColor,r&&(u.isDroppedDown=!1))})}return __extends(r,i),Object.defineProperty(r.prototype,"value",{get:function(){return this._value},set:function(t){t!=this.value&&(t||!this.isRequired)&&(this.text=n.asString(t))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"text",{get:function(){return this._tbx.value},set:function(t){t!=this.text&&(this._setText(n.asString(t),!0),this._commitText())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"showAlphaChannel",{get:function(){return this._colorPicker.showAlphaChannel},set:function(n){this._colorPicker.showAlphaChannel=n},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"colorPicker",{get:function(){return this._colorPicker},enumerable:!0,configurable:!0}),r.prototype.onValueChanged=function(n){this.valueChanged.raise(this,n)},r.prototype._createDropDown=function(){var i=this;this._colorPicker=new t.ColorPicker(this._dropDown);n.setCss(this._dropDown,{minWidth:420,minHeight:200});this._colorPicker.valueChanged.addHandler(function(){i.value=i._colorPicker.value})},r.prototype._keydown=function(t){if(!t.defaultPrevented)switch(t.keyCode){case n.Key.Enter:this._commitText();this.selectAll();break;case n.Key.Escape:this.text=this.value;this.selectAll()}i.prototype._keydown.call(this,t)},r.prototype._commitText=function(){if(this.value!=this.text){if(!this.isRequired&&!this.text){this._value=this.text;this._ePreview.style.backgroundColor='';return}var t=n.Color.fromString(this.text);t?(this._colorPicker.value=this.text,this._value=this._colorPicker.value,this._ePreview.style.backgroundColor=this.value,this.onValueChanged()):this.text=this._value?this._value:''}},r}(t.DropDown);t.InputColor=i})(t=n.input||(n.input={}))}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var __extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},wijmo;wijmo.culture.FlexGrid={groupHeaderFormat:'{name}: <b>{value}</b> ({count:n0} items)'},function(n){var t;(function(t){'use strict';(function(n){n[n.None=0]="None";n[n.Column=1]="Column";n[n.Row=2]="Row";n[n.All=3]="All"})(t.HeadersVisibility||(t.HeadersVisibility={}));var i=t.HeadersVisibility,r=function(r){function u(u,f){var e=this,s,h,o;r.call(this,u,null,!0);this._szClient=new n.Size(0,0);this._ptScrl=new n.Point(0,0);this._rtl=!1;this._cellPadding=3;this._autoGenCols=!0;this._autoClipboard=!0;this._readOnly=!1;this._indent=14;this._autoSizeMode=t.AutoSizeMode.Both;this._hdrVis=i.All;this._alSorting=!0;this._alAddNew=!1;this._alDelete=!1;this._alResizing=t.AllowResizing.Columns;this._alDragging=t.AllowDragging.Columns;this._alMerging=t.AllowMerging.None;this._ssHdr=i.None;this._shSort=!0;this._shGroups=!0;this._shAlt=!0;this._shErr=!0;this._valEdt=!0;this._deferResizing=!1;this._pSel=!0;this._pOutline=!0;this.itemsSourceChanged=new n.Event;this.scrollPositionChanged=new n.Event;this.selectionChanging=new n.Event;this.selectionChanged=new n.Event;this.loadingRows=new n.Event;this.loadedRows=new n.Event;this.updatingLayout=new n.Event;this.updatedLayout=new n.Event;this.resizingColumn=new n.Event;this.resizedColumn=new n.Event;this.autoSizingColumn=new n.Event;this.autoSizedColumn=new n.Event;this.draggingColumn=new n.Event;this.draggedColumn=new n.Event;this.resizingRow=new n.Event;this.resizedRow=new n.Event;this.autoSizingRow=new n.Event;this.autoSizedRow=new n.Event;this.draggingRow=new n.Event;this.draggedRow=new n.Event;this.groupCollapsedChanging=new n.Event;this.groupCollapsedChanged=new n.Event;this.sortingColumn=new n.Event;this.sortedColumn=new n.Event;this.beginningEdit=new n.Event;this.prepareCellForEdit=new n.Event;this.cellEditEnding=new n.Event;this.cellEditEnded=new n.Event;this.rowEditStarting=new n.Event;this.rowEditStarted=new n.Event;this.rowEditEnding=new n.Event;this.rowEditEnded=new n.Event;this.rowAdded=new n.Event;this.deletingRow=new n.Event;this.deletedRow=new n.Event;this.copying=new n.Event;this.copied=new n.Event;this.pasting=new n.Event;this.pasted=new n.Event;this.pastingCell=new n.Event;this.pastedCell=new n.Event;this.formatItem=new n.Event;this.updatingView=new n.Event;this.updatedView=new n.Event;this._mappedColumns=null;s=this.hostElement;n.isIE()&&(s.style.borderRadius='0px');h=this.getTemplate();this.applyTemplate('wj-control wj-flexgrid wj-content',h,{_root:'root',_eSz:'sz',_eCt:'cells',_fCt:'fcells',_eTL:'tl',_eBL:'bl',_eCHdr:'ch',_eRHdr:'rh',_eCFtr:'cf',_eTLCt:'tlcells',_eBLCt:'blcells',_eCHdrCt:'chcells',_eCFtrCt:'cfcells',_eRHdrCt:'rhcells',_eMarquee:'marquee',_eFocus:'focus'});o=this._getDefaultRowHeight();this.deferUpdate(function(){e._rows=new t.RowCollection(e,o);e._cols=new t.ColumnCollection(e,o*4);e._hdrRows=new t.RowCollection(e,o);e._hdrCols=new t.ColumnCollection(e,Math.round(o*1.25));e._ftrRows=new t.RowCollection(e,o);e._gpTL=new t.GridPanel(e,t.CellType.TopLeft,e._hdrRows,e._hdrCols,e._eTLCt);e._gpCHdr=new t.GridPanel(e,t.CellType.ColumnHeader,e._hdrRows,e._cols,e._eCHdrCt);e._gpRHdr=new t.GridPanel(e,t.CellType.RowHeader,e._rows,e._hdrCols,e._eRHdrCt);e._gpCells=new t.GridPanel(e,t.CellType.Cell,e._rows,e._cols,e._eCt);e._gpBL=new t.GridPanel(e,t.CellType.BottomLeft,e._ftrRows,e._hdrCols,e._eBLCt);e._gpCFtr=new t.GridPanel(e,t.CellType.ColumnFooter,e._ftrRows,e._cols,e._eCFtrCt);e._hdrRows.push(new t.Row);e._hdrCols.push(new t.Column);e._hdrCols[0].align='center';e._cf=new t.CellFactory;e._keyHdl=new t._KeyboardHandler(e);e._mouseHdl=new t._MouseHandler(e);e._edtHdl=new t._EditHandler(e);e._selHdl=new t._SelectionHandler(e);e._addHdl=new t._AddNewHandler(e);e._mrgMgr=new t.MergeManager(e);e._bndSortConverter=e._sortConverter.bind(e);e.initialize(f)});this.addEventListener(this._root,'scroll',function(){e._updateScrollPosition()&&(e._afScrl&&cancelAnimationFrame(e._afScrl),e._afScrl=requestAnimationFrame(function(){e.finishEditing();e._updateContent(!0);e._afScrl=null}))})}return __extends(u,r),u.prototype._handleResize=function(){r.prototype._handleResize.call(this);this._rcBounds=null},Object.defineProperty(u.prototype,"headersVisibility",{get:function(){return this._hdrVis},set:function(t){t!=this._hdrVis&&(this._hdrVis=n.asEnum(t,i),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"stickyHeaders",{get:function(){return this._stickyHdr},set:function(t){var i=this;t!=this._stickyHdr&&(this._stickyHdr=n.asBoolean(t),this._updateStickyHeaders(),this.removeEventListener(window,'scroll'),this._stickyHdr&&this.addEventListener(window,'scroll',function(t){n.contains(t.target,i.hostElement)&&(i._toSticky&&cancelAnimationFrame(i._toSticky),i._toSticky=requestAnimationFrame(function(){var t=new n.CancelEventArgs;if(i.onUpdatingLayout(t)){i._updateStickyHeaders();i.onUpdatedLayout(t)}i._toSticky=null}))},!0))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"preserveSelectedState",{get:function(){return this._pSel},set:function(t){this._pSel=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"preserveOutlineState",{get:function(){return this._pOutline},set:function(t){this._pOutline=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"autoGenerateColumns",{get:function(){return this._autoGenCols},set:function(t){this._autoGenCols=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"autoClipboard",{get:function(){return this._autoClipboard},set:function(t){this._autoClipboard=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"columnLayout",{get:function(){for(var c,o,r,i,f,s=u._getSerializableProperties(t.Column),l=new t.Column,h=[],e=0;e<this.columns.length;e++){for(c=this.columns[e],o={},r=0;r<s.length;r++)i=s[r],f=c[i],f!=l[i]&&n.isPrimitive(f)&&i!='size'&&(o[i]=f);h.push(o)}return JSON.stringify({columns:h})},set:function(t){var i=JSON.parse(n.asString(t));if(!i||i.columns==null)throw'Invalid columnLayout data.';this.columns.clear();this.initialize(i)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"isReadOnly",{get:function(){return this._readOnly},set:function(t){t!=this._readOnly&&(this._readOnly=n.asBoolean(t),this.finishEditing(),this.invalidate(!0),this._addHdl.updateNewRowTemplate(),n.toggleClass(this.hostElement,'wj-state-readonly',this.isReadOnly))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"imeEnabled",{get:function(){return this._imeHdl!=null},set:function(n){n!=this.imeEnabled&&(this._imeHdl&&(this._imeHdl.dispose(),this._imeHdl=null),n&&(this._imeHdl=new t._ImeHandler(this)))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowResizing",{get:function(){return this._alResizing},set:function(i){this._alResizing=n.asEnum(i,t.AllowResizing)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"deferResizing",{get:function(){return this._deferResizing},set:function(t){this._deferResizing=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"autoSizeMode",{get:function(){return this._autoSizeMode},set:function(i){this._autoSizeMode=n.asEnum(i,t.AutoSizeMode)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowSorting",{get:function(){return this._alSorting},set:function(t){this._alSorting=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowAddNew",{get:function(){return this._alAddNew},set:function(t){t!=this._alAddNew&&(this._alAddNew=n.asBoolean(t),this._addHdl.updateNewRowTemplate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"newRowAtTop",{get:function(){return this._addHdl.newRowAtTop},set:function(t){this._addHdl.newRowAtTop=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowDelete",{get:function(){return this._alDelete},set:function(t){t!=this._alDelete&&(this._alDelete=n.asBoolean(t))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowMerging",{get:function(){return this._alMerging},set:function(i){i!=this._alMerging&&(this._alMerging=n.asEnum(i,t.AllowMerging),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showSelectedHeaders",{get:function(){return this._ssHdr},set:function(t){t!=this._ssHdr&&(this._ssHdr=n.asEnum(t,i),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showMarquee",{get:function(){return!this._eMarquee.style.display},set:function(t){if(t!=this.showMarquee){var i=this._eMarquee.style;i.visibility='collapse';i.display=n.asBoolean(t)?'':'none';this.invalidate()}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showSort",{get:function(){return this._shSort},set:function(t){t!=this._shSort&&(this._shSort=n.asBoolean(t),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showGroups",{get:function(){return this._shGroups},set:function(t){t!=this._shGroups&&(this._shGroups=n.asBoolean(t),this._bindGrid(!1))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showAlternatingRows",{get:function(){return this._shAlt},set:function(t){t!=this._shAlt&&(this._shAlt=n.asBoolean(t),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showErrors",{get:function(){return this._shErr},set:function(t){t!=this._shErr&&(this._shErr=n.asBoolean(t),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"validateEdits",{get:function(){return this._valEdt},set:function(t){this._valEdt=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"groupHeaderFormat",{get:function(){return this._gHdrFmt},set:function(t){t!=this._gHdrFmt&&(this._gHdrFmt=n.asString(t),this._bindGrid(!1))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowDragging",{get:function(){return this._alDragging},set:function(i){i!=this._alDragging&&(this._alDragging=n.asEnum(i,t.AllowDragging),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"itemsSource",{get:function(){return this._items},set:function(t){var i;t!=this._items&&(this._cv&&(i=n.tryCast(this._cv,n.collections.CollectionView),i&&i.sortConverter==this._bndSortConverter&&(i.sortConverter=null),this._cv.currentChanged.removeHandler(this._cvCurrentChanged,this),this._cv.collectionChanged.removeHandler(this._cvCollectionChanged,this),this._cv=null),this._items=t,this._cv=this._getCollectionView(t),this._lastCount=0,this._cv&&(this._cv.currentChanged.addHandler(this._cvCurrentChanged,this),this._cv.collectionChanged.addHandler(this._cvCollectionChanged,this),i=n.tryCast(this._cv,n.collections.CollectionView),i&&!i.sortConverter&&(i.sortConverter=this._bndSortConverter)),this._bindGrid(!0),this.onItemsSourceChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"collectionView",{get:function(){return this._cv},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"childItemsPath",{get:function(){return this._childItemsPath},set:function(t){t!=this._childItemsPath&&(n.assert(t==null||n.isArray(t)||n.isString(t),'childItemsPath should be an array or a string.'),this._childItemsPath=t,this._bindGrid(!0))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"cells",{get:function(){return this._gpCells},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"columnHeaders",{get:function(){return this._gpCHdr},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"columnFooters",{get:function(){return this._gpCFtr},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"rowHeaders",{get:function(){return this._gpRHdr},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"topLeftCells",{get:function(){return this._gpTL},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"bottomLeftCells",{get:function(){return this._gpBL},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"rows",{get:function(){return this._rows},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"columns",{get:function(){return this._cols},enumerable:!0,configurable:!0}),u.prototype.getColumn=function(n){return this.columns.getColumn(n)},Object.defineProperty(u.prototype,"frozenRows",{get:function(){return this.rows.frozen},set:function(n){this.rows.frozen=n},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"frozenColumns",{get:function(){return this.columns.frozen},set:function(n){this.columns.frozen=n},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"sortRowIndex",{get:function(){return this._sortRowIndex},set:function(t){t!=this._sortRowIndex&&(this._sortRowIndex=n.asNumber(t,!0),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"scrollPosition",{get:function(){return this._ptScrl.clone()},set:function(n){var t=this._root,i=-n.x;if(this._rtl)switch(u._getRtlMode()){case'rev':i=t.scrollWidth-t.clientWidth+n.x;break;case'neg':i=n.x;break;default:i=-n.x}t.scrollLeft=i;t.scrollTop=-n.y},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"clientSize",{get:function(){return this._szClient},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"controlRect",{get:function(){return this._rcBounds||(this._rcBounds=n.getElementRect(this._root)),this._rcBounds},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"scrollSize",{get:function(){return new n.Size(this._gpCells.width,this._heightBrowser)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"viewRange",{get:function(){return this._gpCells.viewRange},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"cellFactory",{get:function(){return this._cf},set:function(i){i!=this._cf&&(this._cf=n.asType(i,t.CellFactory,!1),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"itemFormatter",{get:function(){return this._itemFormatter},set:function(t){t!=this._itemFormatter&&(this._itemFormatter=n.asFunction(t),this.invalidate())},enumerable:!0,configurable:!0}),u.prototype.getCellData=function(n,t,i){return this.cells.getCellData(n,t,i)},u.prototype.getCellBoundingRect=function(n,t,i){return this.cells.getCellBoundingRect(n,t,i)},u.prototype.setCellData=function(n,t,i,r,u){return r===void 0&&(r=!0),u===void 0&&(u=!0),this.cells.setCellData(n,t,i,r,u)},u.prototype.hitTest=function(i,r){return n.isNumber(i)&&n.isNumber(r)&&(i=new n.Point(i,r)),new t.HitTestInfo(this,i)},u.prototype.getClipString=function(i){var r='',h=!0,s=!0,u,f,e,o;if(!i){i=this.selection;switch(this.selectionMode){case t.SelectionMode.Row:case t.SelectionMode.RowRange:i.col=0;i.col2=this.columns.length-1;break;case t.SelectionMode.ListBox:for(i.col=0,i.col2=this.columns.length-1,u=0;u<this.rows.length;u++)this.rows[u].isSelected&&this.rows[u].isVisible&&(i.row=i.row2=u,r&&(r+='\n'),r+=this.getClipString(i));return r}}for(i=n.asType(i,t.CellRange),f=i.topRow;f<=i.bottomRow;f++)if(this.rows[f].isVisible)for(h||(r+='\n'),h=!1,e=i.leftCol,s=!0;e<=i.rightCol;e++)this.columns[e].isVisible&&(s||(r+='\t'),s=!1,o=this.cells.getCellData(f,e,!0).toString(),o=o.replace(/\t/g,' '),r+=o);return r},u.prototype.setClipString=function(i,r){var y=r==null,e,s,l,u,h,o;if(!r){r=this.selection;switch(this.selectionMode){case t.SelectionMode.Row:case t.SelectionMode.RowRange:case t.SelectionMode.ListBox:r.col=0;r.col2=this.columns.length-1}}r=n.asType(r,t.CellRange);i=n.asString(i).replace(/\r\n/g,'\n').replace(/\r/g,'\n');i&&i[i.length-1]=='\n'&&(i=i.substring(0,i.length-1));y&&!r.isSingleCell&&(i=this._expandClipString(i,r));e=new t.CellRange(r.topRow,r.leftCol);this.beginUpdate();var f=r.topRow,a=i.split('\n'),v=!1,c;for(s=0;s<a.length&&f<this.rows.length;s++,f++){if(!this.rows[f].isVisible){s--;continue}for(l=a[s].split('\t'),u=r.leftCol,h=0;h<l.length&&u<this.columns.length;h++,u++){if(!this.columns[u].isVisible){h--;continue}if(!this.columns[u].isReadOnly&&!this.rows[f].isReadOnly){if(c=new t.CellRangeEventArgs(this.cells,new t.CellRange(f,u),l[h]),this.onPastingCell(c)&&this.cells.setCellData(f,u,c.data)){this.onPastedCell(c);v=!0}e.row2=Math.max(e.row2,f);e.col2=Math.max(e.col2,u)}}}this.endUpdate();v&&(o=n.tryCast(this.collectionView,'IEditableCollectionView'),o&&o.currentItem==o.currentAddItem?o.editItem(o.currentItem):this.collectionView&&this.collectionView.refresh());this.select(e)},u.prototype._expandClipString=function(n,t){var s,r,u,i,f;if(!n)return n;var h=n.split('\n'),o=h.length,e=0,c=[];for(i=0;i<o;i++){if(s=h[i].split('\t'),c.push(s),i>1&&s.length!=e)return n;e=s.length}if(r=t.rowSpan,u=t.columnSpan,(r>1||u>1)&&(r==1&&(r=o),u==1&&(u=e),u%e==0&&r%o==0))for(n='',i=0;i<r;i++)for(f=0;f<u;f++)i>0&&f==0&&(n+='\n'),f>0&&(n+='\t'),n+=c[i%o][f%e];return n},u.prototype.focus=function(){var t,i;if(this.activeEditor){this.activeEditor.focus();return}if(n.getActiveElement()!=this._eFocus){if(t=this.hostElement.getBoundingClientRect(),t.bottom>0&&t.right>0&&t.top<innerHeight&&t.left<innerWidth){n.setCss(this._eFocus,{top:Math.max(0,-t.top),left:Math.max(0,-t.left)});this._eFocus.focus();return}if(i=this.cells.hostElement.querySelector('.wj-cell.wj-state-selected'),i){i.focus();return}r.prototype.focus.call(this)}},u.prototype.containsFocus=function(){var n=this._edtHdl?this._edtHdl._lbx:null;return r.prototype.containsFocus.call(this)||n!=null&&n.containsFocus()},u.prototype.dispose=function(){this.finishEditing(!0);this.itemsSource=null;this._afScrl&&cancelAnimationFrame(this._afScrl);r.prototype.dispose.call(this)},u.prototype.refresh=function(n){n===void 0&&(n=!0);r.prototype.refresh.call(this,n);this.finishEditing();n&&(this._updateColumnTypes(),this.scrollPosition=this._ptScrl);this.refreshCells(n)},u.prototype.refreshCells=function(n,t,i){this.isUpdating||(n?this._updateLayout():this._updateContent(t,i))},u.prototype.autoSizeColumn=function(n,t,i){t===void 0&&(t=!1);i===void 0&&(i=4);this.autoSizeColumns(n,n,t,i)},u.prototype.autoSizeColumns=function(i,r,f,e){var h=this;f===void 0&&(f=!1);e===void 0&&(e=4);var s=0,l=f?this.topLeftCells:this.columnHeaders,o=f?this.rowHeaders:this.cells,c=this.viewRange,a,v;i=i==null?0:n.asInt(i);r=r==null?o.columns.length-1:n.asInt(r);n.asBoolean(f);n.asNumber(e);c.row=Math.max(0,c.row-1e3);c.row2=Math.min(c.row2+1e3,this.rows.length-1);this.deferUpdate(function(){var p=document.createElement('div'),y,n,w;for(p.setAttribute(u._WJS_MEASURE,'true'),p.style.visibility='hidden',h.hostElement.appendChild(p),y=i;y<=r&&y>-1&&y<o.columns.length;y++){if(s=0,h.autoSizeMode&t.AutoSizeMode.Headers)for(n=0;n<l.rows.length;n++)l.rows[n].isVisible&&(w=h._getDesiredWidth(l,n,y,p),s=Math.max(s,w));if(h.autoSizeMode&t.AutoSizeMode.Cells)for(v=null,n=c.row;n<=c.row2&&n>-1&&n<o.rows.length;n++)o.rows[n].isVisible&&(!f&&y==o.columns.firstVisibleIndex&&o.rows.maxGroupLevel>-1?(w=h._getDesiredWidth(o,n,y,p),s=Math.max(s,w)):(a=o.getCellData(n,y,!0),a!=v&&(v=a,w=h._getDesiredWidth(o,n,y,p),s=Math.max(s,w))));o.columns[y].width=s+e+2}h.hostElement.removeChild(p)})},u.prototype.autoSizeRow=function(n,t,i){t===void 0&&(t=!1);i===void 0&&(i=0);this.autoSizeRows(n,n,t,i)},u.prototype.autoSizeRows=function(i,r,f,e){var o=this;f===void 0&&(f=!1);e===void 0&&(e=0);var s=0,c=f?this.topLeftCells:this.rowHeaders,h=f?this.columnHeaders:this.cells;f=n.asBoolean(f);e=n.asNumber(e);i=i==null?0:n.asInt(i);r=r==null?h.rows.length-1:n.asInt(r);this.deferUpdate(function(){var l=document.createElement('div'),f,n,a;for(l.setAttribute(u._WJS_MEASURE,'true'),l.style.visibility='hidden',o.hostElement.appendChild(l),f=i;f<=r&&f>-1&&f<h.rows.length;f++){if(s=0,o.autoSizeMode&t.AutoSizeMode.Headers)for(n=0;n<c.columns.length;n++)c.columns[n].renderSize>0&&(a=o._getDesiredHeight(c,f,n,l),s=Math.max(s,a));if(o.autoSizeMode&t.AutoSizeMode.Cells)for(n=0;n<h.columns.length;n++)h.columns[n].renderSize>0&&(a=o._getDesiredHeight(h,f,n,l),s=Math.max(s,a));h.rows[f].height=s+e}o.hostElement.removeChild(l)})},Object.defineProperty(u.prototype,"treeIndent",{get:function(){return this._indent},set:function(t){t!=this._indent&&(this._indent=n.asNumber(t,!1,!0),this.columns.onCollectionChanged())},enumerable:!0,configurable:!0}),u.prototype.collapseGroupsToLevel=function(i){if(this.finishEditing()){var r=this.rows;r.deferUpdate(function(){for(var f,u=0;u<r.length;u++)f=n.tryCast(r[u],t.GroupRow),f&&(f.isCollapsed=f.level>=i)})}},Object.defineProperty(u.prototype,"selectionMode",{get:function(){return this._selHdl.selectionMode},set:function(i){i!=this.selectionMode&&(this._selHdl.selectionMode=n.asEnum(i,t.SelectionMode),this.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"selection",{get:function(){return this._selHdl.selection.clone()},set:function(n){this._selHdl.selection=n},enumerable:!0,configurable:!0}),u.prototype.select=function(n,t){t===void 0&&(t=!0);this._selHdl.select(n,t)},u.prototype.getSelectedState=function(n,t){return this.cells.getSelectedState(n,t,null)},Object.defineProperty(u.prototype,"selectedRows",{get:function(){var i=[],r,n;if(this.selectionMode==t.SelectionMode.ListBox)for(n=0;n<this.rows.length;n++)this.rows[n].isSelected&&i.push(this.rows[n]);else if(this.rows.length)for(r=this.selection,n=r.topRow;n>-1&&n<=r.bottomRow;n++)i.push(this.rows[n]);return i},set:function(i){var r=this;n.assert(this.selectionMode==t.SelectionMode.ListBox,'This property can be set only in ListBox mode.');i=n.asArray(i);this.deferUpdate(function(){for(var u,f,n=0,t=!0;n<r.rows.length;n++)u=r.rows[n],f=i&&i.indexOf(u)>-1,f&&t&&(t=!1,r.select(n,r.selection.col)),u.isSelected=f})},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"selectedItems",{get:function(){for(var n=this.selectedRows,t=0;t<n.length;t++)n[t]=n[t].dataItem;return n},set:function(i){var r=this;n.assert(this.selectionMode==t.SelectionMode.ListBox,'This property can be set only in ListBox mode.');i=n.asArray(i);this.deferUpdate(function(){for(var u,f,n=0,t=!0;n<r.rows.length;n++)u=r.rows[n],f=i&&i.indexOf(u.dataItem)>-1,f&&t&&(t=!1,r.select(n,r.selection.col)),u.isSelected=f})},enumerable:!0,configurable:!0}),u.prototype.scrollIntoView=function(t,i){var u,h;this._maxOffsetY==null&&this._updateLayout();var r=this.scrollPosition,c=this._szClient.width,f=this._szClient.height-this._gpCFtr.rows.getTotalSize(),e=this.cells._getFrozenPos();if(t=n.asInt(t),t>-1&&t<this._rows.length&&t>=this._rows.frozen){var s=this._rows[t],a=this.cells.height>f?Math.round(s.pos/(this.cells.height-f)*100)/100:0,v=Math.round(this._maxOffsetY*a),o=s.pos-v,l=o+s.renderSize-1;l>f-r.y&&(r.y=Math.max(-o,f-l));o-e.y<-r.y&&(r.y=-(o-e.y))}return(i=n.asInt(i),i>-1&&i<this._cols.length&&i>=this._cols.frozen&&(u=this._cols[i],h=u.pos+u.renderSize-1,h>-r.x+c&&(r.x=Math.max(-u.pos,c-h)),u.pos-e.x<-r.x&&(r.x=-(u.pos-e.x))),!r.equals(this._ptScrl))?(this.scrollPosition=r,!0):!1},u.prototype.isRangeValid=function(n){return n.isValid&&n.bottomRow<this.rows.length&&n.rightCol<this.columns.length},u.prototype.startEditing=function(n,t,i,r){return n===void 0&&(n=!0),this._edtHdl.startEditing(n,t,i,r)},u.prototype.finishEditing=function(n){return n===void 0&&(n=!1),this._edtHdl.finishEditing(n)},Object.defineProperty(u.prototype,"activeEditor",{get:function(){return this._edtHdl.activeEditor},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"editRange",{get:function(){return this._edtHdl.editRange},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"mergeManager",{get:function(){return this._mrgMgr},set:function(i){i!=this._mrgMgr&&(this._mrgMgr=n.asType(i,t.MergeManager,!0),this.invalidate())},enumerable:!0,configurable:!0}),u.prototype.getMergedRange=function(n,t,i,r){return r===void 0&&(r=!0),this._mrgMgr?this._mrgMgr.getMergedRange(n,t,i,r):null},u.prototype.onItemsSourceChanged=function(n){this.itemsSourceChanged.raise(this,n)},u.prototype.onScrollPositionChanged=function(n){this.scrollPositionChanged.raise(this,n)},u.prototype.onSelectionChanging=function(n){return this.selectionChanging.raise(this,n),!n.cancel},u.prototype.onSelectionChanged=function(n){this.selectionChanged.raise(this,n)},u.prototype.onLoadingRows=function(n){return this.loadingRows.raise(this,n),!n.cancel},u.prototype.onLoadedRows=function(n){this.loadedRows.raise(this,n)},u.prototype.onUpdatingLayout=function(n){return this.updatingLayout.raise(this,n),!n.cancel},u.prototype.onUpdatedLayout=function(n){this.updatedLayout.raise(this,n)},u.prototype.onResizingColumn=function(n){return this.resizingColumn.raise(this,n),!n.cancel},u.prototype.onResizedColumn=function(n){this.resizedColumn.raise(this,n)},u.prototype.onAutoSizingColumn=function(n){return this.autoSizingColumn.raise(this,n),!n.cancel},u.prototype.onAutoSizedColumn=function(n){this.autoSizedColumn.raise(this,n)},u.prototype.onDraggingColumn=function(n){return this.draggingColumn.raise(this,n),!n.cancel},u.prototype.onDraggedColumn=function(n){this.draggedColumn.raise(this,n)},u.prototype.onResizingRow=function(n){return this.resizingRow.raise(this,n),!n.cancel},u.prototype.onResizedRow=function(n){this.resizedRow.raise(this,n)},u.prototype.onAutoSizingRow=function(n){return this.autoSizingRow.raise(this,n),!n.cancel},u.prototype.onAutoSizedRow=function(n){this.autoSizedRow.raise(this,n)},u.prototype.onDraggingRow=function(n){return this.draggingRow.raise(this,n),!n.cancel},u.prototype.onDraggedRow=function(n){this.draggedRow.raise(this,n)},u.prototype.onGroupCollapsedChanging=function(n){return this.groupCollapsedChanging.raise(this,n),!n.cancel},u.prototype.onGroupCollapsedChanged=function(n){this.groupCollapsedChanged.raise(this,n)},u.prototype.onSortingColumn=function(n){return this.sortingColumn.raise(this,n),!n.cancel},u.prototype.onSortedColumn=function(n){this.sortedColumn.raise(this,n)},u.prototype.onBeginningEdit=function(n){return this.beginningEdit.raise(this,n),!n.cancel},u.prototype.onPrepareCellForEdit=function(n){this.prepareCellForEdit.raise(this,n)},u.prototype.onCellEditEnding=function(n){return this.cellEditEnding.raise(this,n),!n.cancel&&!n.stayInEditMode},u.prototype.onCellEditEnded=function(n){this.cellEditEnded.raise(this,n)},u.prototype.onRowEditStarting=function(n){this.rowEditStarting.raise(this,n)},u.prototype.onRowEditStarted=function(n){this.rowEditStarted.raise(this,n)},u.prototype.onRowEditEnding=function(n){this.rowEditEnding.raise(this,n)},u.prototype.onRowEditEnded=function(n){this.rowEditEnded.raise(this,n)},u.prototype.onRowAdded=function(n){this.rowAdded.raise(this,n)},u.prototype.onDeletingRow=function(n){return this.deletingRow.raise(this,n),!n.cancel},u.prototype.onDeletedRow=function(n){this.deletedRow.raise(this,n)},u.prototype.onCopying=function(n){return this.copying.raise(this,n),!n.cancel},u.prototype.onCopied=function(n){this.copied.raise(this,n)},u.prototype.onPasting=function(n){return this.pasting.raise(this,n),!n.cancel},u.prototype.onPasted=function(n){this.pasted.raise(this,n)},u.prototype.onPastingCell=function(n){return this.pastingCell.raise(this,n),!n.cancel},u.prototype.onPastedCell=function(n){this.pastedCell.raise(this,n)},u.prototype.onFormatItem=function(n){this.formatItem.raise(this,n)},u.prototype.onUpdatingView=function(n){return this.updatingView.raise(this,n),!n.cancel},u.prototype.onUpdatedView=function(n){this.updatedView.raise(this,n)},u.prototype._getDefaultRowHeight=function(){var f=this.hostElement,t=document.body,i=null,r,e,u;if(t&&!n.contains(t,f)){for(r=f;r;r=r.parentElement)i=r;i&&t.appendChild(i)}return e=n.createElement('<div class="wj-cell">123</div>',f),u=e.scrollHeight+2,f.removeChild(e),i&&t.removeChild(i),(u<=6||isNaN(u)||!t)&&(u=28),u},u.prototype._getCollectionView=function(t){return n.asCollectionView(t)},u.prototype._getDesiredWidth=function(n,t,i,r){var u=this.getMergedRange(n,t,i),f;return this.cellFactory.updateCell(n,t,i,r,u),r.style.width='',f=r.offsetWidth,u&&u.columnSpan>1?f/u.columnSpan:f},u.prototype._getDesiredHeight=function(n,t,i,r){var u=this.getMergedRange(n,t,i),f;return this.cellFactory.updateCell(n,t,i,r,u),r.style.height='',f=r.offsetHeight,u&&u.rowSpan>1?f/u.rowSpan:f},u.prototype._getSortRowIndex=function(){return this._sortRowIndex!=null?this._sortRowIndex:this.columnHeaders.rows.length-1},u.prototype._sortConverter=function(n,t,i,r){var u,o,f,e;if(r){if(this._mappedColumns=null,this.collectionView)for(o=this.collectionView.sortDescriptions,f=0;f<o.length;f++)u=this.columns.getColumn(o[f].property),u&&u.dataMap&&(this._mappedColumns||(this._mappedColumns={}),this._mappedColumns[u.binding]=u.dataMap);this._mouseHdl._htDown&&this._mouseHdl._htDown.col>-1&&(u=this.columns[this._mouseHdl._htDown.col],this._mappedColumns&&u.dataMap&&(this._mappedColumns[u.binding]=u.dataMap))}return this._mappedColumns&&(e=this._mappedColumns[n.property],e&&e.sortByDisplayValues&&(i=e.getDisplayValue(i))),i},u.prototype._bindGrid=function(i){var r=this;this.deferUpdate(function(){var f,s,h,e,o,c,l,u;if(r._lastCount==0&&r._cv&&r._cv.items&&r._cv.items.length&&(i=!0),f=[],r.preserveSelectedState&&r.selectionMode==t.SelectionMode.ListBox)for(u=0;u<r.rows.length;u++)s=r.rows[u],s.isSelected&&s.dataItem&&f.push(s.dataItem);if(r.preserveOutlineState&&n.isFunction(window.Map)&&r.rows.maxGroupLevel>-1)for(h=new Map,u=0;u<r.rows.length;u++)e=r.rows[u],e instanceof t.GroupRow&&e.isCollapsed&&e.dataItem&&(o=e.dataItem,o instanceof n.collections.CollectionViewGroup&&(o=o._path),h.set(o,!0));if(i&&r.columns.deferUpdate(function(){r._bindColumns()}),r.rows.deferUpdate(function(){r._bindRows()}),c=0,f.length)for(u=0;u<r.rows.length&&c<f.length;u++)f.indexOf(r.rows[u].dataItem)>-1&&(r.rows[u].isSelected=!0,c++);if(r.selectionMode==t.SelectionMode.ListBox&&c==0)for(l=r.selection,u=l.topRow;u<=l.bottomRow&&u>-1&&u<r.rows.length;u++)r.rows[u].isSelected=!0;h&&r.rows.deferUpdate(function(){for(var f,i,u=0;u<r.rows.length;u++)f=r.rows[u],f instanceof t.GroupRow&&(i=f.dataItem,i instanceof n.collections.CollectionViewGroup&&(i=i._path),h.get(i)&&(f.isCollapsed=!0))});!r._lastCount&&r._cv&&r._cv.items&&(r._lastCount=r._cv.items.length)});this.collectionView&&this._cvCurrentChanged(this.collectionView,n.EventArgs.empty)},u.prototype._cvCollectionChanged=function(i,r){var u;if(this.autoGenerateColumns&&this.columns.length==0){this._bindGrid(!0);return}if(this.childItemsPath&&r.action!=n.collections.NotifyCollectionChangedAction.Change){this._bindGrid(!1);return}switch(r.action){case n.collections.NotifyCollectionChangedAction.Change:this.invalidate();return;case n.collections.NotifyCollectionChangedAction.Add:if(r.index==this.collectionView.items.length-1){u=this.rows.length;this.rows[u-1]instanceof t._NewRowTemplate&&u--;this.rows.insert(u,new t.Row(r.item));return}n.assert(!1,'added item should be the last one.');break;case n.collections.NotifyCollectionChangedAction.Remove:if(u=this._findRow(r.item),u>-1){this.rows.removeAt(u);this._cvCurrentChanged(i,r);return}n.assert(!1,'removed item not found in grid.')}this._bindGrid(!1)},u.prototype._cvCurrentChanged=function(){if(this.collectionView){var i=this.selection,r=i.row>-1&&i.row<this.rows.length?this.rows[i.row].dataItem:null;r instanceof n.collections.CollectionViewGroup&&(r=null);r!=this.collectionView.currentItem&&(i.row=i.row2=this._getRowIndex(this.collectionView.currentPosition),this.select(i,!1),this.selectionMode!=t.SelectionMode.None&&this.scrollIntoView(i.row,-1))}},u.prototype._getRowIndex=function(n){var r,n,i;if(this.collectionView){if(n>-1){for(r=this.collectionView.items[n];n<this.rows.length;n++)if(this.rows[n].dataItem===r)return n;return-1}return this.rows.length==1&&this.rows[0]instanceof t._NewRowTemplate?0:(n=this.selection.row,i=n>-1?this.rows[n]:null,i&&(i instanceof t.GroupRow||i.dataItem==null)?n:-1)}return this.selection.row},u.prototype._getCvIndex=function(n){if(n>-1&&this.collectionView){var t=this.rows[n].dataItem;for(n=Math.min(n,this.collectionView.items.length);n>-1;n--)if(this.collectionView.items[n]===t)return n}return-1},u.prototype._findRow=function(n){for(var t=0;t<this.rows.length;t++)if(this.rows[t].dataItem==n)return t;return-1},u.prototype._updateLayout=function(){var p=new n.CancelEventArgs,h,l,o,a,c;if(this.onUpdatingLayout(p)){var t=this._hdrVis&i.Row?this._hdrCols.getTotalSize():0,r=this._hdrVis&i.Column?this._hdrRows.getTotalSize():0,e=this._ftrRows.getTotalSize(),s=this._rows.getTotalSize()+e;s<1&&(s=1);this._rtl=this.hostElement?getComputedStyle(this.hostElement).direction=='rtl':!1;this._heightBrowser=Math.min(s,u._getMaxSupportedCssHeight());this._maxOffsetY=Math.max(0,s-this._heightBrowser);this.cells.hostElement&&(h=n.createElement('<div class="wj-cell"></div>',this.cells.hostElement),l=getComputedStyle(h),this._cellPadding=parseInt(this._rtl?l.paddingRight:l.paddingLeft),h.parentElement.removeChild(h));o=this._heightBrowser+r-e;this._rtl?(n.setCss(this._eTL,{right:0,top:0,width:t,height:r}),n.setCss(this._eCHdr,{right:t,top:0,height:r}),n.setCss(this._eRHdr,{right:0,top:r,width:t}),n.setCss(this._eCt,{right:t,top:r,width:this._gpCells.width,height:this._heightBrowser}),n.setCss(this._fCt,{right:t,top:r}),n.setCss(this._eBL,{right:0,top:o,width:t,height:e}),n.setCss(this._eCFtr,{right:t,top:o,height:e})):(n.setCss(this._eTL,{left:0,top:0,width:t,height:r}),n.setCss(this._eCHdr,{left:t,top:0,height:r}),n.setCss(this._eRHdr,{left:0,top:r,width:t}),n.setCss(this._eCt,{left:t,top:r,width:this._gpCells.width,height:this._heightBrowser}),n.setCss(this._fCt,{left:t,top:r}),n.setCss(this._eBL,{left:0,top:o,width:t,height:e}),n.setCss(this._eCFtr,{left:t,top:o,height:e}));this._stickyHdr&&this._updateStickyHeaders();a=[this._eTL,this._eBL,this._eCHdr,this._eCFtr,this._eRHdr,this._eMarquee];n.isIE()&&(this.frozenRows||this.frozenColumns)&&this.showMarquee?n.setCss(a,{zIndex:1}):n.setCss(a,{zIndex:''});var f=this._root,v=f.offsetWidth-f.clientWidth,y=f.offsetHeight-f.clientHeight;n.setCss(this._eSz,{width:t+v+this._gpCells.width,height:r+y+this._heightBrowser});c=null;this.columns._updateStarSizes(f.clientWidth-t)&&(c=f.clientWidth,n.setCss(this._eCt,{width:this._gpCells.width}));this._szClient=new n.Size(f.clientWidth-t,f.clientHeight-r);this._rcBounds=null;this._updateContent(!1);v=f.offsetWidth-f.clientWidth;y=f.offsetHeight-f.clientHeight;n.setCss(this._eSz,{width:t+v+this._gpCells.width,height:r+y+this._heightBrowser});this._szClient=new n.Size(f.clientWidth-t,f.clientHeight-r);c&&c!=f.clientWidth&&this.columns._updateStarSizes(f.clientWidth-t)&&(n.setCss(this._eCt,{width:this._gpCells.width}),this._updateContent(!1));n.setCss([this._eCHdr,this._eCFtr,this._fCt],{width:this._szClient.width});n.setCss([this._eRHdr,this._fCt],{height:this._szClient.height});e&&(o=Math.min(o,this._szClient.height+r-e),n.setCss([this._eBL,this._eCFtr],{top:o}));this.onUpdatedLayout(p)}},u.prototype._updateStickyHeaders=function(){var r=!1,o=0,f,t,i,e;if(this._stickyHdr){for(f=0,t=null,i=this.hostElement;i;i=i.parentElement)e=i.getBoundingClientRect(),t==null&&(t=e.top),f=Math.max(f,e.top);t=Math.max(0,f-t-1);o=-t;r=t>0}this._eTL.style.top=this._eCHdr.style.top=r?-o+'px':'';n.toggleClass(this._eTL,u._WJS_STICKY,r);n.toggleClass(this._eCHdr,u._WJS_STICKY,r)},u.prototype._updateScrollPosition=function(){var t=this._root,f=t.scrollTop,i=t.scrollLeft,r;return(this._rtl&&u._getRtlMode()=='rev'&&(i=t.scrollWidth-t.clientWidth-i),r=new n.Point(-Math.abs(i),-f),!this._ptScrl.equals(r))?(this._ptScrl=r,this.onScrollPositionChanged(),!0):!1},u.prototype._updateContent=function(t,r){var a=this,v=this.containsFocus(),y=n.contains(this.columnHeaders.hostElement,n.getActiveElement()),o=new n.CancelEventArgs,s,e,u;if(this.onUpdatingView(o)){if(this._offsetY=0,this._heightBrowser>this._szClient.height&&(s=Math.round(-this._ptScrl.y/(this._heightBrowser-this._szClient.height)*100)/100,this._offsetY=Math.round(this._maxOffsetY*s)),this._updateScrollPosition(),this._gpCells._updateContent(t,r,this._offsetY),this._hdrVis&i.Column&&(!r||this._ssHdr&i.Column)&&this._gpCHdr._updateContent(t,r,0),this._hdrVis&i.Row&&(!r||this._ssHdr&i.Row)&&this._gpRHdr._updateContent(t,r,this._offsetY),this._hdrVis&&!r&&this._gpTL._updateContent(t,r,0),this._gpCFtr.rows.length&&(this._gpBL._updateContent(t,r,0),this._gpCFtr._updateContent(t,r,0)),this.showMarquee)if(e=this._selHdl._sel,u=this._eMarquee,this.isRangeValid(e)){var f=this._getMarqueeRect(e),h=u.firstChild,c=u.offsetWidth-h.offsetWidth,l=u.offsetHeight-h.offsetHeight;n.setCss(u,{left:f.left+this.cells.hostElement.offsetLeft-c/2,top:f.top+this.cells.hostElement.offsetTop-l/2,width:f.width+c,height:f.height+l,visibility:f.width>0&&f.height>0?'':'collapse'})}else n.setCss(u,{left:0,top:0,width:0,height:0,visibility:'collapse'});this._updateFrozenCells();v&&!r&&setTimeout(function(){a.focus()},10);this._rcBounds=null;this.onUpdatedView(o)}},u.prototype._updateFrozenCells=function(){var i,t;if(n.isIE()&&(n.setText(this._fCt,null),!this.activeEditor&&(this.frozenRows||this.frozenColumns)))for(i=this._eCt.querySelectorAll('.wj-frozen'),t=0;t<i.length;t++)this._fCt.appendChild(i[t].cloneNode(!0))},u.prototype._getMarqueeRect=function(i){var s=this.getMergedRange(this.cells,i.topRow,i.leftCol)||new t.CellRange(i.topRow,i.leftCol),h=this.getMergedRange(this.cells,i.bottomRow,i.rightCol)||new t.CellRange(i.bottomRow,i.rightCol),r=this.cells.getCellBoundingRect(s.topRow,s.leftCol,!0),f=this.cells.getCellBoundingRect(h.bottomRow,h.rightCol,!0),o,e,u;return this.rows.frozen&&(o=Math.min(this.rows.length,this.rows.frozen),u=this.cells.getCellBoundingRect(o-1,0,!0),i.topRow>=o&&r.top<u.bottom&&(r.top=u.bottom),i.bottomRow>=o&&f.bottom<u.bottom&&(f.height=u.bottom-f.top)),this.columns.frozen&&(e=Math.min(this.columns.length,this.columns.frozen),u=this.cells.getCellBoundingRect(0,e-1,!0),this._rtl?(i.leftCol>=e&&r.right>u.left&&(r.left=u.left-r.width),i.rightCol>=e&&f.left>u.left&&(f.left=u.left)):(i.leftCol>=e&&r.left<u.right&&(r.left=u.right),i.rightCol>=e&&f.right<u.right&&(f.width=u.right-f.left))),this._rtl?new n.Rect(f.left,r.top,r.right-f.left,f.bottom-r.top):new n.Rect(r.left,r.top,f.right-r.left,f.bottom-r.top)},u.prototype._bindColumns=function(){for(var i,f,e,o,s,r=0;r<this.columns.length;r++)i=this.columns[r],i._getFlag(t.RowColFlags.AutoGenerated)&&(this.columns.removeAt(r),r--);var c=this.collectionView,u=c?c.sourceCollection:null,h=u&&u.length?u[0]:null;if(h&&this.autoGenerateColumns)for(f in h)for(e=null,o=0;o<u.length&&o<1e3&&e==null;o++)e=u[o][f],n.isPrimitive(e)&&(i=new t.Column,i._setFlag(t.RowColFlags.AutoGenerated,!0),i.binding=i.name=f,i.header=n.toHeaderCase(f),i.dataType=n.getType(e),i.dataType==n.DataType.Number&&(i.width=80),s=Object.getOwnPropertyDescriptor(h,f),!s||s.writable||n.isFunction(s.set)||i._setFlag(t.RowColFlags.ReadOnly,!0),this.columns.push(i));this._updateColumnTypes()},u.prototype._updateColumnTypes=function(){var u=this.collectionView,f,r,i,t;if(n.hasItems(u))for(f=u.items[0],r=this.columns,i=0;i<r.length;i++)t=r[i],t.dataType==null&&t._binding&&(t.dataType=n.getType(t._binding.getValue(f)))},u.prototype._getBindingColumn=function(n,t,i){return i},u.prototype._bindRows=function(){var f=new n.CancelEventArgs,i,r,u,t;if(this.onLoadingRows(f)){if(this.rows.clear(),i=this.collectionView,i&&i.items)if(r=i.items,u=i.groups,this.childItemsPath)for(t=0;t<r.length;t++)this._addNode(r,t,0);else if(u!=null&&u.length>0&&this.showGroups)for(t=0;t<u.length;t++)this._addGroup(u[t]);else for(t=0;t<r.length;t++)this._addBoundRow(r,t);this.onLoadedRows(f)}},u.prototype._addBoundRow=function(n,i){this.rows.push(new t.Row(n[i]))},u.prototype._addNode=function(i,r,u){var e=new t.GroupRow,o=this.childItemsPath,c=n.isArray(o)?o[u]:o,h=i[r],s=h[c],f;if(e.dataItem=h,e.level=u,this.rows.push(e),s)for(f=0;f<s.length;f++)this._addNode(s,f,u+1)},u.prototype._addGroup=function(n){var r=new t.GroupRow,u,i;if(r.level=n.level,r.dataItem=n,this.rows.push(r),n.isBottomLevel)for(u=n.items,i=0;i<u.length;i++)this._addBoundRow(u,i);else for(i=0;i<n.groups.length;i++)this._addGroup(n.groups[i])},u._getSerializableProperties=function(n){var f=[],u,i,t,r;for(n=n.prototype;n!=Object.prototype;n=Object.getPrototypeOf(n))for(u=Object.getOwnPropertyNames(n),i=0;i<u.length;i++)t=u[i],r=Object.getOwnPropertyDescriptor(n,t),r&&r.set&&r.get&&t[0]!='_'&&!t.match(/disabled|required/)&&f.push(t);return f},u.prototype._copy=function(i,r){var f,u,e;if(i=='columns'){for(this.columns.clear(),f=n.asArray(r),u=0;u<f.length;u++)e=new t.Column,n.copy(e,f[u]),this.columns.push(e);return!0}return!1},u.prototype._isInputElement=function(n){if(n instanceof HTMLElement){var t=n.tagName.match(/^(input|select|textarea|button|a)$/i);return t&&t.length>0}return!1},u.prototype._wantsInput=function(n){return!this.activeEditor&&this._isInputElement(n)&&!n.getAttribute('wj-part')},u._getMaxSupportedCssHeight=function(){var n;if(!u._maxCssHeight){var i=1e6,t=document.createElement('div');for(t.style.visibility='hidden',document.body.appendChild(t),n=i;n<=6e7;n+=5e5){if(t.style.height=n+'px',t.offsetHeight!=n)break;i=n}document.body.removeChild(t);u._maxCssHeight=i}return u._maxCssHeight},u._getRtlMode=function(){var t,i,r;return u._rtlMode||(t=n.createElement('<div dir="rtl" style="visibility:hidden;width:100px;height:100px;overflow:auto"><div style="width:2000px;height:2000px"><\/div><\/div>'),document.body.appendChild(t),i=t.scrollLeft,t.scrollLeft=-1e3,r=t.scrollLeft,document.body.removeChild(t),u._rtlMode=r<0?'neg':i>0?'rev':'std'),u._rtlMode},u._WJS_STICKY='wj-state-sticky',u._WJS_MEASURE='wj-state-measuring',u.controlTemplate='<div style="position:relative;width:100%;height:100%;overflow:hidden;max-width:inherit;max-height:inherit"><div wj-part="focus" tabIndex="0" style="position:absolute;opacity:0;pointer-events:none;left:-10px;top:-10px"><\/div><div wj-part="root" style="position:absolute;width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch;max-width:inherit;max-height:inherit;boxSizing:content-box"><div wj-part="cells" class="wj-cells" style="position:absolute"><\/div><div wj-part="marquee" class="wj-marquee" style="display:none;pointer-events:none"><div style="width:100%;height:100%"><\/div><\/div><\/div><div wj-part="fcells" style="position:absolute;pointer-events:none;overflow:hidden"><\/div><div wj-part="rh" style="position:absolute;overflow:hidden;outline:none"><div wj-part="rhcells" class="wj-rowheaders" style="position:relative"><\/div><\/div><div wj-part="cf" style=";position:absolute;overflow:hidden;outline:none"><div wj-part="cfcells" class="wj-colfooters" style="position:relative"><\/div><\/div><div wj-part="ch" style="position:absolute;overflow:hidden;outline:none"><div wj-part="chcells" class="wj-colheaders" style="position:relative"><\/div><\/div><div wj-part="bl" style="position:absolute;overflow:hidden;outline:none"><div wj-part="blcells" class="wj-bottomleft" style="position:relative"><\/div><\/div><div wj-part="tl" style="position:absolute;overflow:hidden;outline:none"><div wj-part="tlcells" class="wj-topleft" style="position:relative"><\/div><\/div><div wj-part="sz" style="position:relative;visibility:hidden"><\/div><\/div>',u}(n.Control);t.FlexGrid=r})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i=function(i){function r(r,u,f){i.call(this);this._p=n.asType(r,t.GridPanel);this._rng=n.asType(u,t.CellRange);this._data=f}return __extends(r,i),Object.defineProperty(r.prototype,"panel",{get:function(){return this._p},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"range",{get:function(){return this._rng.clone()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"row",{get:function(){return this._rng.row},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"col",{get:function(){return this._rng.col},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"data",{get:function(){return this._data},set:function(n){this._data=n},enumerable:!0,configurable:!0}),r}(n.CancelEventArgs),r,u;t.CellRangeEventArgs=i;r=function(t){function i(i,r,u){t.call(this,i,r);this._cell=n.asType(u,HTMLElement)}return __extends(i,t),Object.defineProperty(i.prototype,"cell",{get:function(){return this._cell},enumerable:!0,configurable:!0}),i}(i);t.FormatItemEventArgs=r;u=function(t){function i(){t.apply(this,arguments)}return __extends(i,t),Object.defineProperty(i.prototype,"stayInEditMode",{get:function(){return this._stayInEditMode},set:function(t){this._stayInEditMode=n.asBoolean(t)},enumerable:!0,configurable:!0}),i}(i);t.CellEditEndingEventArgs=u})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';(function(n){n[n.None=0]="None";n[n.Cell=1]="Cell";n[n.ColumnHeader=2]="ColumnHeader";n[n.RowHeader=3]="RowHeader";n[n.TopLeft=4]="TopLeft";n[n.ColumnFooter=5]="ColumnFooter";n[n.BottomLeft=6]="BottomLeft"})(t.CellType||(t.CellType={}));var i=t.CellType,r=function(){function r(i,u,f,e,o){this._offsetY=0;this._g=n.asType(i,t.FlexGrid);this._ct=n.asInt(u);this._rows=n.asType(f,t.RowCollection);this._cols=n.asType(e,t.ColumnCollection);this._e=n.asType(o,HTMLElement);this._rng=new t.CellRange;r._evtBlur||(r._evtBlur=document.createEvent('HTMLEvents'),r._evtBlur.initEvent('blur',!0,!1))}return Object.defineProperty(r.prototype,"grid",{get:function(){return this._g},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"cellType",{get:function(){return this._ct},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"viewRange",{get:function(){return this._getViewRange(!1)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"width",{get:function(){return this._cols.getTotalSize()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"height",{get:function(){return this._rows.getTotalSize()},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"rows",{get:function(){return this._rows},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"columns",{get:function(){return this._cols},enumerable:!0,configurable:!0}),r.prototype.getCellData=function(r,u,f){var s=this._rows[n.asNumber(r,!1,!0)],h,o=null,e,c,l,a;if(n.isString(u)&&(u=this._cols.indexOf(u),u<0))throw'Invalid column name or binding.';if(h=this._cols[n.asNumber(u,!1,!0)],e=this._g?this._g._getBindingColumn(this,r,h):h,!e.binding||!s.dataItem||s.dataItem instanceof n.collections.CollectionViewGroup?s._ubv&&(o=s._ubv[h._hash]):o=e._binding.getValue(s.dataItem),o==null)switch(this._ct){case i.ColumnHeader:(r==this._rows.length-1||e!=h)&&(o=e.header);break;case i.ColumnFooter:e.aggregate!=n.Aggregate.None&&s instanceof t.GroupRow&&(c=this._g.collectionView,c&&(l=n.tryCast(c,n.collections.CollectionView),o=l?l.getAggregate(e.aggregate,e.binding):n.getAggregate(e.aggregate,c.items,e.binding)));break;case i.Cell:e.aggregate!=n.Aggregate.None&&s instanceof t.GroupRow&&(a=n.tryCast(s.dataItem,n.collections.CollectionViewGroup),a&&(o=a.getAggregate(e.aggregate,e.binding,this._g.collectionView)))}return f&&(this.cellType==i.Cell&&e.dataMap&&(o=e.dataMap.getDisplayValue(o)),o=o!=null?n.Globalize.format(o,e.format):''),o},r.prototype.setCellData=function(t,r,u,f,e){var s,v,o,c,y,h,p,a,k;if(f===void 0&&(f=!0),e===void 0&&(e=!0),s=this._rows[n.asNumber(t,!1,!0)],n.isString(r)&&(r=this._cols.indexOf(r),r<0))throw'Invalid column name or binding.';if(v=this._cols[n.asNumber(r,!1,!0)],o=this._g?this._g._getBindingColumn(this,t,v):v,this._ct==i.Cell){if(o.dataMap&&u!=null&&(o.isRequired||u!=''&&u!=null))if(c=o.dataMap,y=c.getKeyValue(u),y==null){if(!c.isEditable||c.displayMemberPath!=c.selectedValuePath)return!1}else u=y;if(h=n.DataType.Object,o.dataType?h=o.dataType:(p=this.getCellData(t,r,!1),h=n.getType(p)),n.isBoolean(o.isRequired))if(o.isRequired||u!==''&&u!==null){if(o.isRequired&&(u===''||u===null))return!1}else u=null,f=!1;if(f&&(u=n.changeType(u,h,o.format),h!=n.DataType.Object&&n.getType(u)!=h))return!1}if(s.dataItem&&o.binding){var w=o._binding,l=s.dataItem,b=w.getValue(l);if(u!==b&&!n.DateTime.equals(u,b)&&(w.setValue(l,u),a=this._g.collectionView,a instanceof n.collections.CollectionView&&l!=a.currentEditItem)){k=new n.collections.NotifyCollectionChangedEventArgs(n.collections.NotifyCollectionChangedAction.Change,l,a.items.indexOf(l));a.onCollectionChanged(k)}}else s._ubv||(s._ubv={}),s._ubv[v._hash]=u;return e&&this._g&&this._g.invalidate(),!0},r.prototype.getCellBoundingRect=function(t,i,r){var o=this.rows[t],s=this.columns[i],u=new n.Rect(s.pos,o.pos,s.renderSize,o.renderSize),f,e;return this._g._rtl&&(u.left=this.hostElement.clientWidth-u.right,n.isIE()||(f=this.hostElement.parentElement,u.left-=f.offsetWidth-f.clientWidth)),r||(e=this.hostElement.getBoundingClientRect(),u.left+=e.left,u.top+=e.top-this._offsetY),t<this.rows.frozen&&(u.top-=this._g.scrollPosition.y),i<this.columns.frozen&&(u.left-=this._g.scrollPosition.x*(this._g._rtl?-1:1)),u},r.prototype.getSelectedState=function(n,r,u){var e=this._g,o=e.selectionMode,f=e._selHdl._sel;if(o!=t.SelectionMode.None)switch(this._ct){case i.Cell:if(u||(u=e.getMergedRange(this,n,r)),u){if(u.contains(f.row,f.col))return e.showMarquee?t.SelectedState.None:t.SelectedState.Cursor;if(u.intersects(f))return t.SelectedState.Selected}return f.row==n&&f.col==r?e.showMarquee?t.SelectedState.None:t.SelectedState.Cursor:e.rows[n].isSelected||e.columns[r].isSelected?t.SelectedState.Selected:(f=e._selHdl._adjustSelection(f),o==t.SelectionMode.ListBox)?t.SelectedState.None:f.containsRow(n)&&f.containsColumn(r)?t.SelectedState.Selected:t.SelectedState.None;case i.ColumnHeader:if(e.showSelectedHeaders&t.HeadersVisibility.Column&&(e.columns[r].isSelected||f.containsColumn(r)||f.intersectsColumn(u))&&(u&&(n=u.bottomRow),n==this.rows.length-1))return t.SelectedState.Selected;break;case i.RowHeader:if(e.showSelectedHeaders&t.HeadersVisibility.Row&&(e.rows[n].isSelected||f.containsRow(n)||f.intersectsRow(u))&&(u&&(r=u.rightCol),r==this.columns.length-1))return t.SelectedState.Selected}return t.SelectedState.None},Object.defineProperty(r.prototype,"hostElement",{get:function(){return this._e},enumerable:!0,configurable:!0}),r.prototype._getOffsetY=function(){return this._offsetY},r.prototype._updateContent=function(t,u,f){var e,o,y,p=this._g,c=this._rows,g=this._cols,l=this._ct,a,v,w,s,d,h;if((l==i.ColumnHeader||l==i.ColumnFooter||l==i.RowHeader)&&(a=p._ptScrl,v=this._e.style,l==i.RowHeader?v.top=a.y+'px':p._rtl?v.right=a.x+'px':v.left=a.x+'px'),this._offsetY!=f&&(t=!1,this._offsetY=f),w=this._getViewRange(!1),s=this._getViewRange(!0),!t||u||c.frozen||g.frozen||!this._rng.contains(w)){if(t&&s.equals(this._rng)||(u=!1),!t){var b=n.getActiveElement(),k=n.contains(this._e,b)?b:null,nt=this._g.cellFactory;for(h=0;h<this._e.childElementCount;h++)nt.disposeCell(this._e.children[h]);n.setText(this._e,null);k&&k.dispatchEvent(r._evtBlur);this._rowIdx=[]}for(t&&this._ct!=i.TopLeft&&this._reorderCells(s,this._rng),this._rng=s,o=0,this._rowIdx=[],e=s.topRow;e<=s.bottomRow&&e>-1;e++)this._rowIdx.push(o),o=this._renderRow(e,s,!1,u,o);for(this._rowIdx.push(o),e=s.topRow;e<=s.bottomRow&&e>-1;e++)o=this._renderRow(e,s,!0,u,o);for(e=0;e<c.frozen&&e<c.length;e++)o=this._renderRow(e,s,!1,u,o);for(e=0;e<c.frozen&&e<c.length;e++)o=this._renderRow(e,s,!0,u,o);for(d=this._e.childElementCount,h=o;h<d;h++)y=this._e.children[h],y.style.display='none'}},r.prototype._reorderCells=function(n,i){var h,r,s,c,f,l,e,o,u;if(this._rowIdx&&!(this._rows.frozen>0)&&!(this._cols.frozen>0)&&n.columnSpan==i.columnSpan&&n.rowSpan==i.rowSpan&&i.isValid&&n.isValid&&n.intersects(i)&&(n.row!=i.row&&(r=n.row-i.row,s=Math.max(1,n.rowSpan-1),r!=0&&Math.abs(r)<s&&(r>0&&(u=this._createRange(0,this._rowIdx[r]),this._e.appendChild(u.extractContents())),r<0&&(h=this._rowIdx.length-1,u=this._createRange(this._rowIdx[h+r],this._rowIdx[h]),this._e.insertBefore(u.extractContents(),this._e.firstChild)))),n.col!=i.col&&(r=n.col-i.col,s=Math.max(1,n.columnSpan-1),r!=0&&Math.abs(r)<s)))for(c=this._e.childElementCount,f=0;f<this._rowIdx.length-1;f++)l=this.rows[n.topRow+f],l instanceof t.GroupRow||(e=this._rowIdx[f],o=this._rowIdx[f+1],r>0&&e+r<=c&&(u=this._createRange(e,e+r),this._e.insertBefore(u.extractContents(),this._e.children[o])),r<0&&o+r-1>=0&&(u=this._createRange(o+r-1,o-1),this._e.insertBefore(u.extractContents(),this._e.children[e])))},r.prototype._createRange=function(n,t){var i=document.createRange();return i.setStart(this._e,n),i.setEnd(this._e,t),i},r.prototype._renderRow=function(n,t,i,r,u){var f;if(this.rows[n].renderSize<=0)return u;if(i)for(f=0;f<this.columns.frozen&&f<this.columns.length;f++)u=this._renderCell(n,f,t,r,u);else for(f=t.leftCol;f<=t.rightCol&&f>-1;f++)u=this._renderCell(n,f,t,r,u);return u},r.prototype._renderCell=function(i,r,u,f,e){var l=this._g,h=l.getMergedRange(this,i,r),s,o,c;if(h){for(s=Math.max(u.row,h.row);s<i;s++)if(this.rows[s].isVisible)return e;for(s=Math.max(u.col,h.col);s<r;s++)if(this.columns[s].isVisible)return e}return this.columns[r].renderSize<=0&&(!h||h.getRenderSize(this).width<=0)?e:(o=this._e.childNodes[e++],o&&f)?(c=this.getSelectedState(i,r,h),n.toggleClass(o,'wj-state-selected',c==t.SelectedState.Cursor),n.toggleClass(o,'wj-state-multi-selected',c==t.SelectedState.Selected),e):(o||(o=document.createElement('div'),o.tabIndex=0,this._e.appendChild(o)),l.cellFactory.updateCell(this,i,r,o,h),e)},r.prototype._getViewRange=function(n){var o=this._g,a=o._ptScrl,u=this._rows,f=this._cols,r=new t.CellRange(0,0,u.length-1,f.length-1),e,l;if(this._ct==i.Cell||this._ct==i.RowHeader){var h=-a.y+this._offsetY,v=o._szClient.height,s=Math.min(u.frozen,u.length-1);s>0&&(e=u[s-1].pos,h+=e,v-=e);r.row=Math.min(u.length-1,Math.max(u.frozen,u.getItemAt(h+1)));r.row2=u.getItemAt(h+v)}if(this._ct==i.Cell||this._ct==i.ColumnHeader){var c=-a.x,y=o._szClient.width,s=Math.min(f.frozen,f.length-1);s>0&&(e=f[s-1].pos,c+=e,y-=e);r.col=Math.min(f.length-1,Math.max(f.frozen,f.getItemAt(c+1)));r.col2=f.getItemAt(c+y)}return n&&this._ct==i.Cell&&(l=o.isTouching?6:1,r.row=Math.max(r.row-l,0),r.row2=Math.min(r.row2+l,u.length-1),r.col=Math.max(r.col-1,0),r.col2=Math.min(r.col2+1,f.length-1)),u.length<=u.frozen&&(r.row=r.row2=-1),f.length<=f.frozen&&(r.col=r.col2=-1),r},r.prototype._getFrozenPos=function(){var r=this._rows.frozen,u=this._cols.frozen,t=r>0?this._rows[r-1]:null,i=u>0?this._cols[u-1]:null,f=t?t.pos+t.renderSize:0,e=i?i.pos+i.renderSize:0;return new n.Point(e,f)},r}();t.GridPanel=r})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function i(){}return i.prototype.updateCell=function(r,u,f,e,o,s){var h=r.grid,y=r.cellType,d=r.rows,g=r.columns,v=d[u],k=g[f],rt=u,ft=f,p=n.tryCast(v,t.GroupRow),dt=n.tryCast(v,t._NewRowTemplate),gt=k.renderWidth,ni=v.renderHeight,l='wj-cell',a={display:''},ti=s!=!1,at,ot,yt,tt,st,ii,ht,nt,ri,pt,ct,w,wt,bt,b,kt,ut,lt,it,ei,ui,o,fi;s!=!1&&e.firstElementChild&&(e.childNodes.length!=1||e.firstElementChild.type!='checkbox')&&(n.setText(e,null),ti=!1);o&&!o.isSingleCell&&(u=o.row,f=o.col,rt=o.row2,ft=o.col2,v=d[u],k=g[f],p=n.tryCast(v,t.GroupRow),at=o.getRenderSize(r),ni=at.height,gt=at.width);var c=h._getBindingColumn(r,u,k),et=k.pos,vt=v.pos;if(n.isIE()&&y==t.CellType.Cell&&!h.editRange?(u<d.frozen&&f>=g.frozen&&(et+=h._ptScrl.x),f<g.frozen&&u>=d.frozen&&(vt+=h._ptScrl.y)):(u<d.frozen&&(vt-=h._ptScrl.y),f<g.frozen&&(et-=h._ptScrl.x)),h._rtl?a.right=et+'px':a.left=et+'px',a.top=vt-r._getOffsetY()+'px',a.width=gt+'px',a.height=ni+'px',y==t.CellType.Cell?(p&&(l+=' wj-group'),h.showAlternatingRows&&u%2!=0&&(l+=' wj-alt'),(u<d.frozen||f<g.frozen)&&(l+=' wj-frozen'),dt&&(l+=' wj-new'),v.cssClass&&(l+=' '+v.cssClass),c.cssClass&&(l+=' '+c.cssClass)):(l+=' wj-header',h.showAlternatingRows&&u%2!=0&&(l+=' wj-header-alt')),ot=h.collectionView,ot&&h.showErrors&&v.dataItem)if(y==t.CellType.Cell)tt=ot.getError,n.isFunction(tt)&&(e.title='',yt=tt(v.dataItem,c.binding),yt&&(l+=' wj-state-invalid',e.title=yt));else if(y==t.CellType.RowHeader&&(tt=ot.getError,n.isFunction(tt)))for(st=0;st<h.columns.length;st++)if(ii=h._getBindingColumn(r,u,h.columns[st]),tt(v.dataItem,ii.binding)){l+=' wj-state-invalid';break}ht=r.getSelectedState(u,f,o);ht!=t.SelectedState.None&&y==t.CellType.Cell&&k.dataType!=n.DataType.Boolean&&h.editRange&&h.editRange.contains(u,f)&&(ht=t.SelectedState.None);switch(ht){case t.SelectedState.Cursor:l+=' wj-state-selected';break;case t.SelectedState.Selected:l+=' wj-state-multi-selected'}if(rt==d.frozen-1&&(l+=' wj-frozen-row'),ft==g.frozen-1&&(l+=' wj-frozen-col'),(k.wordWrap||v.wordWrap)&&(l+=' wj-wrap'),ti&&l==e.className&&(nt=e.style,nt.top==a.top&&nt.width==a.width&&nt.height==a.height&&(h._rtl&&nt.right==a.right||!h._rtl&&nt.left==a.left))){nt.display&&(e.style.display='');return}a.textAlign=c.getAlignment();y==t.CellType.Cell&&h.rows.maxGroupLevel>-1&&(a.paddingLeft=a.paddingRight='',f==h.columns.firstVisibleIndex&&h.treeIndent&&(ri=p?Math.max(0,p.level):h.rows.maxGroupLevel+1,pt=h.treeIndent*ri+h._cellPadding,h._rtl?a.paddingRight=pt:a.paddingLeft=pt));s!=!1&&(ct=r.getCellData(u,f,!1),w=r.getCellData(u,f,!0),y==t.CellType.Cell&&f==h.columns.firstVisibleIndex&&p&&p.hasChildren&&!this._isEditingCell(h,u,f)?(w||(w=p.getGroupHeader()),e.innerHTML=this._getTreeIcon(p)+' '+w,a.textAlign=''):y==t.CellType.ColumnHeader&&c.currentSort&&h.showSort&&(rt==h._getSortRowIndex()||c!=k)?(l+=' wj-sort-'+(c.currentSort=='+'?'asc':'desc'),e.innerHTML=n.escapeHtml(w)+'&nbsp;'+this._getSortIcon(c)):y!=t.CellType.RowHeader||f!=h.rowHeaders.columns.length-1||w?y==t.CellType.Cell&&c.dataType==n.DataType.Boolean&&(!p||n.isBoolean(ct))?(b=e.firstChild,b instanceof HTMLInputElement&&b.type=='checkbox'||(e.innerHTML='<input type="checkbox"/>',b=e.firstChild),b.checked=ct==!0?!0:!1,b.indeterminate=ct==null,b.disabled=!h._edtHdl._allowEditing(u,f),b.disabled&&(b.style.cursor='default'),h.editRange&&h.editRange.contains(u,f)&&(h._edtHdl._edt=b)):y==t.CellType.Cell&&this._isEditingCell(h,u,f)?(kt=c.inputType,c.inputType||(kt=c.dataType==n.DataType.Number&&!c.dataMap?'tel':'text'),c.dataMap||c.mask||(ut=r.getCellData(u,f,!1),n.isNumber(ut)&&(lt=c.format,lt&&ut!=Math.round(ut)&&(lt=c.format.replace(/([a-z])(\d*)(.*)/ig,'$0112$3')),w=n.Globalize.formatNumber(ut,lt,!0))),e.innerHTML='<input type="'+kt+'" class="wj-grid-editor wj-form-control">',it=e.children[0],it.value=w,it.required=c.getIsRequired(),it.style.textAlign=c.getAlignment(),a.padding='0px',c.mask&&(ei=new n._MaskProvider(it,c.mask)),h._edtHdl._edt=it):y==t.CellType.Cell&&(v.isContentHtml||c.isContentHtml)?e.innerHTML=w:n.setText(e,w):(wt=h.collectionView,bt=wt?wt.currentEditItem:null,bt&&v.dataItem==bt?e.innerHTML='<span class="wj-glyph-pencil"></span>':n.tryCast(v,t._NewRowTemplate)&&(e.innerHTML='<span class="wj-glyph-asterisk"></span>')),y==t.CellType.Cell&&n.input&&c.dataMap&&c.showDropDown!==!1&&h._edtHdl._allowEditing(u,f)&&(i._ddIcon||(i._ddIcon=n.createElement('<div class="'+i._WJC_DROPDOWN+'"><span class="wj-glyph-down"></span></div>')),ui=i._ddIcon.cloneNode(!0),e.appendChild(ui)));switch(y){case t.CellType.RowHeader:e.removeAttribute('draggable');p||dt||(h.allowDragging&t.AllowDragging.Rows)==0||!v.allowDragging||e.setAttribute('draggable','true');break;case t.CellType.ColumnHeader:e.removeAttribute('draggable');(h.allowDragging&t.AllowDragging.Columns)!=0&&k.allowDragging&&e.setAttribute('draggable','true')}if(e.className!=l&&(e.className=l),n.setCss(e,a),h.itemFormatter&&h.itemFormatter(r,u,f,e),h.formatItem.hasHandlers){o=i._fmtRng;o?o.setRange(u,f,rt,ft):o=i._fmtRng=new t.CellRange(u,f,rt,ft);fi=new t.FormatItemEventArgs(r,o,e);h.onFormatItem(fi)}},i.prototype.disposeCell=function(){},i.prototype.getEditorValue=function(n){var t=n._edtHdl._edt;return t instanceof HTMLInputElement?t.type=='checkbox'?t.checked:t.value:null},i.prototype._isEditingCell=function(n,t,i){return n.editRange&&n.editRange.contains(t,i)},i.prototype._getTreeIcon=function(n){var t='wj-glyph-'+(n.isCollapsed?'':'down-')+(n.grid._rtl?'left':'right');return'<span class="'+i._WJC_COLLAPSE+' '+t+'"></span>'},i.prototype._getSortIcon=function(n){return'<span class="wj-glyph-'+(n.currentSort=='+'?'up':'down')+'"></span>'},i._WJC_COLLAPSE='wj-elem-collapse',i._WJC_DROPDOWN='wj-elem-dropdown',i}();t.CellFactory=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function t(n,t,i,r){n===void 0&&(n=-1);t===void 0&&(t=-1);i===void 0&&(i=n);r===void 0&&(r=t);this.setRange(n,t,i,r)}return t.prototype.setRange=function(t,i,r,u){t===void 0&&(t=-1);i===void 0&&(i=-1);r===void 0&&(r=t);u===void 0&&(u=i);this._row=n.asInt(t);this._col=n.asInt(i);this._row2=n.asInt(r);this._col2=n.asInt(u)},Object.defineProperty(t.prototype,"row",{get:function(){return this._row},set:function(t){this._row=n.asInt(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"col",{get:function(){return this._col},set:function(t){this._col=n.asInt(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"row2",{get:function(){return this._row2},set:function(t){this._row2=n.asInt(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"col2",{get:function(){return this._col2},set:function(t){this._col2=n.asInt(t)},enumerable:!0,configurable:!0}),t.prototype.clone=function(){return new t(this._row,this._col,this._row2,this._col2)},Object.defineProperty(t.prototype,"rowSpan",{get:function(){return Math.abs(this._row2-this._row)+1},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"columnSpan",{get:function(){return Math.abs(this._col2-this._col)+1},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"topRow",{get:function(){return Math.min(this._row,this._row2)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"bottomRow",{get:function(){return Math.max(this._row,this._row2)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"leftCol",{get:function(){return Math.min(this._col,this._col2)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"rightCol",{get:function(){return Math.max(this._col,this._col2)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isValid",{get:function(){return this._row>-1&&this._col>-1&&this._row2>-1&&this._col2>-1},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isSingleCell",{get:function(){return this._row==this._row2&&this._col==this._col2},enumerable:!0,configurable:!0}),t.prototype.contains=function(i,r){var u=n.tryCast(i,t);if(u)return u.topRow>=this.topRow&&u.bottomRow<=this.bottomRow&&u.leftCol>=this.leftCol&&u.rightCol<=this.rightCol;if(n.isInt(i)&&n.isInt(r))return i>=this.topRow&&i<=this.bottomRow&&r>=this.leftCol&&r<=this.rightCol;throw'contains expects a CellRange or row/column indices.';},t.prototype.containsRow=function(t){return n.asInt(t)>=this.topRow&&t<=this.bottomRow},t.prototype.containsColumn=function(t){return n.asInt(t)>=this.leftCol&&t<=this.rightCol},t.prototype.intersects=function(n){return this.intersectsRow(n)&&this.intersectsColumn(n)},t.prototype.intersectsRow=function(n){return n&&!(this.bottomRow<n.topRow||this.topRow>n.bottomRow)},t.prototype.intersectsColumn=function(n){return n&&!(this.rightCol<n.leftCol||this.leftCol>n.rightCol)},t.prototype.getRenderSize=function(t){var u=new n.Size(0,0),i,r;if(this.isValid){for(i=this.topRow;i<=this.bottomRow;i++)u.height+=t.rows[i].renderSize;for(r=this.leftCol;r<=this.rightCol;r++)u.width+=t.columns[r].renderSize}return u},t.prototype.equals=function(n){return n instanceof t&&this._row==n._row&&this._col==n._col&&this._row2==n._row2&&this._col2==n._col2},t}();t.CellRange=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var i,u,r,e,o,f,s,h;(function(n){n[n.Visible=1]="Visible";n[n.AllowResizing=2]="AllowResizing";n[n.AllowDragging=4]="AllowDragging";n[n.AllowMerging=8]="AllowMerging";n[n.AllowSorting=16]="AllowSorting";n[n.AutoGenerated=32]="AutoGenerated";n[n.Collapsed=64]="Collapsed";n[n.ParentCollapsed=128]="ParentCollapsed";n[n.Selected=256]="Selected";n[n.ReadOnly=512]="ReadOnly";n[n.HtmlContent=1024]="HtmlContent";n[n.WordWrap=2048]="WordWrap";n[n.RowDefault=3]="RowDefault";n[n.ColumnDefault=23]="ColumnDefault"})(t.RowColFlags||(t.RowColFlags={}));i=t.RowColFlags;u=function(){function r(){this._list=null;this._pos=0;this._idx=-1}return Object.defineProperty(r.prototype,"visible",{get:function(){return this._getFlag(i.Visible)},set:function(n){this._setFlag(i.Visible,n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isVisible",{get:function(){return this._getFlag(i.Visible)?this._getFlag(i.ParentCollapsed)&&!(this instanceof t._NewRowTemplate)?!1:!0:!1},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"pos",{get:function(){return this._list&&this._list._update(),this._pos},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"index",{get:function(){return this._list&&this._list._update(),this._idx},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"size",{get:function(){return this._sz},set:function(t){t!=this._sz&&(this._sz=n.asNumber(t,!0),this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"renderSize",{get:function(){if(!this.isVisible)return 0;var n=this._sz,t=this._list;return(n==null||n<0)&&t!=null?Math.round(t.defaultSize):(t!=null&&(t.minSize!=null&&n<t.minSize&&(n=t.minSize),t.maxSize!=null&&n>t.maxSize&&(n=t.maxSize)),this._szMin!=null&&n<this._szMin&&(n=this._szMin),this._szMax!=null&&n>this._szMax&&(n=this._szMax),Math.round(n))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"allowResizing",{get:function(){return this._getFlag(i.AllowResizing)},set:function(n){this._setFlag(i.AllowResizing,n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"allowDragging",{get:function(){return this._getFlag(i.AllowDragging)},set:function(n){this._setFlag(i.AllowDragging,n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"allowMerging",{get:function(){return this._getFlag(i.AllowMerging)},set:function(n){this._setFlag(i.AllowMerging,n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isSelected",{get:function(){return this._getFlag(i.Selected)},set:function(n){if(this._setFlag(i.Selected,n,!0)){var t=this.grid;t&&t.refreshCells(!1,!0,!0)}},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isReadOnly",{get:function(){return this._getFlag(i.ReadOnly)},set:function(n){this._setFlag(i.ReadOnly,n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"isContentHtml",{get:function(){return this._getFlag(i.HtmlContent)},set:function(n){this.isContentHtml!=n&&(this._setFlag(i.HtmlContent,n),this.grid&&this.grid.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"wordWrap",{get:function(){return this._getFlag(i.WordWrap)},set:function(n){this._setFlag(i.WordWrap,n)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"cssClass",{get:function(){return this._cssClass},set:function(t){t!=this._cssClass&&(this._cssClass=n.asString(t),this.grid&&this.grid.invalidate(!1))},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"grid",{get:function(){return this._list?this._list._g:null},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"collectionView",{get:function(){return this.grid?this.grid.collectionView:null},enumerable:!0,configurable:!0}),r.prototype.onPropertyChanged=function(){this._list&&(this._list._dirty=!0,this.grid.invalidate())},r.prototype._getFlag=function(n){return(this._f&n)!=0},r.prototype._setFlag=function(n,t,i){return t!=this._getFlag(n)?(this._f=t?this._f|n:this._f&~n,i||this.onPropertyChanged(),!0):!1},r}();t.RowCol=u;r=function(r){function u(t){r.call(this);this._f=i.ColumnDefault;this._hash=u._ctr.toString(36);u._ctr++;t&&n.copy(this,t)}return __extends(u,r),Object.defineProperty(u.prototype,"name",{get:function(){return this._name},set:function(n){this._name=n},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"dataType",{get:function(){return this._type},set:function(t){this._type!=t&&(this._type=n.asEnum(t,n.DataType),this.grid&&this.grid.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"isRequired",{get:function(){return this._required},set:function(t){this._required=n.asBoolean(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"required",{get:function(){return n._deprecated('required','isRequired'),this.isRequired},set:function(t){n._deprecated('required','isRequired');this.isRequired=t},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showDropDown",{get:function(){return this._showDropDown},set:function(t){t!=this._showDropDown&&(this._showDropDown=n.asBoolean(t,!0),this.grid&&this.grid.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"dropDownCssClass",{get:function(){return this._ddCssClass},set:function(t){this._ddCssClass=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"inputType",{get:function(){return this._inpType},set:function(t){this._inpType=n.asString(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"mask",{get:function(){return this._mask},set:function(t){this._mask=n.asString(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"binding",{get:function(){return this._binding?this._binding.path:null},set:function(t){var r,i,u;t!=this.binding&&(r=n.asString(t),this._binding=r?new n.Binding(r):null,!this._type&&this.grid&&this._binding&&(i=this.grid.collectionView,i&&i.sourceCollection&&i.sourceCollection.length&&(u=i.sourceCollection[0],this._type=n.getType(this._binding.getValue(u)))),this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"sortMemberPath",{get:function(){return this._bindingSort?this._bindingSort.path:null},set:function(t){if(t!=this.sortMemberPath){var i=n.asString(t);this._bindingSort=i?new n.Binding(i):null;this.onPropertyChanged()}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"width",{get:function(){return this._szStar!=null?this._szStar:this.size},set:function(t){u._parseStarSize(t)!=null?(this._szStar=t,this.onPropertyChanged()):(this._szStar=null,this.size=n.asNumber(t,!0))},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"minWidth",{get:function(){return this._szMin},set:function(t){t!=this._szMin&&(this._szMin=n.asNumber(t,!0,!0),this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"maxWidth",{get:function(){return this._szMax},set:function(t){t!=this._szMax&&(this._szMax=n.asNumber(t,!0,!0),this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"renderWidth",{get:function(){return this.renderSize},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"align",{get:function(){return this._align},set:function(n){this._align!=n&&(this._align=n,this.onPropertyChanged())},enumerable:!0,configurable:!0}),u.prototype.getAlignment=function(){var t=this._align;if(t==null&&(t='',!this._map))switch(this._type){case n.DataType.Boolean:t='center';break;case n.DataType.Number:t='right'}return t},u.prototype.getIsRequired=function(){return this._required!=null?this._required:this.dataType==n.DataType.String&&!this.mask},Object.defineProperty(u.prototype,"header",{get:function(){return this._hdr?this._hdr:this.binding},set:function(n){this._hdr!=n&&(this._hdr=n,this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"dataMap",{get:function(){return this._map},set:function(i){this._map!=i&&(this._map&&this._map.mapChanged.removeHandler(this.onPropertyChanged,this),n.isArray(i)&&(i=new t.DataMap(i,null,null)),this._map=n.asType(i,t.DataMap,!0),this._map&&this._map.mapChanged.addHandler(this.onPropertyChanged,this),this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"format",{get:function(){return this._fmt},set:function(n){this._fmt!=n&&(this._fmt=n,this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"allowSorting",{get:function(){return this._getFlag(i.AllowSorting)},set:function(n){this._setFlag(i.AllowSorting,n)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"currentSort",{get:function(){var t,n;if(this.grid&&this.grid.collectionView&&this.grid.collectionView.canSort)for(t=this.grid.collectionView.sortDescriptions,n=0;n<t.length;n++)if(t[n].property==this._getBindingSort())return t[n].ascending?'+':'-';return null},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"aggregate",{get:function(){return this._agg!=null?this._agg:n.Aggregate.None},set:function(t){t!=this._agg&&(this._agg=n.asEnum(t,n.Aggregate),this.onPropertyChanged())},enumerable:!0,configurable:!0}),u.prototype._getBindingSort=function(){return this.sortMemberPath?this.sortMemberPath:this.binding?this.binding:null},u._parseStarSize=function(t){if(n.isString(t)&&t.length>0&&t[t.length-1]=='*'){var i=t.length==1?1:t.substr(0,t.length-1)*1;if(i>0&&!isNaN(i))return i}return null},u._ctr=0,u}(u);t.Column=r;e=function(n){function t(t){n.call(this);this._f=i.ColumnDefault;this._data=t}return __extends(t,n),Object.defineProperty(t.prototype,"dataItem",{get:function(){return this._data},set:function(n){this._data=n},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"height",{get:function(){return this.size},set:function(n){this.size=n},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"renderHeight",{get:function(){return this.renderSize},enumerable:!0,configurable:!0}),t}(u);t.Row=e;o=function(r){function u(){r.call(this);this._level=-1;this.isReadOnly=!0}return __extends(u,r),Object.defineProperty(u.prototype,"level",{get:function(){return this._level},set:function(t){n.asInt(t);t!=this._level&&(this._level=t,this.onPropertyChanged())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"hasChildren",{get:function(){if(this.grid!=null&&this._list!=null){this._list._update();var i=this.index<this._list.length-1?this._list[this.index+1]:null,r=n.tryCast(i,u),f=n.tryCast(i,t._NewRowTemplate);return i&&f==null&&(r==null||r.level>this.level)}return!0},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"isCollapsed",{get:function(){return this._getFlag(i.Collapsed)},set:function(t){n.asBoolean(t);t!=this.isCollapsed&&this._list!=null&&this._setCollapsed(t)},enumerable:!0,configurable:!0}),u.prototype.getGroupHeader=function(){var u=this.grid,o=u.groupHeaderFormat?u.groupHeaderFormat:n.culture.FlexGrid.groupHeaderFormat,r=n.tryCast(this.dataItem,n.collections.CollectionViewGroup),s;if(r&&o){var f=r.groupDescription.propertyName,i=r.name,t=u.columns.getColumn(f),e=this.isContentHtml;return t&&(e=e||t.isContentHtml,t.header&&(f=t.header),t.dataMap?i=t.dataMap.getDisplayValue(i):t.format&&(i=n.Globalize.format(i,t.format))),s=r.getAggregate(n.Aggregate.CntAll,null,u.collectionView),n.format(o,{name:n.escapeHtml(f),value:e?i:n.escapeHtml(i),level:r.level,count:s})}return''},u.prototype._setCollapsed=function(r){var c=this,f=this.grid,o=f.rows,h=this.getCellRange(),s=new t.CellRangeEventArgs(f.cells,new t.CellRange(this.index,-1)),e;f.onGroupCollapsedChanging(s);if(!s.cancel){f.deferUpdate(function(){c._setFlag(i.Collapsed,r);for(var t=h.topRow+1;t<=h.bottomRow&&t>-1&&t<o.length;t++)o[t]._setFlag(i.ParentCollapsed,r),e=n.tryCast(o[t],u),e!=null&&e.isCollapsed&&(t=e.getCellRange().bottomRow)});f.onGroupCollapsedChanged(s)}},u.prototype.getCellRange=function(){for(var f,e=this._list,o=this.index,r=e.length-1,i=o+1;i<=r;i++)if(f=n.tryCast(e[i],u),f!=null&&f.level<=this.level){r=i-1;break}return new t.CellRange(o,0,r,this.grid.columns.length-1)},u}(e);t.GroupRow=o;f=function(i){function r(r,u){i.call(this);this._frozen=0;this._szDef=28;this._szTot=0;this._dirty=!1;this._g=n.asType(r,t.FlexGrid);this._szDef=n.asNumber(u,!1,!0)}return __extends(r,i),Object.defineProperty(r.prototype,"defaultSize",{get:function(){return this._szDef},set:function(t){this._szDef!=t&&(this._szDef=n.asNumber(t,!1,!0),this._dirty=!0,this._g.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"frozen",{get:function(){return this._frozen},set:function(t){t!=this._frozen&&(this._frozen=n.asNumber(t,!1,!0),this._dirty=!0,this._g.invalidate())},enumerable:!0,configurable:!0}),r.prototype.isFrozen=function(n){return n<this.frozen},Object.defineProperty(r.prototype,"minSize",{get:function(){return this._szMin},set:function(t){t!=this._szMin&&(this._szMin=n.asNumber(t,!0,!0),this._dirty=!0,this._g.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"maxSize",{get:function(){return this._szMax},set:function(t){t!=this._szMax&&(this._szMax=n.asNumber(t,!0,!0),this._dirty=!0,this._g.invalidate())},enumerable:!0,configurable:!0}),r.prototype.getTotalSize=function(){return this._update(),this._szTot},r.prototype.getItemAt=function(n){if(this._update(),n<=0&&this.length>0)return 0;for(var u=0,i=this.length-1,t,r;u<=i;)if(t=u+i>>>1,r=this[t],r._pos>n)i=t-1;else if(r._pos+r.renderSize<n)u=t+1;else{while(t>0&&!this[t].visible)t--;while(t<this.length-1&&!this[t].visible)t++;return t}return i},r.prototype.getNextCell=function(n,i,r){var u,f;switch(i){case t.SelMove.Next:for(u=n+1;u<this.length;u++)if(this[u].renderSize>0)return u;break;case t.SelMove.Prev:for(u=n-1;u>=0;u--)if(this[u].renderSize>0)return u;break;case t.SelMove.End:for(u=this.length-1;u>=0;u--)if(this[u].renderSize>0)return u;break;case t.SelMove.Home:for(u=0;u<this.length;u++)if(this[u].renderSize>0)return u;break;case t.SelMove.NextPage:return f=this.getItemAt(this[n].pos+r),f<0?this.getNextCell(n,t.SelMove.End,r):f;case t.SelMove.PrevPage:return f=this.getItemAt(this[n].pos-r),f<0?this.getNextCell(n,t.SelMove.Home,r):f}return n},r.prototype.canMoveElement=function(n,i){var u,f,r;if(i==n||n<0||n>=this.length||i>=this.length)return!1;for(i<0&&(i=this.length-1),u=Math.min(n,i),f=Math.max(n,i),r=u;r<=f;r++)if(!this[r].allowDragging)return!1;return this[i]instanceof t._NewRowTemplate?!1:!0},r.prototype.moveElement=function(n,t){if(this.canMoveElement(n,t)){var i=this[n];this.removeAt(n);t<0&&(t=this.length);this.insert(t,i)}},r.prototype.onCollectionChanged=function(t){t===void 0&&(t=n.collections.NotifyCollectionChangedEventArgs.reset);this._dirty=!0;this._g.invalidate();i.prototype.onCollectionChanged.call(this,t)},r.prototype.push=function(n){return n._list=this,i.prototype.push.call(this,n)},r.prototype.splice=function(n,t,r){return r&&(r._list=this),i.prototype.splice.call(this,n,t,r)},r.prototype.beginUpdate=function(){this._update();i.prototype.beginUpdate.call(this)},r.prototype._update=function(){var i,n,t;if(this._dirty&&!this.isUpdating){for(this._dirty=!1,i=0,t=0;t<this.length;t++)n=this[t],n._idx=t,n._list=this,n._pos=i,i+=n.renderSize;return this._szTot=i,!0}return!1},r}(n.collections.ObservableArray);t.RowColCollection=f;s=function(n){function t(){n.apply(this,arguments);this._firstVisible=-1}return __extends(t,n),t.prototype.getColumn=function(n){var t=this.indexOf(n);return t>-1?this[t]:null},t.prototype.indexOf=function(t){var i;if(t instanceof r)return n.prototype.indexOf.call(this,t);for(i=0;i<this.length;i++)if(this[i].name==t)return i;for(i=0;i<this.length;i++)if(this[i].binding==t)return i;return-1},Object.defineProperty(t.prototype,"firstVisibleIndex",{get:function(){return this._update(),this._firstVisible},enumerable:!0,configurable:!0}),t.prototype._update=function(){if(n.prototype._update.call(this)){this._firstVisible=-1;for(var t=0;t<this.length;t++)if(this[t].visible){this._firstVisible=t;break}return!0}return!1},t.prototype._updateStarSizes=function(n){for(var u,t,e=0,f,i=0;i<this.length;i++)t=this[i],t.isVisible&&(t._szStar?(e+=r._parseStarSize(t._szStar),f=t):n-=t.renderWidth);if(f){for(u=n,i=0;i<this.length;i++)t=this[i],t.isVisible&&t._szStar&&(t==f&&u>0?t._sz=u:(t._sz=Math.max(0,Math.round(r._parseStarSize(t._szStar)/e*n)),u-=t.renderWidth));return this._dirty=!0,this._update(),!0}return!1},t}(f);t.ColumnCollection=s;h=function(t){function i(){t.apply(this,arguments);this._maxLevel=-1}return __extends(i,t),Object.defineProperty(i.prototype,"maxGroupLevel",{get:function(){return this._update(),this._maxLevel},enumerable:!0,configurable:!0}),i.prototype._update=function(){var i,r;if(t.prototype._update.call(this)){for(this._maxLevel=-1,i=0;i<this.length;i++)r=n.tryCast(this[i],o),r&&r.level>this._maxLevel&&(this._maxLevel=r.level);return!0}return!1},i}(f);t.RowCollection=h})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(i){'use strict';var r=function(){function r(t,u){var f,s,l,a;if(this._row=-1,this._col=-1,this._edge=0,t instanceof i.FlexGrid)f=this._g=t;else if(t instanceof i.GridPanel)this._p=t,f=this._g=this._p.grid;else throw'First parameter should be a FlexGrid or GridPanel.';u=n.mouseToPage(u);this._pt=u.clone();var v=f.controlRect,y=f._szClient,nt=f.topLeftCells,tt=f._eTL,p=f.headersVisibility,w=i.HeadersVisibility,o=p&w.Row?nt.columns.getTotalSize():0,h=p&w.Column?nt.rows.getTotalSize():0,b=p&w.Column?h+tt.offsetTop:0,k=f._eBL,it=k.offsetHeight;if(u.x=Math.max(0,u.x-v.left),u.y=Math.max(0,u.y-v.top),this._g._rtl&&(u.x=v.width-u.x),!this._p&&u.x>=0&&u.y>=tt.offsetTop&&y&&u.x<=y.width+o&&u.y<=y.height+b&&(this._p=u.y<=b?u.x<=o?f.topLeftCells:f.columnHeaders:u.y<=k.offsetTop?u.x<=o?f.rowHeaders:f.cells:u.x<=o?f.bottomLeftCells:f.columnFooters),this._p!=null){var d=this._p.rows,g=this._p.columns,e=this._p.cellType,c=this._p._getFrozenPos(),rt=e==i.CellType.TopLeft||e==i.CellType.ColumnHeader?h:e==i.CellType.BottomLeft||e==i.CellType.ColumnFooter?it:d.getTotalSize(),ut=e==i.CellType.TopLeft||e==i.CellType.BottomLeft||e==i.CellType.RowHeader?o:g.getTotalSize();if(e==i.CellType.RowHeader||e==i.CellType.Cell?(u.y-=h,(u.y>c.y||c.y<=0)&&(u.y-=f._ptScrl.y,u.y+=this._p._getOffsetY())):(e==i.CellType.BottomLeft||e==i.CellType.ColumnFooter)&&(u.y-=k.offsetTop),(e==i.CellType.ColumnHeader||e==i.CellType.Cell||e==i.CellType.ColumnFooter)&&(u.x-=o,(u.x>c.x||c.x<=0)&&(u.x-=f._ptScrl.x)),(e==i.CellType.ColumnHeader||e==i.CellType.TopLeft)&&(u.y-=b-h),this._row=u.y>rt?-1:d.getItemAt(u.y),this._col=u.x>ut?-1:g.getItemAt(u.x),this._row<0||this._col<0){this._p=null;return}this._edge=0;s=r._SZEDGE[this._g.isTouching?1:0];this._col>-1&&(l=g[this._col],u.x-l.pos<=s&&(this._edge|=1),l.pos+l.renderSize-u.x<=s&&(this._edge|=4));this._row>-1&&(a=d[this._row],u.y-a.pos<=s&&(this._edge|=2),a.pos+a.renderSize-u.y<=s&&(this._edge|=8))}}return Object.defineProperty(r.prototype,"point",{get:function(){return this._pt},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"cellType",{get:function(){return this._p?this._p.cellType:t.CellType.None},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"panel",{get:function(){return this._p},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"row",{get:function(){return this._row},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"col",{get:function(){return this._col},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"range",{get:function(){return new i.CellRange(this._row,this._col)},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"edgeLeft",{get:function(){return(this._edge&1)!=0},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"edgeTop",{get:function(){return(this._edge&2)!=0},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"edgeRight",{get:function(){return(this._edge&4)!=0},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"edgeBottom",{get:function(){return(this._edge&8)!=0},enumerable:!0,configurable:!0}),r._SZEDGE=[5,30],r}();i.HitTestInfo=r})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';(function(n){n[n.None=0]="None";n[n.Cells=1]="Cells";n[n.ColumnHeaders=2]="ColumnHeaders";n[n.RowHeaders=4]="RowHeaders";n[n.AllHeaders=6]="AllHeaders";n[n.All=7]="All"})(t.AllowMerging||(t.AllowMerging={}));var i=t.AllowMerging,r=function(){function r(n){this._g=n}return r.prototype.getMergedRange=function(r,u,f,e){var c,g,b,v,y,nt,k,p,w;e===void 0&&(e=!0);var o,l,h=r.cellType,s=r.columns,a=r.rows,d=a[u],tt=s[f];if(d instanceof t._NewRowTemplate)return null;if(d instanceof t.GroupRow&&d.dataItem instanceof n.collections.CollectionViewGroup){if(o=new t.CellRange(u,f),tt.aggregate==n.Aggregate.None){while(o.col>0&&s[o.col-1].aggregate==n.Aggregate.None&&o.col!=s.frozen)o.col--;while(o.col2<s.length-1&&s[o.col2+1].aggregate==n.Aggregate.None&&o.col2+1!=s.frozen)o.col2++}while(o.col<f&&!s[o.col].visible)o.col++;return o.isSingleCell?null:o}c=!1;switch(this._g.allowMerging){case i.None:c=!0;break;case i.Cells:c=h!=t.CellType.Cell;break;case i.ColumnHeaders:c=h!=t.CellType.ColumnHeader&&h!=t.CellType.TopLeft;break;case i.RowHeaders:c=h!=t.CellType.RowHeader&&h!=t.CellType.TopLeft;break;case i.AllHeaders:c=h==t.CellType.Cell}if(c)return null;if(s[f].allowMerging){for(o=new t.CellRange(u,f),g=0,b=a.length-1,u>=a.frozen?e&&(h==t.CellType.Cell||h==t.CellType.RowHeader)&&(l=r._getViewRange(!0),g=l.topRow,b=l.bottomRow):b=a.frozen-1,v=u-1;v>=g&&this._mergeCell(r,v,f,u,f);v--)o.row=v;for(y=u+1;y<=b&&this._mergeCell(r,u,f,y,f);y++)o.row2=y;while(o.row<u&&!a[o.row].visible)o.row++;if(!o.isSingleCell)return o}if(a[u].allowMerging){for(o=new t.CellRange(u,f),nt=0,k=s.length-1,f>=s.frozen?e&&(h==t.CellType.Cell||h==t.CellType.ColumnHeader)&&(l=r._getViewRange(!0),nt=l.leftCol,k=l.rightCol):k=s.frozen-1,p=f-1;p>=nt&&this._mergeCell(r,u,p,u,f);p--)o.col=p;for(w=f+1;w<=k&&this._mergeCell(r,u,f,u,w);w++)o.col2=w;while(o.col<f&&!s[o.col].visible)o.col++;if(!o.isSingleCell)return o}return null},r.prototype._mergeCell=function(n,i,r,u,f){var e=n.rows[i],o=n.rows[u];return e instanceof t.GroupRow||e instanceof t._NewRowTemplate||o instanceof t.GroupRow||o instanceof t._NewRowTemplate?!1:i!=u&&n.rows.isFrozen(i)!=n.rows.isFrozen(u)?!1:r!=f&&n.columns.isFrozen(r)!=n.columns.isFrozen(f)?!1:i!=u&&(r>0&&(e.allowMerging&&this._mergeCell(n,i,r-1,i,r)||o.allowMerging&&this._mergeCell(n,u,r-1,u,r))||f<n.columns.length-1&&(e.allowMerging&&this._mergeCell(n,i,f,i,f+1)||o.allowMerging&&this._mergeCell(n,u,f,u,f+1)))?!1:n.getCellData(i,r,!0)!=n.getCellData(u,f,!0)?!1:!0},r}();t.MergeManager=r})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function t(t,i,r){var f,u;if(this.mapChanged=new n.Event,n.isArray(t)&&!i&&!r){for(f=[],u=0;u<t.length;u++)f.push({value:t[u]});t=f;i=r='value'}this._cv=n.asCollectionView(t);this._keyPath=n.asString(i,!1);this._displayPath=n.asString(r,!1);this._cv.collectionChanged.addHandler(this.onMapChanged,this)}return Object.defineProperty(t.prototype,"sortByDisplayValues",{get:function(){return this._sortByKey!=!0},set:function(t){this._sortByKey=!n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"collectionView",{get:function(){return this._cv},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"selectedValuePath",{get:function(){return this._keyPath},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"displayMemberPath",{get:function(){return this._displayPath},enumerable:!0,configurable:!0}),t.prototype.getKeyValue=function(n){var t=this._indexOf(n,this._displayPath,!1);return t>-1?this._cv.sourceCollection[t][this._keyPath]:null},t.prototype.getDisplayValue=function(n){var t=this._indexOf(n,this._keyPath,!0);return t>-1?this._cv.sourceCollection[t][this._displayPath]:n},t.prototype.getDisplayValues=function(){var i=[],t,n;if(this._cv&&this._displayPath)for(t=this._cv.items,n=0;n<t.length;n++)i.push(t[n][this._displayPath]);return i},t.prototype.getKeyValues=function(){var i=[],t,n;if(this._cv&&this._keyPath)for(t=this._cv.items,n=0;n<t.length;n++)i.push(t[n][this._keyPath]);return i},Object.defineProperty(t.prototype,"isEditable",{get:function(){return this._editable},set:function(t){this._editable=n.asBoolean(t)},enumerable:!0,configurable:!0}),t.prototype.onMapChanged=function(n){this.mapChanged.raise(this,n)},t.prototype._indexOf=function(n,t,i){var u=-1,e=-1,r,s,f;if(this._cv&&t){var o=n!=null?n.toString():'',h=i?o:o.toLowerCase(),c=this._cv.sourceCollection;for(r=0;r<c.length;r++)if(s=c[r],f=s[t],f==n?u=r:i||f.length!=h.length||f.toLowerCase()!=h?f!=null&&f.toString()==o&&(u=r):u=r,u==r){if(!this._cv.filter||this._cv.filter(s))return u;e<0&&(e=u)}}return e},t}();t.DataMap=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var r,f,i,u;(function(n){n[n.None=0]="None";n[n.Cell=1]="Cell";n[n.CellRange=2]="CellRange";n[n.Row=3]="Row";n[n.RowRange=4]="RowRange";n[n.ListBox=5]="ListBox"})(t.SelectionMode||(t.SelectionMode={}));r=t.SelectionMode,function(n){n[n.None=0]="None";n[n.Selected=1]="Selected";n[n.Cursor=2]="Cursor"}(t.SelectedState||(t.SelectedState={}));f=t.SelectedState,function(n){n[n.None=0]="None";n[n.Next=1]="Next";n[n.Prev=2]="Prev";n[n.NextPage=3]="NextPage";n[n.PrevPage=4]="PrevPage";n[n.Home=5]="Home";n[n.End=6]="End";n[n.NextCell=7]="NextCell";n[n.PrevCell=8]="PrevCell"}(t.SelMove||(t.SelMove={}));i=t.SelMove;u=function(){function u(n){this._sel=new t.CellRange(0,0);this._mode=r.CellRange;this._g=n}return Object.defineProperty(u.prototype,"selectionMode",{get:function(){return this._mode},set:function(n){var u,i,f,e;if(n!=this._mode){if(n==r.ListBox||this._mode==r.ListBox)for(u=this._g.rows,i=0;i<u.length;i++)f=u[i],e=n==r.ListBox?this._sel.containsRow(i):!1,f._setFlag(t.RowColFlags.Selected,e,!0);switch(n){case r.None:this._sel.setRange(-1,-1);break;case r.Cell:this._sel.row2=this._sel.row;this._sel.col2=this._sel.col;break;case r.Row:this._sel.row2=this._sel.row}this._mode=n;this._g.invalidate()}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"selection",{get:function(){return this._sel},set:function(n){this.select(n)},enumerable:!0,configurable:!0}),u.prototype.select=function(i,u){var h,c,o,l;u===void 0&&(u=!0);n.isNumber(i)&&n.isNumber(u)&&(i=new t.CellRange(i,u),u=!0);i=n.asType(i,t.CellRange);var f=this._g,a=this._sel,e=i,s=!1;switch(f.selectionMode){case r.Cell:i.row2=i.row;i.col2=i.col;break;case r.Row:i.row2=i.row;break;case r.ListBox:s=!0}if(h=e.equals(a),s&&e.row>-1&&!f.rows[e.row].isSelected&&(h=!1),h){u&&f.scrollIntoView(e.row,e.col);return}if(c=new t.CellRangeEventArgs(f.cells,e),f.onSelectionChanging(c)){if(s){for(o=0;o<f.rows.length;o++)f.rows[o]._setFlag(t.RowColFlags.Selected,e.containsRow(o),!0);f.refreshCells(!1,!0,!0)}e.row=Math.min(e.row,f.rows.length-1);e.row2=Math.min(e.row2,f.rows.length-1);this._sel=e;f.refreshCells(!1,!0,!0);u&&f.scrollIntoView(e.row,e.col);f.collectionView&&(l=f._getCvIndex(e.row),f.collectionView.moveCurrentToPosition(l));f.onSelectionChanged(c)}},u.prototype.moveSelection=function(n,r,u){var e,f,h=this._g,l=h.rows,c=h.columns,o=this._getReferenceCell(n,r,u),s=Math.max(0,h._szClient.height-h.columnHeaders.height),a;r==i.NextCell?(f=c.getNextCell(o.col,i.Next,s),e=o.row,f==o.col&&(e=l.getNextCell(e,i.Next,s),e>o.row&&(f=c.getNextCell(0,i.Next,s),f=c.getNextCell(f,i.Prev,s))),h.select(e,f)):r==i.PrevCell?(f=c.getNextCell(o.col,i.Prev,s),e=o.row,f==o.col&&(e=l.getNextCell(e,i.Prev,s),e<o.row&&(f=c.getNextCell(c.length-1,i.Prev,s),f=c.getNextCell(f,i.Next,s))),h.select(e,f)):(e=l.getNextCell(o.row,n,s),f=c.getNextCell(o.col,r,s),u?(a=h._selHdl._sel,h.select(new t.CellRange(e,f,a.row2,a.col2))):h.select(e,f))},u.prototype._getReferenceCell=function(n,t){var f=this._g,u=f._selHdl._sel,r=f.getMergedRange(f.cells,u.row,u.col);if(!r||r.isSingleCell)return u;r=r.clone();switch(n){case i.Next:case i.NextCell:r.row=r.bottomRow;break;case i.None:r.row=u.row}switch(t){case i.Next:case i.NextCell:r.col=r.rightCol;break;case i.None:r.col=u.col}return r},u.prototype._adjustSelection=function(n){switch(this._mode){case r.Cell:return new t.CellRange(n.row,n.col,n.row,n.col);case r.Row:return new t.CellRange(n.row,0,n.row,this._g.columns.length-1);case r.RowRange:case r.ListBox:return new t.CellRange(n.row,0,n.row2,this._g.columns.length-1)}return n},u}();t._SelectionHandler=u})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function i(n){this._g=n;n.addEventListener(n.hostElement,'keypress',this._keypress.bind(this));n.addEventListener(n.hostElement,'keydown',this._keydown.bind(this))}return i.prototype._keydown=function(i){var r=this._g,o=r.selection,f=i.ctrlKey||i.metaKey,u=i.shiftKey,y=i.target,s=!0,v,l,a;if(r.isRangeValid(o)&&!i.defaultPrevented){if(r._wantsInput(i.target))return;if(r.activeEditor&&r._edtHdl._keydown(i))return;var c=n.tryCast(r.rows[o.row],t.GroupRow),e=n.tryCast(r.collectionView,'IEditableCollectionView'),h=i.keyCode;if(r.autoClipboard){if(f&&(h==67||h==45)){if(l=new t.CellRangeEventArgs(r.cells,o),r.onCopying(l)){v=r.getClipString();n.Clipboard.copy(v);r.onCopied(l)}i.stopPropagation();return}if(f&&h==86||u&&h==45){r.isReadOnly||(l=new t.CellRangeEventArgs(r.cells,o),r.onPasting(l)&&n.Clipboard.paste(function(n){r.setClipString(n);r.onPasted(l)}));i.stopPropagation();return}}if(r._rtl)switch(h){case n.Key.Left:h=n.Key.Right;break;case n.Key.Right:h=n.Key.Left}switch(h){case 65:f?r.select(new t.CellRange(0,0,r.rows.length-1,r.columns.length-1)):s=!1;break;case n.Key.Left:o.isValid&&o.col==0&&c!=null&&!c.isCollapsed&&c.hasChildren?c.isCollapsed=!0:this._moveSel(t.SelMove.None,f?t.SelMove.Home:t.SelMove.Prev,u);break;case n.Key.Right:o.isValid&&o.col==0&&c!=null&&c.isCollapsed?c.isCollapsed=!1:this._moveSel(t.SelMove.None,f?t.SelMove.End:t.SelMove.Next,u);break;case n.Key.Up:if(i.altKey&&r._edtHdl._toggleListBox(this._g.selection))break;this._moveSel(f?t.SelMove.Home:t.SelMove.Prev,t.SelMove.None,u);break;case n.Key.Down:if(i.altKey&&r._edtHdl._toggleListBox(this._g.selection))break;this._moveSel(f?t.SelMove.End:t.SelMove.Next,t.SelMove.None,u);break;case n.Key.PageUp:this._moveSel(t.SelMove.PrevPage,t.SelMove.None,u);break;case n.Key.PageDown:this._moveSel(t.SelMove.NextPage,t.SelMove.None,u);break;case n.Key.Home:this._moveSel(f?t.SelMove.Home:t.SelMove.None,t.SelMove.Home,u);break;case n.Key.End:this._moveSel(f?t.SelMove.End:t.SelMove.None,t.SelMove.End,u);break;case n.Key.Tab:this._moveSel(t.SelMove.None,u?t.SelMove.PrevCell:t.SelMove.NextCell,!1);break;case n.Key.Enter:this._moveSel(u?t.SelMove.Prev:t.SelMove.Next,t.SelMove.None,!1);!u&&e&&e.currentEditItem!=null&&r._edtHdl._commitRowEdits();break;case n.Key.Escape:if(e&&(e.currentAddItem||e.currentEditItem)){a=new t.CellRangeEventArgs(r.cells,r.selection);a.cancel=!0;r.onRowEditEnding(a);e.currentAddItem&&e.cancelNew();e.currentEditItem&&e.cancelEdit();r.onRowEditEnded(a)}r._mouseHdl.resetMouseState();break;case n.Key.Delete:case n.Key.Back:s=this._deleteSel();break;case n.Key.F2:s=this._startEditing(!0,i);break;case n.Key.F4:s=r._edtHdl._toggleListBox(this._g.selection);break;case n.Key.Space:s=this._startEditing(!0,i);s&&setTimeout(function(){var t=r.activeEditor;t&&(t.type=='checkbox'?(t.checked=!t.checked,r.finishEditing()):n.setSelectionRange(t,t.value.length))});break;default:s=!1}s&&(r.focus(),i.preventDefault(),i.stopPropagation())}},i.prototype._keypress=function(t){var i=this._g;i._wantsInput(t.target)||(i.activeEditor?i._edtHdl._keypress(t):t.charCode>n.Key.Space&&this._startEditing(!1,t)&&i.activeEditor&&setTimeout(function(){var r=i.activeEditor;r&&r.type!='checkbox'&&(r.value=String.fromCharCode(t.charCode),n.setSelectionRange(r,1),r.dispatchEvent(i._edtHdl._evtInput),i._edtHdl._keypress(t))}),t.stopPropagation())},i.prototype._moveSel=function(n,i,r){this._g.selectionMode!=t.SelectionMode.None&&this._g._selHdl.moveSelection(n,i,r)},i.prototype._deleteSel=function(){var i=this._g,f=n.tryCast(i.collectionView,'IEditableCollectionView'),u=i.selection,o=i.rows,e=[],h,c,r,s,l,a;if(i.allowDelete&&!i.isReadOnly&&(f==null||f.canRemove&&!f.isAddingNew&&!f.isEditingItem))switch(i.selectionMode){case t.SelectionMode.CellRange:if(u.leftCol==0&&u.rightCol==i.columns.length-1)for(r=u.topRow;r>-1&&r<=u.bottomRow;r++)e.push(o[r]);break;case t.SelectionMode.ListBox:for(r=0;r<o.length;r++)o[r].isSelected&&e.push(o[r]);break;case t.SelectionMode.Row:u.topRow>-1&&e.push(o[u.topRow]);break;case t.SelectionMode.RowRange:for(r=u.topRow;r>-1&&r<=u.bottomRow;r++)e.push(o[r])}if(e.length>0){for(f&&f.beginUpdate(),i.beginUpdate(),h=new t.CellRange,c=new t.CellRangeEventArgs(i.cells,h),r=e.length-1;r>=0;r--)if(s=e[r],h.row=h.row2=s.index,i.onDeletingRow(c)){f&&s.dataItem?f.remove(s.dataItem):i.rows.removeAt(s.index);i.onDeletedRow(c)}return i.endUpdate(),f&&f.endUpdate(),i.selectionMode==t.SelectionMode.ListBox&&(l=i.selection.row,l>-1&&l<i.rows.length&&(i.rows[l].isSelected=!0)),i.childItemsPath&&i.collectionView&&i.collectionView.refresh(),!0}return!i.isReadOnly&&e.length==0&&u.isSingleCell&&(a=i._getBindingColumn(i.cells,u.row,i.columns[u.col]),!a.getIsRequired()&&i.getCellData(u.row,u.col,!0)&&this._startEditing(!1,c,u.row,u.col))?(i.setCellData(u.row,u.col,'',!0),i.finishEditing(!0),i.invalidate(),!0):!1},i.prototype._startEditing=function(n,t,i,r){return this._g._edtHdl.startEditing(n,i,r,!0,t)},i}();t._KeyboardHandler=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=4,r,e,u,f;(function(n){n[n.None=0]="None";n[n.Columns=1]="Columns";n[n.Rows=2]="Rows";n[n.Both=3]="Both";n[n.ColumnsAllCells=n.Columns|i]="ColumnsAllCells";n[n.RowsAllCells=n.Rows|i]="RowsAllCells";n[n.BothAllCells=n.Both|i]="BothAllCells"})(t.AllowResizing||(t.AllowResizing={}));r=t.AllowResizing,function(n){n[n.None=0]="None";n[n.Headers=1]="Headers";n[n.Cells=2]="Cells";n[n.Both=3]="Both"}(t.AutoSizeMode||(t.AutoSizeMode={}));e=t.AutoSizeMode,function(n){n[n.None=0]="None";n[n.Columns=1]="Columns";n[n.Rows=2]="Rows";n[n.Both=3]="Both"}(t.AllowDragging||(t.AllowDragging={}));u=t.AllowDragging;f=function(){function f(t){var r=this,i=t.hostElement,u,f;this._g=t;t.addEventListener(i,'mousedown',function(i){if(!i.defaultPrevented&&i.button==0){if(t._wantsInput(i.target))return;n.closest(i.target,'.wj-flexgrid')==r._g.hostElement&&(t.addEventListener(document,'mousemove',u),t.addEventListener(document,'mouseup',f),r._mousedown(i))}});u=function(n){r._mousemove(n)};f=function(n){t.removeEventListener(document,'mousemove');t.removeEventListener(document,'mouseup');r._mouseup(n)};t.addEventListener(i,'mousemove',this._hover.bind(this));t.addEventListener(i,'dblclick',this._dblclick.bind(this));t.addEventListener(i,'selectstart',function(n){n.target.tagName!='INPUT'&&n.preventDefault()});t.addEventListener(i,'wheel',function(i){var r=t.cells.hostElement.parentElement;r.scrollHeight>r.offsetHeight&&(i.deltaY<0&&r.scrollTop==0||i.deltaY>0&&r.scrollTop+r.offsetHeight>=r.scrollHeight)&&n.closest(i.target,'.wj-flexgrid')==t.hostElement&&(i.preventDefault(),i.stopPropagation())});t.addEventListener(i,'dragstart',this._dragstart.bind(this));t.addEventListener(i,'dragover',this._dragover.bind(this));t.addEventListener(i,'dragleave',this._dragover.bind(this));t.addEventListener(i,'drop',this._drop.bind(this));t.addEventListener(i,'dragend',this._dragend.bind(this));this._dvMarker=n.createElement('<div class="wj-marker">&nbsp;</div>')}return f.prototype.resetMouseState=function(){var n,t;this._dragSource&&(this._dragSource.style.opacity=1);this._showDragMarker(null);n=this._g.hostElement;n&&(n.style.cursor='default');t=this._g;t.removeEventListener(document,'mousemove');t.removeEventListener(document,'mouseup');this._htDown=null;this._lbSelRows=null;this._szRowCol=null;this._szArgs=null;this._dragSource=null},f.prototype._mousedown=function(i){var r=this._g,f,o,s,e,h;if(r._rcBounds=null,f=r.hitTest(i),o=f.cellType,o==t.CellType.None){r.finishEditing();return}if((o!=t.CellType.Cell||!r.editRange||!r.editRange.contains(f.range))&&(s=n.getActiveElement(),i.target!=s||!r._isInputElement(i.target))){if(i.target!=s&&r.focus(),this._htDown=f,this._eMouse=i,this._szRowCol!=null){this._handleResizing(i);return}switch(o){case t.CellType.Cell:i.ctrlKey&&r.selectionMode==t.SelectionMode.ListBox&&this._startListBoxSelection(f.row);this._mouseSelect(i,i.shiftKey);break;case t.CellType.RowHeader:(this._g.allowDragging&u.Rows)==0&&(i.ctrlKey&&r.selectionMode==t.SelectionMode.ListBox&&this._startListBoxSelection(f.row),this._mouseSelect(i,i.shiftKey))}if(o==t.CellType.Cell&&r.rows.maxGroupLevel>-1&&(e=n.tryCast(r.rows[f.row],t.GroupRow),h=n.closest(i.target,'.'+t.CellFactory._WJC_COLLAPSE),e&&h)){i.ctrlKey?r.collapseGroupsToLevel(e.isCollapsed?e.level+1:e.level):e.isCollapsed=!e.isCollapsed;this.resetMouseState();i.preventDefault();return}}},f.prototype._mousemove=function(n){var i=this;if(this._htDown!=null)if(setTimeout(function(){n.which&&i._g.containsFocus()||i.resetMouseState()}),this._eMouse=n,this._szRowCol)this._handleResizing(n);else switch(this._htDown.cellType){case t.CellType.Cell:this._mouseSelect(n,!0);break;case t.CellType.RowHeader:(this._g.allowDragging&u.Rows)==0&&this._mouseSelect(n,!0)}},f.prototype._mouseup=function(n){var i,r,u,f;this._dragSource&&this._g.isTouching||(i=this._htDown,!i||i.cellType!=t.CellType.TopLeft||this._szArgs||n.defaultPrevented?this._szArgs?this._finishResizing(n):this._handleSort(n):(r=this._g,u=r.hitTest(n),u.panel==i.panel&&u.row==i.row&&u.col==i.col&&(f=r.getMergedRange(i.panel,i.row,i.col)||u.range,f.row==0&&f.col==0&&r.select(new t.CellRange(0,0,r.rows.length-1,r.columns.length-1)))),this.resetMouseState())},f.prototype._dblclick=function(n){var u=this._g,e=u.hitTest(n),o=e.cellType,l=u.selection,s=e.range,f,h,c;if(!n.defaultPrevented){if(e.edgeRight&&u.allowResizing&r.Columns){if(o==t.CellType.ColumnHeader||o==t.CellType.Cell&&u.allowResizing&i){for(n.preventDefault(),n.ctrlKey&&l.containsColumn(e.col)&&(s=l),h=s.leftCol;h<=s.rightCol;h++)if(u.columns[h].allowResizing&&(f=new t.CellRangeEventArgs(u.cells,new t.CellRange(-1,h)),u.onAutoSizingColumn(f)&&u.onResizingColumn(f))){u.autoSizeColumn(h);u.onResizedColumn(f);u.onAutoSizedColumn(f)}}else if(o==t.CellType.TopLeft&&u.topLeftCells.columns[e.col].allowResizing&&(n.preventDefault(),f=new t.CellRangeEventArgs(u.topLeftCells,new t.CellRange(-1,e.col)),u.onAutoSizingColumn(f)&&u.onResizingColumn(f))){u.autoSizeColumn(e.col,!0);u.onAutoSizedColumn(f);u.onResizedColumn(f)}this.resetMouseState();return}if(e.edgeBottom&&u.allowResizing&r.Rows){if(o==t.CellType.RowHeader||o==t.CellType.Cell&&u.allowResizing&i){for(n.ctrlKey&&l.containsRow(e.row)&&(s=l),c=s.topRow;c<=s.bottomRow;c++)if(u.rows[c].allowResizing&&(f=new t.CellRangeEventArgs(u.cells,new t.CellRange(c,-1)),u.onAutoSizingRow(f)&&u.onResizingRow(f))){u.autoSizeRow(c);u.onResizedRow(f);u.onAutoSizedRow(f)}}else if(o==t.CellType.TopLeft&&u.topLeftCells.rows[e.row].allowResizing&&(f=new t.CellRangeEventArgs(u.topLeftCells,new t.CellRange(e.row,-1)),u.onAutoSizingRow(f)&&u.onResizingRow(f))){u.autoSizeRow(e.row,!0);u.onResizedRow(f);u.onAutoSizedRow(f)}this.resetMouseState()}}},f.prototype._hover=function(n){if(this._htDown==null){var u=this._g,f=u.hitTest(n),s=f.panel,e=f.cellType,o='default';this._szRowCol=null;(e==t.CellType.ColumnHeader||e==t.CellType.TopLeft||e==t.CellType.Cell&&u.allowResizing&i)&&f.edgeRight&&(u.allowResizing&r.Columns)!=0&&(this._szRowCol=this._getResizeCol(f));(e==t.CellType.RowHeader||e==t.CellType.TopLeft||e==t.CellType.Cell&&u.allowResizing&i)&&f.edgeBottom&&(u.allowResizing&r.Rows)!=0&&(this._szRowCol=this._getResizeRow(f));this._szRowCol instanceof t.Column?o='col-resize':this._szRowCol instanceof t.Row&&(o='row-resize');this._szStart=this._szRowCol?this._szRowCol.renderSize:0;u.hostElement.style.cursor=o}},f.prototype._getResizeCol=function(n){for(var i,r=n.panel.columns,f=r[n.col],u=n.col+1;u<r.length;u++)if(i=r[u],i.visible){i.size<1&&(f=i);break}if(n.col==r.length-1&&(n.cellType==t.CellType.TopLeft||n.cellType==t.CellType.RowHeader))for(r=this._g.columns,u=0;u<r.length;u++)if(i=r[u],i.visible){i.size<1&&(f=i);break}return f.allowResizing?f:null},f.prototype._getResizeRow=function(n){for(var i,r=n.panel.rows,f=r[n.row],u=n.row+1;u<r.length;u++)if(i=r[u],i.visible){i.size<1&&(f=i);break}if(n.row==r.length-1&&(n.cellType==t.CellType.TopLeft||n.cellType==t.CellType.ColumnHeader))for(r=this._g.rows,u=0;u<r.length;u++)if(i=r[u],i.visible){i.size<1&&(f=i);break}return f.allowResizing?f:null},f.prototype._mouseSelect=function(i,r){var f=this,u;this._htDown&&this._htDown.panel&&this._g.selectionMode!=t.SelectionMode.None&&(u=new t.HitTestInfo(this._htDown.panel,i),this._handleSelection(u,r),this._g._isInputElement(i.target)||i.preventDefault(),!n.isIE9()&&i.button>=0&&(u=new t.HitTestInfo(this._g,i),u.cellType!=t.CellType.Cell&&u.cellType!=t.CellType.RowHeader&&setTimeout(function(){f._mouseSelect(f._eMouse,r)},100)))},f.prototype._handleResizing=function(n){var u;if(n.preventDefault(),this._szRowCol instanceof t.Column){var i=this._g,e=n.clientX+pageXOffset,r=Math.round(Math.max(f._SZ_MIN,this._szStart+(e-this._htDown.point.x)*(i._rtl?-1:1)));this._szRowCol.renderSize!=r&&(this._szArgs==null&&(u=i.rowHeaders.columns.indexOf(this._szRowCol)>-1?i.rowHeaders:i.cells,this._szArgs=new t.CellRangeEventArgs(u,new t.CellRange(-1,this._szRowCol.index))),this._szArgs.cancel=!1,i.onResizingColumn(this._szArgs)&&(i.deferResizing||i.isTouching?this._showResizeMarker(r):this._szRowCol.width=r))}if(this._szRowCol instanceof t.Row){var i=this._g,o=n.clientY+pageYOffset,r=Math.round(Math.max(f._SZ_MIN,this._szStart+(o-this._htDown.point.y)));this._szRowCol.renderSize!=r&&(this._szArgs==null&&(u=i.columnHeaders.rows.indexOf(this._szRowCol)>-1?i.columnHeaders:i.cells,this._szArgs=new t.CellRangeEventArgs(u,new t.CellRange(this._szRowCol.index,-1))),this._szArgs.cancel=!1,i.onResizingRow(this._szArgs)&&(i.deferResizing||i.isTouching?this._showResizeMarker(r):this._szRowCol.height=r))}},f.prototype._dragstart=function(n){var i=this._g,r=this._htDown,f,e;r&&(this._dragSource=null,this._szRowCol||(f=new t.CellRangeEventArgs(i.cells,r.range),r.cellType==t.CellType.ColumnHeader&&i.allowDragging&u.Columns&&r.col>-1&&i.columns[r.col].allowDragging?i.onDraggingColumn(f)&&(this._dragSource=n.target):r.cellType==t.CellType.RowHeader&&i.allowDragging&u.Rows&&r.row>-1&&i.rows[r.row].allowDragging&&(e=i.rows[r.row],e instanceof t.GroupRow||e instanceof t._NewRowTemplate||i.onDraggingRow(f)&&(this._dragSource=n.target))),this._dragSource&&n.dataTransfer?(n.dataTransfer.effectAllowed='move',n.dataTransfer.setData('text',''),this._dragSource.style.opacity=.5,n.stopPropagation(),i.beginUpdate()):n.preventDefault())},f.prototype._dragend=function(){this._g.endUpdate();this.resetMouseState()},f.prototype._dragover=function(n){var r=this._g,i=r.hitTest(n),u=!1;this._htDown&&i.cellType==this._htDown.cellType&&(i.cellType==t.CellType.ColumnHeader?u=r.columns.canMoveElement(this._htDown.col,i.col):i.cellType==t.CellType.RowHeader&&(u=r.rows.canMoveElement(this._htDown.row,i.row)));u?(n.dataTransfer.dropEffect='move',n.preventDefault(),this._showDragMarker(i)):this._showDragMarker(null)},f.prototype._drop=function(n){var i=this._g,r=i.hitTest(n),f=new t.CellRangeEventArgs(i.cells,r.range),u;if(this._htDown&&r.cellType==this._htDown.cellType)if(u=i.selection,r.cellType==t.CellType.ColumnHeader){i.columns.moveElement(this._htDown.col,r.col);i.select(u.row,r.col);i.onDraggedColumn(f)}else if(r.cellType==t.CellType.RowHeader){i.rows.moveElement(this._htDown.row,r.row);i.select(r.row,u.col);i.onDraggedRow(f)}this.resetMouseState()},f.prototype._showResizeMarker=function(i){var f=this._g,e=this._dvMarker,r,u;e.parentElement||f.cells.hostElement.appendChild(e);u=this._szArgs.panel.cellType;this._szRowCol instanceof t.Column?(r={display:'',left:this._szRowCol.pos+i-1,top:0,right:'',bottom:0,width:3,height:'',zIndex:1e3},f._rtl&&(r.left=e.parentElement.clientWidth-r.left-r.width),(u==t.CellType.TopLeft||u==t.CellType.RowHeader)&&(r.left-=f.topLeftCells.hostElement.offsetWidth)):(r={left:0,top:this._szRowCol.pos+i-1,right:0,bottom:'',width:'',height:3,zIndex:1e3},(u==t.CellType.TopLeft||u==t.CellType.ColumnHeader)&&(r.top-=f.topLeftCells.hostElement.offsetHeight));n.setCss(e,r)},f.prototype._showDragMarker=function(i){var f=this._g,u=this._dvMarker,r,e,o;if(!i){u.parentElement&&u.parentElement.removeChild(u);this._rngTarget=null;return}if(!i.range.equals(this._rngTarget)){this._rngTarget=i.range;u.parentElement||i.panel.hostElement.appendChild(u);r={display:'',left:0,top:0,width:6,height:6};switch(i.cellType){case t.CellType.ColumnHeader:r.height=i.panel.height;e=f.columns[i.col];r.left=e.pos-r.width/2;i.col>this._htDown.col&&(r.left+=e.renderWidth);f._rtl&&(r.left=u.parentElement.clientWidth-r.left-r.width);break;case t.CellType.RowHeader:r.width=i.panel.width;o=f.rows[i.row];r.top=o.pos-r.height/2;i.row>this._htDown.row&&(r.top+=o.renderHeight)}n.setCss(u,r)}},f.prototype._finishResizing=function(n){var r=this._g,s=r.selection,c=this._eMouse.ctrlKey,i=this._szArgs,l=n.clientX+pageXOffset,a=n.clientY+pageYOffset,u,h,e,o;if(i&&!i.cancel&&i.col>-1){u=i.col;h=Math.round(Math.max(f._SZ_MIN,this._szStart+(l-this._htDown.point.x)*(this._g._rtl?-1:1)));i.panel.columns[u].width=Math.round(h);r.onResizedColumn(i);if(c&&this._htDown.cellType==t.CellType.ColumnHeader&&s.containsColumn(u))for(e=s.leftCol;e<=s.rightCol;e++)if(r.columns[e].allowResizing&&e!=u&&(i=new t.CellRangeEventArgs(r.cells,new t.CellRange(-1,e)),r.onResizingColumn(i))){r.columns[e].size=r.columns[u].size;r.onResizedColumn(i)}}if(i&&!i.cancel&&i.row>-1){u=i.row;h=Math.round(Math.max(f._SZ_MIN,this._szStart+(a-this._htDown.point.y)));i.panel.rows[u].height=Math.round(h);r.onResizedRow(i);if(c&&this._htDown.cellType==t.CellType.RowHeader&&s.containsRow(u))for(o=s.topRow;o<=s.bottomRow;o++)if(r.rows[o].allowResizing&&o!=u&&(i=new t.CellRangeEventArgs(r.cells,new t.CellRange(o,-1)),r.onResizingRow(i))){r.rows[o].size=r.rows[u].size;r.onResizedRow(i)}}},f.prototype._startListBoxSelection=function(n){var i=this._g.rows,t;for(this._lbSelState=!i[n].isSelected,this._lbSelRows={},t=0;t<i.length;t++)i[t].isSelected&&(this._lbSelRows[t]=!0)},f.prototype._handleSelection=function(n,i){var r=this._g,o=r.rows,e=r._selHdl._sel,f=new t.CellRange(n.row,n.col),s,u,h,c;if(n.row>-1&&n.col>-1)if(this._lbSelRows!=null){for(s=!1,f=new t.CellRange(n.row,n.col,this._htDown.row,this._htDown.col),u=0;u<o.length;u++)if(h=f.containsRow(u)?this._lbSelState:this._lbSelRows[u]!=null,h!=o[u].isSelected&&(c=new t.CellRangeEventArgs(r.cells,new t.CellRange(u,e.col,u,e.col2)),r.onSelectionChanging(c))){o[u]._setFlag(t.RowColFlags.Selected,h,!0);s=!0;r.onSelectionChanged(c)}s&&r.refreshCells(!1,!0,!0);r.scrollIntoView(n.row,n.col)}else n.cellType==t.CellType.RowHeader&&(f.col=0,f.col2=r.columns.length-1),i&&(f.row2=e.row2,f.col2=e.col2),r.select(f)},f.prototype._handleSort=function(i){var u=this._g,o=u.collectionView,r=u.hitTest(i),s,a,h,e;if(this._htDown&&r.cellType==this._htDown.cellType&&r.col==this._htDown.col&&r.cellType==t.CellType.ColumnHeader&&!r.edgeRight&&r.col>-1&&o&&o.canSort&&u.allowSorting){var c=u.getMergedRange(r.panel,r.row,r.col),v=c?c.row2:r.row,l=u.columns[r.col],f=u._getBindingColumn(r.panel,r.row,l);if((v==u._getSortRowIndex()||l!=f)&&(s=f.currentSort,a=s!='+',f.allowSorting&&f.binding)){if(!s&&i.ctrlKey)return;if(h=new t.CellRangeEventArgs(u.columnHeaders,new t.CellRange(-1,r.col)),u.onSortingColumn(h)){e=o.sortDescriptions;i.ctrlKey?e.clear():e.splice(0,e.length,new n.collections.SortDescription(f._getBindingSort(),a));u.onSortedColumn(h)}}}},f._SZ_MIN=0,f}();t._MouseHandler=f})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function i(i){var r=this;this._fullEdit=!1;this._list=null;this._g=i;this._evtInput=document.createEvent('HTMLEvents');this._evtInput.initEvent('input',!0,!1);i.selectionChanging.addHandler(function(n,t){var u;if(r.finishEditing()){if(u=i._selHdl._sel.row,u!=t.row){var f=i.rows.length,e=u>-1&&u<f?i.rows[u].dataItem:null,o=t.row>-1&&t.row<f?i.rows[t.row].dataItem:null;e!=o&&r._commitRowEdits()}}else t.cancel=!0});i.lostFocus.addHandler(function(){if(!r._g.containsFocus()){var t=n.getActiveElement();t&&getComputedStyle(t).position=='fixed'||r._commitRowEdits()}});i.addEventListener(i.hostElement,'mousedown',function(u){var o,e,f,s;if(!u.defaultPrevented&&u.button==0&&!i._mouseHdl._szRowCol)if(o=i.selection,e=i.hitTest(u),r._htDown=null,r._cancelClick=!1,e.cellType!=t.CellType.Cell&&e.cellType!=t.CellType.None)r._lbx&&n.contains(r._lbx.hostElement,u.target)||r._commitRowEdits();else if(e.cellType!=t.CellType.None){if(f=n.tryCast(u.target,HTMLInputElement),f&&f.type=='checkbox'&&n.hasClass(f.parentElement,'wj-cell')&&(f!=r.activeEditor?r.startEditing(!1,e.row,e.col)&&setTimeout(function(){f=r.activeEditor;f&&f.type=='checkbox'?(f.checked=!f.checked,f.focus(),r.finishEditing()):r._cancelClick=!0}):r.finishEditing()),s=document.elementFromPoint(u.clientX,u.clientY),n.closest(s,'.'+t.CellFactory._WJC_DROPDOWN)){r._toggleListBox(u,e.range);r._htDown=null;u.preventDefault();return}f==null&&e.row==o.row&&e.col==o.col&&(r._htDown=e)}},!0);i.addEventListener(i.hostElement,'click',function(n){var t,u;if(r._cancelClick){n.preventDefault();n.stopPropagation();return}r._htDown&&!r.activeEditor&&(t=i.hitTest(n),t.range.equals(r._htDown.range)&&r.startEditing(!0,t.row,t.col,!0,n));r._htDown||r.activeEditor||(t=i.hitTest(n),(t.row<i.rows.frozen||t.col<i.columns.frozen)&&(u=n.target,u instanceof HTMLInputElement&&u.type=='checkbox'&&i._updateFrozenCells()))},!0)}return i.prototype.startEditing=function(i,r,u,f,e){var o,h,c,l,a,v,y,s;if((i===void 0&&(i=!0),o=this._g,r=n.asNumber(r,!0,!0),u=n.asNumber(u,!0,!0),r==null&&(r=o.selection.row),u==null&&(u=o.selection.col),f==null&&(f=!0),!this._allowEditing(r,u))||(h=o.getMergedRange(o.cells,r,u),h||(h=new t.CellRange(r,u)),c=o.rows[r].dataItem,o.select(h,!0),!o.rows[r]||c!=o.rows[r].dataItem))return!1;if(h.equals(this._rng))return!0;if(l=new t.CellRangeEventArgs(o.cells,h,e),!o.onBeginningEdit(l))return!1;if(a=n.tryCast(o.collectionView,'IEditableCollectionView'),a){if(c=o.rows[r].dataItem,v=c!=a.currentEditItem,v)o.onRowEditStarting(l);if(a.editItem(c),v)o.onRowEditStarted(l)}if(this._fullEdit=i,this._rng=h,this._list=null,y=o.columns[u].dataMap,y&&(this._list=y.getDisplayValues(c)),o.refresh(!1),s=this._edt,s){s.type=='checkbox'?this._fullEdit=!1:f&&n.setSelectionRange(s,0,s.value.length);o.onPrepareCellForEdit(l);s=this._edt;s&&f&&s.focus()}return!0},i.prototype.finishEditing=function(i){var f,c,l,a,o,s;if(i===void 0&&(i=!1),f=this._edt,!f)return this._removeListBox(),!0;var r=this._g,e=this._rng,u=new t.CellEditEndingEventArgs(r.cells,e),h=this._g.containsFocus();if(f&&h&&(c=n.Control.getControl(n.closest(n.getActiveElement(),'.wj-control')),c&&c!=this._g))c.onLostFocus(u);if(u.cancel=i,!i&&r.validateEdits&&(l=this._getValidationError(),l&&(n.toggleClass(f.parentElement,'wj-state-invalid',!0),f.parentElement.title=l,u.cancel=u.stayInEditMode=!0)),!r.onCellEditEnding(u)&&u.stayInEditMode&&h)return h&&f&&setTimeout(function(){f.select()}),!1;if(!u.cancel)for(u.data=r.cells.getCellData(e.topRow,e.leftCol,!1),a=r.cellFactory.getEditorValue(r),o=e.topRow;o<=e.bottomRow&&o<r.rows.length;o++)for(s=e.leftCol;s<=e.rightCol&&s<r.columns.length;s++)r.cells.setCellData(o,s,a,!0);this._edt=null;this._rng=null;this._list=null;this._removeListBox();r.refresh(!1);h&&r.focus();r.onCellEditEnded(u);return!0},Object.defineProperty(i.prototype,"activeEditor",{get:function(){return this._edt},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"editRange",{get:function(){return this._rng},enumerable:!0,configurable:!0}),i.prototype._getValidationError=function(){var t=this._g,e=t.collectionView,o=e?e.getError:null,c;if(n.isFunction(o)){var f=this._rng,i=t._getBindingColumn(t.cells,f.row,t.columns[f.col]),l=i.binding,s=i.dataType,r=t.rows[f.row].dataItem,u=t.cellFactory.getEditorValue(t),h=null;if(u=n.changeType(u,s,i.format),n.getType(u)==s&&r)return c=i._binding.getValue(r),i._binding.setValue(r,u),h=o(r,l),i._binding.setValue(r,c),h}return null},i.prototype._allowEditing=function(n,i){var r=this._g,u;return r.isReadOnly||r.selectionMode==t.SelectionMode.None?!1:n<0||n>=r.rows.length||r.rows[n].isReadOnly||!r.rows[n].isVisible?!1:i<0||i>=r.columns.length?!1:(u=r._getBindingColumn(r.cells,n,r.columns[i]),u&&(u.isReadOnly||!u.isVisible))?!1:!0},i.prototype._commitRowEdits=function(){var i,r,u;if(this.finishEditing(),i=this._g,r=n.tryCast(i.collectionView,'IEditableCollectionView'),r&&r.currentEditItem){u=new t.CellRangeEventArgs(i.cells,i.selection);i.onRowEditEnding(u);r.commitEdit();i.onRowEditEnded(u)}},i.prototype._keydown=function(t){switch(t.keyCode){case n.Key.F2:return this._fullEdit=!this._fullEdit,t.preventDefault(),!0;case n.Key.F4:return this._toggleListBox(t),t.preventDefault(),!0;case n.Key.Space:var i=this._edt;return i&&i.type=='checkbox'&&(i.checked=!i.checked,this.finishEditing(),t.preventDefault()),!0;case n.Key.Enter:case n.Key.Tab:return t.preventDefault(),!this.finishEditing();case n.Key.Escape:return t.preventDefault(),this.finishEditing(!0),!0;case n.Key.Up:case n.Key.Down:case n.Key.Left:case n.Key.Right:case n.Key.PageUp:case n.Key.PageDown:case n.Key.Home:case n.Key.End:if(this._lbx)return this._keydownListBox(t);if(t.altKey)switch(t.keyCode){case n.Key.Up:case n.Key.Down:return this._toggleListBox(t),t.preventDefault(),!0}if(!this._fullEdit&&this.finishEditing())return!1}return!0},i.prototype._keydownListBox=function(t){var i=!0;if(this._lbx)switch(t.keyCode){case n.Key.Up:t.altKey?this._toggleListBox(t):this._lbx.selectedIndex>0&&this._lbx.selectedIndex--;break;case n.Key.Down:t.altKey?this._toggleListBox(t):this._lbx.selectedIndex++;break;case n.Key.Home:case n.Key.PageUp:this._lbx.selectedIndex=0;break;case n.Key.End:case n.Key.PageDown:this._lbx.selectedIndex=this._lbx.collectionView.items.length-1;break;default:i=!1}return i?(t.preventDefault(),!0):!1},i.prototype._keypress=function(t){var i=this._edt,f,u,r;if(i&&i.type!='checkbox'&&t.target==i&&this._list&&this._list.length>0&&t.charCode>=32)for(f=i.selectionStart,u=i.value.substr(0,f),t.target==i&&(f++,u+=String.fromCharCode(t.charCode)),u=u.toLowerCase(),r=0;r<this._list.length;r++)if(this._list[r].toLowerCase().indexOf(u)==0){i.value=this._list[r];n.setSelectionRange(i,f,this._list[r].length);i.dispatchEvent(this._evtInput);t.preventDefault();break}},i.prototype._toggleListBox=function(t,i){var r=this._g,u,f;return(i||(i=r.selection),this._lbx&&(this._removeListBox(),r.selection.contains(i)))?(r.activeEditor?r.activeEditor.focus():r.containsFocus()||r.focus(),!0):(u=r.isTouching,f=r._getBindingColumn(r.cells,i.row,r.columns[i.col]),!n.input||!f.dataMap||f.showDropDown===!1)?!1:!n.input||!this.startEditing(!0,i.row,i.col,!u,t)?!1:(this._lbx=this._createListBox(),this._lbx.showSelection(),u&&this._lbx.focus(),!0)},i.prototype._createListBox=function(){var u=this,t=this._g,r=this._rng,e=t.rows[r.row],o=t._getBindingColumn(t.cells,r.row,t.columns[r.col]),f=document.createElement('div'),i=new n.input.ListBox(f);return n.addClass(f,'wj-dropdown-panel'),i.maxHeight=e.renderHeight*4,i.itemsSource=o.dataMap.getDisplayValues(e.dataItem),i.selectedValue=t.activeEditor?t.activeEditor.value:t.getCellData(r.row,r.col,!0),n.addClass(f,o.dropDownCssClass),i.addEventListener(i.hostElement,'click',function(){u._removeListBox();u.finishEditing()}),i.lostFocus.addHandler(function(){u._removeListBox()}),i.selectedIndexChanged.addHandler(function(){var i=t.activeEditor;i&&(i.value=u._lbx.selectedValue,i.dispatchEvent(u._evtInput),n.setSelectionRange(i,0,i.value.length))}),n.showPopup(f,t.getCellBoundingRect(r.row,r.col)),i},i.prototype._removeListBox=function(){this._lbx&&(n.hidePopup(this._lbx.hostElement,!0),this._lbx.dispose(),this._lbx=null)},i}();t._EditHandler=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){'use strict';var r=function(){function r(n){this._nrt=new i;this._g=n;this._keydownBnd=this._keydown.bind(this);this._attach()}return Object.defineProperty(r.prototype,"newRowAtTop",{get:function(){return this._top},set:function(t){t!=this.newRowAtTop&&(this._top=n.asBoolean(t),this.updateNewRowTemplate())},enumerable:!0,configurable:!0}),r.prototype.updateNewRowTemplate=function(){var o=n.tryCast(this._g.collectionView,'IEditableCollectionView'),u=this._g,i=u.rows,s=o&&o.canAddNew&&u.allowAddNew&&!u.isReadOnly,r=i.indexOf(this._nrt),h=this._top?0:i.length-1,e=!1,f;!s&&r>-1?(f=u.selection,f.row==r&&u.select(f.row-1,f.col),i.removeAt(r)):s&&(r<0?e=!0:r!=h&&(i.removeAt(r),e=!0),e&&(this._top?i.insert(0,this._nrt):i.push(this._nrt)),this._nrt&&this._nrt._setFlag(t.RowColFlags.ParentCollapsed,!1))},r.prototype._attach=function(){var n=this._g;n&&(n.beginningEdit.addHandler(this._beginningEdit,this),n.pastingCell.addHandler(this._beginningEdit,this),n.rowEditEnded.addHandler(this._rowEditEnded,this),n.loadedRows.addHandler(this.updateNewRowTemplate,this),n.hostElement.addEventListener('keydown',this._keydownBnd,!0))},r.prototype._detach=function(){var n=this._g;n&&(n.beginningEdit.removeHandler(this._beginningEdit),n.pastingCell.removeHandler(this._beginningEdit),n.rowEditEnded.removeHandler(this._rowEditEnded),n.loadedRows.removeHandler(this.updateNewRowTemplate),n.hostElement.removeEventListener('keydown',this._keydownBnd,!0))},r.prototype._keydown=function(t){t.defaultPrevented||t.keyCode!=n.Key.Escape||this._g.activeEditor==null&&this._top&&this._nrt.dataItem&&(this._nrt.dataItem=null,this._g.invalidate())},r.prototype._beginningEdit=function(t,r){var e,u,f;if(!r.cancel&&(e=this._g.rows[r.row],n.tryCast(e,i)&&(u=n.tryCast(this._g.collectionView,'IEditableCollectionView'),u&&u.canAddNew)))if(this._top){if(this._nrt.dataItem==null){var f=null,o=u.sourceCollection,s=u.newItemCreator;f=n.isFunction(s)?s():o&&o.length?new o[0].constructor:{};this._nrt.dataItem=f}}else{f=u.currentAddItem&&u.currentAddItem==e.dataItem?u.currentAddItem:u.addNew();u.moveCurrentTo(f);this.updateNewRowTemplate();this._g.refresh(!0);this._g.onRowAdded(r);r.cancel&&u.cancelNew()}},r.prototype._rowEditEnded=function(t,i){var e=this,r=n.tryCast(this._g.collectionView,'IEditableCollectionView'),u=this._nrt.dataItem,o,f;if(r)if(r.isAddingNew)r.commitNew();else if(u&&!i.cancel){this._nrt.dataItem=null;o=r.addNew();for(f in u)o[f]=u[f];r.commitNew();setTimeout(function(){e._g.select(0,e._g.columns.firstVisibleIndex)},20)}},r}(),i;t._AddNewHandler=r;i=function(n){function t(){n.apply(this,arguments)}return __extends(t,n),t}(t.Row);t._NewRowTemplate=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function t(t){this._tbx=n.createElement('<input class="wj-grid-editor wj-form-control" wj-part="ime-target"/>');this._cssHidden={opacity:'0',pointerEvents:'none',position:'absolute',left:-10,top:-10,width:0};n.setCss(this._tbx,this._cssHidden);this._g=t;this._g.cells.hostElement.parentElement.appendChild(this._tbx);this._updateImeFocus();var t=this._g,i=t.hostElement;t.addEventListener(this._tbx,'compositionstart',this._compositionstart.bind(this));t.addEventListener(this._tbx,'keydown',this._keydown.bind(this));t.addEventListener(i,'blur',this._updateImeFocus.bind(this),!0);t.addEventListener(i,'focus',this._updateImeFocus.bind(this),!0);t.addEventListener(i,'mousedown',this._mousedown.bind(this),!0);t.addEventListener(i,'mouseup',this._mouseup.bind(this),!0);t.cellEditEnded.addHandler(this._cellEditEnded,this);t.selectionChanged.addHandler(this._updateImeFocus,this)}return t.prototype.dispose=function(){var n=this._g,t=n.hostElement;n.removeEventListener(this._tbx,'compositionstart');n.removeEventListener(t,'blur');n.removeEventListener(t,'focus');n.removeEventListener(t,'mousedown');n.removeEventListener(t,'mouseup');n.cellEditEnded.removeHandler(this._cellEditEnded);n.selectionChanged.removeHandler(this._updateImeFocus);this._tbx.parentElement&&this._tbx.parentElement.removeChild(this._tbx)},t.prototype._cellEditEnded=function(){n.setCss(this._tbx,this._cssHidden);this._tbx.value=''},t.prototype._compositionstart=function(){var t=this._g,i,r,u;t.activeEditor==null&&(i=t._selHdl.selection,t.startEditing(!1,i.row,i.col,!1)&&(r=t.getCellBoundingRect(i.row,i.col),u=t.cells.hostElement,n.setCss(this._tbx,{opacity:'',pointerEvents:'',left:t.columns[i.col].pos+u.offsetLeft,top:t.rows[i.row].pos+u.offsetTop,width:r.width-1,height:r.height-1}),t._edtHdl._edt=this._tbx))},t.prototype._keydown=function(t){switch(t.keyCode){case n.Key.Up:case n.Key.Down:case n.Key.PageUp:case n.Key.PageDown:this._g._keyHdl._keydown(t)}},t.prototype._mousedown=function(){this._mouseDown=!0;this._updateImeFocus()},t.prototype._mouseup=function(){this._mouseDown=!1;this._updateImeFocus()},t.prototype._updateImeFocus=function(){var i=this._g,t,r;!i.containsFocus()||i.activeEditor||i.isTouching||this._mouseDown||(t=this._tbx,this._enableIme()?(t.disabled=!1,t.select()):t.disabled||(t.disabled=!0,r=n.getActiveElement(),r instanceof HTMLElement&&r.blur(),i.focus()))},t.prototype._enableIme=function(){var i=this._g,t=i.selection;return t.row<0||t.col<0||!i._edtHdl._allowEditing(t.row,t.col)?!1:i.columns[t.col].dataType==n.DataType.Boolean?!1:!0},t}();t._ImeHandler=i})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var __extends,wijmo;(function(n){var t;(function(n){var t;(function(){'use strict'})(t=n.filter||(n.filter={}))})(t=n.grid||(n.grid={}))})(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(){function t(t){this._maxValues=250;this._sortValues=!0;this._col=t;this._bnd=t.binding?new n.Binding(t.binding):null}return Object.defineProperty(t.prototype,"showValues",{get:function(){return this._values},set:function(n){this._values=n},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"filterText",{get:function(){return this._filterText},set:function(t){this._filterText=n.asString(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"maxValues",{get:function(){return this._maxValues},set:function(t){this._maxValues=n.asNumber(t,!1,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"uniqueValues",{get:function(){return this._uniqueValues},set:function(t){this._uniqueValues=n.asArray(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"sortValues",{get:function(){return this._sortValues},set:function(t){this._sortValues=n.asBoolean(t)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"column",{get:function(){return this._col},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isActive",{get:function(){return this._values!=null&&Object.keys(this._values).length>0},enumerable:!0,configurable:!0}),t.prototype.apply=function(t){var i=this.column;return!this._bnd||!this._values||!Object.keys(this._values).length?!0:(t=this._bnd.getValue(t),t=i.dataMap?i.dataMap.getDisplayValue(t):n.Globalize.format(t,i.format),this._values[t]!=undefined)},t.prototype.clear=function(){this.showValues=null;this.filterText=null},t.prototype.implementsInterface=function(n){return n=='IColumnFilter'},t}();t.ValueFilter=i})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(i){function r(r,u){var f,e;i.call(this,r);this._filter=n.asType(u,t.ValueFilter,!1);f=this.getTemplate();this.applyTemplate('wj-control',f,{_divFilter:'div-filter',_cbSelectAll:'cb-select-all',_spSelectAll:'sp-select-all',_divValues:'div-values'});this._spSelectAll.textContent=n.culture.FlexGridFilter.selectAll;this._view=new n.collections.CollectionView;u.sortValues&&(e=u.column.dataMap?'text':'value',this._view.sortDescriptions.push(new n.collections.SortDescription(e,!0)));this._view.filter=this._filterValues.bind(this);this._view.collectionChanged.addHandler(this._updateSelectAllCheck,this);this._filterText='';this._cmbFilter=new n.input.ComboBox(this._divFilter,{placeholder:n.culture.FlexGridFilter.search});this._lbValues=new n.input.ListBox(this._divValues,{displayMemberPath:'text',checkedMemberPath:'show',itemsSource:this._view,itemFormatter:function(t,i){return i?i:n.culture.FlexGridFilter.null}});this._cmbFilter.textChanged.addHandler(this._filterTextChanged,this);this._cbSelectAll.addEventListener('click',this._cbSelectAllClicked.bind(this));this.updateEditor()}return __extends(r,i),Object.defineProperty(r.prototype,"filter",{get:function(){return this._filter},enumerable:!0,configurable:!0}),r.prototype.updateEditor=function(){var i=this._filter.column,r=[],h,a,c,u,o,s,v,t;if(this._filter.uniqueValues)for(h=this._filter.uniqueValues,t=0;t<h.length;t++)u=h[t],r.push({value:u,text:u.toString()});else{var l={},f=i.collectionView?i.collectionView.sourceCollection:[],e=i.collectionView;if(e&&e.sourceCollection&&e.filter){for(a=this._filter.showValues,this._filter.showValues=null,c=[],t=0;t<f.length;t++)e.filter(f[t])&&c.push(f[t]);f=c;this._filter.showValues=a}for(t=0;t<f.length;t++)u=i._binding.getValue(f[t]),o=i.dataMap?i.dataMap.getDisplayValue(u):n.Globalize.format(u,i.format),l[o]||(l[o]=!0,r.push({value:u,text:o}))}if(s=this._filter.showValues,s&&Object.keys(s).length!=0){for(v in s)for(t=0;t<r.length;t++)if(r[t].text==v){r[t].show=!0;break}}else for(t=0;t<r.length;t++)r[t].show=!0;this._lbValues.isContentHtml=i.isContentHtml;this._cmbFilter.text=this._filter.filterText;this._filterText=this._cmbFilter.text.toLowerCase();this._view.pageSize=this._filter.maxValues;this._view.sourceCollection=r;this._view.moveCurrentToPosition(-1)},r.prototype.clearEditor=function(){var t,n;for(this._cmbFilter.text='',this._filterText='',this._view.refresh(),t=this._view.items,n=0;n<t.length;n++)t[n].show=!1},r.prototype.updateFilter=function(){var t=null,r=this._view.items,n,i;if(this._filterText||this._cbSelectAll.indeterminate)for(t={},n=0;n<r.length;n++)i=r[n],i.show&&(t[i.text]=!0);this._filter.showValues=t;this._filter.filterText=this._filterText},r.prototype._filterTextChanged=function(){var n=this;this._toText&&clearTimeout(this._toText);this._toText=setTimeout(function(){var t=n._cmbFilter.text.toLowerCase();t!=n._filterText&&(n._filterText=t,n._view.refresh(),n._cbSelectAll.checked=!0,n._cbSelectAllClicked())},500)},r.prototype._filterValues=function(n){return this._filterText?n&&n.text?n.text.toLowerCase().indexOf(this._filterText)>-1:!1:!0},r.prototype._cbSelectAllClicked=function(){for(var i=this._cbSelectAll.checked,t=this._view.items,n=0;n<t.length;n++)t[n].show=i;this._view.refresh()},r.prototype._updateSelectAllCheck=function(){for(var n=0,t=this._view.items,i=0;i<t.length;i++)t[i].show&&n++;n==0?(this._cbSelectAll.checked=!1,this._cbSelectAll.indeterminate=!1):n==t.length?(this._cbSelectAll.checked=!0,this._cbSelectAll.indeterminate=!1):this._cbSelectAll.indeterminate=!0},r.controlTemplate='<div><div wj-part="div-filter"><\/div><div class="wj-listbox-item"><label><input wj-part="cb-select-all" type="checkbox"> <span wj-part="sp-select-all"><\/span><\/label><\/div><div wj-part="div-values" style="height:150px"><\/div><\/div>',r}(n.Control);t.ValueFilterEditor=i})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(){function i(i){this._c1=new t.FilterCondition;this._c2=new t.FilterCondition;this._and=!0;this._col=i;this._bnd=i.binding?new n.Binding(i.binding):null}return Object.defineProperty(i.prototype,"condition1",{get:function(){return this._c1},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"condition2",{get:function(){return this._c2},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"and",{get:function(){return this._and},set:function(t){this._and=n.asBoolean(t);this._bnd=this._col&&this._col.binding?new n.Binding(this._col.binding):null},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"column",{get:function(){return this._col},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isActive",{get:function(){return this._c1.isActive||this._c2.isActive},enumerable:!0,configurable:!0}),i.prototype.apply=function(t){var i=this._col,r=this._c1,u=this._c2,f,e;return!this._bnd||!this.isActive?!0:(t=this._bnd.getValue(t),i.dataMap?t=i.dataMap.getDisplayValue(t):n.isDate(t)?(n.isString(r.value)||n.isString(u.value))&&(t=n.Globalize.format(t,i.format)):n.isNumber(t)&&(t=n.Globalize.parseFloat(n.Globalize.format(t,i.format))),f=r.apply(t),e=u.apply(t),r.isActive&&u.isActive?this._and?f&&e:f||e:r.isActive?f:u.isActive?e:!0)},i.prototype.clear=function(){this._c1.clear();this._c2.clear();this.and=!0},i.prototype.implementsInterface=function(n){return n=='IColumnFilter'},i}();t.ConditionFilter=i})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(i){function r(r,u){var e,f;i.call(this,r);this._filter=n.asType(u,t.ConditionFilter,!1);e=this.getTemplate();this.applyTemplate('wj-control',e,{_divHdr:'div-hdr',_divCmb1:'div-cmb1',_divVal1:'div-val1',_btnAnd:'btn-and',_btnOr:'btn-or',_spAnd:'sp-and',_spOr:'sp-or',_divCmb2:'div-cmb2',_divVal2:'div-val2'});this._divHdr.textContent=n.culture.FlexGridFilter.header;this._spAnd.textContent=n.culture.FlexGridFilter.and;this._spOr.textContent=n.culture.FlexGridFilter.or;this._cmb1=this._createOperatorCombo(this._divCmb1);this._cmb2=this._createOperatorCombo(this._divCmb2);this._val1=this._createValueInput(this._divVal1);this._val2=this._createValueInput(this._divVal2);f=this._btnAndOrChanged.bind(this);this._btnAnd.addEventListener('change',f);this._btnOr.addEventListener('change',f);this.updateEditor()}return __extends(r,i),Object.defineProperty(r.prototype,"filter",{get:function(){return this._filter},enumerable:!0,configurable:!0}),r.prototype.updateEditor=function(){var t=this._filter.condition1,i=this._filter.condition2;this._cmb1.selectedValue=t.operator;this._cmb2.selectedValue=i.operator;this._val1 instanceof n.input.ComboBox?(this._val1.text=n.changeType(t.value,n.DataType.String,null),this._val2.text=n.changeType(i.value,n.DataType.String,null)):(this._val1.value=t.value,this._val2.value=i.value);this._btnAnd.checked=this._filter.and;this._btnOr.checked=!this._filter.and},r.prototype.clearEditor=function(){this._cmb1.selectedValue=this._cmb2.selectedValue=null;this._val1.text=this._val2.text=null;this._btnAnd.checked=!0;this._btnOr.checked=!1},r.prototype.updateFilter=function(){var t=this._filter.column,i=this._filter.condition1,r=this._filter.condition2,u;i.operator=this._cmb1.selectedValue;r.operator=this._cmb2.selectedValue;this._val1 instanceof n.input.ComboBox?(u=t.dataType==n.DataType.Date?n.DataType.String:t.dataType,i.value=n.changeType(this._val1.text,u,t.format),r.value=n.changeType(this._val2.text,u,t.format)):(i.value=this._val1.value,r.value=this._val2.value);this._filter.and=this._btnAnd.checked},r.prototype._createOperatorCombo=function(t){var i=this._filter.column,u=n.culture.FlexGridFilter.stringOperators,r;return i.dataType!=n.DataType.Date||this._isTimeFormat(i.format)?i.dataType!=n.DataType.Number||i.dataMap?i.dataType!=n.DataType.Boolean||i.dataMap||(u=n.culture.FlexGridFilter.booleanOperators):u=n.culture.FlexGridFilter.numberOperators:u=n.culture.FlexGridFilter.dateOperators,r=new n.input.ComboBox(t),r.itemsSource=u,r.displayMemberPath='name',r.selectedValuePath='op',r},r.prototype._createValueInput=function(t){var r=this._filter.column,i=null;return r.dataType!=n.DataType.Date||this._isTimeFormat(r.format)?r.dataType!=n.DataType.Number||r.dataMap?(i=new n.input.ComboBox(t),r.dataMap?(i.itemsSource=r.dataMap.getDisplayValues(),i.isEditable=!0):r.dataType==n.DataType.Boolean&&(i.itemsSource=[!0,!1])):(i=new n.input.InputNumber(t),i.format=r.format):(i=new n.input.InputDate(t),i.format=r.format),i.isRequired=!1,i},r.prototype._isTimeFormat=function(t){return t?(t=n.culture.Globalize.calendar.patterns[t]||t,/[Hmst]+/.test(t)):!1},r.prototype._btnAndOrChanged=function(n){this._btnAnd.checked=n.target==this._btnAnd;this._btnOr.checked=n.target==this._btnOr},r.controlTemplate='<div><div wj-part="div-hdr"><\/div><div wj-part="div-cmb1"><\/div><br/><div wj-part="div-val1"><\/div><br/><div style="text-align:center"><label><input wj-part="btn-and" type="radio"> <span wj-part="sp-and"><\/span> <\/label>&nbsp;&nbsp;&nbsp;<label><input wj-part="btn-or" type="radio"> <span wj-part="sp-or"><\/span> <\/label><\/div><div wj-part="div-cmb2"><\/div><br/><div wj-part="div-val2"><\/div><br/><\/div>',r}(n.Control);t.ConditionFilterEditor=i})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(t){'use strict';var r=function(){function t(){this._op=null}return Object.defineProperty(t.prototype,"operator",{get:function(){return this._op},set:function(t){this._op=n.asEnum(t,i,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"value",{get:function(){return this._val},set:function(t){this._val=t;this._strVal=n.isString(t)?t.toString().toLowerCase():null},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isActive",{get:function(){switch(this._op){case null:return!1;case i.EQ:case i.NE:return!0;default:return this._val!=null||this._strVal!=null}},enumerable:!0,configurable:!0}),t.prototype.clear=function(){this.operator=null;this.value=null},t.prototype.apply=function(t){var r=this._strVal||this._val;n.isString(t)&&(t=t.toLowerCase());switch(this._op){case null:return!0;case i.EQ:return n.isDate(t)&&n.isDate(r)?n.DateTime.sameDate(t,r):t==r;case i.NE:return t!=r;case i.GT:return t>r;case i.GE:return t>=r;case i.LT:return t<r;case i.LE:return t<=r;case i.BW:return this._strVal&&n.isString(t)?t.indexOf(this._strVal)==0:!1;case i.EW:return this._strVal&&n.isString(t)&&t.length>=this._strVal.length?t.substr(t.length-this._strVal.length)==r:!1;case i.CT:return this._strVal&&n.isString(t)?t.indexOf(this._strVal)>-1:!1;case i.NC:return this._strVal&&n.isString(t)?t.indexOf(this._strVal)<0:!1}throw'Unknown operator';},t}(),i;t.FilterCondition=r,function(n){n[n.EQ=0]="EQ";n[n.NE=1]="NE";n[n.GT=2]="GT";n[n.GE=3]="GE";n[n.LT=4]="LT";n[n.LE=5]="LE";n[n.BW=6]="BW";n[n.EW=7]="EW";n[n.CT=8]="CT";n[n.NC=9]="NC"}(t.Operator||(t.Operator={}));i=t.Operator})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(){function i(n,i){this._owner=n;this._col=i;this._valueFilter=new t.ValueFilter(i);this._conditionFilter=new t.ConditionFilter(i)}return Object.defineProperty(i.prototype,"filterType",{get:function(){return this._filterType!=null?this._filterType:this._owner.defaultFilterType},set:function(i){if(i!=this._filterType){var r=this.isActive;this.clear();this._filterType=n.asEnum(i,t.FilterType,!0);r?this._owner.apply():this._col.grid&&this._col.grid.invalidate()}},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"valueFilter",{get:function(){return this._valueFilter},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"conditionFilter",{get:function(){return this._conditionFilter},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"column",{get:function(){return this._col},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"isActive",{get:function(){return this._conditionFilter.isActive||this._valueFilter.isActive},enumerable:!0,configurable:!0}),i.prototype.apply=function(n){return this._conditionFilter.apply(n)&&this._valueFilter.apply(n)},i.prototype.clear=function(){this._valueFilter.clear();this._conditionFilter.clear()},i.prototype.implementsInterface=function(n){return n=='IColumnFilter'},i}();t.ColumnFilter=i})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';n.culture.FlexGridFilter={ascending:'\u2191 Ascending',descending:'\u2193 Descending',apply:'Apply',clear:'Clear',conditions:'Filter by Condition',values:'Filter by Value',search:'Search',selectAll:'Select All',null:'(nothing)',header:'Show items where the value',and:'And',or:'Or',stringOperators:[{name:'(not set)',op:null},{name:'Equals',op:t.Operator.EQ},{name:'Does not equal',op:t.Operator.NE},{name:'Begins with',op:t.Operator.BW},{name:'Ends with',op:t.Operator.EW},{name:'Contains',op:t.Operator.CT},{name:'Does not contain',op:t.Operator.NC}],numberOperators:[{name:'(not set)',op:null},{name:'Equals',op:t.Operator.EQ},{name:'Does not equal',op:t.Operator.NE},{name:'Is Greater than',op:t.Operator.GT},{name:'Is Greater than or equal to',op:t.Operator.GE},{name:'Is Less than',op:t.Operator.LT},{name:'Is Less than or equal to',op:t.Operator.LE}],dateOperators:[{name:'(not set)',op:null},{name:'Equals',op:t.Operator.EQ},{name:'Is Before',op:t.Operator.LT},{name:'Is After',op:t.Operator.GT}],booleanOperators:[{name:'(not set)',op:null},{name:'Equals',op:t.Operator.EQ},{name:'Does not equal',op:t.Operator.NE}]};var i=function(i){function r(r,u,f){var o=this,h,c,l,s,e;f===void 0&&(f=!0);i.call(this,r);this.filterChanged=new n.Event;this.buttonClicked=new n.Event;this._filter=n.asType(u,t.ColumnFilter);h=this.getTemplate();this.applyTemplate('wj-control wj-columnfiltereditor wj-content',h,{_divSort:'div-sort',_btnAsc:'btn-asc',_btnDsc:'btn-dsc',_divType:'div-type',_aVal:'a-val',_aCnd:'a-cnd',_divEdtVal:'div-edt-val',_divEdtCnd:'div-edt-cnd',_btnApply:'btn-apply',_btnClear:'btn-clear'});this._btnAsc.textContent=n.culture.FlexGridFilter.ascending;this._btnDsc.textContent=n.culture.FlexGridFilter.descending;this._aVal.textContent=n.culture.FlexGridFilter.values;this._aCnd.textContent=n.culture.FlexGridFilter.conditions;this._btnApply.textContent=n.culture.FlexGridFilter.apply;this._btnClear.textContent=n.culture.FlexGridFilter.clear;c=this.filter.conditionFilter.isActive||(u.filterType&t.FilterType.Value)==0?t.FilterType.Condition:t.FilterType.Value;this._showFilter(c);l=this.filter.column;s=l.grid.collectionView;f&&s&&s.canSort||(this._divSort.style.display='none');this.updateEditor();e=this._btnClicked.bind(this);this._btnApply.addEventListener('click',e);this._btnClear.addEventListener('click',e);this._btnAsc.addEventListener('click',e);this._btnDsc.addEventListener('click',e);this._aVal.addEventListener('click',e);this._aCnd.addEventListener('click',e);this.hostElement.addEventListener('keydown',function(t){switch(t.keyCode){case n.Key.Enter:switch(t.target.tagName){case'A':case'BUTTON':o._btnClicked(t);break;default:o.updateFilter();o.onFilterChanged();o.onButtonClicked()}t.preventDefault();break;case n.Key.Escape:o.onButtonClicked();t.preventDefault()}})}return __extends(r,i),Object.defineProperty(r.prototype,"filter",{get:function(){return this._filter},enumerable:!0,configurable:!0}),r.prototype.updateEditor=function(){this._edtVal&&this._edtVal.updateEditor();this._edtCnd&&this._edtCnd.updateEditor()},r.prototype.updateFilter=function(){switch(this._getFilterType()){case t.FilterType.Value:this._edtVal.updateFilter();this.filter.conditionFilter.clear();break;case t.FilterType.Condition:this._edtCnd.updateFilter();this.filter.valueFilter.clear()}},r.prototype.onFilterChanged=function(n){this.filterChanged.raise(this,n)},r.prototype.onButtonClicked=function(n){this.buttonClicked.raise(this,n)},r.prototype._showFilter=function(n){n==t.FilterType.Value&&this._edtVal==null&&(this._edtVal=new t.ValueFilterEditor(this._divEdtVal,this.filter.valueFilter));n==t.FilterType.Condition&&this._edtCnd==null&&(this._edtCnd=new t.ConditionFilterEditor(this._divEdtCnd,this.filter.conditionFilter));(n&this.filter.filterType)!=0&&(n==t.FilterType.Value?(this._divEdtVal.style.display='',this._divEdtCnd.style.display='none',this._enableLink(this._aVal,!1),this._enableLink(this._aCnd,!0)):(this._divEdtVal.style.display='none',this._divEdtCnd.style.display='',this._enableLink(this._aVal,!0),this._enableLink(this._aCnd,!1)));switch(this.filter.filterType){case t.FilterType.None:case t.FilterType.Condition:case t.FilterType.Value:this._divType.style.display='none';break;default:this._divType.style.display=''}},r.prototype._enableLink=function(n,t){n.style.textDecoration=t?'':'none';n.style.fontWeight=t?'':'bold';t?n.href='':n.removeAttribute('href')},r.prototype._getFilterType=function(){return this._divEdtVal.style.display!='none'?t.FilterType.Value:t.FilterType.Condition},r.prototype._btnClicked=function(i){if(i.preventDefault(),i.stopPropagation(),!n.hasClass(i.target,'wj-state-disabled')){if(i.target==this._aVal){this._showFilter(t.FilterType.Value);this._edtVal.focus();return}if(i.target==this._aCnd){this._showFilter(t.FilterType.Condition);this._edtCnd.focus();return}if(i.target==this._btnAsc||i.target==this._btnDsc){var r=this.filter.column,f=r.sortMemberPath?r.sortMemberPath:r.binding,u=r.grid.collectionView,e=new n.collections.SortDescription(f,i.target==this._btnAsc);u.sortDescriptions.deferUpdate(function(){u.sortDescriptions.clear();u.sortDescriptions.push(e)})}i.target==this._btnApply?(this.updateFilter(),this.onFilterChanged()):i.target==this._btnClear&&this.filter.isActive&&(this.filter.clear(),this.onFilterChanged());this.updateEditor();this.onButtonClicked()}},r.controlTemplate='<div><div wj-part="div-sort"><a wj-part="btn-asc" href="" style="min-width:95px" draggable="false"><\/a>&nbsp;&nbsp;&nbsp;<a wj-part="btn-dsc" href="" style="min-width:95px" draggable="false"><\/a><\/div><div style="text-align:right;margin:10px 0px;font-size:80%"><div wj-part="div-type"><a wj-part="a-cnd" href="" draggable="false"><\/a>&nbsp;|&nbsp;<a wj-part="a-val" href="" draggable="false"><\/a><\/div><\/div><div wj-part="div-edt-val"><\/div><div wj-part="div-edt-cnd"><\/div><div style="text-align:right;margin-top:10px"><a wj-part="btn-apply" href="" draggable="false"><\/a>&nbsp;&nbsp;<a wj-part="btn-clear" href="" draggable="false"><\/a><\/div>',r}(n.Control);t.ColumnFilterEditor=i})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(i){'use strict';(function(n){n[n.None=0]="None";n[n.Condition=1]="Condition";n[n.Value=2]="Value";n[n.Both=3]="Both"})(i.FilterType||(i.FilterType={}));var r=i.FilterType,u=function(){function u(i){this._showIcons=!0;this._showSort=!0;this._defFilterType=r.Both;this.filterApplied=new n.Event;this.filterChanging=new n.Event;this.filterChanged=new n.Event;var u='Missing dependency: FlexGridFilter requires ';n.assert(n.grid!=null,u+'wijmo.grid.');n.assert(n.input!=null,u+'wijmo.input.');this._filters=[];this._g=n.asType(i,t.FlexGrid,!1);this._g.formatItem.addHandler(this._formatItem.bind(this));this._g.itemsSourceChanged.addHandler(this.clear.bind(this));this._g.hostElement.addEventListener('mousedown',this._mouseDown.bind(this),!0);this._g.invalidate()}return Object.defineProperty(u.prototype,"grid",{get:function(){return this._g},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"filterColumns",{get:function(){return this._filterColumns},set:function(t){this._filterColumns=n.asArray(t);this.clear()},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showFilterIcons",{get:function(){return this._showIcons},set:function(t){t!=this.showFilterIcons&&(this._showIcons=n.asBoolean(t),this._g&&this._g.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"showSortButtons",{get:function(){return this._showSort},set:function(t){this._showSort=n.asBoolean(t)},enumerable:!0,configurable:!0}),u.prototype.getColumnFilter=function(r,u){var f,e;for(u===void 0&&(u=!0),n.isString(r)?r=this._g.columns.getColumn(r):n.isNumber(r)&&(r=this._g.columns[r]),r=n.asType(r,t.Column),f=0;f<this._filters.length;f++)if(this._filters[f].column==r)return this._filters[f];return u&&r.binding?(e=new i.ColumnFilter(this,r),this._filters.push(e),e):null},Object.defineProperty(u.prototype,"defaultFilterType",{get:function(){return this._defFilterType},set:function(t){t!=this.defaultFilterType&&(this._defFilterType=n.asEnum(t,r,!1),this._g.invalidate(),this.clear())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"filterDefinition",{get:function(){for(var n,t,u,i={defaultFilterType:this.defaultFilterType,filters:[]},r=0;r<this._filters.length;r++)n=this._filters[r],n&&n.column&&n.column.binding&&(n.conditionFilter.isActive?(t=n.conditionFilter,i.filters.push({binding:n.column.binding,type:'condition',condition1:{operator:t.condition1.operator,value:t.condition1.value},and:t.and,condition2:{operator:t.condition2.operator,value:t.condition2.value}})):n.valueFilter.isActive&&(u=n.valueFilter,i.filters.push({binding:n.column.binding,type:'value',filterText:u.filterText,showValues:u.showValues})));return JSON.stringify(i)},set:function(t){var e=JSON.parse(n.asString(t)),f,r,s;for(this.clear(),this.defaultFilterType=e.defaultFilterType,f=0;f<e.filters.length;f++){var i=e.filters[f],u=this._g.columns.getColumn(i.binding),o=this.getColumnFilter(u,!0);if(o)switch(i.type){case'condition':r=o.conditionFilter;r.condition1.value=u.dataType==n.DataType.Date?n.changeType(i.condition1.value,u.dataType,null):i.condition1.value;r.condition1.operator=i.condition1.operator;r.and=i.and;r.condition2.value=u.dataType==n.DataType.Date?n.changeType(i.condition2.value,u.dataType,null):i.condition2.value;r.condition2.operator=i.condition2.operator;break;case'value':s=o.valueFilter;s.filterText=i.filterText;s.showValues=i.showValues}}this.apply()},enumerable:!0,configurable:!0}),u.prototype.editColumnFilter=function(r,u){var o=this,f;this.closeEditor();r=n.isString(r)?this._g.columns.getColumn(r):n.asType(r,t.Column,!1);f=new t.CellRangeEventArgs(this._g.cells,new t.CellRange(-1,r.index));this.onFilterChanging(f);if(!f.cancel){f.cancel=!0;var e=document.createElement('div'),a=this.getColumnFilter(r),h=new i.ColumnFilterEditor(e,a,this.showSortButtons);n.addClass(e,'wj-dropdown-panel');this._g._rtl&&(e.dir='rtl');h.filterChanged.addHandler(function(){f.cancel=!1;setTimeout(function(){f.cancel||o.apply()})});h.buttonClicked.addHandler(function(){o.closeEditor();o.onFilterChanged(f)});h.lostFocus.addHandler(function(){setTimeout(function(){var t=n.Control.getControl(o._divEdt);t&&!t.containsFocus()&&o.closeEditor()},10)});var l=this._g.columnHeaders,v=u?u.row:l.rows.length-1,y=u?u.col:r.index,s=l.getCellBoundingRect(v,y),c=document.elementFromPoint(s.left+s.width/2,s.top+s.height/2);c=n.closest(c,'.wj-cell');c?n.showPopup(e,c,!1,!1,!1):n.showPopup(e,s);h.focus();this._divEdt=e;this._edtCol=r}},u.prototype.closeEditor=function(){if(this._divEdt){n.hidePopup(this._divEdt,!0);var t=n.Control.getControl(this._divEdt);t&&t.dispose();this._divEdt=null;this._edtCol=null}},u.prototype.apply=function(){var t=this._g.collectionView,i;t&&(t.filter?t.refresh():t.filter=this._filter.bind(this));i=t?t.updateFilterDefinition:null;n.isFunction(i)&&i.call(t,this);this.onFilterApplied()},u.prototype.clear=function(){this._filters.length&&(this._filters=[],this.apply())},u.prototype.onFilterApplied=function(n){this.filterApplied.raise(this,n)},u.prototype.onFilterChanging=function(n){this.filterChanging.raise(this,n)},u.prototype.onFilterChanged=function(n){this.filterChanged.raise(this,n)},u.prototype._filter=function(n){for(var t=0;t<this._filters.length;t++)if(!this._filters[t].apply(n))return!1;return!0},u.prototype._formatItem=function(i,f){var e,o,a;if(f.panel.cellType==t.CellType.ColumnHeader){var s=this._g,c=s.getMergedRange(f.panel,f.row,f.col)||new t.CellRange(f.row,f.col),l=s.columns[c.col],h=s._getBindingColumn(f.panel,f.row,l);(c.row2==f.panel.rows.length-1||l!=h)&&(e=this.getColumnFilter(h,this.defaultFilterType!=r.None),this._filterColumns&&this._filterColumns.indexOf(h.binding)<0&&(e=null),e&&e.filterType!=r.None?(this._showIcons&&(u._filterGlyph||(u._filterGlyph=n.createElement('<div class="'+u._WJC_FILTER+'"><span class="wj-glyph-filter"></span></div>')),o=f.cell.querySelector('div')||f.cell,a=o.querySelector('.wj-glyph-filter'),a||o.insertBefore(u._filterGlyph.cloneNode(!0),o.firstChild)),n.toggleClass(f.cell,'wj-filter-on',e.isActive),n.toggleClass(f.cell,'wj-filter-off',!e.isActive)):(n.removeClass(f.cell,'wj-filter-on'),n.removeClass(f.cell,'wj-filter-off')))}},u.prototype._mouseDown=function(t){var o=this,r,i,e,f;t.defaultPrevented||t.button!=0||n.closest(t.target,'.'+u._WJC_FILTER)&&(r=this._g,i=r.hitTest(t),i.panel==r.columnHeaders&&(e=r.columns[i.col],f=r._getBindingColumn(i.panel,i.row,e),this._divEdt&&this._edtCol==f?this.closeEditor():setTimeout(function(){o.editColumnFilter(f,i)},this._divEdt?100:0),t.stopPropagation(),t.preventDefault()))},u._WJC_FILTER='wj-elem-filter',u}();i.FlexGridFilter=u})(i=t.filter||(t.filter={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var __extends,wijmo;(function(n){var t;(function(t){var i;(function(i){'use strict';(function(n){n[n.Code=0]="Code";n[n.Selection=1]="Selection";n[n.ExpandSingle=2]="ExpandSingle";n[n.ExpandMulti=3]="ExpandMulti"})(i.DetailVisibilityMode||(i.DetailVisibilityMode={}));var r=i.DetailVisibilityMode,u=function(){function u(n){var t=this;this._mode=r.ExpandSingle;this._g=n;n.mergeManager=new i.DetailMergeManager(n);n.rowHeaders.hostElement.addEventListener('click',this._hdrClick.bind(this));n.formatItem.addHandler(this._formatItem,this);n.selectionChanged.addHandler(this._selectionChanged,this);n.resizedRow.addHandler(this._resizedRow,this);n.loadingRows.addHandler(function(){t.hideDetail()});n.draggingRow.addHandler(function(n,i){t.hideDetail(i.row)});n.formatItem.addHandler(function(n,t){if(t.panel==n.cells){var r=n.rows[t.row];r instanceof i.DetailRow&&(t.cell.style.left='0')}})}return Object.defineProperty(u.prototype,"grid",{get:function(){return this._g},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"detailVisibilityMode",{get:function(){return this._mode},set:function(t){t!=this._mode&&(this._mode=n.asEnum(t,r),this.hideDetail(),this._g.invalidate())},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"maxHeight",{get:function(){return this._maxHeight},set:function(t){this._maxHeight=n.asNumber(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"createDetailCell",{get:function(){return this._createDetailCellFn},set:function(t){this._createDetailCellFn=n.asFunction(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"disposeDetailCell",{get:function(){return this._disposeDetailCellFn},set:function(t){this._disposeDetailCellFn=n.asFunction(t,!0)},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"rowHasDetail",{get:function(){return this._rowHasDetailFn},set:function(t){this._rowHasDetailFn=n.asFunction(t,!0)},enumerable:!0,configurable:!0}),u.prototype.isDetailVisible=function(n){var t=this._g.rows;return(n=this._toIndex(n),t[n]instanceof i.DetailRow)?!0:n<t.length-1&&t[n+1]instanceof i.DetailRow?!0:!1},u.prototype.isDetailAvailable=function(n){var t=this._g.rows;return n=this._toIndex(n),this._hasDetail(n)},u.prototype.hideDetail=function(t){var r=this._g.rows,u;if(t==null){for(u=0;u<r.length;u++)r[u]instanceof i.DetailRow&&this.hideDetail(u);return}t=this._toIndex(t);!(r[t]instanceof i.DetailRow)&&t<r.length-1&&r[t+1]instanceof i.DetailRow&&t++;r[t]instanceof i.DetailRow&&(this.disposeDetailCell&&this.disposeDetailCell(r[t]),n.Control.disposeAll(r[t].detail),r.removeAt(t))},u.prototype.showDetail=function(n,t){var u,e,f,o,r;if(t===void 0&&(t=!1),u=this._g.rows,n=this._toIndex(n),!this.isDetailVisible(n)&&this._hasDetail(n)&&(e=new i.DetailRow(u[n]),e.detail=this._createDetailCell(u[n]),e.detail&&(u.insert(n+1,e),this._g.scrollIntoView(n,-1))),t){for(f=this._g.selection,o=!1,n>0&&u[n]instanceof i.DetailRow&&n--,r=0;r<u.length-1;r++)r!=n&&u[r+1]instanceof i.DetailRow&&(this.hideDetail(r),r<n&&n--,r<f.row&&(f.row--,f.row2--,o=!0));o&&this._g.select(f,!1)}},u.prototype._toIndex=function(i){return i instanceof t.Row&&(i=i.index),n.asNumber(i,!1,!0)},u.prototype._hdrClick=function(n){var u,i,f;(this._mode==r.ExpandMulti||this._mode==r.ExpandSingle)&&(u=this._g,i=u.hitTest(n),i.row>-1&&(f=u.rows[i.row],this.isDetailVisible(i.row)?this.hideDetail(i.row):(u.select(new t.CellRange(i.row,0,i.row,u.columns.length-1)),this.showDetail(i.row,this._mode==r.ExpandSingle)),n.preventDefault()))},u.prototype._selectionChanged=function(n){var t=this;this._mode==r.Selection&&(this._toSel&&clearTimeout(this._toSel),this._toSel=setTimeout(function(){n.selection.row>-1?t.showDetail(n.selection.row,!0):t.hideDetail()},300))},u.prototype._formatItem=function(t,u){var e=this._g,f=u.panel.rows[u.row],h,o,s,c;u.panel==e.cells&&f instanceof i.DetailRow&&f.detail!=null&&(n.addClass(u.cell,'wj-detail'),u.cell.textContent='',u.cell.style.textAlign='',u.cell.appendChild(f.detail),f.height==null?(n.Control.refreshAll(u.cell),h=getComputedStyle(u.cell),o=f.detail.scrollHeight+parseInt(h.paddingTop)+parseInt(h.paddingBottom),this._maxHeight>0&&o>this._maxHeight&&(o=this._maxHeight),f.height=o,f.detail.style.height||(f.detail.style.height='100%'),s=f.detail.querySelector('.wj-flexgrid'),s&&!s.style.height&&(s.style.height='100%')):setTimeout(function(){n.Control.refreshAll(f.detail)}));(this._mode==r.ExpandMulti||this._mode==r.ExpandSingle)&&u.panel==e.rowHeaders&&u.col==0&&this._hasDetail(u.row)&&(c=u.row<e.rows.length-1&&e.rows[u.row+1]instanceof i.DetailRow,u.cell.innerHTML=c?'<span class="wj-glyph-minus"></span>':'<span class="wj-glyph-plus"></span>')},u.prototype._resizedRow=function(t,r){var u=r.panel.rows[r.row];u instanceof i.DetailRow&&u.detail&&n.Control.refreshAll(u.detail)},u.prototype._hasVisibleDetail=function(n){return n instanceof i.DetailRow||n instanceof t.GroupRow||n instanceof t._NewRowTemplate?!1:!0},u.prototype._hasDetail=function(t){return n.isFunction(this._rowHasDetailFn)?this._rowHasDetailFn(this._g.rows[t]):!0},u.prototype._createDetailCell=function(n,t){return this.createDetailCell?this.createDetailCell(n,t):null},u}();i.FlexGridDetailProvider=u})(i=t.detail||(t.detail={}))})(t=n.grid||(n.grid={}))})(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(n){var t;(function(t){'use strict';var i=function(i){function r(n){i.call(this,n)}return __extends(r,i),r.prototype.getMergedRange=function(r,u,f,e){e===void 0&&(e=!0);switch(r.cellType){case n.CellType.Cell:if(r.rows[u]instanceof t.DetailRow)return new n.CellRange(u,0,u,r.columns.length-1);break;case n.CellType.RowHeader:if(r.rows[u]instanceof t.DetailRow)return new n.CellRange(u-1,f,u,f);if(u<r.rows.length-1&&r.rows[u+1]instanceof t.DetailRow)return new n.CellRange(u,f,u+1,f)}return i.prototype.getMergedRange.call(this,r,u,f,e)},r}(n.MergeManager);t.DetailMergeManager=i})(t=n.detail||(n.detail={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(n){var t;(function(t){'use strict';var i=function(n){function t(){n.call(this);this.isReadOnly=!0}return __extends(t,n),Object.defineProperty(t.prototype,"detail",{get:function(){return this._detail},set:function(n){this._detail=n},enumerable:!0,configurable:!0}),t}(n.Row);t.DetailRow=i})(t=n.detail||(n.detail={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var __extends,wijmo;(function(n){var t;(function(t){var i;(function(i){'use strict';var h=function(){function h(t){this._expressionCache={};this._idChars='$:!';this._functionTable={};this._cacheSize=0;this.unknownFunction=new n.Event;this._owner=t;this._buildSymbolTable();this._registerAggregateFunction();this._registerMathFunction();this._registerLogicalFunction();this._registerTextFunction();this._registerDateFunction();this._registLookUpReferenceFunction();this._registFinacialFunction()}return h.prototype.onUnknownFunction=function(n,t){var f,u,r;if(t&&t.length>0)for(f=[],r=0;r<t.length;r++)f[r]=t[r].evaluate();if(u=new i.UnknownFunctionEventArgs(n,f),this.unknownFunction.raise(this,u),u.value!=null)return new i._Expression(u.value);throw'The function "'+n+'" has not supported in FlexSheet yet.';},h.prototype.evaluate=function(t,r,u,f,e){var s,o;try{if(t&&t.length>1&&t[0]==='='){for(s=this._checkCache(t),o=s.evaluate(u,f,e);o instanceof i._Expression;)o=o.evaluate(u);return r&&n.isPrimitive(o)?n.Globalize.format(o,r):o}return t?t:''}catch(h){return"Error: "+h}},h.prototype.addCustomFunction=function(n,t,u,f){var e=this;n=n.toLowerCase();this._functionTable[n]=new r(function(n){var u,f=[],r;if(n.length>0)for(r=0;r<n.length;r++)u=n[r],f[r]=u instanceof i._CellRangeExpression?u.cells:u.evaluate();return t.apply(e,f)},f,u)},h.prototype._clearExpressionCache=function(){this._expressionCache=null;this._expressionCache={};this._cacheSize=0},h.prototype._parse=function(n){return this._expression=n,this._expressLength=n?n.length:0,this._pointer=0,this._expressLength>0&&this._expression[0]==='='&&this._pointer++,this._parseExpression()},h.prototype._buildSymbolTable=function(){this._tokenTable||(this._tokenTable={},this._addToken('+',f.ADD,u.ADDSUB),this._addToken('-',f.SUB,u.ADDSUB),this._addToken('(',f.OPEN,u.GROUP),this._addToken(')',f.CLOSE,u.GROUP),this._addToken('*',f.MUL,u.MULDIV),this._addToken(',',f.COMMA,u.GROUP),this._addToken('.',f.PERIOD,u.GROUP),this._addToken('/',f.DIV,u.MULDIV),this._addToken('\\',f.DIVINT,u.MULDIV),this._addToken('=',f.EQ,u.COMPARE),this._addToken('>',f.GT,u.COMPARE),this._addToken('<',f.LT,u.COMPARE),this._addToken('^',f.POWER,u.POWER),this._addToken("<>",f.NE,u.COMPARE),this._addToken(">=",f.GE,u.COMPARE),this._addToken("<=",f.LE,u.COMPARE),this._addToken('&',f.CONCAT,u.CONCAT))},h.prototype._registerAggregateFunction=function(){var t=this;t._functionTable.sum=new r(function(i,r){return t._getAggregateResult(n.Aggregate.Sum,i,r)});t._functionTable.average=new r(function(i,r){return t._getAggregateResult(n.Aggregate.Avg,i,r)});t._functionTable.max=new r(function(i,r){return t._getAggregateResult(n.Aggregate.Max,i,r)});t._functionTable.min=new r(function(i,r){return t._getAggregateResult(n.Aggregate.Min,i,r)});t._functionTable['var']=new r(function(i,r){return t._getAggregateResult(n.Aggregate.Var,i,r)});t._functionTable.varp=new r(function(i,r){return t._getAggregateResult(n.Aggregate.VarPop,i,r)});t._functionTable.stdev=new r(function(i,r){return t._getAggregateResult(n.Aggregate.Std,i,r)});t._functionTable.stdevp=new r(function(i,r){return t._getAggregateResult(n.Aggregate.StdPop,i,r)});t._functionTable.count=new r(function(n,i){return t._getFlexSheetAggregateResult(o.Count,n,i)});t._functionTable.counta=new r(function(n,i){return t._getFlexSheetAggregateResult(o.CountA,n,i)});t._functionTable.countblank=new r(function(n,i){return t._getFlexSheetAggregateResult(o.ConutBlank,n,i)});t._functionTable.countif=new r(function(n,i){return t._getFlexSheetAggregateResult(o.CountIf,n,i)},2,2);t._functionTable.countifs=new r(function(n,i){return t._getFlexSheetAggregateResult(o.CountIfs,n,i)},254,2);t._functionTable.sumif=new r(function(n,i){return t._getFlexSheetAggregateResult(o.SumIf,n,i)},3,2);t._functionTable.sumifs=new r(function(n,i){return t._getFlexSheetAggregateResult(o.SumIfs,n,i)},255,2);t._functionTable.rank=new r(function(n,i){return t._getFlexSheetAggregateResult(o.Rank,n,i)},3,2);t._functionTable.product=new r(function(n,i){return t._getFlexSheetAggregateResult(o.Product,n,i)},255,1);t._functionTable.subtotal=new r(function(n,i){return t._handleSubtotal(n,i)},255,2);t._functionTable.dcount=new r(function(n,i){return t._handleDCount(n,i)},3,3)},h.prototype._registerMathFunction=function(){var t=this;t._functionTable.pi=new r(function(){return Math.PI},0,0);t._functionTable.rand=new r(function(){return Math.random()},0,0);t._functionTable.power=new r(function(n,t){return Math.pow(i._Expression.toNumber(n[0],t),i._Expression.toNumber(n[1],t))},2,2);t._functionTable.atan2=new r(function(n,t){var r=i._Expression.toNumber(n[0],t),u=i._Expression.toNumber(n[1],t);if(r===0&&u===0)throw'The x number and y number can\'t both be zero for the atan2 function';return Math.atan2(u,r)},2,2);t._functionTable.mod=new r(function(n,t){return i._Expression.toNumber(n[0],t)%i._Expression.toNumber(n[1],t)},2,2);t._functionTable.trunc=new r(function(n,t){var r=i._Expression.toNumber(n[0],t),f=n.length===2?i._Expression.toNumber(n[1],t):0,u;return f===0?r>=0?Math.floor(r):Math.ceil(r):(u=Math.pow(10,f),r>=0?Math.floor(r*u)/u:Math.ceil(r*u)/u)},2,1);['round','rounddown','roundup'].forEach(function(u){t._functionTable[u]=new r(function(t,r){var f=i._Expression.toNumber(t[0],r),s=i._Expression.toNumber(t[1],r),o,h,e;if(s===0){switch(u){case'rounddown':o=f>=0?Math.floor(f):Math.ceil(f);break;case'roundup':o=f>=0?Math.ceil(f):Math.floor(f);break;case'round':o=Math.round(f);break;default:o=Math.floor(f)}h='n0'}else if(s>0&&n.isInt(s)){e=Math.pow(10,s);switch(u){case'rounddown':o=f>=0?Math.floor(f*e)/e:Math.ceil(f*e)/e;break;case'roundup':o=f>=0?Math.ceil(f*e)/e:Math.floor(f*e)/e;break;case'round':o=Math.round(f*e)/e}h='n'+s}if(o!=null)return{value:o,format:h};throw'Invalid precision!';},2,2)});['abs','acos','asin','atan','ceiling','cos','exp','floor','ln','sin','sqrt','tan'].forEach(function(n){t._functionTable[n]=new r(function(t,r){switch(n){case'ceiling':return Math.ceil(i._Expression.toNumber(t[0],r));case'ln':return Math.log(i._Expression.toNumber(t[0],r));default:return Math[n](i._Expression.toNumber(t[0],r))}},1,1)})},h.prototype._registerLogicalFunction=function(){this._functionTable.and=new r(function(n,t){for(var r=!0,u=0;u<n.length;u++)if(r=r&&i._Expression.toBoolean(n[u],t),!r)break;return r},Number.MAX_VALUE,1);this._functionTable.or=new r(function(n,t){for(var r=!1,u=0;u<n.length;u++)if(r=r||i._Expression.toBoolean(n[u],t),r)break;return r},Number.MAX_VALUE,1);this._functionTable.not=new r(function(n,t){return!i._Expression.toBoolean(n[0],t)},1,1);this._functionTable['if']=new r(function(n,t){return i._Expression.toBoolean(n[0],t)?n[1].evaluate(t):n[2].evaluate(t)},3,3);this._functionTable['true']=new r(function(){return!0},0,0);this._functionTable['false']=new r(function(){return!1},0,0)},h.prototype._registerTextFunction=function(){this._functionTable.char=new r(function(n,t){for(var u='',r=0;r<n.length;r++)u+=String.fromCharCode(i._Expression.toNumber(n[r],t));return u},Number.MAX_VALUE,1);this._functionTable.code=new r(function(n,t){var r=i._Expression.toString(n[0],t);return r&&r.length>0?r.charCodeAt(0):-1},1,1);this._functionTable.concatenate=new r(function(n,t){for(var u='',r=0;r<n.length;r++)u=u.concat(i._Expression.toString(n[r],t));return u},Number.MAX_VALUE,1);this._functionTable.left=new r(function(n,t){var r=i._Expression.toString(n[0],t),u=Math.floor(i._Expression.toNumber(n[1],t));return r&&r.length>0?r.slice(0,u):undefined},2,2);this._functionTable.right=new r(function(n,t){var r=i._Expression.toString(n[0],t),u=Math.floor(i._Expression.toNumber(n[1],t));return r&&r.length>0?r.slice(-u):undefined},2,2);this._functionTable.find=new r(function(n,t){var u=i._Expression.toString(n[0],t),f=i._Expression.toString(n[1],t),r;return f!=null&&u!=null&&(r=f.indexOf(u),r>-1)?r+1:-1},2,2);this._functionTable.search=new r(function(n,t){var u=i._Expression.toString(n[0],t),f=i._Expression.toString(n[1],t),e,r;return f!=null&&u!=null&&(e=new RegExp(u,'i'),r=f.search(e),r>-1)?r+1:-1},2,2);this._functionTable.len=new r(function(n,t){var r=i._Expression.toString(n[0],t);return r?r.length:-1},1,1);this._functionTable.mid=new r(function(n,t){var r=i._Expression.toString(n[0],t),u=Math.floor(i._Expression.toNumber(n[1],t)),f=Math.floor(i._Expression.toNumber(n[2],t));return r&&r.length>0&&u>0?r.substr(u-1,f):undefined},3,3);this._functionTable.lower=new r(function(n,t){var r=i._Expression.toString(n[0],t);return r&&r.length>0?r.toLowerCase():undefined},1,1);this._functionTable.upper=new r(function(n,t){var r=i._Expression.toString(n[0],t);return r&&r.length>0?r.toUpperCase():undefined},1,1);this._functionTable.proper=new r(function(n,t){var r=i._Expression.toString(n[0],t);return r&&r.length>0?r[0].toUpperCase()+r.substring(1).toLowerCase():undefined},1,1);this._functionTable.trim=new r(function(n,t){var r=i._Expression.toString(n[0],t);return r&&r.length>0?r.trim():undefined},1,1);this._functionTable.replace=new r(function(n,t){var r=i._Expression.toString(n[0],t),u=Math.floor(i._Expression.toNumber(n[1],t)),f=Math.floor(i._Expression.toNumber(n[2],t)),e=i._Expression.toString(n[3],t);return r&&r.length>0&&u>0?r.substring(0,u-1)+e+r.slice(u-1+f):undefined},4,4);this._functionTable.substitute=new r(function(n,t){var r=i._Expression.toString(n[0],t),u=i._Expression.toString(n[1],t),e=i._Expression.toString(n[2],t),f;return r&&r.length>0&&u&&u.length>0?(f=new RegExp(u,'g'),r.replace(f,e)):undefined},3,3);this._functionTable.rept=new r(function(n,t){var r=i._Expression.toString(n[0],t),e=Math.floor(i._Expression.toNumber(n[1],t)),u='',f;if(r&&r.length>0&&e>0)for(f=0;f<e;f++)u=u.concat(r);return u},2,2);this._functionTable.text=new r(function(t,r){var u=t[0].evaluate(),f=i._Expression.toString(t[1],r);return n.Globalize.format(u,f)},2,2);this._functionTable.value=new r(function(n,t){return i._Expression.toNumber(n[0],t)},1,1)},h.prototype._registerDateFunction=function(){this._functionTable.now=new r(function(){return{value:new Date,format:'M/d/yyyy h:mm'}},0,0);this._functionTable.today=new r(function(){return{value:new Date,format:'d'}},0,0);this._functionTable.year=new r(function(t,r){var u=i._Expression.toDate(t[0],r);return!n.isPrimitive(u)&&u?u.value:n.isDate(u)?u.getFullYear():1900},1,1);this._functionTable.month=new r(function(t,r){var u=i._Expression.toDate(t[0],r);return!n.isPrimitive(u)&&u?u.value:n.isDate(u)?u.getMonth()+1:1},1,1);this._functionTable.day=new r(function(t,r){var u=i._Expression.toDate(t[0],r);return!n.isPrimitive(u)&&u?u.value:n.isDate(u)?u.getDate():0},1,1);this._functionTable.hour=new r(function(t,r){var u=t[0].evaluate(r);if(n.isNumber(u)&&!isNaN(u))return Math.floor(24*(u-Math.floor(u)));if(n.isDate(u)||(u=i._Expression.toDate(t[0],r),!n.isPrimitive(u)&&u&&(u=u.value),n.isDate(u)))return u.getHours();throw'Invalid parameter.';},1,1);this._functionTable.time=new r(function(t,i){var r=t[0].evaluate(i),u=t[1].evaluate(i),f=t[2].evaluate(i);if(n.isNumber(r)&&n.isNumber(u)&&n.isNumber(f))return r%=24,u%=60,f%=60,{value:new Date(0,0,0,r,u,f),format:'t'};throw'Invalid parameters.';},3,3);this._functionTable.date=new r(function(t,i){var r=t[0].evaluate(i),u=t[1].evaluate(i),f=t[2].evaluate(i);if(n.isNumber(r)&&n.isNumber(u)&&n.isNumber(f))return{value:new Date(r,u-1,f),format:'d'};throw'Invalid parameters.';},3,3);this._functionTable.datedif=new r(function(t,r){var f=i._Expression.toDate(t[0],r),u=i._Expression.toDate(t[1],r),l=t[2].evaluate(r),h,c,o,e,s;if(!n.isPrimitive(f)&&f&&(f=f.value),!n.isPrimitive(u)&&u&&(u=u.value),n.isDate(f)&&n.isDate(u)&&n.isString(l)){if(h=f.getTime(),c=u.getTime(),h>c)throw'Start date is later than end date.';o=u.getDate()-f.getDate();e=u.getMonth()-f.getMonth();s=u.getFullYear()-f.getFullYear();switch(l.toUpperCase()){case'Y':return e>0?s:e<0?s-1:o>=0?s:s-1;case'M':return o>=0?s*12+e:s*12+e-1;case'D':return(c-h)/864e5;case'YM':return e=o>=0?s*12+e:s*12+e-1,e%12;case'YD':return e>0?(new Date(f.getFullYear(),u.getMonth(),u.getDate()).getTime()-f.getTime())/864e5:e<0?(new Date(f.getFullYear()+1,u.getMonth(),u.getDate()).getTime()-f.getTime())/864e5:o>=0?o:(new Date(f.getFullYear()+1,u.getMonth(),u.getDate()).getTime()-f.getTime())/864e5;case'MD':return o>=0?o:new Date(u.getFullYear(),u.getMonth(),0).getDate()-new Date(u.getFullYear(),u.getMonth()-1,1).getDate()+1+o;default:throw'Invalid unit.';}}throw'Invalid parameters.';},3,3)},h.prototype._registLookUpReferenceFunction=function(){var n=this;n._functionTable.column=new r(function(t,r,u,f){var e;if(t==null)return f+1;if(e=t[0],e=n._ensureNonFunctionExpression(e),e instanceof i._CellRangeExpression)return e.cells.col+1;throw'Invalid Cell Reference.';},1,0);n._functionTable.columns=new r(function(t){var r=t[0];if(r=n._ensureNonFunctionExpression(r),r instanceof i._CellRangeExpression)return r.cells.columnSpan;throw'Invalid Cell Reference.';},1,1);n._functionTable.row=new r(function(t,r,u){var f;if(t==null)return u+1;if(f=t[0],f=n._ensureNonFunctionExpression(f),f instanceof i._CellRangeExpression)return f.cells.row+1;throw'Invalid Cell Reference.';},1,0);n._functionTable.rows=new r(function(t){var r=t[0];if(r=n._ensureNonFunctionExpression(r),r instanceof i._CellRangeExpression)return r.cells.rowSpan;throw'Invalid Cell Reference.';},1,1);n._functionTable.choose=new r(function(n,t){var r=i._Expression.toNumber(n[0],t);if(isNaN(r))throw'Invalid index number.';if(r<1||r>=n.length)throw'The index number is out of the list range.';return n[r].evaluate(t)},255,2);n._functionTable.index=new r(function(r,u){var s=r[0],f,e=i._Expression.toNumber(r[1],u),o=r[2]!=null?i._Expression.toNumber(r[2],u):0;if(isNaN(e)||e<0)throw'Invalid Row Number.';if(isNaN(o)||o<0)throw'Invalid Column Number.';if(s=n._ensureNonFunctionExpression(s),s instanceof i._CellRangeExpression){if(f=s.cells,e>f.rowSpan||o>f.columnSpan)throw'Index is out of the cell range.';if(e>0&&o>0)return n._owner.getCellValue(f.topRow+e-1,f.leftCol+o-1,!0,u);if(e===0&&o===0)return s;if(e===0)return new i._CellRangeExpression(new t.CellRange(f.topRow,f.leftCol+o-1,f.bottomRow,f.leftCol+o-1),s.sheetRef,n._owner);if(o===0)return new i._CellRangeExpression(new t.CellRange(f.topRow+e-1,f.leftCol,f.topRow+e-1,f.rightCol),s.sheetRef,n._owner)}throw'Invalid Cell Reference.';},4,2);n._functionTable.hlookup=new r(function(t,i){return n._handleHLookup(t,i)},4,3)},h.prototype._registFinacialFunction=function(){var n=this;n._functionTable.rate=new r(function(t,i){var r=n._calculateRate(t,i);return{value:r,format:'p2'}},6,3)},h.prototype._addToken=function(n,t,i){var r=new s(n,t,i);this._tokenTable[n]=r},h.prototype._parseExpression=function(){return this._getToken(),this._parseCompareOrConcat()},h.prototype._parseCompareOrConcat=function(){for(var n=this._parseAddSub(),t,r;this._token.tokenType===u.COMPARE||this._token.tokenType===u.CONCAT;)t=this._token,this._getToken(),r=this._parseAddSub(),n=new i._BinaryExpression(t,n,r);return n},h.prototype._parseAddSub=function(){for(var n=this._parseMulDiv(),t,r;this._token.tokenType===u.ADDSUB;)t=this._token,this._getToken(),r=this._parseMulDiv(),n=new i._BinaryExpression(t,n,r);return n},h.prototype._parseMulDiv=function(){for(var n=this._parsePower(),t,r;this._token.tokenType===u.MULDIV;)t=this._token,this._getToken(),r=this._parsePower(),n=new i._BinaryExpression(t,n,r);return n},h.prototype._parsePower=function(){for(var n=this._parseUnary(),t,r;this._token.tokenType===u.POWER;)t=this._token,this._getToken(),r=this._parseUnary(),n=new i._BinaryExpression(t,n,r);return n},h.prototype._parseUnary=function(){var n,t;return this._token.tokenID===f.ADD||this._token.tokenID===f.SUB?(n=this._token,this._getToken(),t=this._parseAtom(),new i._UnaryExpression(n,t)):this._parseAtom()},h.prototype._parseAtom=function(){var n=null,e,t,r,s,o;switch(this._token.tokenType){case u.LITERAL:n=new i._Expression(this._token);break;case u.IDENTIFIER:if(e=this._token.value.toString(),t=this._functionTable[e.toLowerCase()],t){if(r=this._getParameters(),s=r?r.length:0,t.paramMin!==-1&&s<t.paramMin)throw'Too few parameters.';if(t.paramMax!==-1&&s>t.paramMax)throw'Too many parameters.';n=new i._FunctionExpression(t,r);break}if(o=this._getCellRange(e),o){n=new i._CellRangeExpression(o.cellRange,o.sheetRef,this._owner);break}r=this._getParameters();n=this.onUnknownFunction(e,r);break;case u.GROUP:if(this._token.tokenID!==f.OPEN)throw'Expression expected.';if(this._getToken(),n=this._parseCompareOrConcat(),this._token.tokenID!==f.CLOSE)throw'Unbalanced parenthesis.';}if(n===null)throw'';return this._getToken(),n},h.prototype._getToken=function(){for(var t,n,c,e,o,h='',i='',l=new RegExp('[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]'),r;this._pointer<this._expressLength&&this._expression[this._pointer]===' ';)this._pointer++;if(this._pointer>=this._expressLength){this._token=new s(null,f.END,u.GROUP);return}if(n=this._expression[this._pointer],e=n>='a'&&n<='z'||n>='A'&&n<='Z'||l.test(n),o=n>='0'&&n<='9'||n=='.',!e&&!o&&(r=this._tokenTable[n],r)){this._token=r;this._pointer++;this._pointer<this._expressLength&&(n==='>'||n==='<')&&(r=this._tokenTable[this._expression.substring(this._pointer-1,this._pointer+1)],r&&(this._token=r,this._pointer++));return}if(o){this._parseDigit();return}if(n==='\"'){this._parseString();return}if(n!=='\''||(i=this._parseSheetRef(),i)){if(n==='#'){this._parseDate();return}if(!e&&n!=='_'&&this._idChars.indexOf(n)<0&&!i)throw'Identifier expected.';for(t=1;t+this._pointer<this._expressLength;t++){if(n=this._expression[this._pointer+t],e=n>='a'&&n<='z'||n>='A'&&n<='Z'||l.test(n),o=n>='0'&&n<='9',n==='\''&&c===':'){h=i+this._expression.substring(this._pointer,this._pointer+t);this._pointer+=t;i=this._parseSheetRef();t=0;continue}if(c=n,!e&&!o&&n!=='_'&&this._idChars.indexOf(n)<0)break}h+=i+this._expression.substring(this._pointer,this._pointer+t);this._pointer+=t;this._token=new s(h,f.ATOM,u.IDENTIFIER)}},h.prototype._parseDigit=function(){for(var i=-1,e=!1,o=!1,r=0,n,h,t=0;t+this._pointer<this._expressLength;t++){if(n=this._expression[this._pointer+t],n>='0'&&n<='9'){r=r*10+(+n-0);i>-1&&(i*=10);continue}if(n==='.'&&i<0){i=1;continue}if((n==='E'||n==='e')&&!e){e=!0;n=this._expression[this._pointer+t+1];(n==='+'||n==='-')&&t++;continue}if(n==='%'){o=!0;t++;break}break}e?(h=this._expression.substring(this._pointer,this._pointer+t),r=+h):(i>1&&(r/=i),o&&(r/=100));this._token=new s(r,f.ATOM,u.LITERAL);this._pointer+=t},h.prototype._parseString=function(){for(var t,i,r,n=1;n+this._pointer<this._expressLength;n++)if(t=this._expression[this._pointer+n],t==='\"'){if(i=n+this._pointer<this._expressLength-1?this._expression[this._pointer+n+1]:' ',i!=='\"')break;n++}if(t!=='\"')throw'Can\'t find final quote.';if(r=this._expression.substring(this._pointer+1,this._pointer+n),this._pointer+=n+1,this._expression[this._pointer]==='!')throw'Illegal cross sheet reference.';this._token=new s(r.replace('\"\"','\"'),f.ATOM,u.LITERAL)},h.prototype._parseDate=function(){for(var t,i,n=1;n+this._pointer<this._expressLength;n++)if(t=this._expression[this._pointer+n],t==='#')break;if(t!=='#')throw'Can\'t find final date delimiter ("#").';i=this._expression.substring(this._pointer+1,this._pointer+n);this._pointer+=n+1;this._token=new s(Date.parse(i),f.ATOM,u.LITERAL)},h.prototype._parseSheetRef=function(){for(var t,i,r,n=1;n+this._pointer<this._expressLength;n++)if(t=this._expression[this._pointer+n],t==='\''){if(i=n+this._pointer<this._expressLength-1?this._expression[this._pointer+n+1]:' ',i!=='\'')break;n++}if(t!=='\'')throw'Can\'t find final quote.';return r=this._expression.substring(this._pointer+1,this._pointer+n),this._pointer+=n+1,this._expression[this._pointer]==='!'?r.replace(/\'\'/g,'\''):''},h.prototype._getCellRange=function(n){var i,r,u,t,f;if(n&&(i=n.split(':'),i.length>0&&i.length<3&&(r=this._parseCell(i[0]),t=r.cellRange,t&&i.length===2))){if(u=this._parseCell(i[1]),f=u.cellRange,r.sheetRef&&!u.sheetRef&&(u.sheetRef=r.sheetRef),r.sheetRef!==u.sheetRef)throw'The cell reference must be in the same sheet!';f?(t.col2=f.col,t.row2=f.row):t=null}return t==null?null:{cellRange:t,sheetRef:r.sheetRef}},h.prototype._parseCellRange=function(n){for(var u=-1,f=-1,e=!1,o=!1,i,r=0;r<n.length;r++){if(i=n[r],i==='$'&&!e){e=!0;continue}if(!(i>='a'&&i<='z')&&!(i>='A'&&i<='Z'))break;u<0&&(u=0);u=26*u+(i.toUpperCase().charCodeAt(0)-'A'.charCodeAt(0)+1)}for(;r<n.length;r++){if(i=n[r],i==='$'&&!o){o=!0;continue}if(!(i>='0'&&i<='9'))break;f<0&&(f=0);f=10*f+(+i-0)}return(r<n.length&&(f=u=-1),f===-1||u===-1)?null:new t.CellRange(f-1,u-1)},h.prototype._parseCell=function(n){var r,t,i,u;if(t=n.lastIndexOf('!'),t>0&&t<n.length-1)u=n.substring(0,t),i=n.substring(t+1);else if(t<=0)i=n;else return null;return r=this._parseCellRange(i),{cellRange:r,sheetRef:u}},h.prototype._getParameters=function(){var i=this._pointer,r=this._token,n,t;if(this._getToken(),this._token.tokenID!==f.OPEN)return this._pointer=i,this._token=r,null;if(i=this._pointer,this._getToken(),this._token.tokenID===f.CLOSE)return null;for(this._pointer=i,n=[],t=this._parseExpression(),n.push(t);this._token.tokenID===f.COMMA;)t=this._parseExpression(),n.push(t);if(this._token.tokenID!==f.CLOSE)throw'Syntax error.';return n},h.prototype._getAggregateResult=function(t,i,r){var f=this._getItemList(i,r),u;return u=n.getAggregate(t,f.items),f.isDate&&(u=new Date(u)),u},h.prototype._getFlexSheetAggregateResult=function(n,t,r){var u,f,e,s;switch(n){case o.Count:return u=this._getItemList(t,r,!0,!1),this._countNumberCells(u.items);case o.CountA:return u=this._getItemList(t,r,!1,!1),u.items.length;case o.ConutBlank:return u=this._getItemList(t,r,!1,!0),this._countBlankCells(u.items);case o.Rank:if(e=i._Expression.toNumber(t[0],r),s=t[2]?i._Expression.toNumber(t[2],r):0,isNaN(e))throw'Invalid number.';if(isNaN(s))throw'Invalid order.';if(t[1]=this._ensureNonFunctionExpression(t[1]),t[1]instanceof i._CellRangeExpression)return u=this._getItemList([t[1]],r),this._getRankOfCellRange(e,u.items,s);throw'Invalid Cell Reference.';case o.CountIf:if(t[0]=this._ensureNonFunctionExpression(t[0]),t[0]instanceof i._CellRangeExpression)return u=this._getItemList([t[0]],r,!1),this._countCellsByCriterias([u.items],[t[1]],r);throw'Invalid Cell Reference.';case o.CountIfs:return this._handleCountIfs(t,r);case o.SumIf:if(t[0]=this._ensureNonFunctionExpression(t[0]),t[0]instanceof i._CellRangeExpression)return u=this._getItemList([t[0]],r,!1),t[2]=this._ensureNonFunctionExpression(t[2]),t[2]!=null&&t[2]instanceof i._CellRangeExpression&&(f=this._getItemList([t[2]],r)),this._sumCellsByCriterias([u.items],[t[1]],f?f.items:null,r);throw'Invalid Cell Reference.';case o.SumIfs:return this._handleSumIfs(t,r);case o.Product:return u=this._getItemList(t,r),this._getProductOfNumbers(u.items)}throw'Invalid aggregate type.';},h.prototype._getItemList=function(n,t,r,u,f,e){r===void 0&&(r=!0);u===void 0&&(u=!1);f===void 0&&(f=!0);for(var c=[],o,a,v,s,h=!0,l=0;l<n.length;l++)if(s=n[l],s=this._ensureNonFunctionExpression(s),s instanceof i._CellRangeExpression){v=s.getValues(f,e,t);n:for(a=0;a<v.length;a++)(o=v[a],u||o!=null&&o!=='')&&(h=h&&o instanceof Date,o=r?+o:o,c.push(o))}else{if(o=s instanceof i._Expression?s.evaluate(t):s,!u&&(o==null||o===''))continue;h=h&&o instanceof Date;o=r?+o:o;c.push(o)}return c.length===0&&(h=!1),{isDate:h,items:c}},h.prototype._countBlankCells=function(t){for(var r=0,u=0,i;r<t.length;r++)i=t[r],(i==null||n.isString(i)&&i===''||n.isNumber(i)&&isNaN(i))&&u++;return u},h.prototype._countNumberCells=function(t){for(var r=0,u=0,i;r<t.length;r++)i=t[r],i!=null&&n.isNumber(i)&&!isNaN(i)&&u++;return u},h.prototype._getRankOfCellRange=function(n,t,i){i===void 0&&(i=0);var r=0,f=0,u;for(i?t.sort(function(n,t){return isNaN(n)||isNaN(t)?-1:n-t}):t.sort(function(n,t){return isNaN(n)||isNaN(t)?1:t-n});r<t.length;r++)if((u=t[r],!isNaN(u))&&(f++,n===u))return f;throw n+' is not in the cell range.';},h.prototype._handleCountIfs=function(n,t){var u=0,f=[],e=[],o,r,s,h;if(n.length%2!=0)throw'Invalid params.';for(;u<n.length/2;u++)if(r=n[2*u],r=this._ensureNonFunctionExpression(r),r instanceof i._CellRangeExpression){if(u===0)if(r.cells)s=r.cells.rowSpan,h=r.cells.columnSpan;else throw'Invalid Cell Reference.';else if(r.cells){if(r.cells.rowSpan!==s||r.cells.columnSpan!==h)throw'The row span and column span of each cell range has to be same with each other.';}else throw'Invalid Cell Reference.';o=this._getItemList([r],t,!1);f[u]=o.items;e[u]=n[2*u+1]}else throw'Invalid Cell Reference.';return this._countCellsByCriterias(f,e,t)},h.prototype._countCellsByCriterias=function(t,r,u,f){for(var c=0,o=0,a=0,p=t[0].length,v=[],s,l,y,h,e;o<r.length;o++){if(e=i._Expression.toString(r[o],u),e.length===0)throw'Invalid Criteria.';e==='*'?v.push(e):v.push(this._parseRightExpr(e))}for(;c<p;c++){s=!1;n:for(o=0;o<t.length;o++)if(y=t[o],h=y[c],e=v[o],typeof e=='string'){if(e!=='*'&&(h==null||h==='')){s=!1;break n}if(s=e==='*'||this.evaluate(this._combineExpr(h,e),null,u),!s)break n}else if(s=s=e.reg.test(h.toString())===e.checkMathces,!s)break n;s&&(f?(l=f[c],l!=null&&n.isNumber(l)&&!isNaN(l)&&a++):a++)}return a},h.prototype._handleSumIfs=function(n,t){var f=1,e=[],o=[],s,h,r,u,c,l;if(n.length%2!=1)throw'Invalid params.';if(r=n[0],r=this._ensureNonFunctionExpression(r),r instanceof i._CellRangeExpression){if(r.cells)c=r.cells.rowSpan,l=r.cells.columnSpan;else throw'Invalid Sum Cell Reference.';h=this._getItemList([r],t)}else throw'Invalid Sum Cell Reference.';for(;f<(n.length+1)/2;f++)if(u=n[2*f-1],u=this._ensureNonFunctionExpression(u),u instanceof i._CellRangeExpression){if(u.cells){if(u.cells.rowSpan!==c||u.cells.columnSpan!==l)throw'The row span and column span of each cell range has to be same with each other.';}else throw'Invalid Criteria Cell Reference.';s=this._getItemList([u],t,!1);e[f-1]=s.items;o[f-1]=n[2*f]}else throw'Invalid Criteria Cell Reference.';return this._sumCellsByCriterias(e,o,h.items,t)},h.prototype._sumCellsByCriterias=function(t,r,u,f){var c=0,o=0,v=0,l,p=t[0].length,a=[],s,y,h,e;for(u==null&&(u=t[0]);o<r.length;o++){if(e=i._Expression.toString(r[o],f),e.length===0)throw'Invalid Criteria.';e==='*'?a.push(e):a.push(this._parseRightExpr(e))}for(;c<p;c++){s=!1;l=u[c];n:for(o=0;o<t.length;o++)if(y=t[o],h=y[c],e=a[o],typeof e=='string'){if(e!=='*'&&(h==null||h==='')){s=!1;break n}if(s=e==='*'||this.evaluate(this._combineExpr(h,e),null,f),!s)break n}else if(s=e.reg.test(h.toString())===e.checkMathces,!s)break n;s&&n.isNumber(l)&&!isNaN(l)&&(v+=l)}return v},h.prototype._getProductOfNumbers=function(t){var i,r=0,u=1,f=!1;if(t)for(;r<t.length;r++)i=t[r],n.isNumber(i)&&!isNaN(i)&&(u*=i,f=!0);return f?u:0},h.prototype._handleSubtotal=function(t,r){var u,o,f,s,h=!0;if(u=i._Expression.toNumber(t[0],r),u>=1&&u<=11||u>=101&&u<=111){u>=101&&u<=111&&(h=!1);u=n.asEnum(u,e);o=this._getItemList(t.slice(1),r,!0,!1,h);switch(u){case e.Count:case e.CountWithoutHidden:return this._countNumberCells(o.items);case e.CountA:case e.CountAWithoutHidden:return o.items.length;case e.Product:case e.ProductWithoutHidden:return this._getProductOfNumbers(o.items);case e.Average:case e.AverageWithoutHidden:f=n.Aggregate.Avg;break;case e.Max:case e.MaxWithoutHidden:f=n.Aggregate.Max;break;case e.Min:case e.MinWithoutHidden:f=n.Aggregate.Min;break;case e.Std:case e.StdWithoutHidden:f=n.Aggregate.Std;break;case e.StdPop:case e.StdPopWithoutHidden:f=n.Aggregate.StdPop;break;case e.Sum:case e.SumWithoutHidden:f=n.Aggregate.Sum;break;case e.Var:case e.VarWithoutHidden:f=n.Aggregate.Var;break;case e.VarPop:case e.VarPopWithoutHidden:f=n.Aggregate.VarPop}return s=n.getAggregate(f,o.items),o.isDate&&(s=new Date(s)),s}throw'Invalid Subtotal function.';},h.prototype._handleDCount=function(n,t){var r=n[0],u=n[2],e,o,f;if(r=this._ensureNonFunctionExpression(r),u=this._ensureNonFunctionExpression(u),r instanceof i._CellRangeExpression&&u instanceof i._CellRangeExpression&&(e=n[1].evaluate(t),o=this._getColumnIndexByField(r,e),f=this._getItemList([r],t,!0,!1,!0,o),f.items&&f.items.length>1))return this._DCountWithCriterias(f.items.slice(1),r,u);throw'Invalid Count Cell Reference.';},h.prototype._DCountWithCriterias=function(n,t,r){var u=r.cells,v=0,h,c,y,e,f,p,o,w,s,l,a;if(h=this._getSheet(t.sheetRef),c=this._getSheet(r.sheetRef),u.rowSpan>1){for(y=u.topRow,e=u.bottomRow;e>u.topRow;e--){for(l=[],a=[],f=u.leftCol;f<=u.rightCol;f++)if(o=this._owner.getCellValue(e,f,!1,c),o!=null&&o!=='')if(a.push(new i._Expression(o)),w=this._owner.getCellValue(y,f,!1,c),p=this._getColumnIndexByField(t,w),s=this._getItemList([t],h,!1,!1,!0,p),s.items!=null&&s.items.length>1)l.push(s.items.slice(1));else throw'Invalid Count Cell Reference.';v+=this._countCellsByCriterias(l,a,h,n)}return v}throw'Invalid Criteria Cell Reference.';},h.prototype._getColumnIndexByField=function(t,i){var r,o,f,u,e;if(r=t.cells,e=r.topRow,e===-1)throw'Invalid Count Cell Reference.';if(n.isInt(i)&&!isNaN(i)){if(i>=1&&i<=r.columnSpan)return r.leftCol+i-1}else for(o=this._getSheet(t.sheetRef),f=r.leftCol;f<=r.rightCol;f++)if(u=this._owner.getCellValue(e,f,!1,o),i=n.isString(i)?i.toLowerCase():i,u=n.isString(u)?u.toLowerCase():u,i===u)return f;throw'Invalid field.';},h.prototype._getSheet=function(n){var t=0,i;if(n)for(;t<this._owner.sheets.length;t++)if(i=this._owner.sheets[t],i.name===n)break;return i},h.prototype._parseRightExpr=function(n){var t,r,i=!1;if(n.indexOf('?')>-1||n.indexOf('*')>-1){if(t=n.match(/([\?\*]*)(\w+)([\?\*]*)(\w+)([\?\*]*)/),t!=null&&t.length===6)r=new RegExp('^'+(t[1].length>0?this._parseRegCriteria(t[1]):'')+t[2]+(t[3].length>0?this._parseRegCriteria(t[3]):'')+t[4]+(t[5].length>0?this._parseRegCriteria(t[5]):'')+'$','i');else throw'Invalid Criteria.';return/^[<>=]/.test(n)?n.trim()[0]==='='&&(i=!0):i=!0,{reg:r,checkMathces:i}}if(isNaN(+n))if(/^\w/.test(n))n='="'+n+'"';else if(/^[<>=]{1,2}\s*-?\w+$/.test(n))n=n.replace(/([<>=]{1,2})\s*(-?\w+)/,'$1"$2"');else throw'Invalid Criteria.';else n='='+n;return n},h.prototype._combineExpr=function(t,i){return n.isString(t)&&(t='"'+t+'"'),t='='+t,t+i},h.prototype._parseRegCriteria=function(n){for(var i=0,t=0,r='';i<n.length;i++)n[i]==='*'?(t>0&&(r+='\\w{'+t+'}',t=0),r+='\\w*'):n[i]==='?'&&t++;return t>0&&(r+='\\w{'+t+'}'),r},h.prototype._calculateRate=function(n,t){var v=1e-7,w=20,p=0,b=0,y,r,u,e,o,s,c,k,a,f,l,h;for(u=i._Expression.toNumber(n[0],t),e=i._Expression.toNumber(n[1],t),o=i._Expression.toNumber(n[2],t),s=n[3]!=null?i._Expression.toNumber(n[3],t):0,c=n[4]!=null?i._Expression.toNumber(n[4],t):0,k=n[5]!=null?i._Expression.toNumber(n[5],t):.1,r=k,Math.abs(r)<v?a=o*(1+u*r)+e*(1+r*c)*u+s:(f=Math.exp(u*Math.log(1+r)),a=o*f+e*(1/r+c)*(f-1)+s),l=o+e*u+s,h=o*f+e*(1/r+c)*(f-1)+s,y=r;Math.abs(l-h)>v&&p<w;)r=(h*b-l*y)/(h-l),b=y,y=r,Math.abs(r)<v?a=o*(1+u*r)+e*(1+r*c)*u+s:(f=Math.exp(u*Math.log(1+r)),a=o*f+e*(1/r+c)*(f-1)+s),l=h,h=a,++p;if(Math.abs(l-h)>v&&p===w)throw'It is not able to calculate the rate with current parameters.';return r},h.prototype._handleHLookup=function(n,t){var f=n[0].evaluate(t),e=n[1],o=i._Expression.toNumber(n[2],t),s=n[3]!=null?i._Expression.toBoolean(n[3],t):!0,r,u;if(f==null||f=='')throw'Invalid lookup value.';if(isNaN(o)||o<0)throw'Invalid row index.';if(e=this._ensureNonFunctionExpression(e),e instanceof i._CellRangeExpression){if(r=e.cells,o>r.rowSpan)throw'Row index is out of the cell range.';if(s?(u=this._exactMatch(f,r,t,!1),u===-1&&(u=this._approximateMatch(f,r,t))):u=this._exactMatch(f,r,t),u===-1)throw'Lookup Value is not found.';return this._owner.getCellValue(r.topRow+o-1,u,!1,t)}throw'Invalid Cell Reference.';},h.prototype._exactMatch=function(t,i,r,u){u===void 0&&(u=!0);var h=i.topRow,e,o,f,s;if(n.isString(t)&&(t=t.toLowerCase()),u&&n.isString(t)&&(t.indexOf('?')>-1||t.indexOf('*')>-1))if(f=t.match(/([\?\*]*)(\w+)([\?\*]*)(\w+)([\?\*]*)/),f!=null&&f.length===6)s=new RegExp('^'+(f[1].length>0?this._parseRegCriteria(f[1]):'')+f[2]+(f[3].length>0?this._parseRegCriteria(f[3]):'')+f[4]+(f[5].length>0?this._parseRegCriteria(f[5]):'')+'$','i');else throw'Invalid lookup value.';for(e=i.leftCol;e<=i.rightCol;e++)if(o=this._owner.getCellValue(h,e,!1,r),s!=null){if(s.test(o))return e}else if(n.isString(o)&&(o=o.toLowerCase()),t===o)return e;return-1},h.prototype._approximateMatch=function(t,i,r){var u,f,s=i.topRow,e=[],o=0;for(n.isString(t)&&(t=t.toLowerCase()),f=i.leftCol;f<=i.rightCol;f++)u=this._owner.getCellValue(s,f,!1,r),u=isNaN(+u)?u:+u,e.push({value:u,index:f});for(e.sort(function(t,i){return(n.isString(t.value)&&(t.value=t.value.toLowerCase()),n.isString(i.value)&&(i.value=i.value.toLowerCase()),t.value>i.value)?-1:t.value===i.value?i.index-t.index:1});o<e.length;o++)if(u=e[o],n.isString(u.value)&&(u.value=u.value.toLowerCase()),t>u.value)return u.index;throw'Lookup Value is not found.';},h.prototype._checkCache=function(n){var t=this._expressionCache[n];return t?t:(t=this._parse(n),this._cacheSize>1e4&&this._clearExpressionCache(),this._expressionCache[n]=t,this._cacheSize++,t)},h.prototype._ensureNonFunctionExpression=function(n,t){while(n instanceof i._FunctionExpression)n=n.evaluate(t);return n},h}(),s,r,u,f,o,e;i._CalcEngine=h;s=function(){function n(n,t,i){this._value=n;this._tokenID=t;this._tokenType=i}return Object.defineProperty(n.prototype,"value",{get:function(){return this._value},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"tokenID",{get:function(){return this._tokenID},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"tokenType",{get:function(){return this._tokenType},enumerable:!0,configurable:!0}),n}();i._Token=s;r=function(){function t(t,i,r){this._paramMax=Number.MAX_VALUE;this._paramMin=Number.MIN_VALUE;this._func=t;n.isNumber(i)&&!isNaN(i)&&(this._paramMax=i);n.isNumber(r)&&!isNaN(r)&&(this._paramMin=r)}return Object.defineProperty(t.prototype,"paramMax",{get:function(){return this._paramMax},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"paramMin",{get:function(){return this._paramMin},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"func",{get:function(){return this._func},enumerable:!0,configurable:!0}),t}();i._FunctionDefinition=r,function(n){n[n.COMPARE=0]="COMPARE";n[n.ADDSUB=1]="ADDSUB";n[n.MULDIV=2]="MULDIV";n[n.POWER=3]="POWER";n[n.CONCAT=4]="CONCAT";n[n.GROUP=5]="GROUP";n[n.LITERAL=6]="LITERAL";n[n.IDENTIFIER=7]="IDENTIFIER"}(i._TokenType||(i._TokenType={}));u=i._TokenType,function(n){n[n.GT=0]="GT";n[n.LT=1]="LT";n[n.GE=2]="GE";n[n.LE=3]="LE";n[n.EQ=4]="EQ";n[n.NE=5]="NE";n[n.ADD=6]="ADD";n[n.SUB=7]="SUB";n[n.MUL=8]="MUL";n[n.DIV=9]="DIV";n[n.DIVINT=10]="DIVINT";n[n.MOD=11]="MOD";n[n.POWER=12]="POWER";n[n.CONCAT=13]="CONCAT";n[n.OPEN=14]="OPEN";n[n.CLOSE=15]="CLOSE";n[n.END=16]="END";n[n.COMMA=17]="COMMA";n[n.PERIOD=18]="PERIOD";n[n.ATOM=19]="ATOM"}(i._TokenID||(i._TokenID={}));f=i._TokenID,function(n){n[n.Count=0]="Count";n[n.CountA=1]="CountA";n[n.ConutBlank=2]="ConutBlank";n[n.CountIf=3]="CountIf";n[n.CountIfs=4]="CountIfs";n[n.Rank=5]="Rank";n[n.SumIf=6]="SumIf";n[n.SumIfs=7]="SumIfs";n[n.Product=8]="Product"}(o||(o={})),function(n){n[n.Average=1]="Average";n[n.Count=2]="Count";n[n.CountA=3]="CountA";n[n.Max=4]="Max";n[n.Min=5]="Min";n[n.Product=6]="Product";n[n.Std=7]="Std";n[n.StdPop=8]="StdPop";n[n.Sum=9]="Sum";n[n.Var=10]="Var";n[n.VarPop=11]="VarPop";n[n.AverageWithoutHidden=101]="AverageWithoutHidden";n[n.CountWithoutHidden=102]="CountWithoutHidden";n[n.CountAWithoutHidden=103]="CountAWithoutHidden";n[n.MaxWithoutHidden=104]="MaxWithoutHidden";n[n.MinWithoutHidden=105]="MinWithoutHidden";n[n.ProductWithoutHidden=106]="ProductWithoutHidden";n[n.StdWithoutHidden=107]="StdWithoutHidden";n[n.StdPopWithoutHidden=108]="StdPopWithoutHidden";n[n.SumWithoutHidden=109]="SumWithoutHidden";n[n.VarWithoutHidden=110]="VarWithoutHidden";n[n.VarPopWithoutHidden=111]="VarPopWithoutHidden"}(e||(e={}))})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))})(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(i){'use strict';var r=function(){function t(n){this._token=n?n instanceof i._Token?n:new i._Token(n,i._TokenID.ATOM,i._TokenType.LITERAL):new i._Token(null,i._TokenID.ATOM,i._TokenType.IDENTIFIER)}return Object.defineProperty(t.prototype,"token",{get:function(){return this._token},enumerable:!0,configurable:!0}),t.prototype.evaluate=function(){if(this._token.tokenType!==i._TokenType.LITERAL)throw'Bad expression.';return this._token.value},t.toString=function(t,i){var r=t.evaluate(i);return n.isPrimitive(r)||(r=r.value),r!=null?r.toString():''},t.toNumber=function(t,i){var r=t.evaluate(i);return(n.isPrimitive(r)||(r=r.value),n.isNumber(r))?r:n.isBoolean(r)?r?1:0:n.isDate(r)?this._toOADate(r):n.isString(r)?r?+r:0:n.changeType(r,n.DataType.Number,'')},t.toBoolean=function(t,i){var r=t.evaluate(i);return(n.isPrimitive(r)||(r=r.value),n.isBoolean(r))?r:n.isNumber(r)?r===0?!1:!0:n.changeType(r,n.DataType.Boolean,'')},t.toDate=function(t,i){var r=t.evaluate(i);return(n.isPrimitive(r)||(r=r.value),n.isDate(r))?r:n.isNumber(r)?this._fromOADate(r):n.changeType(r,n.DataType.Date,'')},t._toOADate=function(n){var t=Date.UTC(1899,11,30),i=Date.UTC(n.getFullYear(),n.getMonth(),n.getDate(),n.getHours(),n.getMinutes(),n.getSeconds(),n.getMilliseconds());return(i-t)/864e5},t._fromOADate=function(n){var t=Date.UTC(1899,11,30);return new Date(n*864e5+t)},t}(),u,f,e,o;i._Expression=r;u=function(n){function t(t,i){n.call(this,t);this._expr=i}return __extends(t,n),t.prototype.evaluate=function(n){if(this.token.tokenID===i._TokenID.SUB)return this._evaluatedValue==null&&(this._evaluatedValue=-r.toNumber(this._expr,n)),this._evaluatedValue;if(this.token.tokenID===i._TokenID.ADD)return this._evaluatedValue==null&&(this._evaluatedValue=+r.toNumber(this._expr,n)),this._evaluatedValue;throw'Bad expression.';},t}(r);i._UnaryExpression=u;f=function(n){function t(t,i,r){n.call(this,t);this._leftExpr=i;this._rightExpr=r}return __extends(t,n),t.prototype.evaluate=function(n){var e,o,t,u,f;if(this._evaluatedValue!=null)return this._evaluatedValue;if(e=r.toString(this._leftExpr,n),o=r.toString(this._rightExpr,n),this.token.tokenType===i._TokenType.CONCAT)return this._evaluatedValue=e+o,this._evaluatedValue;if(t=r.toNumber(this._leftExpr,n),u=r.toNumber(this._rightExpr,n),f=t-u,this.token.tokenType===i._TokenType.COMPARE)switch(this.token.tokenID){case i._TokenID.GT:return f>0;case i._TokenID.LT:return f<0;case i._TokenID.GE:return f>=0;case i._TokenID.LE:return f<=0;case i._TokenID.EQ:return isNaN(f)?(this._evaluatedValue=e.toLowerCase()===o.toLowerCase(),this._evaluatedValue):(this._evaluatedValue=f===0,this._evaluatedValue);case i._TokenID.NE:return isNaN(f)?(this._evaluatedValue=e.toLowerCase()!==o.toLowerCase(),this._evaluatedValue):(this._evaluatedValue=f!==0,this._evaluatedValue)}switch(this.token.tokenID){case i._TokenID.ADD:this._evaluatedValue=t+u;break;case i._TokenID.SUB:this._evaluatedValue=t-u;break;case i._TokenID.MUL:this._evaluatedValue=t*u;break;case i._TokenID.DIV:this._evaluatedValue=t/u;break;case i._TokenID.DIVINT:this._evaluatedValue=Math.floor(t/u);break;case i._TokenID.MOD:this._evaluatedValue=Math.floor(t%u);break;case i._TokenID.POWER:u===0&&(this._evaluatedValue=1);u===.5&&(this._evaluatedValue=Math.sqrt(t));u===1&&(this._evaluatedValue=t);u===2&&(this._evaluatedValue=t*t);u===3&&(this._evaluatedValue=t*t*t);u===4&&(this._evaluatedValue=t*t*t*t);this._evaluatedValue=Math.pow(t,u);break;default:this._evaluatedValue=NaN}if(!isNaN(this._evaluatedValue))return this._evaluatedValue;throw'Bad expression.';},t}(r);i._BinaryExpression=f;e=function(i){function r(n,t,r){i.call(this);this._cells=n;this._sheetRef=t;this._flex=r;this._evalutingRange={}}return __extends(r,i),r.prototype.evaluate=function(n){return this._evaluatedValue==null&&(this._evaluatedValue=this._getCellValue(this._cells,n)),this._evaluatedValue},r.prototype.getValues=function(i,r,u){i===void 0&&(i=!0);var e,o=[],s=0,f,r,h,c;if(h=r!=null&&!isNaN(+r)?r:this._cells.leftCol,c=r!=null&&!isNaN(+r)?r:this._cells.rightCol,u=this._getSheet()||u||this._flex.selectedSheet,!u)return null;for(f=this._cells.topRow;f<=this._cells.bottomRow;f++){if(f>=u.grid.rows.length)throw'The cell reference is out of the cell range of the flexsheet.';if(i||u.grid.rows[f].isVisible!==!1)for(r=h;r<=c;r++){if(r>=u.grid.columns.length)throw'The cell reference is out of the cell range of the flexsheet.';(i||u.grid.columns[r].isVisible!==!1)&&(e=this._getCellValue(new t.CellRange(f,r),u),n.isPrimitive(e)||(e=e.value),o[s]=e,s++)}}return o},Object.defineProperty(r.prototype,"cells",{get:function(){return this._cells},enumerable:!0,configurable:!0}),Object.defineProperty(r.prototype,"sheetRef",{get:function(){return this._sheetRef},enumerable:!0,configurable:!0}),r.prototype._getCellValue=function(n,t){var t,i;if(t=this._getSheet()||t||this._flex.selectedSheet,!t)return null;if(i=t.name+':'+n.row+','+n.col+'-'+n.row2+','+n.col2,this._evalutingRange[i])throw'Circular Reference';try{if(this._flex)return this._evalutingRange[i]=!0,this._flex.getCellValue(n.row,n.col,!1,t)}finally{delete this._evalutingRange[i]}},r.prototype._getSheet=function(){var n=0,t;if(!this._sheetRef)return null;for(;n<this._flex.sheets.length;n++)if(t=this._flex.sheets[n],t.name===this._sheetRef)return t;throw'Invalid sheet reference';},r}(r);i._CellRangeExpression=e;o=function(n){function t(t,i){n.call(this);this._funcDefinition=t;this._params=i}return __extends(t,n),t.prototype.evaluate=function(n,t,i){return this._evaluatedValue==null&&(this._evaluatedValue=this._funcDefinition.func(this._params,n,t,i)),this._evaluatedValue},t}(r);i._FunctionExpression=o})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(){function n(n){this._owner=n;this._sheetIndex=n.selectedSheetIndex}return Object.defineProperty(n.prototype,"sheetIndex",{get:function(){return this._sheetIndex},enumerable:!0,configurable:!0}),n.prototype.undo=function(){throw'This abstract method must be overrided.';},n.prototype.redo=function(){throw'This abstract method must be overrided.';},n.prototype.saveNewState=function(){throw'This abstract method must be overrided.';},n}(),u,f,e,o,s,h,r,c,l;t._UndoAction=i;u=function(n){function t(t,i){var e,i,o,u,f;for(n.call(this,t),this._isPaste=!1,this._selections=i?[i]:t.selectedSheet.selectionRanges.slice(),this._oldValues=[],this._mergeAction=new r(t),e=0;e<this._selections.length;e++)for(i=this._selections[e],o=i.topRow;o<=i.bottomRow;o++)for(u=i.leftCol;u<=i.rightCol;u++)f=t.getCellData(o,u,!!t.columns[u].dataMap),f=f==undefined?'':f,this._oldValues.push(f)}return __extends(t,n),Object.defineProperty(t.prototype,"isPaste",{get:function(){return this._isPaste},enumerable:!0,configurable:!0}),t.prototype.undo=function(){var n=this,f=0,i,t,r,u;n._owner._clearCalcEngine();n._owner.selectedSheet.selectionRanges.clear();n._owner.deferUpdate(function(){for(i=0;i<n._selections.length;i++){for(t=n._selections[i],r=t.topRow;r<=t.bottomRow;r++)for(u=t.leftCol;u<=t.rightCol;u++)n._owner.setCellData(r,u,n._oldValues[f]),f++;n._owner.selectedSheet.selectionRanges.push(t)}n._mergeAction.undo();n._owner.refresh(!1)})},t.prototype.redo=function(){var n=this,f=0,i,t,r,u;n._owner._clearCalcEngine();n._owner.selectedSheet.selectionRanges.clear();n._owner.deferUpdate(function(){for(i=0;i<n._selections.length;i++){for(t=n._selections[i],r=t.topRow;r<=t.bottomRow;r++)for(u=t.leftCol;u<=t.rightCol;u++)n._owner.setCellData(r,u,n._newValues[f]),f++;n._owner.selectedSheet.selectionRanges.push(t)}n._mergeAction.redo();n._owner.refresh(!1)})},t.prototype.saveNewState=function(){var r,n,f,u,t,i;for(this._newValues=[],r=0;r<this._selections.length;r++)for(n=this._selections[r],u=n.topRow;u<=n.bottomRow;u++)for(t=n.leftCol;t<=n.rightCol;t++){if(f=this._owner.columns[t],!f)return!1;i=this._owner.getCellData(u,t,!!f.dataMap);i=i==undefined?'':i;this._newValues.push(i)}return this._mergeAction.saveNewState(),!this._checkActionState()},t.prototype.markIsPaste=function(){this._isPaste=!0},t.prototype.updateForPasting=function(n){var t=this._selections[this._selections.length-1],i=this._owner.getCellData(n.row,n.col,!!this._owner.columns[n.col].dataMap);this._addingValue||(this._addingValue=!0,this._oldValues=[]);i=i==undefined?'':i;this._oldValues.push(i);t.row=Math.min(t.topRow,n.topRow);t.row2=Math.max(t.bottomRow,n.bottomRow);t.col=Math.min(t.leftCol,n.leftCol);t.col2=Math.max(t.rightCol,n.rightCol)},t.prototype._checkActionState=function(){var n;if(this._oldValues.length!==this._newValues.length)return!1;for(n=0;n<this._oldValues.length;n++)if(this._oldValues[n]!==this._newValues[n])return!1;return!0},t}(i);t._EditAction=u;f=function(n){function t(t,i,r){n.call(this,t);this._panel=i;this._colIndex=r;this._oldColWidth=i.columns[r].width}return __extends(t,n),t.prototype.undo=function(){this._panel.columns[this._colIndex].width=this._oldColWidth},t.prototype.redo=function(){this._panel.columns[this._colIndex].width=this._newColWidth},t.prototype.saveNewState=function(){return(this._newColWidth=this._panel.columns[this._colIndex].width,this._oldColWidth===this._newColWidth)?!1:!0},t}(i);t._ColumnResizeAction=f;e=function(n){function t(t,i,r){n.call(this,t);this._panel=i;this._rowIndex=r;this._oldRowHeight=i.rows[r].height}return __extends(t,n),t.prototype.undo=function(){this._panel.rows[this._rowIndex].height=this._oldRowHeight},t.prototype.redo=function(){this._panel.rows[this._rowIndex].height=this._newRowHeight},t.prototype.saveNewState=function(){return(this._newRowHeight=this._panel.rows[this._rowIndex].height,this._oldRowHeight===this._newRowHeight)?!1:!0},t}(i);t._RowResizeAction=e;o=function(n){function t(t){var i,r=[];for(n.call(this,t),this._selection=t.selection,i=0;i<t.columns.length;i++)r.push(t.columns[i]);this._oldValue={columns:r,sortList:t.sortManager._committedList.slice(),styledCells:t.selectedSheet?JSON.parse(JSON.stringify(t.selectedSheet._styledCells)):null,mergedCells:t._cloneMergedCells()}}return __extends(t,n),t.prototype.undo=function(){var i,r,u,t,n=this;if(n._owner.selectedSheet){for(n._owner._clearCalcEngine(),n._owner.finishEditing(),n._owner.columns.clear(),n._owner.selectedSheet._styledCells=undefined,n._owner.selectedSheet._mergedRanges=undefined,n._owner.columns.beginUpdate(),i=0;i<n._oldValue.columns.length;i++)n._owner.columns.push(n._oldValue.columns[i]);n._owner.columns.endUpdate();n._owner.selectedSheet._styledCells=n._oldValue.styledCells;n._owner.selectedSheet._mergedRanges=n._oldValue.mergedCells;n._affectedFormulas&&(t=n._affectedFormulas.oldFormulas);n._owner.deferUpdate(function(){if(n._owner.selection=n._selection,!!t&&t.length>0)for(r=0;r<t.length;r++)u=t[r],n._owner.setCellData(u.point.x,u.point.y,u.formula);n._owner._copyTo(n._owner.selectedSheet);n._owner._copyFrom(n._owner.selectedSheet)});n._owner.selectedSheet.grid.wj_sheetInfo.styledCells=n._owner.selectedSheet._styledCells;n._owner.selectedSheet.grid.wj_sheetInfo.mergedRanges=n._owner.selectedSheet._mergedRanges;n._owner.sortManager.sortDescriptions.sourceCollection=n._oldValue.sortList.slice();n._owner.sortManager.commitSort(!1);n._owner.sortManager._refresh();n._owner.selection=n._selection;n._owner.refresh(!0);setTimeout(function(){n._owner._setFlexSheetToDirty();n._owner.refresh(!0)},10)}},t.prototype.redo=function(){var i,r,u,t,n=this;if(n._owner.selectedSheet){for(n._owner._clearCalcEngine(),n._owner.finishEditing(),n._owner.columns.clear(),n._owner.selectedSheet._styledCells=undefined,n._owner.selectedSheet._mergedRanges=undefined,n._owner.columns.beginUpdate(),i=0;i<n._newValue.columns.length;i++)n._owner.columns.push(n._newValue.columns[i]);n._owner.columns.endUpdate();n._owner.selectedSheet._styledCells=n._newValue.styledCells;n._owner.selectedSheet._mergedRanges=n._newValue.mergedCells;n._affectedFormulas&&(t=n._affectedFormulas.newFormulas);n._owner.deferUpdate(function(){if(n._owner.selection=n._selection,!!t&&t.length>0)for(r=0;r<t.length;r++)u=t[r],n._owner.setCellData(u.point.x,u.point.y,u.formula);n._owner._copyTo(n._owner.selectedSheet);n._owner._copyFrom(n._owner.selectedSheet)});n._owner.selectedSheet.grid.wj_sheetInfo.styledCells=n._owner.selectedSheet._styledCells;n._owner.selectedSheet.grid.wj_sheetInfo.mergedRanges=n._owner.selectedSheet._mergedRanges;n._owner.sortManager.sortDescriptions.sourceCollection=n._newValue.sortList.slice();n._owner.sortManager.commitSort(!1);n._owner.sortManager._refresh();n._owner.selection=n._selection;n._owner.refresh(!0);setTimeout(function(){n._owner._setFlexSheetToDirty();n._owner.refresh(!0)},10)}},t.prototype.saveNewState=function(){for(var t=[],n=0;n<this._owner.columns.length;n++)t.push(this._owner.columns[n]);return this._newValue={columns:t,sortList:this._owner.sortManager._committedList.slice(),styledCells:this._owner.selectedSheet?JSON.parse(JSON.stringify(this._owner.selectedSheet._styledCells)):null,mergedCells:this._owner._cloneMergedCells()},!0},t}(i);t._ColumnsChangedAction=o;s=function(n){function i(t){var i,r,u=[],f=[];for(n.call(this,t),this._selection=t.selection,i=0;i<t.rows.length;i++)u.push(t.rows[i]);for(r=0;r<t.columns.length;r++)f.push(t.columns[r]);this._oldValue={rows:u,columns:f,itemsSource:t.itemsSource?t.itemsSource.slice():undefined,styledCells:t.selectedSheet?JSON.parse(JSON.stringify(t.selectedSheet._styledCells)):null,mergedCells:t._cloneMergedCells()}}return __extends(i,n),i.prototype.undo=function(){var i,f,e,r,o,u,n=this,s=!!n._oldValue.itemsSource;if(n._owner.selectedSheet){for(n._owner._clearCalcEngine(),n._owner.finishEditing(),n._owner.columns.clear(),n._owner.rows.clear(),n._owner.selectedSheet._styledCells=undefined,n._owner.selectedSheet._mergedRanges=undefined,s&&(n._owner.autoGenerateColumns=!1,n._owner.itemsSource=n._oldValue.itemsSource.slice()),n._owner.rows.beginUpdate(),i=0;i<n._oldValue.rows.length;i++)r=n._oldValue.rows[i],s?r.dataItem||r instanceof t.HeaderRow||n._owner.rows.splice(i,0,r):n._owner.rows.push(r);for(f=0;f<n._oldValue.columns.length;f++)n._owner.columns.push(n._oldValue.columns[f]);n._owner.rows.endUpdate();n._owner.selectedSheet._styledCells=n._oldValue.styledCells;n._owner.selectedSheet._mergedRanges=n._oldValue.mergedCells;n._affecedFormulas&&(u=n._affecedFormulas.oldFormulas);n._owner.deferUpdate(function(){if(n._owner.selection=n._selection,!!u&&u.length>0)for(e=0;e<u.length;e++)o=u[e],n._owner.setCellData(o.point.x,o.point.y,o.formula);n._owner._copyTo(n._owner.selectedSheet);n._owner._copyFrom(n._owner.selectedSheet)});n._owner.selectedSheet.grid.wj_sheetInfo.styledCells=n._owner.selectedSheet._styledCells;n._owner.selectedSheet.grid.wj_sheetInfo.mergedRanges=n._owner.selectedSheet._mergedRanges;n._owner.selection=n._selection;n._owner.refresh(!0);setTimeout(function(){n._owner._setFlexSheetToDirty();n._owner.refresh(!0)},10)}},i.prototype.redo=function(){var i,f,e,r,o,u,n=this,s=!!n._newValue.itemsSource;if(n._owner.selectedSheet){for(n._owner._clearCalcEngine(),n._owner.finishEditing(),n._owner.columns.clear(),n._owner.rows.clear(),n._owner.selectedSheet._styledCells=undefined,n._owner.selectedSheet._mergedRanges=undefined,s&&(n._owner.autoGenerateColumns=!1,n._owner.itemsSource=n._newValue.itemsSource.slice()),n._owner.rows.beginUpdate(),i=0;i<n._newValue.rows.length;i++)r=n._newValue.rows[i],s?r.dataItem||r instanceof t.HeaderRow||n._owner.rows.splice(i,0,r):n._owner.rows.push(r);for(f=0;f<n._newValue.columns.length;f++)n._owner.columns.push(n._newValue.columns[f]);n._owner.rows.endUpdate();n._owner.selectedSheet._styledCells=n._newValue.styledCells;n._owner.selectedSheet._mergedRanges=n._newValue.mergedCells;n._affecedFormulas&&(u=n._affecedFormulas.newFormulas);n._owner.deferUpdate(function(){if(!!u&&u.length>0)for(e=0;e<u.length;e++)o=u[e],n._owner.setCellData(o.point.x,o.point.y,o.formula);n._owner._copyTo(n._owner.selectedSheet);n._owner._copyFrom(n._owner.selectedSheet)});n._owner.selectedSheet.grid.wj_sheetInfo.styledCells=n._owner.selectedSheet._styledCells;n._owner.selectedSheet.grid.wj_sheetInfo.mergedRanges=n._owner.selectedSheet._mergedRanges;n._owner.selection=n._selection;n._owner.refresh(!0);setTimeout(function(){n._owner._setFlexSheetToDirty();n._owner.refresh(!0)},10)}},i.prototype.saveNewState=function(){for(var t,i=[],r=[],n=0;n<this._owner.rows.length;n++)i.push(this._owner.rows[n]);for(t=0;t<this._owner.columns.length;t++)r.push(this._owner.columns[t]);return this._newValue={rows:i,columns:r,itemsSource:this._owner.itemsSource?this._owner.itemsSource.slice():undefined,styledCells:this._owner.selectedSheet?JSON.parse(JSON.stringify(this._owner.selectedSheet._styledCells)):null,mergedCells:this._owner._cloneMergedCells()},!0},i}(i);t._RowsChangedAction=s;h=function(n){function t(t,i){n.call(this,t);this._oldStyledCells=i?JSON.parse(JSON.stringify(i)):t.selectedSheet?JSON.parse(JSON.stringify(t.selectedSheet._styledCells)):null}return __extends(t,n),t.prototype.undo=function(){this._owner.selectedSheet&&(this._owner.selectedSheet._styledCells=JSON.parse(JSON.stringify(this._oldStyledCells)),this._owner.selectedSheet.grid.wj_sheetInfo.styledCells=this._owner.selectedSheet._styledCells,this._owner.refresh(!1))},t.prototype.redo=function(){this._owner.selectedSheet&&(this._owner.selectedSheet._styledCells=JSON.parse(JSON.stringify(this._newStyledCells)),this._owner.selectedSheet.grid.wj_sheetInfo.styledCells=this._owner.selectedSheet._styledCells,this._owner.refresh(!1))},t.prototype.saveNewState=function(){return this._newStyledCells=this._owner.selectedSheet?JSON.parse(JSON.stringify(this._owner.selectedSheet._styledCells)):null,!0},t}(i);t._CellStyleAction=h;r=function(n){function t(t){n.call(this,t);this._oldMergedCells=t._cloneMergedCells()}return __extends(t,n),t.prototype.undo=function(){this._owner.selectedSheet&&(this._owner._clearCalcEngine(),this._owner.selectedSheet._mergedRanges=this._oldMergedCells,this._owner.selectedSheet.grid.wj_sheetInfo.mergedRanges=this._owner.selectedSheet._mergedRanges,this._owner.refresh(!0))},t.prototype.redo=function(){this._owner.selectedSheet&&(this._owner._clearCalcEngine(),this._owner.selectedSheet._mergedRanges=this._newMergedCells,this._owner.selectedSheet.grid.wj_sheetInfo.mergedRanges=this._owner.selectedSheet._mergedRanges,this._owner.refresh(!0))},t.prototype.saveNewState=function(){return this._newMergedCells=this._owner._cloneMergedCells(),!0},t}(i);t._CellMergeAction=r;c=function(n){function t(t){var i,r,u=[],f=[];if(n.call(this,t),!t.itemsSource){for(i=0;i<t.rows.length;i++)f.push(t.rows[i]);for(r=0;r<t.columns.length;r++)u.push(t.columns[r])}this._oldValue={sortList:t.sortManager._committedList.slice(),rows:f,columns:u}}return __extends(t,n),t.prototype.undo=function(){var n=this,t,i;if(n._owner.selectedSheet&&(n._owner._clearCalcEngine(),n._owner.sortManager.sortDescriptions.sourceCollection=n._oldValue.sortList.slice(),n._owner.sortManager.commitSort(!1),n._owner.sortManager._refresh(),!n._owner.itemsSource)){for(n._owner._isCopyingOrUndoing=!0,n._owner.rows.clear(),n._owner.columns.clear(),n._owner.selectedSheet.grid.rows.clear(),n._owner.selectedSheet.grid.columns.clear(),t=0;t<n._oldValue.rows.length;t++)n._owner.rows.push(n._oldValue.rows[t]),n._owner.selectedSheet.grid.rows.push(n._oldValue.rows[t]);for(i=0;i<n._oldValue.columns.length;i++)n._owner.columns.push(n._oldValue.columns[i]),n._owner.selectedSheet.grid.columns.push(n._oldValue.columns[i]);n._owner._isCopyingOrUndoing=!1;setTimeout(function(){n._owner._setFlexSheetToDirty();n._owner.refresh(!0)},10)}},t.prototype.redo=function(){var n=this,t,i;if(n._owner.selectedSheet&&(n._owner._clearCalcEngine(),n._owner.sortManager.sortDescriptions.sourceCollection=n._newValue.sortList.slice(),n._owner.sortManager.commitSort(!1),n._owner.sortManager._refresh(),!n._owner.itemsSource)){for(n._owner._isCopyingOrUndoing=!0,n._owner.rows.clear(),n._owner.columns.clear(),n._owner.selectedSheet.grid.rows.clear(),n._owner.selectedSheet.grid.columns.clear(),t=0;t<n._newValue.rows.length;t++)n._owner.rows.push(n._newValue.rows[t]),n._owner.selectedSheet.grid.rows.push(n._newValue.rows[t]);for(i=0;i<n._newValue.columns.length;i++)n._owner.columns.push(n._newValue.columns[i]),n._owner.selectedSheet.grid.columns.push(n._newValue.columns[i]);n._owner._isCopyingOrUndoing=!1;setTimeout(function(){n._owner._setFlexSheetToDirty();n._owner.refresh(!0)},10)}},t.prototype.saveNewState=function(){var n,t,i=[],r=[];if(!this._owner.itemsSource){for(n=0;n<this._owner.rows.length;n++)r.push(this._owner.rows[n]);for(t=0;t<this._owner.columns.length;t++)i.push(this._owner.columns[t])}return this._newValue={sortList:this._owner.sortManager._committedList.slice(),rows:r,columns:i},!0},t}(i);t._SortColumnAction=c;l=function(t){function i(n,i,r,u){var e,f,o,s,h;if(t.call(this,n),n.selectedSheet){for(this._isDraggingColumns=i.topRow===0&&i.bottomRow===n.rows.length-1?!0:!1,this._isCopyCells=u,this._dragRange=i,this._dropRange=r,this._oldDroppingCells=[],this._oldDroppingColumnSetting={},e=r.topRow;e<=r.bottomRow;e++)for(f=r.leftCol;f<=r.rightCol;f++)this._isDraggingColumns&&(this._oldDroppingColumnSetting[f]||(this._oldDroppingColumnSetting[f]={dataType:n.columns[f].dataType,align:n.columns[f].align,format:n.columns[f].format})),o=e*this._owner.columns.length+f,h=this._owner.selectedSheet._styledCells[o]?JSON.parse(JSON.stringify(this._owner.selectedSheet._styledCells[o])):undefined,s=this._owner.getCellData(e,f,!1),this._oldDroppingCells.push({rowIndex:e,columnIndex:f,cellContent:s,cellStyle:h});if(!u)for(this._draggingCells=[],this._draggingColumnSetting={},e=i.topRow;e<=i.bottomRow;e++)for(f=i.leftCol;f<=i.rightCol;f++)this._isDraggingColumns&&(this._draggingColumnSetting[f]||(this._draggingColumnSetting[f]={dataType:n.columns[f].dataType,align:n.columns[f].align,format:n.columns[f].format})),o=e*this._owner.columns.length+f,h=this._owner.selectedSheet._styledCells[o]?JSON.parse(JSON.stringify(this._owner.selectedSheet._styledCells[o])):undefined,s=this._owner.getCellData(e,f,!1),this._draggingCells.push({rowIndex:e,columnIndex:f,cellContent:s,cellStyle:h})}}return __extends(i,t),i.prototype.undo=function(){var t=this,r,i,e,u,f;if(t._owner.selectedSheet){for(t._owner._clearCalcEngine(),r=0;r<t._oldDroppingCells.length;r++)i=t._oldDroppingCells[r],t._owner.setCellData(i.rowIndex,i.columnIndex,i.cellContent),e=i.rowIndex*t._owner.columns.length+i.columnIndex,i.cellStyle?t._owner.selectedSheet._styledCells[e]=i.cellStyle:delete t._owner.selectedSheet._styledCells[e];if(t._isDraggingColumns&&!!t._oldDroppingColumnSetting&&Object.keys(t._oldDroppingColumnSetting).forEach(function(i){t._owner.columns[+i].dataType=t._oldDroppingColumnSetting[+i].dataType?t._oldDroppingColumnSetting[+i].dataType:n.DataType.Object;t._owner.columns[+i].align=t._oldDroppingColumnSetting[+i].align;t._owner.columns[+i].format=t._oldDroppingColumnSetting[+i].format}),!t._isCopyCells){for(r=0;r<t._draggingCells.length;r++)i=t._draggingCells[r],t._owner.setCellData(i.rowIndex,i.columnIndex,i.cellContent),e=i.rowIndex*t._owner.columns.length+i.columnIndex,i.cellStyle&&(t._owner.selectedSheet._styledCells[e]=i.cellStyle);if(t._isDraggingColumns&&!!t._draggingColumnSetting&&Object.keys(t._draggingColumnSetting).forEach(function(i){t._owner.columns[+i].dataType=t._draggingColumnSetting[+i].dataType?t._draggingColumnSetting[+i].dataType:n.DataType.Object;t._owner.columns[+i].align=t._draggingColumnSetting[+i].align;t._owner.columns[+i].format=t._draggingColumnSetting[+i].format}),t._isDraggingColumns)if(t._dragRange.leftCol<t._dropRange.leftCol)for(f=t._dragRange.leftCol,u=t._dropRange.leftCol;u<=t._dropRange.rightCol;u++)t._owner._updateColumnFiler(u,f),f++;else for(f=t._dragRange.rightCol,u=t._dropRange.rightCol;u>=t._dropRange.leftCol;u--)t._owner._updateColumnFiler(u,f),f--}}},i.prototype.redo=function(){var t=this,r,i,f,u,e;if(t._owner.selectedSheet){if(t._owner._clearCalcEngine(),!t._isCopyCells){for(r=0;r<t._draggingCells.length;r++)i=t._draggingCells[r],t._owner.setCellData(i.rowIndex,i.columnIndex,null),f=i.rowIndex*t._owner.columns.length+i.columnIndex,t._owner.selectedSheet._styledCells[f]&&delete t._owner.selectedSheet._styledCells[f];t._isDraggingColumns&&!!t._draggingColumnSetting&&Object.keys(t._draggingColumnSetting).forEach(function(i){t._owner.columns[+i].dataType=n.DataType.Object;t._owner.columns[+i].align=null;t._owner.columns[+i].format=null})}for(r=0;r<t._newDroppingCells.length;r++)i=t._newDroppingCells[r],t._owner.setCellData(i.rowIndex,i.columnIndex,i.cellContent),f=i.rowIndex*t._owner.columns.length+i.columnIndex,i.cellStyle?t._owner.selectedSheet._styledCells[f]=i.cellStyle:delete t._owner.selectedSheet._styledCells[f];if(t._isDraggingColumns&&!!t._newDroppingColumnSetting&&Object.keys(t._newDroppingColumnSetting).forEach(function(i){t._owner.columns[+i].dataType=t._newDroppingColumnSetting[+i].dataType?t._newDroppingColumnSetting[+i].dataType:n.DataType.Object;t._owner.columns[+i].align=t._newDroppingColumnSetting[+i].align;t._owner.columns[+i].format=t._newDroppingColumnSetting[+i].format}),t._isDraggingColumns&&!t._isCopyCells)if(t._dragRange.leftCol>t._dropRange.leftCol)for(e=t._dropRange.leftCol,u=t._dragRange.leftCol;u<=t._dragRange.rightCol;u++)t._owner._updateColumnFiler(u,e),e++;else for(e=t._dropRange.rightCol,u=t._dragRange.rightCol;u>=t._dragRange.leftCol;u--)t._owner._updateColumnFiler(u,e),e--}},i.prototype.saveNewState=function(){var t,n,i,r,u;if(!this._owner.selectedSheet)return!1;if(this._dropRange){for(this._newDroppingCells=[],this._newDroppingColumnSetting={},t=this._dropRange.topRow;t<=this._dropRange.bottomRow;t++)for(n=this._dropRange.leftCol;n<=this._dropRange.rightCol;n++)this._isDraggingColumns&&(this._newDroppingColumnSetting[n]||(this._newDroppingColumnSetting[n]={dataType:this._owner.columns[n].dataType,align:this._owner.columns[n].align,format:this._owner.columns[n].format})),i=t*this._owner.columns.length+n,u=this._owner.selectedSheet._styledCells[i]?JSON.parse(JSON.stringify(this._owner.selectedSheet._styledCells[i])):undefined,r=this._owner.getCellData(t,n,!1),this._newDroppingCells.push({rowIndex:t,columnIndex:n,cellContent:r,cellStyle:u});return!0}return!1},i}(i);t._MoveCellsAction=l})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(n){function t(t,i){n.call(this,t);this._owner=i;this.applyTemplate('',this.getTemplate(),{_insRows:'insert-rows',_delRows:'delete-rows',_insCols:'insert-columns',_delCols:'delete-columns'});this._init()}return __extends(t,n),t.prototype.show=function(n,t){var i=(t?t.x:n.clientX)+(n?window.pageXOffset:0),r=(t?t.y:n.clientY)+(n?window.pageYOffset:0);this.hostElement.style.position='absolute';this.hostElement.style.display='inline';r+this.hostElement.clientHeight>window.innerHeight&&(r-=this.hostElement.clientHeight);i+this.hostElement.clientWidth>window.innerWidth&&(i-=this.hostElement.clientWidth);this.hostElement.style.top=r+'px';this.hostElement.style.left=i+'px'},t.prototype.hide=function(){this.hostElement.style.display='none'},t.prototype._init=function(){var n=this;n.hostElement.style.zIndex='9999';document.querySelector('body').appendChild(n.hostElement);n.addEventListener(n.hostElement,'contextmenu',function(n){n.preventDefault()});n.addEventListener(n._insRows,'click',function(){n._owner.insertRows();n.hide();n._owner.hostElement.focus()});n.addEventListener(n._delRows,'click',function(){n._owner.deleteRows();n.hide();n._owner.hostElement.focus()});n.addEventListener(n._insCols,'click',function(){n._owner.insertColumns();n.hide();n._owner.hostElement.focus()});n.addEventListener(n._delCols,'click',function(){n._owner.deleteColumns();n.hide();n._owner.hostElement.focus()})},t.controlTemplate='<div class="wj-context-menu" width="150px"><div class="wj-context-menu-item" wj-part="insert-rows">Insert Row<\/div><div class="wj-context-menu-item" wj-part="delete-rows">Delete Rows<\/div><div class="wj-context-menu-item" wj-part="insert-columns">Insert Column<\/div><div class="wj-context-menu-item" wj-part="delete-columns">Delete Columns<\/div><\/div>',t}(n.Control);t._ContextMenu=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(n){function i(t,i){n.call(this,t);this._splitterMousedownHdl=this._splitterMousedownHandler.bind(this);this._owner=i;this.hostElement.attributes.tabindex&&this.hostElement.attributes.removeNamedItem('tabindex');this.applyTemplate('',this.getTemplate(),{_divSheet:'left',_divSplitter:'splitter',_divRight:'right'});this._init()}return __extends(i,n),Object.defineProperty(i.prototype,"sheetControl",{get:function(){return this._sheetControl},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"visible",{get:function(){return this.hostElement.style.display!=='none'},set:function(n){this.hostElement.style.display=n?'block':'none';this._divSheet.style.display=n?'block':'none'},enumerable:!0,configurable:!0}),i.prototype.getSheetBlanketSize=function(){return 20},i.prototype.adjustSize=function(){var t=this._owner.scrollSize.width-this._owner.clientSize.width,i=this._owner.scrollSize.height-this._owner.clientSize.height,n=this._divSplitter.parentElement;t<=0?(n.style.minWidth='100px',this._divSplitter.style.display='none',this._divRight.style.display='none',this._divSheet.style.width='100%',this._divSplitter.removeEventListener('mousedown',this._splitterMousedownHdl,!0)):(n.style.minWidth='300px',this._divSplitter.style.display='none',this._divRight.style.display='none',this._divSheet.style.width='100%',this._divSplitter.removeEventListener('mousedown',this._splitterMousedownHdl,!0),this._divSplitter.addEventListener('mousedown',this._splitterMousedownHdl,!0));this._sheetControl._adjustSize()},i.prototype._init=function(){var n=this;n._funSplitterMousedown=function(t){n._splitterMouseupHandler(t)};n._divSplitter.parentElement.style.height=n.getSheetBlanketSize()+'px';n._sheetControl=new t._SheetTabs(n._divSheet,this._owner)},i.prototype._splitterMousedownHandler=function(n){this._startPos=n.pageX;document.addEventListener('mousemove',this._splitterMousemoveHandler.bind(this),!0);document.addEventListener('mouseup',this._funSplitterMousedown,!0);n.preventDefault()},i.prototype._splitterMousemoveHandler=function(n){this._startPos!==null&&typeof this._startPos!='undefined'&&this._adjustDis(n.pageX-this._startPos)},i.prototype._splitterMouseupHandler=function(n){document.removeEventListener('mousemove',this._splitterMousemoveHandler,!0);document.removeEventListener('mouseup',this._funSplitterMousedown,!0);this._adjustDis(n.pageX-this._startPos);this._startPos=null},i.prototype._adjustDis=function(n){var t=this._divRight.offsetWidth-n,i=this._divSheet.offsetWidth+n;(t<=100?(t=100,n=this._divRight.offsetWidth-t,i=this._divSheet.offsetWidth+n):i<=100&&(i=100,n=i-this._divSheet.offsetWidth,t=this._divRight.offsetWidth-n),n!=0)&&(this._divRight.style.width=t+'px',this._divSheet.style.width=i+'px',this._startPos=this._startPos+n)},i.controlTemplate='<div><div wj-part="left" style ="float:left;height:100%;overflow:hidden"><\/div><div wj-part="splitter" style="float:left;height:100%;width:6px;background-color:#e9eaee;padding:2px;cursor:e-resize"><div style="background-color:#8a9eb2;height:100%"><\/div><\/div><div wj-part="right" style="float:left;height:100%;background-color:#e9eaee"><\/div><\/div>',i}(n.Control);t._TabHolder=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(i){'use strict';var r=function(r){function u(){r.apply(this,arguments)}return __extends(u,r),u.prototype.updateCell=function(u,f,e,o,s){var a=u.grid,k=f,d=e,rt,g,h,y,l,p,nt,c,tt,it,w,b,ut,ft,v,s,et;u.cellType===n.grid.CellType.Cell&&this._resetCellStyle(u.columns[e],o);r.prototype.updateCell.call(this,u,f,e,o,s);s&&!s.isSingleCell&&(f=s.row,e=s.col,k=s.row2,d=s.col2);w=a._getBindingColumn(u,f,u.columns[e]);switch(u.cellType){case n.grid.CellType.RowHeader:o.textContent=f+1+'';break;case n.grid.CellType.ColumnHeader:rt=i.FlexSheet.convertNumberToAlpha(e);o.innerHTML=o.innerHTML.replace(n.escapeHtml(o.textContent),'')+rt;o.style.textAlign='center';break;case n.grid.CellType.Cell:if(h=u.grid,g=f*h.columns.length+e,c=h.selectedSheet&&h.selectedSheet._styledCells?h.selectedSheet._styledCells[g]:null,u.rows[f]instanceof i.HeaderRow)o.innerHTML=n.escapeHtml(u.columns[e].header),n.addClass(o,'wj-header-row');else if(l=h.getCellValue(f,e,!1),p=h.getCellData(f,e,!1),nt=p!=null&&typeof p=='string'&&p[0]==='=',b=(c?c.format:null)||w.format,h.editRange&&h.editRange.contains(f,e)?!n.isNumber(l)||w.dataMap||nt||(b&&(l=this._getFormattedValue(l,b)),it=o.querySelector('input'),it&&(it.value=l)):u.rows[f]instanceof t.GroupRow||(u.columns[e].dataType===n.DataType.Boolean?(tt=o.querySelector('[type="checkbox"]'),tt&&(tt.checked=h.getCellValue(f,e))):w.dataMap?(l=h.getCellValue(f,e,!0),y=o.firstChild,y&&y.nodeType===3&&y.nodeValue!==l&&(y.nodeValue=l)):(l=!n.isNumber(l)||nt||b?h.getCellValue(f,e,!0):h.getCellData(f,e,!0),o.innerHTML=l)),c){ut=o.style;for(v in c)v==='className'?c.className&&n.addClass(o,c.className+'-style'):v!=='format'&&(ft=c[v])&&(ut[v]=(n.hasClass(o,'wj-state-selected')||n.hasClass(o,'wj-state-multi-selected'))&&(v==='color'||v==='backgroundColor')?'':ft)}if(a.itemFormatter&&a.itemFormatter(u,f,e,o),a.formatItem.hasHandlers){s=t.CellFactory._fmtRng;s?s.setRange(f,e,k,d):s=t.CellFactory._fmtRng=new t.CellRange(f,e,k,d);et=new t.FormatItemEventArgs(u,s,o);a.onFormatItem(et)}!o.style.backgroundColor&&!o.style.color||(c||(h.selectedSheet._styledCells[g]=c={}),!o.style.backgroundColor||(c.backgroundColor=o.style.backgroundColor),!o.style.color||(c.color=o.style.color))}u.cellType===t.CellType.Cell&&(f!==a._lastVisibleFrozenRow||n.hasClass(o,'wj-frozen-row')||n.addClass(o,'wj-frozen-row'),e!==a._lastVisibleFrozenColumn||n.hasClass(o,'wj-frozen-col')||n.addClass(o,'wj-frozen-col'))},u.prototype._resetCellStyle=function(n,t){['fontFamily','fontSize','fontStyle','fontWeight','textDecoration','textAlign','verticalAlign','backgroundColor','color'].forEach(function(i){i==='textAlign'?t.style.textAlign=n.getAlignment():t.style[i]=''})},u.prototype._getFormattedValue=function(t,i){return t!==Math.round(t)&&(i=i.replace(/([a-z])(\d*)(.*)/ig,'$0112$3')),n.Globalize.formatNumber(t,i,!0)},u}(t.CellFactory);i._FlexSheetCellFactory=r})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(i){'use strict';var e=[{name:'abs',description:'Returns the absolute value of a number.'},{name:'acos',description:'Returns the arccosine of a number.'},{name:'and',description:'Returns TRUE if all of its arguments are TRUE.'},{name:'asin',description:'Returns the arcsine of a number.'},{name:'atan',description:'Returns the arctangent of a number.'},{name:'atan2',description:'Returns the arctangent from x- and y-coordinates.'},{name:'average',description:'Returns the average of its arguments.'},{name:'ceiling',description:'Rounds a number to the nearest integer or to the nearest multiple of significance.'},{name:'char',description:'Returns the character specified by the code number.'},{name:'choose',description:'Chooses a value from a list of values.'},{name:'code',description:'Returns a numeric code for the first character in a text string.'},{name:'column',description:'Returns the column number of a reference.'},{name:'columns',description:'Returns the number of columns in a reference.'},{name:'concatenate',description:'Joins several text items into one text item.'},{name:'cos',description:'Returns the cosine of a number.'},{name:'count',description:'Counts how many numbers are in the list of arguments.'},{name:'counta',description:'Counts how many values are in the list of arguments.'},{name:'countblank',description:'Counts the number of blank cells within a range.'},{name:'countif',description:'Counts the number of cells within a range that meet the given criteria.'},{name:'countifs',description:'Counts the number of cells within a range that meet multiple criteria.'},{name:'date',description:'Returns the serial number of a particular date.'},{name:'datedif',description:'Calculates the number of days, months, or years between two dates.'},{name:'day',description:'Converts a serial number to a day of the month.'},{name:'dcount',description:'Counts the cells that contain numbers in a database.'},{name:'exp',description:'Returns e raised to the power of a given number.'},{name:'false',description:'Returns the logical value FALSE.'},{name:'find',description:'Finds one text value within another (case-sensitive).'},{name:'floor',description:'Rounds a number down, toward zero.'},{name:'hlookup',description:'Looks in the top row of an array and returns the value of the indicated cell.'},{name:'hour',description:'Converts a serial number to an hour.'},{name:'if',description:'Specifies a logical test to perform.'},{name:'index',description:'Uses an index to choose a value from a reference.'},{name:'left',description:'Returns the leftmost characters from a text value.'},{name:'len',description:'Returns the number of characters in a text string.'},{name:'ln',description:'Returns the natural logarithm of a number.'},{name:'lower',description:'Converts text to lowercase.'},{name:'max',description:'Returns the maximum value in a list of arguments.'},{name:'mid',description:'Returns a specific number of characters from a text string starting at the position you specify.'},{name:'min',description:'Returns the minimum value in a list of arguments.'},{name:'mod',description:'Returns the remainder from division.'},{name:'month',description:'Converts a serial number to a month.'},{name:'not',description:'Reverses the logic of its argument.'},{name:'now',description:'Returns the serial number of the current date and time.'},{name:'or',description:'Returns TRUE if any argument is TRUE.'},{name:'pi',description:'Returns the value of pi.'},{name:'power',description:'Returns the result of a number raised to a power.'},{name:'product',description:'Multiplies its arguments.'},{name:'proper',description:'Capitalizes the first letter in each word of a text value.'},{name:'rand',description:'Returns a random number between 0 and 1.'},{name:'rank',description:'Returns the rank of a number in a list of numbers.'},{name:'rate',description:'Returns the interest rate per period of an annuity.'},{name:'replace',description:'Replaces characters within text.'},{name:'rept',description:'Repeats text a given number of times.'},{name:'right',description:'Returns the rightmost characters from a text value.'},{name:'round',description:'Rounds a number to a specified number of digits.'},{name:'rounddown',description:'Rounds a number down, toward zero.'},{name:'roundup',description:'Rounds a number up, away from zero.'},{name:'row',description:'Returns the row number of a reference.'},{name:'rows',description:'Returns the number of rows in a reference.'},{name:'search',description:'Finds one text value within another (not case-sensitive).'},{name:'sin',description:'Returns the sine of the given angle.'},{name:'sqrt',description:'Returns a positive square root.'},{name:'stdev',description:'Estimates standard deviation based on a sample.'},{name:'stdevp',description:'Calculates standard deviation based on the entire population.'},{name:'substitute',description:'Substitutes new text for old text in a text string.'},{name:'subtotal',description:'Returns a subtotal in a list or database.'},{name:'sum',description:'Adds its arguments.'},{name:'sumif',description:'Adds the cells specified by a given criteria.'},{name:'sumifs',description:'Adds the cells in a range that meet multiple criteria.'},{name:'tan',description:'Returns the tangent of a number.'},{name:'text',description:'Formats a number and converts it to text.'},{name:'time',description:'Returns the serial number of a particular time.'},{name:'today',description:'Returns the serial number of today\'s date.'},{name:'trim',description:'Removes spaces from text.'},{name:'true',description:'Returns the logical value TRUE.'},{name:'trunc',description:'Truncates a number to an integer.'},{name:'upper',description:'Converts text to uppercase.'},{name:'value',description:'Converts a text argument to a number.'},{name:'var',description:'Estimates variance based on a sample.'},{name:'varp',description:'Calculates variance based on the entire population.'},{name:'year',description:'Converts a serial number to a year.'},],s=function(o){function s(r,u){o.call(this,r,u);this._selectedSheetIndex=-1;this._columnHeaderClicked=!1;this._addingSheet=!1;this._mouseMoveHdl=this._mouseMove.bind(this);this._clickHdl=this._click.bind(this);this._touchStartHdl=this._touchStart.bind(this);this._touchEndHdl=this._touchEnd.bind(this);this._isClicking=!1;this.selectedSheetChanged=new n.Event;this.draggingRowColumn=new n.Event;this.droppingRowColumn=new n.Event;this.loaded=new n.Event;this.unknownFunction=new n.Event;this.sheetCleared=new n.Event;this._eCt.style.backgroundColor='white';n.addClass(this.hostElement,'wj-flexsheet');n.setCss(this.hostElement,{fontFamily:'Arial'});this._cf=new i._FlexSheetCellFactory;this._init();this.showSort=!1;this.allowSorting=!1;this.showGroups=!1;this.showMarquee=!0;this.showSelectedHeaders=t.HeadersVisibility.All;this.allowResizing=t.AllowResizing.Both;this.allowDragging=t.AllowDragging.None}return __extends(s,o),Object.defineProperty(s.prototype,"sheets",{get:function(){return this._sheets||(this._sheets=new i.SheetCollection,this._sheets.selectedSheetChanged.addHandler(this._selectedSheetChange,this),this._sheets.collectionChanged.addHandler(this._sourceChange,this),this._sheets.sheetVisibleChanged.addHandler(this._sheetVisibleChange,this),this._sheets.sheetCleared.addHandler(this.onSheetCleared,this)),this._sheets},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"selectedSheetIndex",{get:function(){return this._selectedSheetIndex},set:function(n){n!==this._selectedSheetIndex&&(this._showSheet(n),this._sheets.selectedIndex=n)},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"selectedSheet",{get:function(){return this._sheets[this._selectedSheetIndex]},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"isFunctionListOpen",{get:function(){return this._functionListHost&&this._functionListHost.style.display!=='none'},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"isTabHolderVisible",{get:function(){return this._tabHolder.visible},set:function(n){n!==this._tabHolder.visible&&(this._divContainer.style.height=n?this._divContainer.parentElement.clientHeight-this._tabHolder.getSheetBlanketSize()+'px':this._divContainer.parentElement.clientHeight+'px',this._tabHolder.visible=n)},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"undoStack",{get:function(){return this._undoStack},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"sortManager",{get:function(){return this._sortManager},enumerable:!0,configurable:!0}),Object.defineProperty(s.prototype,"showFilterIcons",{get:function(){return!this._filter?!1:this._filter.showFilterIcons},set:function(n){!this._filter||this._filter.showFilterIcons===n||(this._filter.showFilterIcons=n)},enumerable:!0,configurable:!0}),s.prototype.onSelectedSheetChanged=function(n){this._sortManager._refresh();this.selectedSheetChanged.raise(this,n)},s.prototype.onDraggingRowColumn=function(n){this.draggingRowColumn.raise(this,n)},s.prototype.onDroppingRowColumn=function(){this.droppingRowColumn.raise(this,new n.EventArgs)},s.prototype.onLoaded=function(){var t=this;t._toRefresh&&(clearTimeout(t._toRefresh),t._toRefresh=null);t._toRefresh=setTimeout(function(){t._setFlexSheetToDirty();t.invalidate()},10);t.loaded.raise(this,new n.EventArgs)},s.prototype.onUnknownFunction=function(n){this.unknownFunction.raise(this,n)},s.prototype.onSheetCleared=function(){this.sheetCleared.raise(this,new n.EventArgs)},s.prototype.refresh=function(n){var t,i;if(n===void 0&&(n=!0),this._divContainer.style.height=this._divContainer.parentElement.clientHeight-(this.isTabHolderVisible?this._tabHolder.getSheetBlanketSize():0)+'px',this.preserveSelectedState||!this.selectedSheet||(this.selectedSheet.selectionRanges.clear(),this.selectedSheet.selectionRanges.push(this.selection)),n&&this._calcEngine._clearExpressionCache(),this._lastVisibleFrozenRow=-1,this.frozenRows>0)for(t=this.frozenRows-1;t>=0;t--)if(this.rows[t]&&this.rows[t].isVisible){this._lastVisibleFrozenRow=t;break}if(this._lastVisibleFrozenColumn=-1,this.frozenColumns>0)for(i=this.frozenColumns-1;i>=0;i--)if(this.columns[i]&&this.columns[i].isVisible){this._lastVisibleFrozenColumn=i;break}o.prototype.refresh.call(this,n);this._tabHolder.adjustSize()},s.prototype.setCellData=function(t,i,r,u){u===void 0&&(u=!1);var f=n.isString(r)&&r.length>1&&r[0]==='=';return this._calcEngine._clearExpressionCache(),this.cells.setCellData(t,i,r,u&&!f)},s.prototype.containsFocus=function(){return this.isFunctionListOpen||o.prototype.containsFocus.call(this)},s.prototype.addUnboundSheet=function(n,t,i,r,u){var f=this._addSheet(n,t,i,r,u);return f.selectionRanges.length===0&&f.selectionRanges.push(this.selection),f},s.prototype.addBoundSheet=function(n,t,i,r){var u=this._addSheet(n,0,0,i,r);return t&&(u.itemsSource=t),u.selectionRanges.length===0&&u.selectionRanges.push(this.selection),u},s.prototype.applyCellsStyle=function(n,t,r){r===void 0&&(r=!1);var f,e,s=t||[this.selection],u,o,h;if(this.selectedSheet){if(!n&&this._cloneStyle){this.selectedSheet._styledCells=JSON.parse(JSON.stringify(this._cloneStyle));this._cloneStyle=null;this.refresh(!1);return}if(s){for(t||r?r&&!this._cloneStyle&&(this._cloneStyle=JSON.parse(JSON.stringify(this.selectedSheet._styledCells))):(h=new i._CellStyleAction(this,this._cloneStyle),this._cloneStyle=null),o=0;o<s.length;o++)for(u=s[o],f=u.topRow;f<=u.bottomRow;f++)for(e=u.leftCol;e<=u.rightCol;e++)this._applyStyleForCell(f,e,n);t||r||(h.saveNewState(),this._undoStack._addAction(h))}t||this.refresh(!1)}},s.prototype.freezeAtCursor=function(){var n=this,i,t,f,e,u,o;if(n.selectedSheet){if(n.selection&&n.frozenRows===0&&n.frozenColumns===0){if(n._ptScrl.y<0)for(i=0;i<n.selection.topRow-1;i++)if(u=n.rows[i],!(u instanceof r))if(u._pos+n._ptScrl.y<0)u.visible=!1;else{n.selectedSheet._freezeHiddenRowCnt=i;break}if(n._ptScrl.x<0)for(t=0;t<n.selection.leftCol-1;t++)if(o=n.columns[t],o._pos+n._ptScrl.x<0)n.columns[t].visible=!1;else{n.selectedSheet._freezeHiddenColumnCnt=t;break}f=n.selection.leftCol>0?n.selection.leftCol:0;e=n.selection.topRow>0?n.selection.topRow:0}else{for(i=0;i<n.frozenRows-1;i++)n.rows[i].visible=!0;for(t=0;t<n.frozenColumns-1;t++)n.columns[t].visible=!0;n._filter.apply();f=0;e=0;n.selectedSheet._freezeHiddenRowCnt=0;n.selectedSheet._freezeHiddenColumnCnt=0}n.frozenRows=n.selectedSheet.grid.frozenRows=e;n.frozenColumns=n.selectedSheet.grid.frozenColumns=f;setTimeout(function(){n._setFlexSheetToDirty();n.invalidate();n.scrollIntoView(n.selection.topRow,n.selection.leftCol)},10)}},s.prototype.showColumnFilter=function(){var n=this.selection.col>0?this.selection.col:0;this.columns.length>0&&this._filter.editColumnFilter(this.columns[n])},s.prototype.clear=function(){this.selection=new t.CellRange;this.sheets.clear();this._selectedSheetIndex=-1;this.columns.clear();this.rows.clear();this.columnHeaders.columns.clear();this.rowHeaders.rows.clear();this._undoStack.clear();this._ptScrl=new n.Point;this._clearCalcEngine();this.addUnboundSheet()},s.prototype.getSelectionFormatState=function(){var n,t,r=this.rows.length,u=this.columns.length,i={isBold:!1,isItalic:!1,isUnderline:!1,textAlign:'left',isMergedCell:!1};if(r===0||u===0)return i;if(this.selection){if(this.selection.row>=r||this.selection.row2>=r||this.selection.col>=u||this.selection.col2>=u)return i;for(n=this.selection.topRow;n<=this.selection.bottomRow;n++)for(t=this.selection.leftCol;t<=this.selection.rightCol;t++)this._checkCellFormat(n,t,i)}return i},s.prototype.insertRows=function(u,f){var e=n.isNumber(u)&&u>=0?u:this.selection&&this.selection.topRow>-1?this.selection.topRow:0,o=n.isNumber(f)?f:1,s=new i._RowsChangedAction(this),c=this.rows[e],h;if(this.selectedSheet&&!this.itemsSource){for(this._clearCalcEngine(),this.finishEditing(),e===0&&c&&c.constructor===r&&(e=1),this._updateCellsForUpdatingRow(this.rows.length,e,o),s._affecedFormulas=this._updateAffectedFormula(e,o,!0,!0),this.rows.beginUpdate(),h=0;h<o;h++)this.rows.insert(e,new t.Row);this.rows.endUpdate();this.selection&&this.selection.row!==-1&&this.selection.col!==-1||(this.selection=new t.CellRange(0,0));this._copyTo(this.selectedSheet);s.saveNewState();this._undoStack._addAction(s)}},s.prototype.deleteRows=function(u,f){var l=n.isNumber(f)&&f>=0?f:this.selection&&this.selection.topRow>-1?this.selection.bottomRow-this.selection.topRow+1:1,o=n.isNumber(u)&&u>=0?u:this.selection&&this.selection.topRow>-1?this.selection.topRow:-1,e=n.isNumber(u)&&u>=0?u+l-1:this.selection&&this.selection.topRow>-1?this.selection.bottomRow:-1,h=new i._RowsChangedAction(this),a=!1,s,v,c;if(this.selectedSheet&&!this.itemsSource&&(this._clearCalcEngine(),this.finishEditing(),o>-1&&e>-1)){for(this._updateCellsForUpdatingRow(this.rows.length,o,l,!0),h._affecedFormulas=this._updateAffectedFormula(e,e-o+1,!1,!0),this.rows.beginUpdate();e>=o;e--)(s=this.rows[e],s&&s.constructor===r)||(s.dataItem&&this.collectionView?(this.collectionView.beginUpdate(),v=this._getCvIndex(e),v>-1&&this.itemsSource.splice(e-1,1),this.collectionView.endUpdate()):this.rows.removeAt(e),a=!0);this.rows.endUpdate();c=this.rows.length;c===0?(this.selectedSheet.selectionRanges.clear(),this.select(new t.CellRange),this.hostElement.style.cursor==='move'&&(this.hostElement.style.cursor='default')):e===c-1?this.select(new t.CellRange(e,0,e,this.columns.length-1)):this.select(new t.CellRange(this.selection.topRow,this.selection.col,this.selection.topRow,this.selection.col2));this._copyTo(this.selectedSheet);a&&(h.saveNewState(),this._undoStack._addAction(h))}},s.prototype.insertColumns=function(r,u){var f=n.isNumber(r)&&r>=0?r:this.selection&&this.selection.leftCol>-1?this.selection.leftCol:0,e=n.isNumber(u)?u:1,o=new i._ColumnsChangedAction(this),s;if(this.selectedSheet&&!this.itemsSource){for(this._clearCalcEngine(),this.finishEditing(),this._updateCellsForUpdatingColumn(this.columns.length,f,e),o._affectedFormulas=this._updateAffectedFormula(f,e,!0,!1),this.columns.beginUpdate(),s=0;s<e;s++)this.columns.insert(f,new t.Column);this.columns.endUpdate();this.selection&&this.selection.row!==-1&&this.selection.col!==-1||(this.selection=new t.CellRange(0,0));this._copyTo(this.selectedSheet);o.saveNewState();this._undoStack._addAction(o)}},s.prototype.deleteColumns=function(r,u){var o,h=n.isNumber(u)&&u>=0?u:this.selection&&this.selection.leftCol>-1?this.selection.rightCol-this.selection.leftCol+1:1,e=n.isNumber(r)&&r>=0?r:this.selection&&this.selection.leftCol>-1?this.selection.leftCol:-1,f=n.isNumber(r)&&r>=0?r+h-1:this.selection&&this.selection.leftCol>-1?this.selection.rightCol:-1,s=new i._ColumnsChangedAction(this);if(this.selectedSheet&&!this.itemsSource&&(this._clearCalcEngine(),this.finishEditing(),e>-1&&f>-1)){for(this._updateCellsForUpdatingColumn(this.columns.length,e,h,!0),s._affectedFormulas=this._updateAffectedFormula(f,f-e+1,!1,!1),this.columns.beginUpdate();f>=e;f--)this.columns.removeAt(f),this._sortManager.deleteSortLevel(f);this.columns.endUpdate();this._sortManager.commitSort(!1);o=this.columns.length;o===0?(this.selectedSheet.selectionRanges.clear(),this.select(new t.CellRange),this.hostElement.style.cursor==='move'&&(this.hostElement.style.cursor='default')):f===o-1?this.select(new t.CellRange(0,f,this.rows.length-1,f)):this.select(new t.CellRange(this.selection.row,this.selection.leftCol,this.selection.row2,this.selection.leftCol));this._copyTo(this.selectedSheet);s.saveNewState();this._undoStack._addAction(s)}},s.prototype.mergeRange=function(n,r){r===void 0&&(r=!1);var f,e,s,u=n||this.selection,o;if(this.selectedSheet){if(u){if(u.rowSpan===1&&u.columnSpan===1)return;if(n||r||(o=new i._CellMergeAction(this),this.hostElement.focus()),!this._resetMergedRange(u))for(f=u.topRow;f<=u.bottomRow;f++)for(e=u.leftCol;e<=u.rightCol;e++)s=f*this.columns.length+e,this.selectedSheet._mergedRanges[s]=new t.CellRange(u.topRow,u.leftCol,u.bottomRow,u.rightCol);n||r||(o.saveNewState(),this._undoStack._addAction(o))}n||this.refresh()}},s.prototype.getMergedRange=function(n,i,r,u){u===void 0&&(u=!0);var l=i*this.columns.length+r,f=this.selectedSheet?this.selectedSheet._mergedRanges[l]:null,h,e,c,s;return n===this.cells&&f?!f.isSingleCell&&(this.frozenRows>0||this.frozenColumns>0)&&(f.topRow<this.frozenRows&&f.bottomRow>=this.frozenRows||f.leftCol<this.frozenColumns&&f.rightCol>=this.frozenColumns)?(h=f.topRow,e=f.bottomRow,c=f.leftCol,s=f.rightCol,i>=this.frozenRows&&f.topRow<this.frozenRows&&(h=this.frozenRows),i<this.frozenRows&&f.bottomRow>=this.frozenRows&&(e=this.frozenRows-1),e>=this.rows.length&&(e=this.rows.length-1),r>=this.frozenColumns&&f.leftCol<this.frozenColumns&&(c=this.frozenColumns),r<this.frozenColumns&&f.rightCol>=this.frozenColumns&&(s=this.frozenColumns-1),s>=this.columns.length&&(s=this.columns.length-1),new t.CellRange(h,c,e,s)):f.bottomRow>=this.rows.length?new t.CellRange(f.topRow,f.leftCol,this.rows.length-1,f.rightCol):f.rightCol>=this.columns.length?new t.CellRange(f.topRow,f.leftCol,f.bottomRow,this.columns.length-1):f.clone():r>=0&&this.columns&&this.columns.length>r&&i>=0&&this.rows&&this.rows.length>r?o.prototype.getMergedRange.call(this,n,i,r,u):null},s.prototype.evaluate=function(n,t,i){return this._evaluate(n,t,i)},s.prototype.getCellValue=function(t,i,r,u){r===void 0&&(r=!1);var e=this.columns[i],h=t*this.columns.length+i,o,s,f;return o=u?u._styledCells[h]:this.selectedSheet?this.selectedSheet._styledCells[h]:null,s=o&&o.format?o.format:'',f=u?u.grid.getCellData(t,i,!1):this.getCellData(t,i,!1),n.isString(f)&&f[0]==='='&&(f=this._evaluate(f,r?s:'',u,t,i)),n.isPrimitive(f)?r&&(e.dataMap&&(f=e.dataMap.getDisplayValue(f)),f=f!=null?n.Globalize.format(f,s||e.format):''):f&&(f=r?n.Globalize.format(f.value,s||f.format||e.format):f.value),f==null?'':f},s.prototype.showFunctionList=function(t){var i=this,e=i._cumulativeOffset(t),f=i._cumulativeOffset(i._root),r,u;i._functionTarget=n.tryCast(t,HTMLInputElement);i._functionTarget&&i._functionTarget.value&&i._functionTarget.value[0]==='='?(i._functionList._cv.filter=function(n){var u=n.actualvalue.toLowerCase(),t=i._getCurrentFormulaIndex(i._functionTarget.value),r;return(t===-1&&(t=0),r=i._functionTarget.value.substr(t+1).trim().toLowerCase(),r.length>0&&u.indexOf(r)===0||i._functionTarget.value==='=')?!0:!1},i._functionList.selectedIndex=0,r=e.y+t.clientHeight+2+(n.hasClass(t,'wj-grid-editor')?this._ptScrl.y:0),u=e.x+(n.hasClass(t,'wj-grid-editor')?this._ptScrl.x:0),n.setCss(i._functionListHost,{height:i._functionList._cv.items.length>5?'218px':'auto',display:i._functionList._cv.items.length>0?'block':'none',top:'',left:''}),i._functionListHost.scrollTop=0,i._functionListHost.offsetHeight+r>f.y+i._root.offsetHeight?r=r-t.clientHeight-i._functionListHost.offsetHeight-5:r+=5,i._functionListHost.offsetWidth+u>f.x+i._root.offsetWidth&&(u=f.x+i._root.offsetWidth-i._functionListHost.offsetWidth),n.setCss(i._functionListHost,{top:r,left:u})):i.hideFunctionList()},s.prototype.hideFunctionList=function(){this._functionListHost.style.display='none'},s.prototype.selectPreviousFunction=function(){var n=this._functionList.selectedIndex;n>0&&this._functionList.selectedIndex--},s.prototype.selectNextFunction=function(){var n=this._functionList.selectedIndex;n<this._functionList.itemsSource.length&&this._functionList.selectedIndex++},s.prototype.applyFunctionToCell=function(){var n=this,t;n._functionTarget&&(t=n._getCurrentFormulaIndex(n._functionTarget.value),t===-1?t=n._functionTarget.value.indexOf('='):t+=1,n._functionTarget.value=n._functionTarget.value.substring(0,t)+n._functionList.selectedValue+'(',n._functionTarget.value[0]!=='='&&(n._functionTarget.value='='+n._functionTarget.value),n._functionTarget.focus(),n.hideFunctionList())},s.prototype.save=function(n){var t=this._saveToWorkbook();return n&&t.save(n),t},s.prototype.saveToWorkbookOM=function(){var n=this._saveToWorkbook();return n._serialize()},s.prototype.load=function(t){var i,r,u=this;if(t instanceof Blob)r=new FileReader,r.onload=function(){var t=r.result;t=n.xlsx.Workbook._base64EncArr(new Uint8Array(t));i=new n.xlsx.Workbook;i.load(t);u._loadFromWorkbook(i)},r.readAsArrayBuffer(t);else if(t instanceof n.xlsx.Workbook)u._loadFromWorkbook(t);else{if(t instanceof ArrayBuffer)t=n.xlsx.Workbook._base64EncArr(new Uint8Array(t));else if(!n.isString(t))throw'Invalid workbook.';i=new n.xlsx.Workbook;i.load(t);u._loadFromWorkbook(i)}},s.prototype.loadFromWorkbookOM=function(t){var i;t instanceof n.xlsx.Workbook?i=t:(i=new n.xlsx.Workbook,i._deserialize(t));this._loadFromWorkbook(i)},s.prototype.undo=function(){var n=this;setTimeout(function(){n._undoStack.undo()},100)},s.prototype.redo=function(){var n=this;setTimeout(function(){n._undoStack.redo()},100)},s.prototype.select=function(n,t){t===void 0&&(t=!0);var i,r,u;if(n.rowSpan!==this.rows.length&&n.columnSpan!==this.columns.length)for(r=n.topRow;r<=n.bottomRow;r++)for(u=n.leftCol;u<=n.rightCol;u++)i=this.getMergedRange(this.cells,r,u),i&&!n.equals(i)&&(n.row<=n.row2?(n.row=Math.min(n.topRow,i.topRow),n.row2=Math.max(n.bottomRow,i.bottomRow)):(n.row=Math.max(n.bottomRow,i.bottomRow),n.row2=Math.min(n.topRow,i.topRow)),n.col<=n.col2?(n.col=Math.min(n.leftCol,i.leftCol),n.col2=Math.max(n.rightCol,i.rightCol)):(n.col=Math.max(n.rightCol,i.rightCol),n.col2=Math.min(n.leftCol,i.leftCol)));this.collectionView&&n.topRow===0&&n.bottomRow===this.rows.length-1&&n.leftCol===0&&n.rightCol===this.columns.length-1&&(n.row=1,n.row2=this.rows.length-1);o.prototype.select.call(this,n,t)},s.prototype.addCustomFunction=function(n,t,i,r,u){this._calcEngine.addCustomFunction(n,t,r,u);this._addCustomFunctionDescription(n,i)},s.prototype.dispose=function(){var n=window.navigator.userAgent;document.removeEventListener('mousemove',this._mouseMoveHdl);document.body.removeEventListener('click',this._clickHdl);(n.match(/iPad/i)||n.match(/iPhone/i))&&(document.body.removeEventListener('touchstart',this._touchStartHdl),document.body.removeEventListener('touchend',this._touchEndHdl));this.hideFunctionList();o.prototype.dispose.call(this)},s.prototype.getClipString=function(n){var t=o.prototype.getClipString.call(this,n),i,u,r,e,s,f;if(!n)if(this._isMultipleRowsSelected())for(t='',i=this.selectedSheet.selectionRanges.slice(0),i.sort(this._sortByRow),r=0;r<i.length;r++)t&&(t+='\n'),t+=this.getClipString(i[r]);else if(this._isMultipleColumnsSelected())for(t='',i=this.selectedSheet.selectionRanges.slice(0),i.sort(this._sortByColumn),u=0,e=!0;u<this.rows.length;u++)for(e||(t+='\n'),e=!1,r=0,s=!0;r<i.length;r++)f=i[r].clone(),f.row=f.row2=u,s||(t+='\t'),s=!1,t+=this.getClipString(f);return t},s.prototype.setClipString=function(i,r){var et=r==null,ut=!1,h,u,l,a,f,c,v,y,g,nt,e,p,w,k,d,s,ft,tt,it,rt,b;if(!this._copiedRange){o.prototype.setClipString.call(this,i,r);return}for(r=r?n.asType(r,t.CellRange):this.selection,i=n.asString(i).replace(/\r\n/g,'\n').replace(/\r/g,'\n'),i&&i[i.length-1]=='\n'&&(i=i.substring(0,i.length-1)),et&&!r.isSingleCell&&(i=this._expandClipString(i,r)),h=new t.CellRange(r.topRow,r.leftCol),this.beginUpdate(),u=r.topRow,l=this._copiedRange.topRow,tt=u-l,g=i.split('\n'),w=0;w<g.length&&u<this.rows.length;w++,u++){if(!this.rows[u].isVisible){w--;continue}for(nt=g[w].split('\t'),a=this._copiedRange.leftCol,f=r.leftCol,it=f-a,b=0;b<nt.length&&f<this.columns.length;b++,f++){if(!this.columns[f].isVisible){b--;continue}if(!this.columns[f].isReadOnly&&!this.rows[u].isReadOnly){if(e=nt[b],!!e&&typeof e=='string'&&e[0]==='='&&(tt!==0||it!==0)&&(p=e.match(/(?=\b\D)\$?[A-Za-z]+\$?\d+/g),!!p&&p.length>0))for(k=0;k<p.length;k++)d=p[k],d.toLowerCase()!=='atan2'&&(s=n.xlsx.Workbook.tableAddress(d),s.row+=tt,s.col+=it,ft=n.xlsx.Workbook.xlsxAddress(s.row,s.col,s.absRow,s.absCol),e=e.replace(d,ft));if(c=this.getMergedRange(this.cells,l,a),!c||c.topRow!==l||c.leftCol!==a||(v=u+c.rowSpan-1,v=v<this.rows.length?v:this.rows.length-1,y=f+c.columnSpan-1,y=y<this.columns.length?y:this.columns.length-1,this.mergeRange(new t.CellRange(u,f,v,y),!0)),rt=new t.CellRangeEventArgs(this.cells,new t.CellRange(u,f),e),this.onPastingCell(rt)&&this.cells.setCellData(u,f,e)){this.onPastedCell(rt);ut=!0}h.row2=Math.max(h.row2,u);h.col2=Math.max(h.col2,f)}a++}l++}this.endUpdate();this.collectionView&&ut&&this.collectionView.refresh();this.select(h)},s.prototype._getCvIndex=function(n){var t;return n>-1&&this.collectionView?(t=this.rows[n],t instanceof r)?n:t.dataItem?o.prototype._getCvIndex.call(this,n):this.collectionView.currentPosition:-1},s.prototype._init=function(){var e=this,f=this,o=window.navigator.userAgent,s=function(n){document.removeEventListener('mouseup',s);f._mouseUp(n)};f._divContainer=f.hostElement.querySelector('[wj-part="container"]');f._tabHolder=new i._TabHolder(f.hostElement.querySelector('[wj-part="tab-holder"]'),f);f._contextMenu=new i._ContextMenu(f.hostElement.querySelector('[wj-part="context-menu"]'),f);f._gpCells=new u(f,t.CellType.Cell,f.rows,f.columns,f._eCt);f._gpCHdr=new u(f,t.CellType.ColumnHeader,f._hdrRows,f.columns,f._eCHdrCt);f._gpRHdr=new u(f,t.CellType.RowHeader,f.rows,f._hdrCols,f._eRHdrCt);f._gpTL=new u(f,t.CellType.TopLeft,f._hdrRows,f._hdrCols,f._eTLCt);f._sortManager=new i.SortManager(f);f._filter=new i._FlexSheetFilter(f);f._filter.filterApplied.addHandler(function(){f._wholeColumnsSelected&&(f.selection=new t.CellRange(f.selection.topRow,f.selection.col,f.rows.length-1,f.selection.col2))});f._calcEngine=new i._CalcEngine(f);f._calcEngine.unknownFunction.addHandler(function(n,t){f.onUnknownFunction(t)},f);f._initFuncsList();f._undoStack=new i.UndoStack(f);f.loadedRows.addHandler(function(){!f.itemsSource||f.rows[0]instanceof r||f.rows.insert(0,new r);f._filter&&f._filter.apply()});f.itemsSourceChanged.addHandler(function(){for(var n=0;n<f.columns.length;n++)f.columns[n].isRequired=!1});f.copied.addHandler(function(n,t){var i;f._isMultipleRowsSelected()?(i=f.selectedSheet.selectionRanges.slice(0),i.sort(f._sortByRow),f._copiedRange=i[0]):f._isMultipleColumnsSelected()?(i=f.selectedSheet.selectionRanges.slice(0),i.sort(f._sortByColumn),f._copiedRange=i[0]):f._copiedRange=t.range});f.rows.collectionChanged.addHandler(function(){f._clearForEmptySheet('rows')},f);f.columns.collectionChanged.addHandler(function(){f._clearForEmptySheet('columns')},f);f.addEventListener(f.hostElement,'mousedown',function(n){document.addEventListener('mouseup',s);f._isDescendant(f._divContainer,n.target)&&f._mouseDown(n)},!0);f.addEventListener(f.hostElement,'drop',function(){f._columnHeaderClicked=!1});f.addEventListener(f.hostElement,'contextmenu',function(i){var r,o,s,h,c,l,u;i.defaultPrevented||f._edtHdl.activeEditor||(i.pageX===0&&i.pageY===0&&f.selection.row>-1&&f.selection.col>-1&&f.rows.length>0&&f.columns.length>0?(s=f.columns[f.selection.col],o=f.rows[f.selection.row],h=s.pos+f.hostElement.offsetLeft+e._ptScrl.x,c=o.pos+f.hostElement.offsetTop+e._ptScrl.y,l=new n.Point(h+s.renderSize,c+o.renderSize),r=f.hitTest(h,c)):r=f.hitTest(i),i.preventDefault(),r&&r.cellType!==t.CellType.None&&(e.itemsSource||f._contextMenu.show(i,l),u=new t.CellRange(r.row,r.col),r.cellType!==t.CellType.Cell||u.intersects(f.selection)||(f.selectedSheet&&f.selectedSheet.selectionRanges.clear(),f.selection=u,f.selectedSheet.selectionRanges.push(u))))});f.prepareCellForEdit.addHandler(f._prepareCellForEditHandler,f);f.cellEditEnded.addHandler(function(){setTimeout(function(){f.hideFunctionList()},200)});f.cellEditEnding.addHandler(function(){f._clearCalcEngine()});f.pasted.addHandler(function(){f._clearCalcEngine()});f.addEventListener(f.hostElement,'keydown',function(r){var u,e,o;if(r.ctrlKey&&(r.keyCode===89&&(f.finishEditing(),f.redo(),r.preventDefault()),r.keyCode===90&&(f.finishEditing(),f.undo(),r.preventDefault()),!f.selectedSheet||r.keyCode!==65||(f.selectedSheet.selectionRanges.clear(),f.selectedSheet.selectionRanges.push(f.selection)),r.keyCode===88)){if(f.finishEditing(),e=new t.CellRangeEventArgs(f.cells,f.selection),f.onCopying(e)){o=f.getClipString();n.Clipboard.copy(o);f.deferUpdate(function(){for(var r,u,e=!1,o=new i._EditAction(f),t=f.selection.topRow;t<=f.selection.bottomRow;t++)for(r=f.selection.leftCol;r<=f.selection.rightCol;r++)u=f._getBindingColumn(f.cells,t,f.columns[r]),(u.isRequired==!1||u.isRequired==null&&u.dataType==n.DataType.String)&&f.getCellData(t,r,!0)&&(f.setCellData(t,r,'',!0),e=!0);e&&(o.saveNewState(),f._undoStack._addAction(o))});f.onCopied(e)}r.stopPropagation();return}if(r.keyCode===n.Key.Escape&&(f._contextMenu.hide(),r.preventDefault()),f._edtHdl.activeEditor||(r.keyCode===n.Key.Delete||r.keyCode===n.Key.Back)&&(f._delSeletionContent(),r.preventDefault()),!!f.selectedSheet)switch(r.keyCode){case n.Key.Left:case n.Key.Right:case n.Key.Up:case n.Key.Down:case n.Key.PageUp:case n.Key.PageDown:case n.Key.Home:case n.Key.End:case n.Key.Tab:case n.Key.Enter:u=f.selectedSheet.selectionRanges.length;u>0&&(f.selectedSheet.selectionRanges[u-1]=f.selection)}});document.body.addEventListener('click',f._clickHdl);document.addEventListener('mousemove',f._mouseMoveHdl);(o.match(/iPad/i)||o.match(/iPhone/i))&&(document.body.addEventListener('touchstart',f._touchStartHdl),document.body.addEventListener('touchend',f._touchEndHdl));f.addEventListener(f.hostElement,'drop',function(){f._htDown=null})},s.prototype._initFuncsList=function(){var t=this;t._functionListHost=document.createElement('div');n.addClass(t._functionListHost,'wj-flexsheet-formula-list');document.querySelector('body').appendChild(t._functionListHost);t._functionListHost.style.display='none';t._functionListHost.style.position='absolute';t._functionList=new n.input.ListBox(t._functionListHost);t._functionList.isContentHtml=!0;t._functionList.itemsSource=t._getFunctions();t._functionList.displayMemberPath='displayValue';t._functionList.selectedValuePath='actualvalue';t.addEventListener(t._functionListHost,'click',t.applyFunctionToCell.bind(t));t.addEventListener(t._functionListHost,'keydown',function(i){i.keyCode===n.Key.Escape&&(t.hideFunctionList(),t.hostElement.focus(),i.preventDefault());i.keyCode===n.Key.Enter&&(t.applyFunctionToCell(),t.hostElement.focus(),i.preventDefault())})},s.prototype._getFunctions=function(){for(var i=[],t=0,n;t<e.length;t++)n=e[t],i.push({displayValue:'<div class="wj-flexsheet-formula-name">'+n.name+'</div><div class="wj-flexsheet-formula-description">'+n.description+'</div>',actualvalue:n.name});return i},s.prototype._addCustomFunctionDescription=function(n,t){for(var f={displayValue:'<div class="wj-flexsheet-formula-name">'+n+'</div>'+(t?'<div class="wj-flexsheet-formula-description">'+t+'</div>':''),actualvalue:n},i=this._functionList.itemsSource,u=-1,r=0,e;r<i.length;r++)if(e=i[r],e.actualvalue===n){u=r;break}u>-1?i.splice(u,1,f):i.push(f)},s.prototype._getCurrentFormulaIndex=function(n){var t=-1;return['+','-','*','/','^','(','&'].forEach(function(i){var r=n.lastIndexOf(i);r>t&&(t=r)}),t},s.prototype._prepareCellForEditHandler=function(){var t=this,i=t._edtHdl._edt;i&&(t.addEventListener(i,'keydown',function(i){if(t.isFunctionListOpen)switch(i.keyCode){case n.Key.Up:t.selectPreviousFunction();i.preventDefault();break;case n.Key.Down:t.selectNextFunction();i.preventDefault();break;case n.Key.Tab:case n.Key.Enter:t.applyFunctionToCell();i.preventDefault();break;case n.Key.Escape:t.hideFunctionList();i.preventDefault()}}),t.addEventListener(i,'keyup',function(r){(r.keyCode>40||r.keyCode<32)&&r.keyCode!==n.Key.Tab&&r.keyCode!==n.Key.Escape&&setTimeout(function(){t.showFunctionList(i)},0)}))},s.prototype._addSheet=function(n,t,r,u,f){var e=new i.Sheet(this,f,n,t,r);return this.sheets.isValidSheetName(e)||e._setValidName(this.sheets.getValidSheetName(e)),typeof u=='number'?(u<0&&(u=0),u>=this.sheets.length&&(u=this.sheets.length)):u=this.sheets.length,this.sheets.insert(u,e),u<=this._selectedSheetIndex&&(this._selectedSheetIndex+=1),this.selectedSheetIndex=u,e},s.prototype._showSheet=function(n){!this.sheets||!this.sheets.length||n>=this.sheets.length||n<0||n===this.selectedSheetIndex||this.sheets[n]&&!this.sheets[n].visible||(this.finishEditing(),this.selectedSheetIndex>-1&&this.selectedSheetIndex<this.sheets.length&&(this._copyTo(this.sheets[this.selectedSheetIndex]),this._resetFilterDefinition()),this.sheets[n]&&(this._selectedSheetIndex=n,this._copyFrom(this.sheets[n])),this._filter.closeEditor())},s.prototype._selectedSheetChange=function(n,t){this._showSheet(t.newValue);this.invalidate(!0);this.onSelectedSheetChanged(t)},s.prototype._sourceChange=function(t,i){var r,u;if(i.action===n.collections.NotifyCollectionChangedAction.Add||i.action===n.collections.NotifyCollectionChangedAction.Change)r=i.item,r._attachOwner(this),i.action===n.collections.NotifyCollectionChangedAction.Add?(this._addingSheet=!0,i.index<=this.selectedSheetIndex&&(this._selectedSheetIndex+=1)):i.index===this.selectedSheetIndex&&this._copyFrom(i.item,!0),this.selectedSheetIndex=i.index;else if(i.action===n.collections.NotifyCollectionChangedAction.Reset){for(u=0;u<this.sheets.length;u++)r=this.sheets[u],r._attachOwner(this);this.sheets.length>0?(this.selectedSheetIndex===0&&this._copyFrom(this.selectedSheet,!0),this.selectedSheetIndex=0):(this.rows.clear(),this.columns.clear(),this._selectedSheetIndex=-1)}else this.sheets.length>0?this.selectedSheetIndex>=this.sheets.length?this.selectedSheetIndex=0:this.selectedSheetIndex>i.index&&(this._selectedSheetIndex-=1):(this.rows.clear(),this.columns.clear(),this._selectedSheetIndex=-1);this.invalidate(!0)},s.prototype._sheetVisibleChange=function(n,t){t.item.visible||t.index===this.selectedSheetIndex&&(this.selectedSheetIndex=this.selectedSheetIndex===this.sheets.length-1?t.index-1:t.index+1)},s.prototype._applyStyleForCell=function(n,t,i){var f=this,s=f.rows[n],u,o,e;s instanceof r||!s.isVisible||(e=n*f.columns.length+t,o=f.selectedSheet._mergedRanges[e],o&&(e=o.topRow*f.columns.length+o.leftCol),u=f.selectedSheet._styledCells[e],u?(u.className=i.className==='normal'?'':i.className||u.className,u.textAlign=i.textAlign||u.textAlign,u.verticalAlign=i.verticalAlign||u.verticalAlign,u.fontFamily=i.fontFamily||u.fontFamily,u.fontSize=i.fontSize||u.fontSize,u.backgroundColor=i.backgroundColor||u.backgroundColor,u.color=i.color||u.color,u.fontStyle=i.fontStyle==='none'?'':i.fontStyle||u.fontStyle,u.fontWeight=i.fontWeight==='none'?'':i.fontWeight||u.fontWeight,u.textDecoration=i.textDecoration==='none'?'':i.textDecoration||u.textDecoration,u.format=i.format||u.format):f.selectedSheet._styledCells[e]={className:i.className,textAlign:i.textAlign,verticalAlign:i.verticalAlign,fontStyle:i.fontStyle,fontWeight:i.fontWeight,fontFamily:i.fontFamily,fontSize:i.fontSize,textDecoration:i.textDecoration,backgroundColor:i.backgroundColor,color:i.color,format:i.format})},s.prototype._checkCellFormat=function(n,t,i){var f=n*this.columns.length+t,u,r;this.selectedSheet&&(u=this.selectedSheet._mergedRanges[f],u&&(i.isMergedCell=!0,f=u.topRow*this.columns.length+u.leftCol),r=this.selectedSheet._styledCells[f],r&&(i.isBold=i.isBold||r.fontWeight==='bold',i.isItalic=i.isItalic||r.fontStyle==='italic',i.isUnderline=i.isUnderline||r.textDecoration==='underline'),n===this.selection.row&&t===this.selection.col&&(r&&r.textAlign?i.textAlign=r.textAlign:t>-1&&(i.textAlign=this.columns[t].getAlignment()||i.textAlign)))},s.prototype._resetMergedRange=function(n){for(var r,e,u,f,o,t,s=!1,i=n.topRow;i<=n.bottomRow;i++)for(r=n.leftCol;r<=n.rightCol;r++)if(e=i*this.columns.length+r,t=this.selectedSheet._mergedRanges[e],t)for(s=!0,u=t.topRow;u<=t.bottomRow;u++)for(f=t.leftCol;f<=t.rightCol;f++)o=u*this.columns.length+f,delete this.selectedSheet._mergedRanges[o];return s},s.prototype._updateCellsForUpdatingRow=function(n,t,i,r){var l=this,s,f,e,o,u,h={},c=n*this.columns.length;if(r)for(s=t*this.columns.length,f=s;f<c;f++)e=f-i*this.columns.length,o=this.selectedSheet._styledCells[f],o&&(f>=(t+i)*this.columns.length&&(this.selectedSheet._styledCells[e]=o),delete this.selectedSheet._styledCells[f]),u=this.selectedSheet._mergedRanges[f],u&&(t<=u.topRow&&t+i>u.bottomRow?delete this.selectedSheet._mergedRanges[f]:u.bottomRow<t||u.topRow>=t+i?(u.topRow>t&&(u.row-=i),u.row2-=i,this.selectedSheet._mergedRanges[e]=u,delete this.selectedSheet._mergedRanges[f]):this._updateCellMergeRangeForRow(u,t,i,h,!0));else for(s=t*this.columns.length-1,f=c-1;f>s;f--)e=f+this.columns.length*i,o=this.selectedSheet._styledCells[f],o&&(this.selectedSheet._styledCells[e]=o,delete this.selectedSheet._styledCells[f]),u=this.selectedSheet._mergedRanges[f],u&&(u.topRow<t&&u.bottomRow>=t?this._updateCellMergeRangeForRow(u,t,i,h):(u.row+=i,u.row2+=i,this.selectedSheet._mergedRanges[e]=u,delete this.selectedSheet._mergedRanges[f]));Object.keys(h).forEach(function(n){l.selectedSheet._mergedRanges[n]=h[n]})},s.prototype._updateCellMergeRangeForRow=function(n,t,i,r,u){var e,s,o,c,l,h,f;if(u)for(e=n.topRow;e<=n.bottomRow;e++)for(s=n.leftCol;s<=n.rightCol;s++)o=e*this.columns.length+s,c=o-i*this.columns.length,h=this.selectedSheet._mergedRanges[o],h&&(f=h.clone(),f.row>t&&(f.row-=f.row-t),f.row2-=f.row2<t+i-1?f.row2-t+1:i,e<t?r[o]=f:(e>=t+i&&(r[c]=f),delete this.selectedSheet._mergedRanges[o]));else for(e=n.bottomRow;e>=n.topRow;e--)for(s=n.rightCol;s>=n.leftCol;s--)if(o=e*this.columns.length+s,h=this.selectedSheet._mergedRanges[o],h){for(f=h.clone(),f.row2+=i,e<t&&(r[o]=f.clone()),l=1;l<=i;l++)c=o+this.columns.length*l,r[c]=f;delete this.selectedSheet._mergedRanges[o]}},s.prototype._updateCellsForUpdatingColumn=function(n,t,i,r){var a=this,u,e,o,h,s,f,c={},l=this.rows.length*n;if(r)for(u=t;u<l;u++)h=Math.floor(u/n),s=u%n,e=u-i*(h+(s>=t?1:0)),o=this.selectedSheet._styledCells[u],o&&((s<t||s>=t+i)&&(this.selectedSheet._styledCells[e]=o),delete this.selectedSheet._styledCells[u]),f=this.selectedSheet._mergedRanges[u],f&&(t<=f.leftCol&&t+i>f.rightCol?delete this.selectedSheet._mergedRanges[u]:f.rightCol<t||f.leftCol>=t+i?(f.leftCol>=t&&(f.col-=i,f.col2-=i),this.selectedSheet._mergedRanges[e]=f,delete this.selectedSheet._mergedRanges[u]):this._updateCellMergeRangeForColumn(f,t,i,n,c,!0));else for(u=l-1;u>=t;u--)h=Math.floor(u/n),s=u%n,e=u+h*i+(s>=t?1:0),o=this.selectedSheet._styledCells[u],o&&(this.selectedSheet._styledCells[e]=o,delete this.selectedSheet._styledCells[u]),f=this.selectedSheet._mergedRanges[u],f&&(f.leftCol<t&&f.rightCol>=t?this._updateCellMergeRangeForColumn(f,t,i,n,c):(f.leftCol>=t&&(f.col+=i,f.col2+=i),this.selectedSheet._mergedRanges[e]=f,delete this.selectedSheet._mergedRanges[u]));Object.keys(c).forEach(function(n){a.selectedSheet._mergedRanges[n]=c[n]})},s.prototype._updateCellMergeRangeForColumn=function(n,t,i,r,u,f){var s,e,h,c,a,l,o;if(f)for(s=n.topRow;s<=n.bottomRow;s++)for(e=n.leftCol;e<=n.rightCol;e++)h=s*r+e,c=h-i*(s+(e>=t?1:0)),l=this.selectedSheet._mergedRanges[h],l&&(o=l.clone(),o.col>t&&(o.col-=o.col-t),o.col2-=o.col2<t+i-1?o.col2-t+1:i,(e<t||e>=t+i)&&(u[c]=o),delete this.selectedSheet._mergedRanges[h]);else for(s=n.bottomRow;s>=n.topRow;s--)for(e=n.rightCol;e>=n.leftCol;e--)if(h=s*r+e,c=h+s*i+(e>=t?1:0),l=this.selectedSheet._mergedRanges[h],l){if(o=l.clone(),o.col2+=i,e===t&&(u[c-1]=o.clone()),e>=t)for(a=0;a<i;a++)u[c+a]=o;else u[c]=o;delete this.selectedSheet._mergedRanges[h]}},s.prototype._cloneMergedCells=function(){var i,n,t;if(!this.selectedSheet)return null;if(n=this.selectedSheet._mergedRanges,null==n||"object"!=typeof n)return n;if(n instanceof Object){i={};for(t in n)n.hasOwnProperty(t)&&n[t]&&n[t].clone&&(i[t]=n[t].clone());return i}throw new Error("Unable to copy obj! Its type isn't supported.");},s.prototype._evaluate=function(n,t,i,r,u){return n&&n.length>1?(n=n[0]==='='?n:'='+n,this._calcEngine.evaluate(n,t,i,r,u)):n},s.prototype._copyTo=function(i){var r=this,o=i.grid.autoGenerateColumns,u,f,e;if(i._storeRowSettings(),i.grid.selection=new t.CellRange,i.grid.rows.clear(),i.grid.columns.clear(),i.grid.columnHeaders.columns.clear(),i.grid.rowHeaders.rows.clear(),r.itemsSource){if(i.grid.autoGenerateColumns=!1,i.itemsSource=r.itemsSource,i.grid.collectionView.beginUpdate(),!(i.grid.itemsSource instanceof n.collections.CollectionView))for(i.grid.collectionView.sortDescriptions.clear(),e=0;e<r.collectionView.sortDescriptions.length;e++)i.grid.collectionView.sortDescriptions.push(r.collectionView.sortDescriptions[e])}else for(i.itemsSource=null,f=0;f<r.rows.length;f++)i.grid.rows.push(r.rows[f]);for(i._filterDefinition=r._filter.filterDefinition,u=0;u<r.columns.length;u++)i.grid.columns.push(r.columns[u]);i.grid.collectionView&&(r._resetMappedColumns(i.grid),i.grid.collectionView.endUpdate());i.grid.autoGenerateColumns=o;i.grid.frozenRows=r.frozenRows;i.grid.frozenColumns=r.frozenColumns;i.grid.selection=r.selection;i._scrollPosition=r.scrollPosition;setTimeout(function(){r._setFlexSheetToDirty();r.refresh(!0)},10)},s.prototype._copyFrom=function(i,u){u===void 0&&(u=!0);var f=this,l=f.autoGenerateColumns,o,e,s,h,c;if(f._isCopyingOrUndoing=!0,f._dragable=!1,f.rows.clear(),f.columns.clear(),f.columnHeaders.columns.clear(),f.rowHeaders.rows.clear(),f.selection=new t.CellRange,i.selectionRanges.length>1&&f.selectionMode===t.SelectionMode.CellRange&&(f._enableMulSel=!0),i.itemsSource){if(f.autoGenerateColumns=!1,f.itemsSource=i.itemsSource,f.collectionView.beginUpdate(),!(f.itemsSource instanceof n.collections.CollectionView))for(f.collectionView.sortDescriptions.clear(),s=0;s<i.grid.collectionView.sortDescriptions.length;s++)f.collectionView.sortDescriptions.push(i.grid.collectionView.sortDescriptions[s])}else for(f.itemsSource=null,e=0;e<i.grid.rows.length;e++)f.rows.push(i.grid.rows[e]);for(o=0;o<i.grid.columns.length;o++)f.columns.push(i.grid.columns[o]);if(f.collectionView)for(f._resetMappedColumns(f),f.collectionView.endUpdate(),f.collectionView.collectionChanged.addHandler(function(t,i){i.action===n.collections.NotifyCollectionChangedAction.Reset&&f.invalidate()},f),e=0;e<f.rows.length;e++)c=i._rowSettings[e],c&&(f.rows[e].height=c.height);if(f.rows.length&&f.columns.length&&(f.selection=i.grid.selection),i._filterDefinition&&(f._filter.filterDefinition=i._filterDefinition),f.autoGenerateColumns=l,i._freezeHiddenRowCnt>0)for(e=0;e<i._freezeHiddenRowCnt;e++)h=f.rows[e],h instanceof r||(h.visible=!1);if(i._freezeHiddenColumnCnt>0)for(o=0;o<i._freezeHiddenColumnCnt;o++)f.columns[o].visible=!1;f.frozenRows=i.grid.frozenRows;f.frozenColumns=i.grid.frozenColumns;f._isCopyingOrUndoing=!1;f._addingSheet?(f._toRefresh&&(clearTimeout(f._toRefresh),f._toRefresh=null),f._toRefresh=setTimeout(function(){f._setFlexSheetToDirty();f.invalidate()},10),f._addingSheet=!1):u&&f.refresh();f.scrollPosition=i._scrollPosition},s.prototype._resetMappedColumns=function(n){var t,i,r=0;if(n._mappedColumns=null,n.collectionView)for(i=n.collectionView.sortDescriptions;r<i.length;r++)t=n.columns.getColumn(i[r].property),t&&t.dataMap&&(n._mappedColumns||(n._mappedColumns={}),n._mappedColumns[t.binding]=t.dataMap)},s.prototype._resetFilterDefinition=function(){this._filter.filterDefinition=JSON.stringify({defaultFilterType:n.grid.filter.FilterType.Both,filters:[]})},s.prototype._loadFromWorkbook=function(t){var u,r=0,i=this;if(t.sheets!=null&&t.sheets.length!==0){for(i.clear(),i._reservedContent=t.reservedContent,u=t.sheets.length;r<u;r++)r>0&&i.addUnboundSheet(),n.grid.xlsx.FlexGridXlsxConverter.load(i.selectedSheet.grid,t,{sheetIndex:r,includeColumnHeaders:!1}),i.selectedSheet.grid.wj_sheetInfo&&(i.selectedSheet.name=i.selectedSheet.grid.wj_sheetInfo.name,i.selectedSheet.visible=i.selectedSheet.grid.wj_sheetInfo.visible,i.selectedSheet._styledCells=i.selectedSheet.grid.wj_sheetInfo.styledCells,i.selectedSheet._mergedRanges=i.selectedSheet.grid.wj_sheetInfo.mergedRanges),i._copyFrom(i.selectedSheet,!1);i.selectedSheetIndex=t.activeWorksheet!=null&&t.activeWorksheet>-1&&t.activeWorksheet<i.sheets.length?t.activeWorksheet:0;i.onLoaded()}},s.prototype._saveToWorkbook=function(){var r,u,t,i;if(this.sheets.length===0)throw'The flexsheet is empty.';for(t=this.sheets[0],this.selectedSheetIndex===0&&(t._storeRowSettings(),t._setRowSettings()),r=n.grid.xlsx.FlexGridXlsxConverter.save(t.grid,{sheetName:t.name,sheetVisible:t.visible,includeColumnHeaders:!1}),r.reservedContent=this._reservedContent,i=1;i<this.sheets.length;i++)t=this.sheets[i],this.selectedSheetIndex===i&&(t._storeRowSettings(),t._setRowSettings()),u=n.grid.xlsx.FlexGridXlsxConverter.save(t.grid,{sheetName:t.name,sheetVisible:t.visible,includeColumnHeaders:!1}),r._addWorkSheet(u.sheets[0],i);return r.activeWorksheet=this.selectedSheetIndex,r},s.prototype._mouseDown=function(i){var o=window.navigator.userAgent,r=this.hitTest(i),h=this.columns,u,e,s;if(this._wholeColumnsSelected=!1,this._dragable){this._isDragging=!0;this._draggingMarker=document.createElement('div');n.setCss(this._draggingMarker,{position:'absolute',display:'none',borderStyle:'dotted',cursor:'move'});document.body.appendChild(this._draggingMarker);this._draggingTooltip=new n.Tooltip;this._draggingCells=this.selection;this.selectedSheet&&this.selectedSheet.selectionRanges.clear();this.onDraggingRowColumn(new f(this._draggingRow,i.shiftKey));i.preventDefault();return}if((r.cellType!==t.CellType.None&&(s=n.tryCast(i.target,HTMLInputElement),s==null&&this._checkHitWithinSelection(r)&&(this._edtHdl._htDown=r),this._isClicking=!0),this.selectionMode===t.SelectionMode.CellRange?i.ctrlKey?this._enableMulSel||(this._enableMulSel=!0):r.cellType!==t.CellType.None&&(this.selectedSheet&&this.selectedSheet.selectionRanges.clear(),this._enableMulSel&&this.refresh(!1),this._enableMulSel=!1):(this._enableMulSel=!1,this.selectedSheet&&this.selectedSheet.selectionRanges.clear()),this._htDown=r,this.rows.length!==0&&this.columns.length!==0)&&(o.match(/iPad/i)||o.match(/iPhone/i)||this._contextMenu.hide(),this.selectionMode===t.SelectionMode.CellRange)){if(r.cellType===t.CellType.RowHeader&&i.which===3){e=new t.CellRange(r.row,0,r.row,this.columns.length-1);this.selection.contains(e)||(this.selection=e);return}if((r.cellType===t.CellType.ColumnHeader||r.cellType===t.CellType.None)&&(!(r.col>-1)||!this.columns[r.col].isSelected)&&n.hasClass(i.target,'wj-cell')&&!r.edgeRight)if(this._columnHeaderClicked=!0,this._wholeColumnsSelected=!0,i.shiftKey)this._multiSelectColumns(r);else{if(u=new t.CellRange(this.itemsSource?1:0,r.col,this.rows.length-1,r.col),i.which===3&&this.selection.contains(u))return;this.select(u)}}},s.prototype._mouseMove=function(n){var i=this.hitTest(n),r=this.selection,f=this.rows.length,e=this.columns.length,u=this.hostElement.style.cursor,o;if(this.rows.length===0||this.columns.length===0){this._dragable=!1;i.cellType===t.CellType.Cell&&(this.hostElement.style.cursor='default');return}if(this._isDragging){this.hostElement.style.cursor='move';this._showDraggingMarker(n);return}(o=this.itemsSource?r.topRow===0||r.topRow===1:r.topRow===0,r&&i.cellType!==t.CellType.None&&!this.itemsSource&&(this._draggingColumn=o&&r.bottomRow===f-1,this._draggingRow=r.leftCol===0&&r.rightCol===e-1,i.cellType===t.CellType.Cell?(this._draggingColumn&&((i.col===r.leftCol-1||i.col===r.rightCol)&&i.edgeRight||i.row===f-1&&i.edgeBottom)&&(u='move'),this._draggingRow&&!this._containsGroupRows(r)&&((i.row===r.topRow-1||i.row===r.bottomRow)&&i.edgeBottom||i.col===e-1&&i.edgeRight)&&(u='move')):i.cellType===t.CellType.ColumnHeader?i.edgeBottom&&(this._draggingColumn&&i.col>=r.leftCol&&i.col<=r.rightCol?u='move':this._draggingRow&&r.topRow===0&&(u='move')):i.cellType===t.CellType.RowHeader&&i.edgeRight&&(this._draggingColumn&&r.leftCol===0?u='move':this._draggingRow&&i.row>=r.topRow&&i.row<=r.bottomRow&&!this._containsGroupRows(r)&&(u='move')),this._dragable=u==='move'?!0:!1,this.hostElement.style.cursor=u),this._htDown&&this._htDown.panel)&&(i=new t.HitTestInfo(this._htDown.panel,n),this._multiSelectColumns(i),i.cellType===t.CellType.Cell&&this.scrollIntoView(i.row,i.col))},s.prototype._mouseUp=function(n){this._isDragging&&(this._draggingCells.equals(this._dropRange)||(this._handleDropping(n),this.onDroppingRowColumn()),this._draggingCells=null,this._dropRange=null,document.body.removeChild(this._draggingMarker),this._draggingMarker=null,this._draggingTooltip.hide(),this._draggingTooltip=null,this._isDragging=!1,this._draggingColumn=!1,this._draggingRow=!1);this._htDown&&this._htDown.cellType!==t.CellType.None&&this.selection.isValid&&this.selectedSheet&&(this.selectionMode===t.SelectionMode.ListBox||this.selectionMode===t.SelectionMode.Row||this.selectionMode===t.SelectionMode.RowRange?this.selectedSheet.selectionRanges.push(new t.CellRange(this.selection.row,0,this.selection.row2,this.columns.length-1)):this._htDown.cellType===t.CellType.TopLeft?this.selectedSheet.selectionRanges.push(new t.CellRange(this.selectedSheet.itemsSource?1:0,0,this.rows.length-1,this.columns.length-1)):this.selectedSheet.selectionRanges.push(this.selection),this._enableMulSel=!1);this._isClicking=!1;this._columnHeaderClicked=!1;this._htDown=null},s.prototype._click=function(){var n=this,t=window.navigator.userAgent;t.match(/iPad/i)||t.match(/iPhone/i)||n._contextMenu.hide();setTimeout(function(){n.hideFunctionList()},200)},s.prototype._touchStart=function(i){var r=this;n.hasClass(i.target,'wj-context-menu-item')||r._contextMenu.hide();r._longClickTimer=setTimeout(function(){var u;u=r.hitTest(i);u&&u.cellType!==t.CellType.None&&!r.itemsSource&&r._contextMenu.show(undefined,new n.Point(i.pageX+10,i.pageY+10))},500)},s.prototype._touchEnd=function(){clearTimeout(this._longClickTimer)},s.prototype._showDraggingMarker=function(i){var a=new t.HitTestInfo(this.cells,i),v=this.selection,w=this.columns.length,b=this.rows.length,y=this._cumulativeScrollOffset(this.hostElement),k=this._root.getBoundingClientRect(),d=k.left+y.x,g=k.top+y.y,f,u,r,c,o,l,h,p,e;if(this.scrollIntoView(a.row,a.col),this._draggingColumn){for(u=v.rightCol-v.leftCol+1,r=a.col,o=0,(r<0||r+u>w)&&(r=w-u),f=this.cells.getCellBoundingRect(0,r),l=this._root.offsetHeight-this._eCHdr.offsetHeight,c=this.cells.height,c=c>l?l:c,h=0;h<u;h++)o+=this.columns[r+h].renderSize;p=s.convertNumberToAlpha(r)+' : '+s.convertNumberToAlpha(r+u-1);this._dropRange?(this._dropRange.col=r,this._dropRange.col2=r+u-1):this._dropRange=new t.CellRange(0,r,this.rows.length-1,r+u-1)}else if(this._draggingRow){for(u=v.bottomRow-v.topRow+1,r=a.row,c=0,(r<0||r+u>b)&&(r=b-u),f=this.cells.getCellBoundingRect(r,0),l=this._root.offsetWidth-this._eRHdr.offsetWidth,h=0;h<u;h++)c+=this.rows[r+h].renderSize;o=this.cells.width;o=o>l?l:o;p=r+1+' : '+(r+u);this._dropRange?(this._dropRange.row=r,this._dropRange.row2=r+u-1):this._dropRange=new t.CellRange(r,0,r+u-1,this.columns.length-1)}if(f){if(e={display:'inline',zIndex:'9999',opacity:.5,top:f.top-(this._draggingColumn?this._ptScrl.y:0)+y.y,left:f.left-(this._draggingRow?this._ptScrl.x:0)+y.x,height:c,width:o},f.top=f.top-(this._draggingColumn?this._ptScrl.y:0),f.left=f.left-(this._draggingRow?this._ptScrl.x:0),this._rtl&&this._draggingRow&&(e.left=e.left-o+f.width+2*this._ptScrl.x,f.left=f.left+2*this._ptScrl.x),this._draggingRow){if(d+this._eRHdr.offsetWidth!==e.left||g+this._root.offsetHeight<e.top+e.height)return}else if(g+this._eCHdr.offsetHeight!==e.top||d+this._root.offsetWidth<e.left+e.width)return;n.setCss(this._draggingMarker,e);this._draggingTooltip.show(this.hostElement,p,f)}},s.prototype._handleDropping=function(t){var r=this,e,u,o,f,s;if(r.selectedSheet&&r._draggingCells&&r._dropRange&&!r._containsMergedCells(r._draggingCells)&&!r._containsMergedCells(r._dropRange)){if(r._clearCalcEngine(),r._draggingColumn&&r._draggingCells.leftCol>r._dropRange.leftCol||r._draggingRow&&r._draggingCells.topRow>r._dropRange.topRow)if(t.shiftKey){if(r._draggingColumn)for(f=r._dropRange.leftCol,u=r._draggingCells.leftCol;u<=r._draggingCells.rightCol;u++)r.columns.moveElement(u,f),f++;else if(r._draggingRow)for(o=r._dropRange.topRow,e=r._draggingCells.topRow;e<=r._draggingCells.bottomRow;e++)r.rows.moveElement(e,o),o++;r._exchangeCellStyle(!0)}else{for(s=new i._MoveCellsAction(r,r._draggingCells,r._dropRange,t.ctrlKey),o=r._dropRange.topRow,e=r._draggingCells.topRow;e<=r._draggingCells.bottomRow;e++){for(f=r._dropRange.leftCol,u=r._draggingCells.leftCol;u<=r._draggingCells.rightCol;u++)r._moveCellContent(e,u,o,f,t.ctrlKey),r._draggingColumn&&o===r._dropRange.topRow&&(r.columns[f].dataType=r.columns[u].dataType?r.columns[u].dataType:n.DataType.Object,r.columns[f].align=r.columns[u].align,r.columns[f].format=r.columns[u].format,t.ctrlKey||(r.columns[u].dataType=n.DataType.Object,r.columns[u].align=null,r.columns[u].format=null)),f++;o++}if(r._draggingColumn&&!t.ctrlKey)for(f=r._dropRange.leftCol,u=r._draggingCells.leftCol;u<=r._draggingCells.rightCol;u++)r._updateColumnFiler(u,f),f++;s.saveNewState()&&r._undoStack._addAction(s)}else if(r._draggingColumn&&r._draggingCells.leftCol<r._dropRange.leftCol||r._draggingRow&&r._draggingCells.topRow<r._dropRange.topRow)if(t.shiftKey){if(r._draggingColumn)for(f=r._dropRange.rightCol,u=r._draggingCells.rightCol;u>=r._draggingCells.leftCol;u--)r.columns.moveElement(u,f),f--;else if(r._draggingRow)for(o=r._dropRange.bottomRow,e=r._draggingCells.bottomRow;e>=r._draggingCells.topRow;e--)r.rows.moveElement(e,o),o--;r._exchangeCellStyle(!1)}else{for(s=new i._MoveCellsAction(r,r._draggingCells,r._dropRange,t.ctrlKey),o=r._dropRange.bottomRow,e=r._draggingCells.bottomRow;e>=r._draggingCells.topRow;e--){for(f=r._dropRange.rightCol,u=r._draggingCells.rightCol;u>=r._draggingCells.leftCol;u--)r._moveCellContent(e,u,o,f,t.ctrlKey),r._draggingColumn&&o===r._dropRange.bottomRow&&(r.columns[f].dataType=r.columns[u].dataType?r.columns[u].dataType:n.DataType.Object,r.columns[f].align=r.columns[u].align,r.columns[f].format=r.columns[u].format,t.ctrlKey||(r.columns[u].dataType=n.DataType.Object,r.columns[u].align=null,r.columns[u].format=null)),f--;o--}if(r._draggingColumn&&!t.ctrlKey)for(f=r._dropRange.rightCol,u=r._draggingCells.rightCol;u>=r._draggingCells.leftCol;u--)r._updateColumnFiler(u,f),f--;s.saveNewState()&&r._undoStack._addAction(s)}r.select(r._dropRange);r.selectedSheet.selectionRanges.push(r.selection);r.hostElement.focus()}},s.prototype._moveCellContent=function(n,t,i,r,u){var s=this.getCellData(n,t,!1),f=n*this.columns.length+t,e=i*this.columns.length+r,o=this.selectedSheet._styledCells[f];this.setCellData(i,r,s);o?this.selectedSheet._styledCells[e]=JSON.parse(JSON.stringify(o)):delete this.selectedSheet._styledCells[e];u||(this.setCellData(n,t,undefined),delete this.selectedSheet._styledCells[f])},s.prototype._exchangeCellStyle=function(n){for(var i,r,u,f,o=0,e=[],t=this._draggingCells.topRow;t<=this._draggingCells.bottomRow;t++)for(i=this._draggingCells.leftCol;i<=this._draggingCells.rightCol;i++)r=t*this.columns.length+i,this.selectedSheet._styledCells[r]?(e.push(JSON.parse(JSON.stringify(this.selectedSheet._styledCells[r]))),delete this.selectedSheet._styledCells[r]):e.push(undefined);if(n){if(this._draggingColumn)for(f=this._draggingCells.rightCol-this._draggingCells.leftCol+1,i=this._draggingCells.leftCol-1;i>=this._dropRange.leftCol;i--)for(t=0;t<this.rows.length;t++)r=t*this.columns.length+i,u=t*this.columns.length+i+f,this.selectedSheet._styledCells[r]?(this.selectedSheet._styledCells[u]=JSON.parse(JSON.stringify(this.selectedSheet._styledCells[r])),delete this.selectedSheet._styledCells[r]):delete this.selectedSheet._styledCells[u];else if(this._draggingRow)for(f=this._draggingCells.bottomRow-this._draggingCells.topRow+1,t=this._draggingCells.topRow-1;t>=this._dropRange.topRow;t--)for(i=0;i<this.columns.length;i++)r=t*this.columns.length+i,u=(t+f)*this.columns.length+i,this.selectedSheet._styledCells[r]?(this.selectedSheet._styledCells[u]=JSON.parse(JSON.stringify(this.selectedSheet._styledCells[r])),delete this.selectedSheet._styledCells[r]):delete this.selectedSheet._styledCells[u]}else if(this._draggingColumn)for(f=this._draggingCells.rightCol-this._draggingCells.leftCol+1,i=this._draggingCells.rightCol+1;i<=this._dropRange.rightCol;i++)for(t=0;t<this.rows.length;t++)r=t*this.columns.length+i,u=t*this.columns.length+i-f,this.selectedSheet._styledCells[r]?(this.selectedSheet._styledCells[u]=JSON.parse(JSON.stringify(this.selectedSheet._styledCells[r])),delete this.selectedSheet._styledCells[r]):delete this.selectedSheet._styledCells[u];else if(this._draggingRow)for(f=this._draggingCells.bottomRow-this._draggingCells.topRow+1,t=this._draggingCells.bottomRow+1;t<=this._dropRange.bottomRow;t++)for(i=0;i<this.columns.length;i++)r=t*this.columns.length+i,u=(t-f)*this.columns.length+i,this.selectedSheet._styledCells[r]?(this.selectedSheet._styledCells[u]=JSON.parse(JSON.stringify(this.selectedSheet._styledCells[r])),delete this.selectedSheet._styledCells[r]):delete this.selectedSheet._styledCells[u];for(t=this._dropRange.topRow;t<=this._dropRange.bottomRow;t++)for(i=this._dropRange.leftCol;i<=this._dropRange.rightCol;i++)r=t*this.columns.length+i,e[o]?this.selectedSheet._styledCells[r]=e[o]:delete this.selectedSheet._styledCells[r],o++},s.prototype._containsMergedCells=function(n){var t,i,u,r;if(!this.selectedSheet)return!1;for(t=n.topRow;t<=n.bottomRow;t++)for(i=n.leftCol;i<=n.rightCol;i++)if(u=t*this.columns.length+i,r=this.selectedSheet._mergedRanges[u],r&&r.isValid&&!r.isSingleCell)return!0;return!1},s.prototype._multiSelectColumns=function(n){var i;n&&this._columnHeaderClicked&&(i=new t.CellRange(n.row,n.col),i.row=!this.selectedSheet.itemsSource?0:1,i.row2=this.rows.length-1,i.col2=this.selection.col2,this.select(i))},s.prototype._cumulativeOffset=function(t){var i=0,r=0;do i+=t.offsetTop||0,r+=t.offsetLeft||0,t=t.offsetParent;while(t);return new n.Point(r,i)},s.prototype._cumulativeScrollOffset=function(t){var i=0,r=0;do i+=t.scrollTop||0,r+=t.scrollLeft||0,t=t.offsetParent;while(t&&!(t instanceof HTMLBodyElement));return i+=document.body.scrollTop||document.documentElement.scrollTop,r+=document.body.scrollLeft||document.documentElement.scrollLeft,new n.Point(r,i)},s.prototype._checkHitWithinSelection=function(n){var i;return n!=null&&n.cellType===t.CellType.Cell&&((i=this.getMergedRange(this.cells,n.row,n.col),i&&i.intersects(this.selection))||this.selection.row===n.row&&this.selection.col===n.col)?!0:!1},s.prototype._clearForEmptySheet=function(n){this.selectedSheet&&this[n].length===0&&this._isCopyingOrUndoing!==!0&&(this.selectedSheet._mergedRanges=null,this.selectedSheet._styledCells=null,this.select(new t.CellRange))},s.prototype._containsGroupRows=function(n){for(var r,i=n.topRow;i<=n.bottomRow;i++)if(r=this.rows[i],r instanceof t.GroupRow)return!0;return!1},s.prototype._delSeletionContent=function(){var t=this,r=t.selectedSheet.selectionRanges;t.isReadOnly||t.deferUpdate(function(){for(var e,u,f,s,h=!1,c=new i._EditAction(t),o=0;o<r.length;o++)for(e=r[o],f=e.topRow;f<=e.bottomRow;f++)for(u=e.leftCol;u<=e.rightCol;u++)s=t._getBindingColumn(t.cells,f,t.columns[u]),(s.isRequired==!1||s.isRequired==null&&s.dataType==n.DataType.String)&&t.getCellData(f,u,!0)&&(t.setCellData(f,u,'',!0),h=!0);h&&(c.saveNewState(),t._undoStack._addAction(c))})},s.prototype._updateAffectedFormula=function(t,i,r,u){for(var s,l,a,c,v,h,y,w,p=[],b=[],e,f,o=0;o<this.rows.length;o++)for(s=0;s<this.columns.length;s++)if(f=this.getCellData(o,s,!1),!!f&&typeof f=='string'&&f[0]==='='&&(c=f.match(/(?=\b\D)\$?[A-Za-z]+\$?\d+/g),!!c&&c.length>0)){for(h=!1,v=0;v<c.length;v++)y=c[v],y.toLowerCase()!=='atan2'&&(e=n.xlsx.Workbook.tableAddress(y),u?e.row>t&&(r?e.row+=i:e.row-=i,h||(h=!0,p.push({point:new n.Point(o,s),formula:f}))):e.col>t&&(r?e.col+=i:e.col-=i,h||(h=!0,p.push({point:new n.Point(o,s),formula:f}))),w=n.xlsx.Workbook.xlsxAddress(e.row,e.col,e.absRow,e.absCol),f=f.replace(y,w));h&&(this.setCellData(o,s,f),l=o,a=s,u?o>t&&(r?l+=i:l-=i):s>t&&(r?a+=i:a-=i),b.push({point:new n.Point(l,a),formula:f}))}return{oldFormulas:p,newFormulas:b}},s.prototype._updateColumnFiler=function(n,t){for(var u,i=JSON.parse(this._filter.filterDefinition),r=0;r<i.filters.length;r++)if(u=i.filters[r],u.columnIndex===n){u.columnIndex=t;break}this._filter.filterDefinition=JSON.stringify(i)},s.prototype._isDescendant=function(n,t){for(var i=t.parentNode;i!=null;){if(i===n)return!0;i=i.parentNode}return!1},s.prototype._clearCalcEngine=function(){this._calcEngine._clearExpressionCache()},s.prototype._isMultipleRowsSelected=function(){for(var i=this.selectedSheet.selectionRanges||[this.selection],n,t=0;t<i.length;t++)if(n=i[t],n.leftCol!==0||n.rightCol!==this.columns.length-1)return!1;return!0},s.prototype._isMultipleColumnsSelected=function(){for(var i=this.selectedSheet.selectionRanges||[this.selection],n,t=0;t<i.length;t++)if((n=i[t],n.bottomRow!==this.rows.length-1)||!this.selectedSheet.itemsSource&&n.topRow!==0||!!this.selectedSheet.itemsSource&&n.topRow!==1)return!1;return!0},s.prototype._sortByRow=function(n,t){return n.topRow>t.topRow?1:n.topRow<t.topRow?-1:0},s.prototype._sortByColumn=function(n,t){return n.leftCol>t.leftCol?1:n.leftCol<t.leftCol?-1:0},s.prototype._setFlexSheetToDirty=function(){this.columns._dirty=!0;this.rows._dirty=!0;this.rowHeaders.columns._dirty=!0;this.rowHeaders.rows._dirty=!0;this.columnHeaders.columns._dirty=!0;this.columnHeaders.rows._dirty=!0},s.convertNumberToAlpha=function(n){var t='',i,r;if(n>=0)do i=Math.floor(n/26),r=n%26,t=String.fromCharCode(r+65)+t,n=i-1;while(i);return t},s.controlTemplate='<div style="width:100%;height:100%"><div wj-part="container" style="width:100%">'+t.FlexGrid.controlTemplate+'<\/div><div wj-part="tab-holder" style="width:100%; min-width:100px"><\/div><div wj-part="context-menu" style="display:none;z-index:100"><\/div><\/div>',s}(t.FlexGrid),f,o,u,r;i.FlexSheet=s;f=function(n){function t(t,i){n.call(this);this._isDraggingRows=t;this._isShiftKey=i}return __extends(t,n),Object.defineProperty(t.prototype,"isDraggingRows",{get:function(){return this._isDraggingRows},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isShiftKey",{get:function(){return this._isShiftKey},enumerable:!0,configurable:!0}),t}(n.EventArgs);i.DraggingRowColumnEventArgs=f;o=function(n){function t(t,i){n.call(this);this._funcName=t;this._params=i}return __extends(t,n),Object.defineProperty(t.prototype,"funcName",{get:function(){return this._funcName},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"params",{get:function(){return this._params},enumerable:!0,configurable:!0}),t}(n.EventArgs);i.UnknownFunctionEventArgs=o;u=function(i){function r(n,t,r,u,f){i.call(this,n,t,r,u,f)}return __extends(r,i),r.prototype.getSelectedState=function(n,r,u){var o,s,e,f,c,h;if(!this.grid)return undefined;if(h=this.grid.getMergedRange(this,n,r),o=this.grid.selectedSheet?this.grid.selectedSheet.selectionRanges:null,c=i.prototype.getSelectedState.call(this,n,r,u),s=o?o.length:0,c===t.SelectedState.None&&s>0&&this.grid._enableMulSel)for(e=0;e<o.length;e++)if(f=o[e],f&&f instanceof t.CellRange){if(this.cellType===t.CellType.Cell){if(h){if(h.contains(f.row,f.col))return e===s-1&&!this.grid._isClicking?this.grid.showMarquee?t.SelectedState.None:t.SelectedState.Cursor:t.SelectedState.Selected;if(h.intersects(f))return t.SelectedState.Selected}if(f.row===n&&f.col===r)return e===s-1&&!this.grid._isClicking?this.grid.showMarquee?t.SelectedState.None:t.SelectedState.Cursor:t.SelectedState.Selected;if(f.contains(n,r))return t.SelectedState.Selected}if(this.grid.showSelectedHeaders&t.HeadersVisibility.Row&&this.cellType===t.CellType.RowHeader&&f.containsRow(n)||this.grid.showSelectedHeaders&t.HeadersVisibility.Column&&this.cellType===t.CellType.ColumnHeader&&f.containsColumn(r))return t.SelectedState.Selected}return c},r.prototype.getCellData=function(t,r,u){var o=i.prototype.getCellData.call(this,t,r,u),s=this.columns[n.asNumber(r,!1,!0)],e=this.grid?this.grid._getBindingColumn(this,t,s):s,f;return u&&(f=i.prototype.getCellData.call(this,t,r,!1),!n.isNumber(f)||f===0||!e||e.format||e.dataMap||(o=f)),o},r.prototype.setCellData=function(t,r,u,f){f===void 0&&(f=!0);var e;return f&&u&&n.isString(u)&&(n.isNullOrWhiteSpace(u)||isNaN(+u)?u[0]!=='='&&(e=n.Globalize.parseDate(u,''),e&&(u=e)):u=+u),u&&n.isString(u)&&u[0]==='='&&(f=!1),i.prototype.setCellData.call(this,t,r,u,f)},r.prototype._renderCell=function(t,r,u,f,e){var o=this.hostElement.childNodes[e],s,c=t*this.grid.columns.length+r,h=this.grid.getMergedRange(this,t,r);return(e=i.prototype._renderCell.call(this,t,r,u,f,e),this.cellType!==n.grid.CellType.Cell)?e:h&&c>h.topRow*this.grid.columns.length+h.leftCol?e:(n.hasClass(o,'wj-state-selected')||n.hasClass(o,'wj-state-multi-selected')?(o.style.backgroundColor='',o.style.color=''):this.grid.selectedSheet&&(s=this.grid.selectedSheet._styledCells[c],o&&s&&(o.style.backgroundColor=s.backgroundColor,o.style.color=s.color)),e)},r}(t.GridPanel);i.FlexSheetPanel=u;r=function(n){function t(){n.call(this);this.isReadOnly=!0}return __extends(t,n),t}(t.Row);i.HeaderRow=r})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(i){'use strict';var e=function(){function u(t,i,u,f,e){this._visible=!0;this._unboundSortDesc=new n.collections.ObservableArray;this._currentStyledCells={};this._currentMergedRanges={};this._isEmptyGrid=!1;this._rowSettings=[];this._scrollPosition=new n.Point;this._freezeHiddenRowCnt=0;this._freezeHiddenColumnCnt=0;this.nameChanged=new n.Event;this.visibleChanged=new n.Event;var o=this;o._owner=t;o._name=u;o._rowCount=n.isNumber(f)&&!isNaN(f)&&f>=0?f:200;o._columnCount=n.isNumber(e)&&!isNaN(e)&&e>=0?e:20;o._grid=i||this._createGrid();o._grid.itemsSourceChanged.addHandler(this._gridItemsSourceChanged,this);o._unboundSortDesc.collectionChanged.addHandler(function(){for(var i=o._unboundSortDesc,u,t=0;t<i.length;t++)if(u=n.tryCast(i[t],r),!u)throw'sortDescriptions array must contain SortDescription objects.';o._owner&&(o._owner.rows.beginUpdate(),o._owner.rows.sort(o._compareRows()),o._owner.rows.endUpdate(),o._owner.rows._dirty=!0,o._owner.rows._update(),o._owner.selectedSheet&&(o._owner._copyTo(o._owner.selectedSheet),o._owner._copyFrom(o._owner.selectedSheet)))})}return Object.defineProperty(u.prototype,"grid",{get:function(){return this._grid},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"name",{get:function(){return this._name},set:function(t){if(!n.isNullOrWhiteSpace(t)&&(this._name&&this._name.toLowerCase()!==t.toLowerCase()||!this._name)){this._name=t;this._grid.wj_sheetInfo.name=t;this.onNameChanged(new n.EventArgs)}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"visible",{get:function(){return this._visible},set:function(t){if(this._visible!==t){this._visible=t;this._grid.wj_sheetInfo.visible=t;this.onVisibleChanged(new n.EventArgs)}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"rowCount",{get:function(){return this._grid!=null?this._grid.rows.length:0},set:function(i){var r;if(n.isNumber(i)&&!isNaN(i)&&i>=0&&this._rowCount!==i){if(this._rowCount<i)for(r=0;r<i-this._rowCount;r++)this._grid.rows.push(new t.Row);else this._grid.rows.splice(i,this._rowCount-i);this._rowCount=i;this._owner&&this._owner.selectedSheet&&this._name===this._owner.selectedSheet.name&&this._owner._copyFrom(this,!0)}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"columnCount",{get:function(){return this._grid!=null?this._grid.columns.length:0},set:function(i){var r;if(n.isNumber(i)&&!isNaN(i)&&i>=0&&this._columnCount!==i){if(this._columnCount<i)for(r=0;r<i-this._columnCount;r++)this._grid.columns.push(new t.Column);else this._grid.columns.splice(i,this._columnCount-i);this._columnCount=i;this._owner&&this._owner.selectedSheet&&this._name===this._owner.selectedSheet.name&&this._owner._copyFrom(this,!0)}},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"selectionRanges",{get:function(){var i=this;return this._selectionRanges||(this._selectionRanges=new n.collections.ObservableArray,this._selectionRanges.collectionChanged.addHandler(function(){var n,r;i._owner&&!i._owner._isClicking&&(n=i._selectionRanges.length,n>0&&(r=i._selectionRanges[n-1],r&&r instanceof t.CellRange&&(i._owner.selection=r)),n>1&&(i._owner._enableMulSel=!0),i._owner.refresh(),i._owner._enableMulSel=!1)},this)),this._selectionRanges},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"itemsSource",{get:function(){return this._grid!=null?this._grid.itemsSource:null},set:function(n){this._grid==null&&(this._createGrid(),this._grid.itemsSourceChanged.addHandler(this._gridItemsSourceChanged,this));this._isEmptyGrid&&this._clearGrid();this._grid.itemsSource=n},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"_styledCells",{get:function(){return this._currentStyledCells||(this._currentStyledCells={}),this._currentStyledCells},set:function(n){this._currentStyledCells=n},enumerable:!0,configurable:!0}),Object.defineProperty(u.prototype,"_mergedRanges",{get:function(){return this._currentMergedRanges||(this._currentMergedRanges={}),this._currentMergedRanges},set:function(n){this._currentMergedRanges=n},enumerable:!0,configurable:!0}),u.prototype.onNameChanged=function(n){this.nameChanged.raise(this,n)},u.prototype.onVisibleChanged=function(n){this.visibleChanged.raise(this,n)},u.prototype.getCellStyle=function(n,t){var i,u=this._grid.rows.length,r=this._grid.columns.length;return n>=u||t>=r?null:(i=n*r+t,this._styledCells[i])},u.prototype._attachOwner=function(n){this._owner!==n&&(this._owner=n)},u.prototype._setValidName=function(n){this._name=n;this._grid.wj_sheetInfo.name=n},u.prototype._storeRowSettings=function(){var n=0,t;for(this._rowSettings=[];n<this._grid.rows.length;n++)t=this._owner.rows[n],t&&(this._rowSettings[n]={height:t.height})},u.prototype._setRowSettings=function(){for(var n=0,t;n<this._rowSettings.length;n++)t=this._rowSettings[n],t&&(this._grid.rows[n].height=t.height)},u.prototype._compareRows=function(){var t=this,i=this._unboundSortDesc;return function(r,u){for(var s,o=0;o<i.length;o++){var h=i[o],f=r._ubv?r._ubv[h.column._hash]:'',e=u._ubv?u._ubv[h.column._hash]:'';if(n.isString(f)&&f[0]==='='&&(f=t._owner.evaluate(f),n.isPrimitive(f)||(f=f.value)),n.isString(e)&&e[0]==='='&&(e=t._owner.evaluate(e),n.isPrimitive(e)||(e=e.value)),f!==f&&(f=null),e!==e&&(e=null),n.isString(f)&&(f=f.toLowerCase()+f),n.isString(e)&&(e=e.toLowerCase()+e),s=f<e?-1:f>e?1:0,s!==0)return h.ascending?+s:-s}return 0}},u.prototype._createGrid=function(){var r=document.createElement('div'),n,u,f,e;for(this._isEmptyGrid=!0,r.style.visibility='hidden',document.body.appendChild(r),n=new t.FlexGrid(r),document.body.removeChild(r),e=0;e<this._rowCount;e++)n.rows.push(new t.Row);for(f=0;f<this._columnCount;f++)u=new t.Column,u.isRequired=!1,n.columns.push(u);return n.loadedRows.addHandler(function(){!n.itemsSource||n.rows[0]instanceof i.HeaderRow||n.rows.insert(0,new i.HeaderRow)}),n.wj_sheetInfo={name:this.name,visible:this.visible,styledCells:this._styledCells,mergedRanges:this._mergedRanges},n},u.prototype._clearGrid=function(){this._grid.rows.clear();this._grid.columns.clear();this._grid.columnHeaders.columns.clear();this._grid.rowHeaders.rows.clear()},u.prototype._gridItemsSourceChanged=function(){this._owner&&this._owner.selectedSheet&&this._name===this._owner.selectedSheet.name&&this._owner._copyFrom(this,!1)},u}(),u,f,r;i.Sheet=e;u=function(t){function i(){t.apply(this,arguments);this._current=-1;this.sheetCleared=new n.Event;this.selectedSheetChanged=new n.Event;this.sheetNameChanged=new n.Event;this.sheetVisibleChanged=new n.Event}return __extends(i,t),i.prototype.onSheetCleared=function(){this.sheetCleared.raise(this,new n.EventArgs)},Object.defineProperty(i.prototype,"selectedIndex",{get:function(){return this._current},set:function(n){this._moveCurrentTo(+n)},enumerable:!0,configurable:!0}),i.prototype.onSelectedSheetChanged=function(n){this.selectedSheetChanged.raise(this,n)},i.prototype.insert=function(n,i){var r;r=i.name?this.getValidSheetName(i):this._getUniqueName();r!==i.name&&(i.name=r);t.prototype.insert.call(this,n,i);this._postprocessSheet(i)},i.prototype.push=function(){for(var f,n,u,i=[],r=0;r<arguments.length;r++)i[+r]=arguments[r];for(f=this.length,n=0;n<i.length;n++)u=i[n].name?this.getValidSheetName(i[n]):this._getUniqueName(),u!==i[n].name&&(i[n].name=u),t.prototype.push.call(this,i[n]),this._postprocessSheet(i[n]);return this.length},i.prototype.splice=function(n,i,r){var u;return r?(u=r.name?this.getValidSheetName(r):this._getUniqueName(),u!==r.name&&(r.name=u),this._postprocessSheet(r),t.prototype.splice.call(this,n,i,r)):t.prototype.splice.call(this,n,i,r)},i.prototype.removeAt=function(n){var i=this.hide(n);i&&(t.prototype.removeAt.call(this,n),n<this.selectedIndex&&(this._current-=1))},i.prototype.onSheetNameChanged=function(n){this.sheetNameChanged.raise(this,n)},i.prototype.onSheetVisibleChanged=function(n){this.sheetVisibleChanged.raise(this,n)},i.prototype.selectFirst=function(){return this._moveCurrentTo(0)},i.prototype.selectLast=function(){return this._moveCurrentTo(this.length-1)},i.prototype.selectPrevious=function(){return this._moveCurrentTo(this._current-1)},i.prototype.selectNext=function(){return this._moveCurrentTo(this._current+1)},i.prototype.hide=function(n){return n<0&&n>=this.length?!1:this[n].visible?(this[n].visible=!1,!0):!1},i.prototype.show=function(n){return n<0&&n>=this.length?!1:(this[n].visible=!0,this._moveCurrentTo(n),!0)},i.prototype.clear=function(){t.prototype.clear.call(this);this._current=-1;this.onSheetCleared()},i.prototype.isValidSheetName=function(n){var t=this._getSheetIndexFrom(n.name),i=this.indexOf(n);return t===-1||t===i},i.prototype.getValidSheetName=function(n){var t=n.name,i=1,u=this.indexOf(n),r;do{if(r=this._getSheetIndexFrom(t),r===-1||r===u)break;else t=n.name.concat((i+1).toString());i=i+1}while(1);return t},i.prototype._moveCurrentTo=function(t){var i=t,r;if(t<0||t>=this.length)return!1;if(this._current<i||i===0)while(i<this.length&&!this[i].visible)i++;else if(this._current>i)while(i>=0&&!this[i].visible)i--;if(i===this.length)for(i=t;i>=0&&!this[i].visible;)i--;if(i<0)return!1;if(i!==this._current){r=new n.PropertyChangedEventArgs('sheetIndex',this._current,i);this._current=i;this.onSelectedSheetChanged(r)}return!0},i.prototype._getSheetIndexFrom=function(n){var r=-1,i,u,t;if(!n)return r;for(n=n.toLowerCase(),t=0;t<this.length;t++)if(i=this[t],u=i.name?i.name.toLowerCase():'',u===n)return t;return r},i.prototype._postprocessSheet=function(t){var i=this;t.nameChanged.addHandler(function(){var r,u=i._getSheetIndexFrom(t.name);i.isValidSheetName(t)||t._setValidName(i.getValidSheetName(t));r=new n.collections.NotifyCollectionChangedEventArgs(n.collections.NotifyCollectionChangedAction.Change,t,n.isNumber(u)?u:i.length-1);i.onSheetNameChanged(r)});t.visibleChanged.addHandler(function(){var r=i._getSheetIndexFrom(t.name),u=new n.collections.NotifyCollectionChangedEventArgs(n.collections.NotifyCollectionChangedAction.Change,t,n.isNumber(r)?r:i.length-1);i.onSheetVisibleChanged(u)})},i.prototype._getUniqueName=function(){var n='Sheet1',t=0;do{if(this._getSheetIndexFrom(n)===-1)break;else n='Sheet'.concat((t+1).toString());t=t+1}while(1);return n},i}(n.collections.ObservableArray);i.SheetCollection=u;f=function(i){function r(n,t,r){i.call(this,n,r);this._rtl=!1;this._sheetTabClicked=!1;var u=this;u._owner=t;u._sheets=t.sheets;u._rtl=getComputedStyle(u._owner.hostElement).direction=='rtl';u.hostElement.attributes.tabindex&&u.hostElement.attributes.removeNamedItem('tabindex');u._initControl();u.deferUpdate(function(){r&&u.initialize(r)})}return __extends(r,i),r.prototype.refresh=function(){this._tabContainer.innerHTML='';this._tabContainer.innerHTML=this._getSheetTabs();this._rtl&&this._adjustSheetsPosition();this._adjustSize()},r.prototype._sourceChanged=function(t,i){i===void 0&&(i=n.collections.NotifyCollectionChangedEventArgs.reset);var r=i,u;switch(r.action){case n.collections.NotifyCollectionChangedAction.Add:u=r.index-1;u<0&&(u=0);this._tabContainer.innerHTML='';this._tabContainer.innerHTML=this._getSheetTabs();this._rtl&&this._adjustSheetsPosition();this._adjustSize();break;case n.collections.NotifyCollectionChangedAction.Remove:this._tabContainer.removeChild(this._tabContainer.children[r.index]);this._tabContainer.hasChildNodes()&&this._updateTabActive(r.index,!0);this._adjustSize();break;default:this.invalidate()}},r.prototype._selectedSheetChanged=function(n,t){this._updateTabActive(t.oldValue,!1);this._updateTabActive(t.newValue,!0);this._sheetTabClicked?this._sheetTabClicked=!1:this._scrollToActiveSheet(t.newValue,t.oldValue);this._adjustSize()},r.prototype._initControl=function(){var n=this;n.applyTemplate('',n.getTemplate(),{_sheetContainer:'sheet-container',_tabContainer:'container',_sheetPage:'sheet-page',_newSheet:'new-sheet'});n._rtl&&(n._sheetPage.style.right='0px',n._tabContainer.parentElement.style.right=n._sheetPage.clientWidth+'px',n._tabContainer.style.right='0px',n._tabContainer.style.cssFloat='right',n._newSheet.style.right=n._sheetPage.clientWidth+n._tabContainer.parentElement.clientWidth+'px');n._adjustNavigationButtons(n._rtl);n.addEventListener(n._newSheet,'click',function(){var t=n._owner.selectedSheetIndex;n._owner.addUnboundSheet();n._scrollToActiveSheet(n._owner.selectedSheetIndex,t)});n._sheets.collectionChanged.addHandler(n._sourceChanged,n);n._sheets.selectedSheetChanged.addHandler(n._selectedSheetChanged,n);n._sheets.sheetNameChanged.addHandler(n._updateSheetName,n);n._sheets.sheetVisibleChanged.addHandler(n._updateTabShown,n);n._initSheetPage();n._initSheetTab()},r.prototype._initSheetTab=function(){var n=this;n.addEventListener(n._tabContainer,'mousedown',function(t){var i=t.target,r;i instanceof HTMLLIElement&&(n._sheetTabClicked=!0,r=n._getItemIndex(n._tabContainer,i),n._scrollSheetTabContainer(i),r>-1&&(n._sheets.selectedIndex=r))})},r.prototype._initSheetPage=function(){var n=this;n.hostElement.querySelector('div.wj-sheet-page').addEventListener('click',function(t){var i=t.target.toString()==='[object HTMLButtonElement]'?t.target:t.target.parentElement,r=n._getItemIndex(n._sheetPage,i);if(n._sheets.length!==0)switch(r){case 0:n._sheets.selectFirst();break;case 1:n._sheets.selectPrevious();break;case 2:n._sheets.selectNext();break;case 3:n._sheets.selectLast()}})},r.prototype._getSheetTabs=function(){for(var t='',n=0;n<this._sheets.length;n++)t+=this._getSheetElement(this._sheets[n],this._sheets.selectedIndex===n);return t},r.prototype._getSheetElement=function(n,t){t===void 0&&(t=!1);var i='<li';return n.visible?t&&(i+=' class="active"'):i+=' class="hidden"',i+('>'+n.name+'</li>')},r.prototype._updateTabActive=function(t,i){t<0||t>=this._tabContainer.children.length||(i?n.addClass(this._tabContainer.children[t],'active'):n.removeClass(this._tabContainer.children[t],'active'))},r.prototype._updateTabShown=function(t,i){i.index<0||i.index>=this._tabContainer.children.length||(i.item.visible?n.removeClass(this._tabContainer.children[i.index],'hidden'):n.addClass(this._tabContainer.children[i.index],'hidden'),this._adjustSize())},r.prototype._adjustSize=function(){var u=this._tabContainer.childElementCount,n,i,t=0,r=0;if(this.hostElement.style.display!=='none'){for(r=this._tabContainer.parentElement.scrollLeft,this._tabContainer.parentElement.style.width='',this._tabContainer.style.width='',this._sheetPage.parentElement.style.width='',n=0;n<u;n++)t+=this._tabContainer.children[n].offsetWidth+1;i=this.hostElement.offsetWidth-this._sheetPage.offsetWidth-this._newSheet.offsetWidth-2;this._tabContainer.parentElement.style.width=(t>i?i:t)+'px';this._tabContainer.style.width=t+'px';this._sheetPage.parentElement.style.width=this._sheetPage.offsetWidth+this._newSheet.offsetWidth+this._tabContainer.parentElement.offsetWidth+3+'px';this._tabContainer.parentElement.scrollLeft=r}},r.prototype._getItemIndex=function(n,t){for(var i=0;i<n.children.length;i++)if(n.children[i]===t)return i;return-1},r.prototype._updateSheetName=function(n,t){this._tabContainer.querySelectorAll('li')[t.index].textContent=t.item.name;this._adjustSize()},r.prototype._scrollSheetTabContainer=function(n){var i=this._tabContainer.parentElement.scrollLeft,f=this._sheetPage.offsetWidth,e=this._newSheet.offsetWidth,r=this._tabContainer.parentElement.offsetWidth,u;if(this._rtl)switch(t.FlexGrid._getRtlMode()){case'rev':u=-this._tabContainer.offsetLeft;u+n.offsetLeft+n.offsetWidth>r+i?this._tabContainer.parentElement.scrollLeft+=n.offsetWidth:u+n.offsetLeft<i&&(this._tabContainer.parentElement.scrollLeft-=n.offsetWidth);break;case'neg':n.offsetLeft<i?this._tabContainer.parentElement.scrollLeft-=n.offsetWidth:n.offsetLeft+n.offsetWidth>r+i&&(this._tabContainer.parentElement.scrollLeft+=n.offsetWidth);break;default:n.offsetLeft-e+i<0?this._tabContainer.parentElement.scrollLeft+=n.offsetWidth:n.offsetLeft+n.offsetWidth-e+i>r&&(this._tabContainer.parentElement.scrollLeft-=n.offsetWidth)}else n.offsetLeft+n.offsetWidth-f>r+i?this._tabContainer.parentElement.scrollLeft+=n.offsetWidth:n.offsetLeft-f<i&&(this._tabContainer.parentElement.scrollLeft-=n.offsetWidth)},r.prototype._adjustSheetsPosition=function(){for(var t=this._tabContainer.querySelectorAll('li'),r=0,i,n=0;n<t.length;n++)i=t[n],i.style.cssFloat='right',i.style.right=r+'px',r+=t[n].clientWidth},r.prototype._scrollToActiveSheet=function(n,i){var u=this._tabContainer.querySelectorAll('li'),e,f,r;if(f=this._tabContainer.clientWidth>this._tabContainer.parentElement.clientWidth?this._tabContainer.clientWidth-this._tabContainer.parentElement.clientWidth:0,u.length>0&&n<u.length&&i<u.length){if(n===0&&!this._rtl||n===u.length-1&&this._rtl){if(this._rtl)switch(t.FlexGrid._getRtlMode()){case'rev':this._tabContainer.parentElement.scrollLeft=0;break;case'neg':this._tabContainer.parentElement.scrollLeft=-f;break;default:this._tabContainer.parentElement.scrollLeft=f}else this._tabContainer.parentElement.scrollLeft=0;return}if(n===0&&this._rtl||n===u.length-1&&!this._rtl){if(this._rtl)switch(t.FlexGrid._getRtlMode()){case'rev':this._tabContainer.parentElement.scrollLeft=f;break;case'neg':this._tabContainer.parentElement.scrollLeft=0;break;default:this._tabContainer.parentElement.scrollLeft=0}else this._tabContainer.parentElement.scrollLeft=f;return}if(n>=i)for(r=i+1;r<=n;r++)e=u[r],this._scrollSheetTabContainer(e);else for(r=i-1;r>=n;r--)e=u[r],this._scrollSheetTabContainer(e)}},r.prototype._adjustNavigationButtons=function(t){var r=this.hostElement.querySelectorAll('.wj-sheet-page button'),i;r&&r.length===4&&(t?(i=r[0].querySelector('span'),n.removeClass(i,'wj-glyph-step-backward'),n.addClass(i,'wj-glyph-step-backward-rtl'),i=r[1].querySelector('span'),n.removeClass(i,'wj-glyph-left'),n.addClass(i,'wj-glyph-left-rtl'),i=r[2].querySelector('span'),n.removeClass(i,'wj-glyph-right'),n.addClass(i,'wj-glyph-right-rtl'),i=r[3].querySelector('span'),n.removeClass(i,'wj-glyph-step-forward'),n.addClass(i,'wj-glyph-step-forward-rtl')):(i=r[0].querySelector('span'),n.removeClass(i,'wj-glyph-step-backward-rtl'),n.addClass(i,'wj-glyph-step-backward'),i=r[1].querySelector('span'),n.removeClass(i,'wj-glyph-left-rtl'),n.addClass(i,'wj-glyph-left'),i=r[2].querySelector('span'),n.removeClass(i,'wj-glyph-right-rtl'),n.addClass(i,'wj-glyph-right'),i=r[3].querySelector('span'),n.removeClass(i,'wj-glyph-step-forward-rtl'),n.addClass(i,'wj-glyph-step-forward')))},r.controlTemplate='<div wj-part="sheet-container" class="wj-sheet" style="height:100%;position:relative"><div wj-part="sheet-page" class="wj-btn-group wj-sheet-page"><button type="button" class="wj-btn wj-btn-default"><span class="wj-sheet-icon wj-glyph-step-backward"><\/span><\/button><button type="button" class="wj-btn wj-btn-default"><span class="wj-sheet-icon wj-glyph-left"><\/span><\/button><button type="button" class="wj-btn wj-btn-default"><span class="wj-sheet-icon wj-glyph-right"><\/span><\/button><button type="button" class="wj-btn wj-btn-default"><span class="wj-sheet-icon wj-glyph-step-forward"><\/span><\/button><\/div><div class="wj-sheet-tab" style="height:100%;overflow:hidden"><ul wj-part="container"><\/ul><\/div><div wj-part="new-sheet" class="wj-new-sheet"><span class="wj-sheet-icon wj-glyph-file"><\/span><\/div><\/div>',r}(n.Control);i._SheetTabs=f;r=function(){function n(n,t){this._column=n;this._ascending=t}return Object.defineProperty(n.prototype,"column",{get:function(){return this._column},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"ascending",{get:function(){return this._ascending},enumerable:!0,configurable:!0}),n}();i._UnboundSortDescription=r})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(t){'use strict';var r=function(){function r(t){this._owner=t;this._sortDescriptions=new n.collections.CollectionView;this._committedList=[new i(-1,!0)];this._sortDescriptions.newItemCreator=function(){return new i(-1,!0)};this._refresh()}return Object.defineProperty(r.prototype,"sortDescriptions",{get:function(){return this._sortDescriptions},set:function(n){this._sortDescriptions=n;this.commitSort(!0);this._refresh()},enumerable:!0,configurable:!0}),r.prototype.addSortLevel=function(t,i){i===void 0&&(i=!0);var r=this._sortDescriptions.addNew();t!=null&&!isNaN(t)&&n.isInt(t)&&(r.columnIndex=t);r.ascending=i;this._sortDescriptions.commitNew()},r.prototype.deleteSortLevel=function(n){var t;t=n!=null?this._getSortItem(n):this._sortDescriptions.currentItem;t&&this._sortDescriptions.remove(t)},r.prototype.copySortLevel=function(){var n=this._sortDescriptions.currentItem,t;n&&(t=this._sortDescriptions.addNew(),t.columnIndex=parseInt(n.columnIndex),t.ascending=n.ascending,this._sortDescriptions.commitNew())},r.prototype.editSortLevel=function(n,t){n!=null&&(this._sortDescriptions.currentItem.columnIndex=n);t!=null&&(this._sortDescriptions.currentItem.ascending=t)},r.prototype.moveSortLevel=function(n){var t=this._sortDescriptions.currentItem;if(t){var i=this._sortDescriptions.sourceCollection,r=i.indexOf(t),u=r+n;r>-1&&u>-1&&(i.splice(r,1),i.splice(u,0,t),this._sortDescriptions.refresh(),this._sortDescriptions.moveCurrentTo(t))}},r.prototype.checkSortItemExists=function(n){for(var t=0,r=this._sortDescriptions.itemCount,i;t<r;t++)if(i=this._sortDescriptions.items[t],+i.columnIndex===n)return t;return-1},r.prototype.commitSort=function(r){var v=this,u,o,s,h,f,c,l,e,a;if(r===void 0&&(r=!0),a=this._owner.itemsSource&&this._owner.itemsSource instanceof n.collections.CollectionView,this._owner.selectedSheet){if(c=this._owner.selectedSheet._unboundSortDesc,r&&(l=new t._SortColumnAction(this._owner)),this._committedList=this._sortDescriptions.itemCount>0?this._sortDescriptions.items.slice():[new i(-1,!0)],this._owner.collectionView){for(e=this._scanUnboundRows(),this._owner.collectionView.beginUpdate(),this._owner.selectedSheet.grid.collectionView.beginUpdate(),s=this._owner.collectionView.sortDescriptions,s.clear(),a===!1&&(h=this._owner.selectedSheet.grid.collectionView.sortDescriptions,h.clear()),f=0;f<this._sortDescriptions.itemCount;f++)u=this._sortDescriptions.items[f],u.columnIndex>-1&&(o=new n.collections.SortDescription(this._owner.columns[u.columnIndex].binding,u.ascending),s.push(o),a===!1&&h.push(o));this._owner.collectionView.endUpdate();this._owner.selectedSheet.grid.collectionView.endUpdate();e&&Object.keys(e).forEach(function(n){v._owner.rows.splice(+n,0,e[n])})}else for(c.clear(),f=0;f<this._sortDescriptions.itemCount;f++)u=this._sortDescriptions.items[f],u.columnIndex>-1&&c.push(new t._UnboundSortDescription(this._owner.columns[u.columnIndex],u.ascending));r&&(l.saveNewState(),this._owner.undoStack._addAction(l))}},r.prototype.cancelSort=function(){this._sortDescriptions.sourceCollection=this._committedList.slice();this._refresh()},r.prototype._refresh=function(){var r=[],n,t;if(this._owner.selectedSheet){if(this._owner.collectionView&&this._owner.collectionView.sortDescriptions.length>0)for(n=0;n<this._owner.collectionView.sortDescriptions.length;n++)t=this._owner.collectionView.sortDescriptions[n],r.push(new i(this._getColumnIndex(t.property),t.ascending));else if(this._owner.selectedSheet&&this._owner.selectedSheet._unboundSortDesc.length>0)for(n=0;n<this._owner.selectedSheet._unboundSortDesc.length;n++)t=this._owner.selectedSheet._unboundSortDesc[n],r.push(new i(t.column.index,t.ascending));else r.push(new i(-1,!0));this._sortDescriptions.sourceCollection=r}},r.prototype._getColumnIndex=function(n){for(var t=0,i=this._owner.columns.length;t<i;t++)if(this._owner.columns[t].binding===n)return t;return-1},r.prototype._getSortItem=function(n){var t=this.checkSortItemExists(n);return t>-1?this._sortDescriptions.items[t]:undefined},r.prototype._scanUnboundRows=function(){for(var i,r,n=0;n<this._owner.rows.length;n++)i=this._owner.rows[n],i.dataItem||i instanceof t.HeaderRow||(r||(r={}),r[n]=i);return r},r}(),i;t.SortManager=r;i=function(){function n(n,t){this._columnIndex=n;this._ascending=t}return Object.defineProperty(n.prototype,"columnIndex",{get:function(){return this._columnIndex},set:function(n){this._columnIndex=n},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"ascending",{get:function(){return this._ascending},set:function(n){this._ascending=n},enumerable:!0,configurable:!0}),n}();t.ColumnSortDescription=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(){function i(i){this.MAX_STACK_SIZE=500;this._stack=[];this._pointer=-1;this._resizingTriggered=!1;this.undoStackChanged=new n.Event;var r=this;r._owner=i;r._owner.prepareCellForEdit.addHandler(r._initCellEditAction,r);r._owner.cellEditEnded.addHandler(function(){r._pendingAction instanceof t._EditAction&&!r._pendingAction.isPaste&&r._afterProcessCellEditAction(r)},r);r._owner.pasting.addHandler(r._initCellEditActionForPasting,r);r._owner.pastingCell.addHandler(function(n,i){r._pendingAction instanceof t._EditAction&&r._pendingAction.updateForPasting(i.range)},r);r._owner.pasted.addHandler(function(){r._pendingAction instanceof t._EditAction&&r._pendingAction.isPaste&&r._afterProcessCellEditAction(r)},r);r._owner.resizingColumn.addHandler(function(n,i){r._resizingTriggered||(r._pendingAction=new t._ColumnResizeAction(r._owner,i.panel,i.col),r._resizingTriggered=!0)},r);r._owner.resizedColumn.addHandler(function(){r._pendingAction instanceof t._ColumnResizeAction&&r._pendingAction.saveNewState()&&r._addAction(r._pendingAction);r._pendingAction=null;r._resizingTriggered=!1},r);r._owner.resizingRow.addHandler(function(n,i){r._resizingTriggered||(r._pendingAction=new t._RowResizeAction(r._owner,i.panel,i.row),r._resizingTriggered=!0)},r);r._owner.resizedRow.addHandler(function(){r._pendingAction instanceof t._RowResizeAction&&r._pendingAction.saveNewState()&&r._addAction(r._pendingAction);r._pendingAction=null;r._resizingTriggered=!1},r);r._owner.draggingRowColumn.addHandler(function(n,i){i.isShiftKey&&(r._pendingAction=i.isDraggingRows?new t._RowsChangedAction(r._owner):new t._ColumnsChangedAction(r._owner))},r);r._owner.droppingRowColumn.addHandler(function(){r._pendingAction&&r._pendingAction.saveNewState()&&r._addAction(r._pendingAction);r._pendingAction=null},r)}return Object.defineProperty(i.prototype,"canUndo",{get:function(){return this._pointer>-1&&this._pointer<this._stack.length},enumerable:!0,configurable:!0}),Object.defineProperty(i.prototype,"canRedo",{get:function(){return this._pointer+1>-1&&this._pointer+1<this._stack.length},enumerable:!0,configurable:!0}),i.prototype.onUndoStackChanged=function(){this.undoStackChanged.raise(this)},i.prototype.undo=function(){var n;this.canUndo&&(n=this._stack[this._pointer],this._beforeUndoRedo(n),n.undo(),this._pointer--,this.onUndoStackChanged())},i.prototype.redo=function(){var n;this.canRedo&&(this._pointer++,n=this._stack[this._pointer],this._beforeUndoRedo(n),n.redo(),this.onUndoStackChanged())},i.prototype._addAction=function(n){this._stack.length>0&&this._stack.length>this._pointer+1&&this._stack.splice(this._pointer+1,this._stack.length-this._pointer-1);this._stack.length>=this.MAX_STACK_SIZE&&this._stack.splice(0,this._stack.length-this.MAX_STACK_SIZE+1);this._pointer=this._stack.length;this._stack.push(n);this.onUndoStackChanged()},i.prototype.clear=function(){this._stack.length=0},i.prototype._initCellEditAction=function(n,i){this._pendingAction=new t._EditAction(this._owner,i.range)},i.prototype._initCellEditActionForPasting=function(){this._pendingAction=new t._EditAction(this._owner);this._pendingAction.markIsPaste()},i.prototype._afterProcessCellEditAction=function(n){n._pendingAction instanceof t._EditAction&&n._pendingAction.saveNewState()&&n._addAction(this._pendingAction);n._pendingAction=null},i.prototype._beforeUndoRedo=function(n){this._owner.selectedSheetIndex=n.sheetIndex},i}();t.UndoStack=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(n){function i(){n.apply(this,arguments)}return __extends(i,n),i.prototype.apply=function(n){var i=this.column.grid;return(i instanceof t.FlexSheet)?!this.showValues||!Object.keys(this.showValues).length?!0:(n=i.getCellValue(n,this.column.index,!0),this.showValues[n]!=undefined):!1},i}(n.grid.filter.ValueFilter);t._FlexSheetValueFilter=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(n){function i(){n.apply(this,arguments)}return __extends(i,n),i.prototype.updateEditor=function(){var h=this.filter.column,r=h.grid,f=h.index,u=[],l={},c,e,a,v,y,p,o,s,w,i;if(this.filter.uniqueValues){n.prototype.updateEditor.call(this);return}for(i=0;i<r.rows.length;i++)(y=this.filter.apply(i),v=this.filter.showValues,this.filter.showValues=null,p=r._filter._filter(i),this.filter.showValues=v,e=r.getMergedRange(r.cells,i,f),e&&(i!==e.topRow||f!==e.leftCol))||(c=r.rows[i],c instanceof t.HeaderRow||!c.isVisible&&(y||!p))||(a=r.getCellValue(i,f),o=r.getCellValue(i,f,!0),l[o]||(l[o]=!0,u.push({value:a,text:o})));if(s=this.filter.showValues,s&&Object.keys(s).length!=0){for(w in s)for(i=0;i<u.length;i++)if(u[i].text==w){u[i].show=!0;break}}else for(i=0;i<u.length;i++)u[i].show=!0;this._lbValues.isContentHtml=h.isContentHtml;this._cmbFilter.text=this.filter.filterText;this._filterText=this._cmbFilter.text.toLowerCase();this._view.pageSize=this.filter.maxValues;this._view.sourceCollection=u;this._view.moveCurrentToPosition(-1)},i}(n.grid.filter.ValueFilterEditor);t._FlexSheetValueFilterEditor=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(i){function r(){i.apply(this,arguments)}return __extends(r,i),r.prototype.apply=function(i){var u=this.column,h=u.grid,f=this.condition1,e=this.condition2,r,o,s,c,l;return(h instanceof t.FlexSheet)?this.isActive?(r=h.getCellValue(i,u.index),o=s=r,u.dataMap?(r=u.dataMap.getDisplayValue(r),o=s=r):n.isDate(r)?(n.isString(f.value)||n.isString(e.value))&&(r=h.getCellValue(i,u.index,!0),o=s=r):n.isNumber(r)&&(r=n.Globalize.parseFloat(h.getCellValue(i,u.index,!0)),o=s=r,r!==0||u.dataType||(f.isActive&&f.value===''&&(o=null),e.isActive&&e.value===''&&(s=null))),c=f.apply(o),l=e.apply(s),f.isActive&&e.isActive?this.and?c&&l:c||l:f.isActive?c:e.isActive?l:!0):!0:!1},r}(n.grid.filter.ConditionFilter);t._FlexSheetConditionFilter=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(n){function i(i,r){n.call(this,i,r);this._valueFilter=new t._FlexSheetValueFilter(r);this._conditionFilter=new t._FlexSheetConditionFilter(r)}return __extends(i,n),i}(n.grid.filter.ColumnFilter);t._FlexSheetColumnFilter=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(t){'use strict';var i=function(i){function r(n,t,r){r===void 0&&(r=!0);i.call(this,n,t,r);var e=this,u,f;r&&(this._divSort.style.display='');u=this.cloneElement(this._btnAsc);f=this.cloneElement(this._btnDsc);this._btnAsc.parentNode.replaceChild(u,this._btnAsc);this._btnDsc.parentNode.replaceChild(f,this._btnDsc);u.addEventListener('click',function(n){e._sortBtnClick(n,!0)});f.addEventListener('click',function(n){e._sortBtnClick(n,!1)})}return __extends(r,i),r.prototype._showFilter=function(r){r==n.grid.filter.FilterType.Value&&this._edtVal==null&&(this._edtVal=new t._FlexSheetValueFilterEditor(this._divEdtVal,this.filter.valueFilter));i.prototype._showFilter.call(this,r)},r.prototype._sortBtnClick=function(n,t){var u=this.filter.column,i=u.grid.sortManager,r,f,e;n.preventDefault();n.stopPropagation();r=i.checkSortItemExists(u.index);r>-1?(i.sortDescriptions.moveCurrentToPosition(r),e=i.sortDescriptions.currentItem,e.ascending=t,f=-r):(i.addSortLevel(u.index,t),f=-(i.sortDescriptions.items.length-1));i.moveSortLevel(f);i.commitSort();this.updateEditor();this.onButtonClicked()},r.prototype.cloneElement=function(n){for(var t=n.cloneNode();n.firstChild;)t.appendChild(n.lastChild);return t},r}(n.grid.filter.ColumnFilterEditor);t._FlexSheetColumnFilterEditor=i})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(n,t){function r(){this.constructor=n}for(var i in t)t.hasOwnProperty(i)&&(n[i]=t[i]);n.prototype=t===null?Object.create(t):(r.prototype=t.prototype,new r)},function(n){var t;(function(t){var i;(function(i){'use strict';var r=function(r){function u(){r.apply(this,arguments)}return __extends(u,r),Object.defineProperty(u.prototype,"filterDefinition",{get:function(){for(var n,t,u,i={defaultFilterType:this.defaultFilterType,filters:[]},r=0;r<this._filters.length;r++)n=this._filters[r],n&&n.column&&(n.conditionFilter.isActive?(t=n.conditionFilter,i.filters.push({columnIndex:n.column.index,type:'condition',condition1:{operator:t.condition1.operator,value:t.condition1.value},and:t.and,condition2:{operator:t.condition2.operator,value:t.condition2.value}})):n.valueFilter.isActive&&(u=n.valueFilter,i.filters.push({columnIndex:n.column.index,type:'value',filterText:u.filterText,showValues:u.showValues})));return JSON.stringify(i)},set:function(t){var e=JSON.parse(n.asString(t)),f,r,s;for(this.clear(),this.defaultFilterType=e.defaultFilterType,f=0;f<e.filters.length;f++){var i=e.filters[f],u=this.grid.columns[i.columnIndex],o=this.getColumnFilter(u,!0);if(o)switch(i.type){case'condition':r=o.conditionFilter;r.condition1.value=u.dataType==n.DataType.Date?n.changeType(i.condition1.value,u.dataType,null):i.condition1.value;r.condition1.operator=i.condition1.operator;r.and=i.and;r.condition2.value=u.dataType==n.DataType.Date?n.changeType(i.condition2.value,u.dataType,null):i.condition2.value;r.condition2.operator=i.condition2.operator;break;case'value':s=o.valueFilter;s.filterText=i.filterText;s.showValues=i.showValues}}this.apply()},enumerable:!0,configurable:!0}),u.prototype.apply=function(){var n=this;n.grid.deferUpdate(function(){for(var r,t=0;t<n.grid.rows.length;t++)(r=n.grid.rows[t],r instanceof i.HeaderRow)||(r.visible=n._filter(t))})},u.prototype.editColumnFilter=function(r,u){var o=this,f;this.closeEditor();r=n.isString(r)?this.grid.columns.getColumn(r):n.asType(r,t.Column,!1);f=new t.CellRangeEventArgs(this.grid.cells,new t.CellRange(-1,r.index));this.onFilterChanging(f);if(!f.cancel){f.cancel=!0;var e=document.createElement('div'),a=this.getColumnFilter(r),h=new i._FlexSheetColumnFilterEditor(e,a,this.showSortButtons);n.addClass(e,'wj-dropdown-panel');this.grid._rtl&&(e.dir='rtl');h.filterChanged.addHandler(function(){f.cancel=!1;setTimeout(function(){f.cancel||o.apply()})});h.buttonClicked.addHandler(function(){o.closeEditor();o.onFilterChanged(f)});h.lostFocus.addHandler(function(){setTimeout(function(){var t=n.Control.getControl(o._divEdt);t&&!t.containsFocus()&&o.closeEditor()},10)});var l=this.grid.columnHeaders,v=u?u.row:l.rows.length-1,y=u?u.col:r.index,s=l.getCellBoundingRect(v,y),c=document.elementFromPoint(s.left+s.width/2,s.top+s.height/2);c=n.closest(c,'.wj-cell');c?n.showPopup(e,c,!1,!1,!1):n.showPopup(e,s);h.focus();this._divEdt=e;this._edtCol=r}},u.prototype.getColumnFilter=function(r,u){var f,e;if(u===void 0&&(u=!0),n.isString(r)?r=this.grid.columns.getColumn(r):n.isNumber(r)&&(r=this.grid.columns[r]),!r)return null;for(r=n.asType(r,t.Column),f=0;f<this._filters.length;f++)if(this._filters[f].column==r)return this._filters[f];return u?(e=new i._FlexSheetColumnFilter(this,r),this._filters.push(e),e):null},u}(n.grid.filter.FlexGridFilter);i._FlexSheetFilter=r})(i=t.sheet||(t.sheet={}))})(t=n.grid||(n.grid={}))}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var wijmo;(function(n){var t;(function(t){var i;(function(i){'use strict';var r=function(){function i(){}return i.export=function(t,i){n._deprecated('FlexGridXlsxConverter.export','FlexGridXlsxConverter.save');var r=this.toWorkbookOM(t,i);return n.xlsx.XlsxConverter.export(r)},i.import=function(t,i,r,u){n._deprecated('FlexGridXlsxConverter.import','FlexGridXlsxConverter.load');var f=n.xlsx.XlsxConverter.import(t);this.fromWorkbookOM(f,i,r,u)},i.toWorkbookOM=function(t,i){n._deprecated('FlexGridXlsxConverter.toWorkbookOM','FlexGridXlsxConverter.save');var r={sheets:[],creator:'',created:new Date,lastModifiedBy:'',modified:new Date,activeWorksheet:0},u,f;if(i&&i.activeWorksheet!=null&&i.activeWorksheet>0&&(r.activeWorksheet=i.activeWorksheet),n.isArray(t))for(u=0;u<t.length;u++)f=t[u],this._exportFlexGrid(f,r,i);else this._exportFlexGrid(t,r,i);return r},i.fromWorkbookOM=function(i,r,u,f){n._deprecated('FlexGridXlsxConverter.fromWorkbookOM','FlexGridXlsxConverter.load');var ui=u?u.includeColumnHeader:!0,p=u?u.includeColumnHeader:!0,dt=1,g=0,e=0,h=0,it,rt,v,ut,b,w,ft,pt,nt,gt,s,l,ni,k,et,c,ot,st,ti,wt,a,ht,d,y,ii,ct,o,bt,kt,lt,ri,tt,at=!1,vt={},yt;if(r.itemsSource=null,r.columns.clear(),r.rows.clear(),r.frozenColumns=0,r.frozenRows=0,i.sheets.length!==0)for(f&&(dt=i.sheets.length);g<dt;g++){for(bt={},kt={},h=0,ut=[],lt=[],l=i.sheets[g],ui&&(h=1,l.rows.length<=1&&(p=!1,h=0),pt=l.rows[0]),k=this._getColumnCount(l.rows),ni=this._getRowCount(l.rows,k),ti=l.summaryBelow,g>0&&(ii=document.createElement('div'),r=new t.FlexGrid(ii)),v=l.columns||l.cols,e=0;e<k;e++)r.columns.push(new t.Column),!v[e]||(isNaN(+v[e].width)||(r.columns[e].width=+v[e].width),v[e].visible||v[e].visible==undefined||(r.columns[e].visible=!!v[e].visible),v[e].style&&!!v[e].style.wordWrap&&(r.columns[e].wordWrap=v[e].style.wordWrap));for(;h<ni;h++){if(et=!1,yt=!0,s=l.rows[h],s)for(ot=h+1;ot<l.rows.length;)if(st=l.rows[ot],st){(isNaN(s.groupLevel)&&!isNaN(st.groupLevel)||!isNaN(s.groupLevel)&&s.groupLevel<st.groupLevel)&&(et=!0);break}else ot++;for(et&&!ti?(a&&(a.isCollapsed=at),a=new t.GroupRow,a.isReadOnly=!1,at=s.collapsed==null?!1:s.collapsed,a.level=isNaN(s.groupLevel)?0:s.groupLevel,vt[a.level]=at,this._checkParentCollapsed(vt,a.level)&&a._setFlag(t.RowColFlags.ParentCollapsed,!0),r.rows.push(a)):(wt=new t.Row,s&&this._checkParentCollapsed(vt,s.groupLevel)&&wt._setFlag(t.RowColFlags.ParentCollapsed,!0),r.rows.push(wt)),!s||!s.height||isNaN(s.height)||(r.rows[p?h-1:h].height=s.height),e=0;e<k;e++)if(s){if(c=s.cells[e],y=c?c.formula:undefined,y&&y[0]!=='='&&(y='='+y),y=y?this._parseToFlexSheetFormula(y):undefined,r.setCellData(p?h-1:h,e,y&&f?y:this._getItemValue(c)),!et&&c&&c.value!=null&&c.value!==''&&this._setColumn(ut,e,c),ct=h*k+e,o=c?c.style:undefined,o){if(yt=yt&&!!o.wordWrap,ri=this._getItemType(c),o.hAlign)tt=n.xlsx.Workbook._parseHAlignToString(n.asEnum(o.hAlign,n.xlsx.HAlign));else switch(ri){case n.DataType.Number:tt='right';break;case n.DataType.Boolean:tt='center';break;default:tt='left'}bt[ct]={fontWeight:o.font&&o.font.bold?'bold':'none',fontStyle:o.font&&o.font.italic?'italic':'none',textDecoration:o.font&&o.font.underline?'underline':'none',textAlign:tt,fontFamily:o.font&&o.font.family?o.font.family:'',fontSize:o.font&&o.font.size?o.font.size+'px':'',color:o.font&&o.font.color?o.font.color:'',backgroundColor:o.fill&&o.fill.color?o.fill.color:'',format:n.xlsx.Workbook._parseExcelFormat(c)};o.font&&lt.indexOf(o.font.family)===-1&&lt.push(o.font.family)}if(c&&n.isNumber(c.rowSpan)&&n.isNumber(c.colSpan))for(it=h;it<h+c.rowSpan;it++)for(rt=e;rt<e+c.colSpan;rt++)ct=it*k+rt,kt[ct]=new t.CellRange(h,e,h+c.rowSpan-1,e+c.colSpan-1)}else r.setCellData(p?h-1:h,e,''),this._setColumn(ut,e,undefined);s&&(this._checkParentCollapsed(vt,s.groupLevel)||s.visible||s.visible==undefined||(r.rows[p?h-1:h].visible=s.visible),r.rows[p?h-1:h].wordWrap=!!s.style&&!!s.style.wordWrap||yt)}for(a&&(a.isCollapsed=at),l.frozenPane&&(ht=l.frozenPane.columns,n.isNumber(ht)&&!isNaN(ht)&&(r.frozenColumns=ht),d=l.frozenPane.rows,n.isNumber(d)&&!isNaN(d)&&(r.frozenRows=p&&d>0?d-1:d)),e=0;e<r.columnHeaders.columns.length;e++)b=ut[e],w=r.columns[e],w.isRequired=!1,p?(nt=pt?pt.cells[e]:undefined,nt&&nt.value?(gt=n.xlsx.Workbook._parseExcelFormat(nt),ft=n.Globalize.format(nt.value,gt)):ft=this._numAlpha(e)):ft=this._numAlpha(e),w.header=ft,b&&(b.dataType===n.DataType.Boolean&&(w.dataType=b.dataType),w.format=b.format,w.align=b.hAlign,w.wordWrap=w.wordWrap||b.wordWrap);f&&(r.wj_sheetInfo={name:l.name,visible:l.visible!==!1,styledCells:bt,mergedRanges:kt,fonts:lt});f&&g>0&&f.push(r)}},i.save=function(i,r,u){var nt=new n.xlsx.Workbook,h=new n.xlsx.WorkSheet,tt=new n.xlsx.WorkbookFrozenPane,ft=r&&r.includeColumnHeaders!=null?r.includeColumnHeaders:!0,g=r&&r.includeRowHeaders!=null?r.includeRowHeaders:!1,w=r&&r.includeCellStyles!=null?r.includeCellStyles:!0,st=r?r.activeWorksheet:null,l=r?r.includeColumns:null,o,v,b,y,p,s,f,e,it,a,d,et,k,rt=0,ut=0,ot=0,c=0;if(it=i.wj_sheetInfo,h.name=r?r.sheetName:'',h.visible=r?r.sheetVisible!==!1:!0,h.style=new n.xlsx.WorkbookStyle,h.style.font=new n.xlsx.WorkbookFont,h.style.font.family='Arial',h.style.font.size=14,s=[],!it&&w&&(a=document.createElement('div'),a.style.visibility='hidden',i.hostElement.appendChild(a)),g){for(f=0;f<i.rowHeaders.rows.length;f++)for(s[f]=[],e=0;e<i.rowHeaders.columns.length;e++)b=i._getBindingColumn(i.rowHeaders,f,i.rowHeaders.columns[e]),y=this._getColumnSetting(b,i.columnHeaders.columns.defaultSize),s[f][e]=y,f===0&&(p=new n.xlsx.WorkbookColumn,p._deserialize(y),h._addWorkbookColumn(p,e));c=e}if(ft&&i.columnHeaders.rows.length>0){for(f=0;f<i.columnHeaders.rows.length;f++){for(s[f]||(s[f]=[]),e=0;e<i.columnHeaders.columns.length;e++)b=i._getBindingColumn(i.columnHeaders,f,i.columnHeaders.columns[e]),y=this._getColumnSetting(b,i.columnHeaders.columns.defaultSize),s[f][c+e]=y,f===0&&(!l||l(b))&&(p=new n.xlsx.WorkbookColumn,p._deserialize(y),h._addWorkbookColumn(p));c=0;o={};v=new n.xlsx.WorkbookRow;g&&(c=this._parseFlexGridRowToSheetRow(i.topLeftCells,o,f,0,s,w,a,!1,0,l));this._parseFlexGridRowToSheetRow(i.columnHeaders,o,f,c,s,w,a,!1,0,l);o.cells.length>0&&(v._deserialize(o),h._addWorkbookRow(v,f))}ut=f}else for(s[0]||(s[0]=[]),e=0;e<i.columnHeaders.columns.length;e++)b=i._getBindingColumn(i.columnHeaders,0,i.columnHeaders.columns[e]),y=this._getColumnSetting(b,i.columnHeaders.columns.defaultSize),s[0][c+e]=y,(!l||l(b))&&(p=new n.xlsx.WorkbookColumn,p._deserialize(y),h._addWorkbookColumn(p));for(f=0;f<i.cells.rows.length;f++)(c=0,o={},v=new n.xlsx.WorkbookRow,d=i.rows[f],d instanceof t._NewRowTemplate)||(k=d instanceof t.GroupRow,k&&(et=n.tryCast(d,t.GroupRow),rt=et.level+1),g&&(c=this._parseFlexGridRowToSheetRow(i.rowHeaders,o,f,0,s,w,a,k,rt,l)),this._parseFlexGridRowToSheetRow(i.cells,o,f,c,s,w,a,k,rt,l),o.cells.length>0&&(v._deserialize(o),h._addWorkbookRow(v,ut+f)));for(ot=i.cells.rows.length,f=0;f<i.columnFooters.rows.length;f++)c=0,o={},v=new n.xlsx.WorkbookRow,d=i.columnFooters.rows[f],k=d instanceof t.GroupRow,g&&(c=this._parseFlexGridRowToSheetRow(i.rowHeaders,o,f,0,s,w,a,k,0,l)),this._parseFlexGridRowToSheetRow(i.columnFooters,o,f,c,s,w,a,k,0,l),o.cells.length>0&&(v._deserialize(o),h._addWorkbookRow(v,ut+ot+f));return tt.rows=ft?i.frozenRows+i.columnHeaders.rows.length:i.frozenRows,tt.columns=g?i.frozenColumns+i.rowHeaders.columns.length:i.frozenColumns,h.frozenPane=tt,nt._addWorkSheet(h),!it&&w&&i.hostElement.removeChild(a),nt.activeWorksheet=st,u&&nt.save(u),nt},i.load=function(t,i,r){var u,f,e=this;if(i instanceof Blob)f=new FileReader,f.onload=function(){var i=n.xlsx.Workbook._base64EncArr(new Uint8Array(f.result));u=new n.xlsx.Workbook;u.load(i);e._loadToFlexGrid(t,u,r)},f.readAsArrayBuffer(i);else if(i instanceof n.xlsx.Workbook)e._loadToFlexGrid(t,i,r);else{if(i instanceof ArrayBuffer)i=n.xlsx.Workbook._base64EncArr(new Uint8Array(i));else if(!n.isString(i))throw'Invalid workbook.';u=new n.xlsx.Workbook;u.load(i);e._loadToFlexGrid(t,u,r)}},i._exportFlexGrid=function(i,r,u){var d=[],s=[],o={columns:[],rows:[],summaryBelow:!1},tt=u?u.includeColumnHeaders!=null?u.includeColumnHeaders:u.includeColumnHeader!=null?u.includeColumnHeader:!0:!0,b=u?u.includeRowHeaders!=null?u.includeRowHeaders:!1:!1,w=u?u.includeCellStyles!=null?u.includeCellStyles:u.needGetCellStyle!=null?u.needGetCellStyle:!0:!0,a=u?u.includeColumns:null,h,v,c,f,e,p,y,g,it,k,nt=0,rt=0,l=0;if(p=i.wj_sheetInfo,o.name=p?p.name:'',o.visible=p?p.visible!==!1:!0,o.style={font:{family:'Arial',size:14}},o.columns=[],!p&&w&&(y=document.createElement('div'),y.style.visibility='hidden',i.hostElement.appendChild(y)),b){for(f=0;f<i.rowHeaders.rows.length;f++)for(s[f]=[],o.columns[f]=[],e=0;e<i.rowHeaders.columns.length;e++)v=i._getBindingColumn(i.rowHeaders,f,i.rowHeaders.columns[e]),c=this._getColumnSetting(v,i.columnHeaders.columns.defaultSize),s[f][e]=c,o.columns[f][e]=c;l=e}if(tt&&i.columnHeaders.rows.length>0){for(f=0;f<i.columnHeaders.rows.length;f++){for(s[f]||(s[f]=[]),o.columns[f]||(o.columns[f]=[]),e=0;e<i.columnHeaders.columns.length;e++)v=i._getBindingColumn(i.rowHeaders,f,i.columnHeaders.columns[e]),c=this._getColumnSetting(v,i.columnHeaders.columns.defaultSize),s[f][l+e]=c,(!a||a(v))&&o.columns[f].push(c);l=0;h={};b&&(l=this._parseFlexGridRowToSheetRow(i.topLeftCells,h,f,0,s,w,y,!1,0,a));this._parseFlexGridRowToSheetRow(i.columnHeaders,h,f,l,s,w,y,!1,0,a);h.cells.length>0&&(d[f]=h)}rt=f}else for(s[0]||(s[0]=[]),o.columns[f]||(o.columns[f]=[]),e=0;e<i.columnHeaders.columns.length;e++)v=i.columnHeaders.columns[e],c=this._getColumnSetting(v,i.columnHeaders.columns.defaultSize),s[0][l+e]=c,(!a||a(v))&&o.columns[f].push(c);for(o.columns=s,f=0;f<i.cells.rows.length;f++)l=0,h={},g=i.rows[f],k=g instanceof t.GroupRow,k&&(it=n.tryCast(g,t.GroupRow),nt=it.level+1),b&&(l=this._parseFlexGridRowToSheetRow(i.rowHeaders,h,f,0,s,w,y,k,nt,a)),this._parseFlexGridRowToSheetRow(i.cells,h,f,l,s,w,y,k,nt,a),h.cells.length>0&&(d[rt+f]=h);o.rows=d;o.frozenPane={rows:tt?i.frozenRows+i.columnHeaders.rows.length:i.frozenRows,columns:b?i.frozenColumns+i.rowHeaders.columns.length:i.frozenColumns};r.sheets.push(o);!p&&w&&i.hostElement.removeChild(y)},i._loadToFlexGrid=function(i,r,u){var ti=u&&u.includeColumnHeaders!=null?u.includeColumnHeaders:!0,y=u&&u.includeColumnHeaders!=null?u.includeColumnHeaders:!0,vt=u&&u.sheetIndex!=null&&!isNaN(u.sheetIndex)?u.sheetIndex:0,ii=u?u.sheetName:null,ri=u?u.sheetVisible:!0,ui=u&&(u.sheetIndex!=null&&!isNaN(u.sheetIndex)||u.sheetName!=null||u.sheetVisible!=null),f=0,s=0,nt,tt,a,it,w,p,rt,yt,d,kt,o,c,dt,b,ut,h,ft,et,gt,pt,l,ot,k,v,st,e,wt,bt,ht,ni,g,ct=!1,lt={},at;if(i.itemsSource=null,i.columns.clear(),i.rows.clear(),i.frozenColumns=0,i.frozenRows=0,wt={},bt={},s=0,it=[],ht=[],vt<0||vt>=r.sheets.length)throw'The sheet index option is out of the sheet range of current workbook.';if(c=r.sheets[vt],c.rows!=null){for(ti&&(s=1,c.rows.length<=1&&(y=!1,s=0),yt=c.rows[0]),b=this._getColumnCount(c.rows),dt=this._getRowCount(c.rows,b),gt=c.summaryBelow,a=c.columns||c.cols,f=0;f<b;f++)i.columns.push(new t.Column),!a[f]||(isNaN(+a[f].width)||(i.columns[f].width=+a[f].width),a[f].visible||a[f].visible==undefined||(i.columns[f].visible=!!a[f].visible),a[f].style&&!!a[f].style.wordWrap&&(i.columns[f].wordWrap=a[f].style.wordWrap));for(;s<dt;s++){if(ut=!1,at=!0,o=c.rows[s],o)for(ft=s+1;ft<c.rows.length;)if(et=c.rows[ft],et){(isNaN(o.groupLevel)&&!isNaN(et.groupLevel)||!isNaN(o.groupLevel)&&o.groupLevel<et.groupLevel)&&(ut=!0);break}else ft++;for(ut&&!gt?(l&&(l.isCollapsed=ct),l=new t.GroupRow,l.isReadOnly=!1,ct=o.collapsed==null?!1:o.collapsed,l.level=isNaN(o.groupLevel)?0:o.groupLevel,lt[l.level]=ct,this._checkParentCollapsed(lt,l.level)&&l._setFlag(t.RowColFlags.ParentCollapsed,!0),i.rows.push(l)):(pt=new t.Row,o&&this._checkParentCollapsed(lt,o.groupLevel)&&pt._setFlag(t.RowColFlags.ParentCollapsed,!0),i.rows.push(pt)),!o||!o.height||isNaN(o.height)||(i.rows[y?s-1:s].height=o.height),f=0;f<b;f++)if(o){if(h=o.cells[f],v=h?h.formula:undefined,v&&v[0]!=='='&&(v='='+v),v=v?this._parseToFlexSheetFormula(v):undefined,i.setCellData(y?s-1:s,f,v&&ui?v:this._getItemValue(h)),ut||this._setColumn(it,f,h),st=s*b+f,e=h?h.style:undefined,e){if(at=at&&!!e.wordWrap,ni=this._getItemType(h),e.hAlign)g=n.xlsx.Workbook._parseHAlignToString(n.asEnum(e.hAlign,n.xlsx.HAlign));else switch(ni){case n.DataType.Number:g='right';break;case n.DataType.Boolean:g='center';break;default:g='left'}wt[st]={fontWeight:e.font&&e.font.bold?'bold':'none',fontStyle:e.font&&e.font.italic?'italic':'none',textDecoration:e.font&&e.font.underline?'underline':'none',textAlign:g,fontFamily:e.font&&e.font.family?e.font.family:'',fontSize:e.font&&e.font.size?e.font.size+'px':'',color:e.font&&e.font.color?e.font.color:'',backgroundColor:e.fill&&e.fill.color?e.fill.color:'',format:n.xlsx.Workbook._parseExcelFormat(h)};e.font&&ht.indexOf(e.font.family)===-1&&ht.push(e.font.family)}if(h&&n.isNumber(h.rowSpan)&&h.rowSpan>0&&n.isNumber(h.colSpan)&&h.colSpan>0&&(h.rowSpan>1||h.colSpan>1))for(nt=s;nt<s+h.rowSpan;nt++)for(tt=f;tt<f+h.colSpan;tt++)st=nt*b+tt,bt[st]=new t.CellRange(s,f,s+h.rowSpan-1,f+h.colSpan-1)}else i.setCellData(y?s-1:s,f,''),this._setColumn(it,f,undefined);o&&(this._checkParentCollapsed(lt,o.groupLevel)||o.visible||o.visible==undefined||(i.rows[y?s-1:s].visible=o.visible),i.rows[y?s-1:s].wordWrap=!!o.style&&!!o.style.wordWrap||at)}for(l&&(l.isCollapsed=ct),c.frozenPane&&(ot=c.frozenPane.columns,n.isNumber(ot)&&!isNaN(ot)&&(i.frozenColumns=ot),k=c.frozenPane.rows,n.isNumber(k)&&!isNaN(k)&&(i.frozenRows=y&&k>0?k-1:k)),f=0;f<i.columnHeaders.columns.length;f++)w=it[f],p=i.columns[f],p.isRequired=!1,y?(d=yt?yt.cells[f]:undefined,d&&d.value?(kt=n.xlsx.Workbook._parseExcelFormat(d),rt=n.Globalize.format(d.value,kt)):rt=this._numAlpha(f)):rt=this._numAlpha(f),p.header=rt,w&&(w.dataType===n.DataType.Boolean&&(p.dataType=w.dataType),p.format=w.format,p.align=w.hAlign,p.wordWrap=p.wordWrap||w.wordWrap);i.wj_sheetInfo={name:ii||c.name,visible:ri===!0?!0:c.visible!==!1,styledCells:wt,mergedRanges:bt,fonts:ht}}},i._parseFlexGridRowToSheetRow=function(t,i,r,u,f,e,o,s,h,c){var k,l,d,a,v,y,tt,ut,it,g,ot,w,b,ft,et,rt,p,ht=!1,st,nt,ct;for(k=t.grid,rt=k.wj_sheetInfo,l=t.rows[r],ct=l.recordIndex!=null?l.recordIndex:0,i.cells||(i.cells=[]),i.visible=l.isVisible,i.height=l.renderHeight||t.rows.defaultSize,i.groupLevel=s?h-1:h,s&&(i.collapsed=l.isCollapsed),l.wordWrap&&(i.style={wordWrap:l.wordWrap}),(l.constructor===n.grid.Row||l.constructor===n.grid._NewRowTemplate||n.grid.detail&&l.constructor===n.grid.detail.DetailRow||n.grid.multirow&&l.constructor===n.grid.multirow._MultiRow)&&(ht=!0),a=0;a<t.columns.length;a++)if(et=1,ft=1,nt=!1,st=k._getBindingColumn(t,r,t.columns[a]),b=null,rt&&t===k.cells?(ot=r*t.columns.length+a,rt.mergedRanges&&(b=rt.mergedRanges[ot]),rt.styledCells&&(w=rt.styledCells[ot])):e&&(w=this._getCellStyle(t,o,r,a)||{}),b||(b=k.getMergedRange(t,r,a,!1)),b?r===b.topRow&&a===b.leftCol&&(ft=b.bottomRow-b.topRow+1,et=this._getColSpan(t,b,c),nt=!0):nt=!0,!c||c(st))if(d=f[ct][a+u],ht||s?(y=nt?t.getCellData(r,a,!0):null,tt=nt?t.getCellData(r,a,!1):null,it=!1,y&&n.isString(y)&&y.length>1&&y[0]==='='&&(it=!0),p=n.isDate(tt),v=w&&w.format?n.xlsx.Workbook._parseCellFormat(w.format,p):d&&d.style&&d.style.format?n.xlsx.Workbook._parseCellFormat(d.style.format,p):null,v||(p?v='m/d/yyyy':n.isNumber(tt)&&!st.dataMap?v=n.isInt(tt)?'#,##0':'#,##0.00':it?(g=y.toLowerCase(),g==='=now()'?(v='m/d/yyyy h:mm',p=!0):g==='=today()'||g.substring(0,g.indexOf('('))==='=date'?(v='m/d/yyyy',p=!0):g.substring(0,g.indexOf('('))==='=time'&&(v='h:mm AM/PM',p=!0)):v='General')):(y=nt?k.columnHeaders.getCellData(0,a,!0):null,v='General'),t===k.cells&&s&&l.hasChildren&&a===k.columns.firstVisibleIndex){if(y?ut=y:nt&&(ut=l.getGroupHeader().replace(/<\/?\w+>/g,'')),ut==null&&!w)continue;p=n.isDate(ut);i.cells.push({value:ut,isDate:p,formula:it?this._parseToExcelFormula(y,p):null,colSpan:et,rowSpan:ft,style:this._extend(this._parseCellStyle(w),{format:v,font:{bold:!0},hAlign:n.xlsx.HAlign.Left,indent:h-1})})}else i.cells.push({value:it?undefined:v==='General'?y:tt,isDate:p,formula:it?this._parseToExcelFormula(y,p):null,colSpan:et,rowSpan:ft,style:this._extend(this._parseCellStyle(w),{format:v,hAlign:w&&w.textAlign?n.xlsx.Workbook._parseStringToHAlign(w.textAlign):n.isDate(tt)&&d.style.hAlign==null?n.xlsx.HAlign.Left:n.asEnum(d.style.hAlign,n.xlsx.HAlign,!0),vAlign:ft>1?t===k.cells?n.xlsx.VAlign.Top:n.xlsx.VAlign.Center:null})});return u+a},i._parseCellStyle=function(t){var i=t&&t.fontSize?+t.fontSize.substring(0,t.fontSize.indexOf('px')):null;return isNaN(i)&&(i=null),{font:{bold:t&&t.fontWeight&&(t.fontWeight==='bold'||!isNaN(+t.fontWeight)&&+t.fontWeight>=700),italic:t&&t.fontStyle&&t.fontStyle==='italic',underline:t&&t.textDecoration&&t.textDecoration==='underline',family:t?this._parseToExcelFontFamily(t.fontFamily):null,size:i,color:t&&t.color?t.color:null},fill:{color:t&&t.backgroundColor?t.backgroundColor:null},borders:t?this._parseBorder(t):null,hAlign:t&&t.textAlign?n.xlsx.Workbook._parseStringToHAlign(t.textAlign):null}},i._parseBorder=function(n){var t,i;for(var r in{Left:0,Right:0,Top:0,Bottom:0})i=this._parseEgdeBorder(n,r),i&&(t||(t={}),t[r.toLowerCase()]=i);return t},i._parseEgdeBorder=function(t,i){var r,f='border'+i+'Color',u=t['border'+i+'Style'],e;if(u&&u!=='none'&&u!=='hidden'){r={};u=u.toLowerCase();switch(u){case'dotted':r.style=n.xlsx.BorderStyle.Dotted;break;case'dashed':r.style=n.xlsx.BorderStyle.Dashed;break;case'double':r.style=n.xlsx.BorderStyle.Double;break;default:r.style=n.xlsx.BorderStyle.Thin}t[f]&&(e=new n.Color(t[f]),r.color=e.toString())}return r},i._parseToExcelFontFamily=function(n){var t;return n?(t=n.split(','),t&&t.length>0&&(n=t[0].replace(/\"|\'/g,''))):n='Arial',n},i._parseToExcelFormula=function(t,i){var u=t.substring(1,t.indexOf('(')).toLowerCase(),r;switch(u){case'ceiling':case'floor':t=t.substring(0,t.lastIndexOf(')'))+', 1)';break;case'text':r=t.substring(t.lastIndexOf(','),t.lastIndexOf('\"'));r=n.xlsx.Workbook._parseCellFormat(r.substring(r.lastIndexOf('\"')+1),i);t=t.substring(0,t.lastIndexOf(',')+1)+'\"'+r+'\")'}return t},i._parseToFlexSheetFormula=function(t){var u=t.substring(1).match(/\W+(\w+)\(/),r,f,e,o,i;f=u&&u.length===2?u[1]:t.substring(1,t.indexOf('('));e=t.indexOf(f);switch(f.toLowerCase()){case'ceiling':case'floor':t=t.substring(0,t.lastIndexOf(','))+')';break;case'text':r=t.substring(e);i=r.substring(r.indexOf('\"'),r.lastIndexOf('\"'));i=i.substring(i.lastIndexOf('\"')+1);o=i.indexOf('0')>-1?0:'';i=n.xlsx.Workbook._parseExcelFormat({value:o,style:{format:i}});i=i.replace(/m+/g,function(n){return n.toUpperCase()}).replace(/Y+/g,function(n){return n.toLowerCase()}).replace(/M+:?|:?M+/gi,function(n){return n.indexOf(':')>-1?n.toLowerCase():n});t=t.substring(0,e)+r.substring(0,r.indexOf('\"')+1)+i+'\")'}return t},i._getColumnSetting=function(t,i){var r=t.renderWidth;return r=r||i,{autoWidth:!0,width:r,visible:t.visible,style:{format:t.format?n.xlsx.Workbook._parseCellFormat(t.format,t.dataType===n.DataType.Date):'',hAlign:n.xlsx.Workbook._parseStringToHAlign(this._toExcelHAlign(t.getAlignment())),wordWrap:t.wordWrap}}},i._toExcelHAlign=function(n){return(n=n?n.trim().toLowerCase():n,!n)?n:n.indexOf('center')>-1?'center':n.indexOf('right')>-1||n.indexOf('end')>-1?'right':n.indexOf('justify')>-1?'justify':'left'},i._getColumnCount=function(t){for(var f=0,i=0,r,u=0;u<t.length;u++)r=t[u]&&t[u].cells?t[u].cells:[],r&&r.length>0&&(i=r.length,n.isInt(r[i-1].colSpan)&&r[i-1].colSpan>1&&(i=i+r[i-1].colSpan-1),i>f&&(f=i));return f},i._getRowCount=function(t,i){for(var f=t.length,u=f-1,o=0,e,s,r;o<i;o++)n:for(;u>=0;u--)if(e=t[u],s=e&&e.cells?e.cells:[],r=s[o],r&&(r.value!=null&&r.value!==''||n.isInt(r.rowSpan)&&r.rowSpan>1)){n.isInt(r.rowSpan)&&r.rowSpan>1&&u+r.rowSpan>f&&(f=u+r.rowSpan);break n}return f},i._numAlpha=function(n){var t=Math.floor(n/26)-1;return(t>-1?this._numAlpha(t):'')+String.fromCharCode(65+n%26)},i._getItemType=function(t){return t===undefined||t===null||t.value===undefined||t.value===null||isNaN(t.value)?undefined:n.getType(t.value)},i._setColumn=function(t,i,r){var f,e,o,u=t[i];u?(f=this._getItemType(r),u.dataType!==f&&u.dataType===n.DataType.Boolean&&f!==n.DataType.Boolean&&(u.dataType=f),r&&r.value!=null&&r.value!==''&&(e=n.xlsx.Workbook._parseExcelFormat(r),e&&u.format!==e&&e!=='General'&&(u.format=e)),r&&r.style&&(r.style.hAlign&&(o=n.xlsx.Workbook._parseHAlignToString(n.asEnum(r.style.hAlign,n.xlsx.HAlign))),u.wordWrap=u.wordWrap&&!!r.style.wordWrap),o||f!==n.DataType.Number||(o='right'),u.hAlign=o):t[i]={dataType:this._getItemType(r),format:n.xlsx.Workbook._parseExcelFormat(r),hAlign:'',wordWrap:!0}},i._getItemValue=function(t){if(t===undefined||t===null||t.value===undefined||t.value===null)return undefined;var i=t.value;return n.isNumber(i)&&isNaN(i)?'':i instanceof Date&&isNaN(i.getTime())?'':i},i._getCellStyle=function(n,t,i,r){try{this._resetCellStyle(t);n.grid.cellFactory.updateCell(n,i,r,t)}catch(u){return undefined}return window.getComputedStyle(t)},i._resetCellStyle=function(n){for(var t in n.style)typeof n.style[t]=='string'&&isNaN(+t)&&(n.style[t]='')},i._extend=function(t,i){var r,u;for(r in i)u=i[r],n.isObject(u)&&t[r]?n.copy(t[r],u):t[r]=u;return t},i._checkParentCollapsed=function(n,t){var i=!1;return Object.keys(n).forEach(function(r){n[r]===!0&&i===!1&&!isNaN(t)&&+r<t&&(i=!0)}),i},i._getColSpan=function(n,t,i){for(var u=0,r=t.leftCol;r<=t.rightCol;r++)(!i||i(n.columns[r]))&&u++;return u},i}();i.FlexGridXlsxConverter=r})(i=t.xlsx||(t.xlsx={}))})(t=n.grid||(n.grid={}))})(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var JSZip=window.JSZip,wijmo;typeof JSZip!='undefined'&&JSZip||typeof require!='function'||(JSZip=window.require('node-zip')),function(n){var t;(function(t){'use strict';function i(i){function si(n){var t=Math.floor(n/26)-1;return(t>-1?si(t):'')+au.charAt(n%26)}function ki(n){var t=0;return n.length===2&&(t=ki(n.charAt(0))+1),t*26+au.indexOf(n.substr(-1))}function vu(t){var i=new Date(1900,0,0),f=Object.prototype.toString.call(t)==="[object Date]",r=((f?t.getTimezoneOffset():(new Date).getTimezoneOffset())-i.getTimezoneOffset())*6e4,u;return f?(t.getTime()-i.getTime()-r)/864e5+1:n.isNumber(t)?(u=new Date(Math.round((+i+(t-1)*864e5)/1e3)*1e3),r=(u.getTimezoneOffset()-i.getTimezoneOffset())*6e4,r!==0)?new Date(Math.round((+i+r+(t-1)*864e5)/1e3)*1e3):u:null}function nf(n){return{}.toString.call(n).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function yu(n,t){var u,f,i,r=t?n.querySelector('fgColor'):n.querySelector('color');return r?(r.hasAttribute('rgb')?(i=r.getAttribute('rgb'),i&&i.length===8&&(i=i.substring(2))):r.hasAttribute('indexed')?(f=+r.getAttribute('indexed'),i=gu[f]||''):(u=+r.getAttribute('theme'),r.hasAttribute('tint')&&(i=+r.getAttribute('tint')),i=tf(u,i)),i&&i[0]==='#'?i:'#'+i):null}function tf(t,i){var f=ft[t],u,r;return i!=null?(u=new n.Color('#'+f),r=u.getHsl(),r[2]=i<0?r[2]*(1+i):r[2]*(1-i)+(1-1*(1-i)),u=n.Color.fromHsl(r[0],r[1],r[2]),u.toString().substring(1)):f}function ni(t){var i=new n.Color(t);return i.a<1&&(i=n.Color.toOpaque(i)),i.toString()}function rf(n){return typeof n=='string'?n.replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&quot;/g,'"').replace(/&#x27;/g,'\''):''}function uf(n){return n==null||isNaN(+n)?null:((+n-5)/7*100+.5)/100}function ff(n){return n==null||isNaN(+n)?null:(256*+n+128/7)/256*7}function ef(n){return n==null||isNaN(+n)?null:(+n*7+5)/7/1}function of(i){var u,r;for(u in{left:0,right:0,top:0,bottom:0,diagonal:0})r=i[u],r&&(r.color&&(r.color=ni(r.color)),r.style==null||n.isString(r.style)||(r.style=t.Workbook._parseBorderTypeToString(n.asEnum(r.style,t.BorderStyle,!1))))}function hi(n){var r,t,i;if(!n.basedOn)return n;for(t in n.basedOn)if(t==='basedOn'){r=hi(n.basedOn);for(t in r)i=r[t],n[t]=n[t]==null?i:ci(n[t],i)}else i=n.basedOn[t],n[t]=n[t]==null?i:ci(n[t],i);return delete n.basedOn,n}function sf(n){var r=n.querySelectorAll('sheetData>row>c>f[ref]'),t,f,i,u;if(li=[],r&&r.length>0)for(u=0;u<r.length;u++)t=r[u],f=t.getAttribute('si'),i=t.getAttribute('ref'),i=i?i.substring(0,i.indexOf(':')):'',t=t.textContent,li[+f]=hf(i,t)}function hf(n,i){var f=i.match(/(\'?\w+\'?\!)?(\$?[A-Za-z]+)(\$?\d+)/g),r,e,s,h,o,u;if(h=t.Workbook.tableAddress(n),f&&f.length>0)for(o=[],u=0;u<f.length;u++)r=f[u],i=i.replace(r,'{'+u+'}'),e=r.indexOf('!'),e>0&&(s=r.substring(0,e),r=r.substring(e+1)),o[u]={cellAddress:t.Workbook.tableAddress(r),sheetRef:s};return{cellRef:h,formula:i,formulaRefs:o}}function cf(n,i){var u,h,c,l,a,v,o,f,r,s,e;if(li&&li.length>0&&(u=li[+n],u)){if(o=u.formula,f=u.formulaRefs,f&&f.length>0)for(h=t.Workbook.tableAddress(i),c=h.row-u.cellRef.row,l=h.col-u.cellRef.col,e=0;e<f.length;e++)r=f[e],a=r.cellAddress.row+(r.cellAddress.absRow?0:c),v=r.cellAddress.col+(r.cellAddress.absCol?0:l),s=t.Workbook.xlsxAddress(a,v,r.cellAddress.absRow,r.cellAddress.absCol),r.sheetRef!=null&&r.sheetRef!==''&&(s=r.sheetRef+'!'+s),o=o.replace('{'+e+'}',s);return o}return''}function ci(t,i){var r,u;if(n.isObject(t)&&n.isObject(i)){for(r in i)u=i[r],n.isObject(u)&&t[r]!=null?ci(t[r],u):u!=null&&t[r]==null&&(t[r]=u);return t}return i}function lf(n){var i=Object.prototype.hasOwnProperty,t;if(n==null)return!0;if(n.length>0)return!1;if(n.length===0)return!0;for(t in n)if(i.call(n,t))return!1;return!0}function af(){var t=document.implementation.createDocument(vt,'Relationships',null),n=t.createElementNS(vt,'Relationship');return n.setAttribute('Id','rId3'),n.setAttribute('Type','http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties'),n.setAttribute('Target','docProps/app.xml'),t.documentElement.appendChild(n),n=t.createElementNS(vt,'Relationship'),n.setAttribute('Id','rId2'),n.setAttribute('Type','http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties'),n.setAttribute('Target','docProps/core.xml'),t.documentElement.appendChild(n),n=t.createElementNS(vt,'Relationship'),n.setAttribute('Id','rId1'),n.setAttribute('Type','http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument'),n.setAttribute('Target','xl/workbook.xml'),t.documentElement.appendChild(n),t}function vf(){var n=document.implementation.createDocument('','',null),t=n.createElement('a:theme'),i,r,u,f,e,o;return t.setAttribute('xmlns:a','http://schemas.openxmlformats.org/drawingml/2006/main'),t.setAttribute('name','Office Theme'),i=n.createElement('a:themeElements'),r=yf(n),i.appendChild(r),u=pf(n),i.appendChild(u),f=wf(n),i.appendChild(f),t.appendChild(i),e=n.createElement('a:objectDefaults'),t.appendChild(e),o=n.createElement('a:extraClrSchemeLst'),t.appendChild(o),n.appendChild(t),n}function yf(n){var r=n.createElement('a:clrScheme'),i,t;return r.setAttribute('name','Office'),i=n.createElement('a:dk1'),t=n.createElement('a:sysClr'),t.setAttribute('val','windowText'),t.setAttribute('lastClr','000000'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:lt1'),t=n.createElement('a:sysClr'),t.setAttribute('val','window'),t.setAttribute('lastClr','FFFFFF'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:dk2'),t=n.createElement('a:srgbClr'),t.setAttribute('val','1F497D'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:lt2'),t=n.createElement('a:srgbClr'),t.setAttribute('val','EEECE1'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:accent1'),t=n.createElement('a:srgbClr'),t.setAttribute('val','4F81BD'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:accent2'),t=n.createElement('a:srgbClr'),t.setAttribute('val','C0504D'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:accent3'),t=n.createElement('a:srgbClr'),t.setAttribute('val','9BBB59'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:accent4'),t=n.createElement('a:srgbClr'),t.setAttribute('val','8064A2'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:accent5'),t=n.createElement('a:srgbClr'),t.setAttribute('val','4BACC6'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:accent6'),t=n.createElement('a:srgbClr'),t.setAttribute('val','F79646'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:hlink'),t=n.createElement('a:srgbClr'),t.setAttribute('val','0000FF'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:folHlink'),t=n.createElement('a:srgbClr'),t.setAttribute('val','800080'),i.appendChild(t),r.appendChild(i),r}function pf(n){var r=n.createElement('a:fontScheme'),i,t;return r.setAttribute('name','Office'),i=n.createElement('a:majorFont'),t=n.createElement('a:latin'),t.setAttribute('typeface','Cambria'),i.appendChild(t),t=n.createElement('a:ea'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:cs'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Jpan'),t.setAttribute('typeface',' '),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hang'),t.setAttribute('typeface',' '),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hans'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hant'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Arab'),t.setAttribute('typeface','Times New Roman'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hebr'),t.setAttribute('typeface','Times New Roman'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hebr'),t.setAttribute('typeface','Times New Roman'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Thai'),t.setAttribute('typeface','Tahoma'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Ethi'),t.setAttribute('typeface','Nyala'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Beng'),t.setAttribute('typeface','Vrinda'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Gujr'),t.setAttribute('typeface','Shruti'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Khmr'),t.setAttribute('typeface','MoolBoran'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Knda'),t.setAttribute('typeface','Tunga'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Guru'),t.setAttribute('typeface','Raavi'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Cans'),t.setAttribute('typeface','Euphemia'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Cher'),t.setAttribute('typeface','Plantagenet Cherokee'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Yiii'),t.setAttribute('typeface','Microsoft Yi Baiti'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Tibt'),t.setAttribute('typeface','Microsoft Himalaya'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Thaa'),t.setAttribute('typeface','MV Boli'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Deva'),t.setAttribute('typeface','Mangal'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Telu'),t.setAttribute('typeface','Gautami'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Taml'),t.setAttribute('typeface','Latha'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Syrc'),t.setAttribute('typeface','Estrangelo Edessa'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Orya'),t.setAttribute('typeface','Kalinga'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Mlym'),t.setAttribute('typeface','Kartika'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Laoo'),t.setAttribute('typeface','DokChampa'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Sinh'),t.setAttribute('typeface','Iskoola Pota'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Mong'),t.setAttribute('typeface','Mongolian Baiti'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Viet'),t.setAttribute('typeface','Times New Roman'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Uigh'),t.setAttribute('typeface','Microsoft Uighur'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Geor'),t.setAttribute('typeface','Sylfaen'),i.appendChild(t),r.appendChild(i),i=n.createElement('a:minorFont'),t=n.createElement('a:latin'),t.setAttribute('typeface','Calibri'),i.appendChild(t),t=n.createElement('a:ea'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:cs'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Jpan'),t.setAttribute('typeface',' '),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hang'),t.setAttribute('typeface',' '),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hans'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hant'),t.setAttribute('typeface',''),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Arab'),t.setAttribute('typeface','Arial'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hebr'),t.setAttribute('typeface','Arial'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Hebr'),t.setAttribute('typeface','Times New Roman'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Thai'),t.setAttribute('typeface','Tahoma'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Ethi'),t.setAttribute('typeface','Nyala'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Beng'),t.setAttribute('typeface','Vrinda'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Gujr'),t.setAttribute('typeface','Shruti'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Khmr'),t.setAttribute('typeface','DaunPenh'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Knda'),t.setAttribute('typeface','Tunga'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Guru'),t.setAttribute('typeface','Raavi'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Cans'),t.setAttribute('typeface','Euphemia'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Cher'),t.setAttribute('typeface','Plantagenet Cherokee'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Yiii'),t.setAttribute('typeface','Microsoft Yi Baiti'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Tibt'),t.setAttribute('typeface','Microsoft Himalaya'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Thaa'),t.setAttribute('typeface','MV Boli'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Deva'),t.setAttribute('typeface','Mangal'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Telu'),t.setAttribute('typeface','Gautami'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Taml'),t.setAttribute('typeface','Latha'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Syrc'),t.setAttribute('typeface','Estrangelo Edessa'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Orya'),t.setAttribute('typeface','Kalinga'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Mlym'),t.setAttribute('typeface','Kartika'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Laoo'),t.setAttribute('typeface','DokChampa'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Sinh'),t.setAttribute('typeface','Iskoola Pota'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Mong'),t.setAttribute('typeface','Mongolian Baiti'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Viet'),t.setAttribute('typeface','Arial'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Uigh'),t.setAttribute('typeface','Microsoft Uighur'),i.appendChild(t),t=n.createElement('a:font'),t.setAttribute('script','Geor'),t.setAttribute('typeface','Sylfaen'),i.appendChild(t),r.appendChild(i),r}function wf(n){var t=n.createElement('a:fmtScheme'),i,r,u,f;return t.setAttribute('name','Office'),i=bf(n),t.appendChild(i),r=kf(n),t.appendChild(r),u=df(n),t.appendChild(u),f=gf(n),t.appendChild(f),t}function bf(n){var h=n.createElement('a:fillStyleLst'),u=n.createElement('a:solidFill'),t=n.createElement('a:schemeClr'),f,i,e,r,o,s;return t.setAttribute('val','phClr'),u.appendChild(t),h.appendChild(u),u=n.createElement('a:gradFill'),u.setAttribute('rotWithShape','1'),f=n.createElement('a:gsLst'),i=n.createElement('a:gs'),i.setAttribute('pos','0'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),e=n.createElement('a:tint'),e.setAttribute('val','50000'),t.appendChild(e),r=n.createElement('a:satMod'),r.setAttribute('val','300000'),t.appendChild(r),i.appendChild(t),f.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','35000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),e=n.createElement('a:tint'),e.setAttribute('val','37000'),t.appendChild(e),r=n.createElement('a:satMod'),r.setAttribute('val','300000'),t.appendChild(r),i.appendChild(t),f.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','100000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),e=n.createElement('a:tint'),e.setAttribute('val','15000'),t.appendChild(e),r=n.createElement('a:satMod'),r.setAttribute('val','350000'),t.appendChild(r),i.appendChild(t),f.appendChild(i),u.appendChild(f),o=n.createElement('a:lin'),o.setAttribute('ang','16200000'),o.setAttribute('scaled','1'),u.appendChild(o),h.appendChild(u),u=n.createElement('a:gradFill'),u.setAttribute('rotWithShape','1'),f=n.createElement('a:gsLst'),i=n.createElement('a:gs'),i.setAttribute('pos','0'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),s=n.createElement('a:shade'),s.setAttribute('val','51000'),t.appendChild(s),r=n.createElement('a:satMod'),r.setAttribute('val','130000'),t.appendChild(r),i.appendChild(t),f.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','80000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),s=n.createElement('a:shade'),s.setAttribute('val','93000'),t.appendChild(e),r=n.createElement('a:satMod'),r.setAttribute('val','130000'),t.appendChild(r),i.appendChild(t),f.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','100000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),s=n.createElement('a:shade'),s.setAttribute('val','94000'),t.appendChild(s),r=n.createElement('a:satMod'),r.setAttribute('val','135000'),t.appendChild(r),i.appendChild(t),f.appendChild(i),u.appendChild(f),o=n.createElement('a:lin'),o.setAttribute('ang','16200000'),o.setAttribute('scaled','0'),u.appendChild(o),h.appendChild(u),h}function kf(n){var f=n.createElement('a:lnStyleLst'),t=n.createElement('a:ln'),r,i,e,o,u;return t.setAttribute('w','9525'),t.setAttribute('cap','flat'),t.setAttribute('cmpd','sng'),t.setAttribute('algn','ctr'),r=n.createElement('a:solidFill'),i=n.createElement('a:schemeClr'),i.setAttribute('val','phClr'),e=n.createElement('a:shade'),e.setAttribute('val','95000'),i.appendChild(e),o=n.createElement('a:satMod'),o.setAttribute('val','105000'),i.appendChild(o),r.appendChild(i),t.appendChild(r),u=n.createElement('a:prstDash'),u.setAttribute('val','solid'),t.appendChild(u),f.appendChild(t),t=n.createElement('a:ln'),t.setAttribute('w','25400'),t.setAttribute('cap','flat'),t.setAttribute('cmpd','sng'),t.setAttribute('algn','ctr'),r=n.createElement('a:solidFill'),i=n.createElement('a:schemeClr'),i.setAttribute('val','phClr'),r.appendChild(i),t.appendChild(r),u=n.createElement('a:prstDash'),u.setAttribute('val','solid'),t.appendChild(u),f.appendChild(t),t=n.createElement('a:ln'),t.setAttribute('w','38100'),t.setAttribute('cap','flat'),t.setAttribute('cmpd','sng'),t.setAttribute('algn','ctr'),r=n.createElement('a:solidFill'),i=n.createElement('a:schemeClr'),i.setAttribute('val','phClr'),r.appendChild(i),t.appendChild(r),u=n.createElement('a:prstDash'),u.setAttribute('val','solid'),t.appendChild(u),f.appendChild(t),f}function df(n){var o=n.createElement('a:effectStyleLst'),i=n.createElement('a:effectStyle'),u=n.createElement('a:effectLst'),t=n.createElement('a:outerShdw'),r,e,h,c,f,s,a,l;return t.setAttribute('blurRad','40000'),t.setAttribute('dist','23000'),t.setAttribute('dir','5400000'),t.setAttribute('rotWithShape','0'),r=n.createElement('a:srgbClr'),r.setAttribute('val','000000'),e=n.createElement('a:alpha'),e.setAttribute('val','38000'),r.appendChild(e),t.appendChild(r),u.appendChild(t),i.appendChild(u),o.appendChild(i),i=n.createElement('a:effectStyle'),u=n.createElement('a:effectLst'),t=n.createElement('a:outerShdw'),t.setAttribute('blurRad','40000'),t.setAttribute('dist','23000'),t.setAttribute('dir','5400000'),t.setAttribute('rotWithShape','0'),r=n.createElement('a:srgbClr'),r.setAttribute('val','000000'),e=n.createElement('a:alpha'),e.setAttribute('val','35000'),r.appendChild(e),t.appendChild(r),u.appendChild(t),i.appendChild(u),o.appendChild(i),u.appendChild(t),i.appendChild(u),o.appendChild(i),i=n.createElement('a:effectStyle'),u=n.createElement('a:effectLst'),t=n.createElement('a:outerShdw'),t.setAttribute('blurRad','40000'),t.setAttribute('dist','23000'),t.setAttribute('dir','5400000'),t.setAttribute('rotWithShape','0'),r=n.createElement('a:srgbClr'),r.setAttribute('val','000000'),e=n.createElement('a:alpha'),e.setAttribute('val','35000'),r.appendChild(e),t.appendChild(r),u.appendChild(t),i.appendChild(u),h=n.createElement('a:scene3d'),c=n.createElement('a:camera'),c.setAttribute('prst','orthographicFront'),f=n.createElement('a:rot'),f.setAttribute('lat','0'),f.setAttribute('lon','0'),f.setAttribute('rev','0'),c.appendChild(f),h.appendChild(c),s=n.createElement('a:lightRig'),s.setAttribute('rig','threePt'),s.setAttribute('dir','t'),f=n.createElement('a:rot'),f.setAttribute('lat','0'),f.setAttribute('lon','0'),f.setAttribute('rev','1200000'),s.appendChild(f),h.appendChild(s),i.appendChild(h),a=n.createElement('a:sp3d'),l=n.createElement('a:bevelT'),l.setAttribute('w','63500'),l.setAttribute('h','25400'),a.appendChild(l),i.appendChild(a),o.appendChild(i),o}function gf(n){var c=n.createElement('a:bgFillStyleLst'),f=n.createElement('a:solidFill'),t=n.createElement('a:schemeClr'),o,i,u,r,h,s,e;return t.setAttribute('val','phClr'),f.appendChild(t),c.appendChild(f),f=n.createElement('a:gradFill'),f.setAttribute('rotWithShape','1'),o=n.createElement('a:gsLst'),i=n.createElement('a:gs'),i.setAttribute('pos','0'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),u=n.createElement('a:tint'),u.setAttribute('val','40000'),t.appendChild(u),r=n.createElement('a:satMod'),r.setAttribute('val','350000'),t.appendChild(r),i.appendChild(t),o.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','40000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),u=n.createElement('a:tint'),u.setAttribute('val','45000'),t.appendChild(u),h=n.createElement('a:shade'),h.setAttribute('val','99000'),t.appendChild(h),r=n.createElement('a:satMod'),r.setAttribute('val','350000'),t.appendChild(r),i.appendChild(t),o.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','100000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),u=n.createElement('a:tint'),u.setAttribute('val','20000'),t.appendChild(u),r=n.createElement('a:satMod'),r.setAttribute('val','255000'),t.appendChild(r),i.appendChild(t),o.appendChild(i),f.appendChild(o),s=n.createElement('a:path'),s.setAttribute('path','circle'),e=n.createElement('a:fillToRect'),e.setAttribute('b','180000'),e.setAttribute('r','50000'),e.setAttribute('t','-80000'),e.setAttribute('l','50000'),s.appendChild(e),f.appendChild(s),c.appendChild(f),f=n.createElement('a:gradFill'),f.setAttribute('rotWithShape','1'),o=n.createElement('a:gsLst'),i=n.createElement('a:gs'),i.setAttribute('pos','0'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),u=n.createElement('a:tint'),u.setAttribute('val','80000'),t.appendChild(u),r=n.createElement('a:satMod'),r.setAttribute('val','300000'),t.appendChild(r),i.appendChild(t),o.appendChild(i),i=n.createElement('a:gs'),i.setAttribute('pos','100000'),t=n.createElement('a:schemeClr'),t.setAttribute('val','phClr'),h=n.createElement('a:shade'),h.setAttribute('val','30000'),t.appendChild(u),r=n.createElement('a:satMod'),r.setAttribute('val','200000'),t.appendChild(r),i.appendChild(t),o.appendChild(i),f.appendChild(o),s=n.createElement('a:path'),s.setAttribute('path','circle'),e=n.createElement('a:fillToRect'),e.setAttribute('b','50000'),e.setAttribute('r','50000'),e.setAttribute('t','50000'),e.setAttribute('l','50000'),s.appendChild(e),f.appendChild(s),c.appendChild(f),c}function ne(){var t=document.implementation.createDocument('','',null),n=t.createElement('cp:coreProperties'),f,e,r,u;return n.setAttribute('xmlns:cp','http://schemas.openxmlformats.org/package/2006/metadata/core-properties'),n.setAttribute('xmlns:dc','http://purl.org/dc/elements/1.1/'),n.setAttribute('xmlns:dcterms','http://purl.org/dc/terms/'),n.setAttribute('xmlns:dcmitype','http://purl.org/dc/dcmitype/'),n.setAttribute('xmlns:xsi','http://www.w3.org/2001/XMLSchema-instance'),f=t.createElement('dc:creator'),!i.creator||(f.textContent=i.creator),n.appendChild(f),e=t.createElement('cp:lastModifiedBy'),!i.lastModifiedBy||(e.textContent=i.lastModifiedBy),n.appendChild(e),r=t.createElement('dcterms:created'),r.setAttribute('xsi:type','dcterms:W3CDTF'),r.textContent=(i.created||new Date).toISOString(),n.appendChild(r),u=t.createElement('dcterms:modified'),u.setAttribute('xsi:type','dcterms:W3CDTF'),u.textContent=(i.modified||new Date).toISOString(),n.appendChild(u),t.appendChild(n),t}function te(n,t){var c=t.rows&&t.rows[0]&&t.rows[0].cells?t.rows[0].cells.length:0,e,o,s,h,r,i,u;n.documentElement.setAttribute('xmlns:r','http://schemas.openxmlformats.org/officeDocument/2006/relationships');n.documentElement.setAttribute('xmlns:mc','http://schemas.openxmlformats.org/markup-compatibility/2006');n.documentElement.setAttribute('mc:Ignorable','x14ac');n.documentElement.setAttribute('xmlns:x14ac','http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac');e=n.createElementNS(f,'sheetPr');o=n.createElementNS(f,'outlinePr');o.setAttribute('summaryBelow','0');e.appendChild(o);n.documentElement.appendChild(e);s=n.createElementNS(f,'dimension');s.setAttribute('ref','A1'+(c>0?':'+si(c-1)+t.rows.length:''));n.documentElement.appendChild(s);h=n.createElementNS(f,'sheetViews');r=n.createElementNS(f,'sheetView');r.setAttribute('workbookViewId','0');r.setAttribute('tabSelected','1');t.frozenPane&&(t.frozenPane.rows!==0||t.frozenPane.columns!==0)&&(i=n.createElementNS(f,'pane'),i.setAttribute('state','frozen'),i.setAttribute('activePane',t.frozenPane.rows!==0&&t.frozenPane.columns!==0?'bottomRight':t.frozenPane.rows!==0?'bottomLeft':'topRight'),i.setAttribute('topLeftCell',si(t.frozenPane.columns)+(t.frozenPane.rows+1)),i.setAttribute('ySplit',t.frozenPane.rows.toString()),i.setAttribute('xSplit',t.frozenPane.columns.toString()),r.appendChild(i));h.appendChild(r);n.documentElement.appendChild(h);u=n.createElementNS(f,'sheetFormatPr');u.setAttribute('defaultRowHeight','15');u.setAttribute('x14ac:dyDescent','0.25');n.documentElement.appendChild(u)}function ie(n,t,i,r,u,e,o){var s=n.createElementNS(f,'c'),h,c;return s.setAttribute('r',si(i)+(t+1)),s.setAttribute('s',r.toString()),!u||s.setAttribute('t',u),!o||(h=n.createElementNS(f,'f'),h.setAttribute('ca','1'),h.textContent=o,s.appendChild(h)),e!=null&&(c=n.createElementNS(f,'v'),c.textContent=e,s.appendChild(c)),s}function re(n,t){var r=n.createElementNS(f,'mergeCells'),i,u;for(r.setAttribute('count',t.length.toString()),i=0;i<t.length;i++)u=n.createElementNS(f,'mergeCell'),u.setAttribute('ref',t[i].join(':')),r.appendChild(u);return r}function ue(){var et='http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac',n=document.implementation.createDocument(f,'styleSheet',null),i,u,e,t,o,p,h,nt,c,tt,l,it,w,s,b,a,rt,v,ut,k,ft;n.documentElement.setAttribute('xmlns:mc','http://schemas.openxmlformats.org/markup-compatibility/2006');n.documentElement.setAttribute('mc:Ignorable','x14ac');n.documentElement.setAttribute('xmlns:x14ac',et);var d=0,ot=0,y=n.createElementNS(f,'numFmts'),r=n.createElementNS(f,'fonts');for(r.setAttribute('x14ac:knownFonts','1'),r.appendChild(wu(n,{},!0)),i=n.createElementNS(f,'fills'),i.appendChild(uu(n,'none',null)),i.appendChild(uu(n,'gray125',null)),u=n.createElementNS(f,'borders'),u.appendChild(pu(n,{})),e=n.createElementNS(f,'cellXfs'),e.appendChild(bu(n,0,0,0,0,{}));d<g.length;)t=g[d],!t||(t=JSON.parse(t),o=0,t.format&&t.format!=='General'&&(o=dr.indexOf(t.format),o<0&&(o=164+ot,p=n.createElementNS(f,'numFmt'),p.setAttribute('formatCode',t.format),p.setAttribute('numFmtId',o.toString()),y.appendChild(p),ot++)),h=0,t.borders&&(nt=JSON.stringify(t.borders),h=yr.indexOf(nt),h<0&&(h=yr.push(nt)-1,u.appendChild(pu(n,t.borders)))),c=0,t.font&&(tt=JSON.stringify(t.font),c=ii.indexOf(tt),c<0&&(c=ii.push(tt)-1,r.appendChild(wu(n,t.font)))),l=0,t.fill&&t.fill.color&&(it=JSON.stringify(t.fill),l=fi.indexOf(it),l<0&&(l=fi.push(it)-1,i.appendChild(uu(n,'solid',t.fill.color)))),e.appendChild(bu(n,o,h,c,l,t))),d++;return y.setAttribute('count',y.childElementCount.toString()),n.documentElement.appendChild(y),r.setAttribute('count',r.childElementCount.toString()),n.documentElement.appendChild(r),i.setAttribute('count',i.childElementCount.toString()),n.documentElement.appendChild(i),u.setAttribute('count',u.childElementCount.toString()),n.documentElement.appendChild(u),w=n.createElementNS(f,'cellStyleXfs'),s=n.createElementNS(f,'xf'),s.setAttribute('numFmtId','0'),s.setAttribute('borderId','0'),s.setAttribute('fillId','0'),s.setAttribute('fontId','0'),w.appendChild(s),w.setAttribute('count','1'),n.documentElement.appendChild(w),e.setAttribute('count',e.childElementCount.toString()),n.documentElement.appendChild(e),b=n.createElementNS(f,'cellStyles'),a=n.createElementNS(f,'cellStyle'),a.setAttribute('name','Normal'),a.setAttribute('xfId','0'),a.setAttribute('builtinId','0'),b.appendChild(a),b.setAttribute('count','1'),n.documentElement.appendChild(b),rt=n.createElementNS(f,'dxfs'),rt.setAttribute('count','0'),n.documentElement.appendChild(rt),v=n.createElementNS(f,'tableStyles'),v.setAttribute('count','0'),v.setAttribute('defaultTableStyle','TableStyleMedium2'),v.setAttribute('defaultPivotStyle','PivotStyleLight16'),n.documentElement.appendChild(v),ut=n.createElementNS(f,'extLst'),k=n.createElementNS(f,'ext'),k.setAttribute('uri','{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}'),ft=n.createElementNS(et,'x14:slicerStyles'),ft.setAttribute('defaultSlicerStyle','SlicerStyleLight1'),k.appendChild(ft),ut.appendChild(k),n.documentElement.appendChild(ut),n}function pu(n,t){var o=n.createElementNS(f,'border'),r,u,i,e;for(r in{left:0,right:0,top:0,bottom:0,diagonal:0})u=n.createElementNS(f,r),t[r]&&(i=t[r].color,i=i?i[0]==='#'?i.substring(1):i:'',i.length===6&&(i='FF'+i),i||(i='FF000000'),u.setAttribute('style',t[r].style),e=n.createElementNS(f,'color'),e.setAttribute('rgb',i),u.appendChild(e)),o.appendChild(u);return o}function wu(n,t,i){var r,u,o,l,e,s,h,c;return i===void 0&&(i=!1),r=n.createElementNS(f,'font'),t.bold&&(u=n.createElementNS(f,'b'),r.appendChild(u)),t.italic&&(u=n.createElementNS(f,'i'),r.appendChild(u)),t.underline&&(u=n.createElementNS(f,'u'),r.appendChild(u)),o=n.createElementNS(f,'sz'),l=Math.round(t.size*72/96)||du,o.setAttribute('val',l.toString()),r.appendChild(o),e=n.createElementNS(f,'color'),t.color?e.setAttribute('rgb','FF'+(t.color[0]==='#'?t.color.substring(1):t.color)):e.setAttribute('theme','1'),r.appendChild(e),s=n.createElementNS(f,'name'),s.setAttribute('val',t.family||ku),r.appendChild(s),h=n.createElementNS(f,'family'),h.setAttribute('val','2'),r.appendChild(h),i&&(c=n.createElementNS(f,'scheme'),c.setAttribute('val','minor'),r.appendChild(c)),r}function uu(n,t,i){var o=n.createElementNS(f,'fill'),r=n.createElementNS(f,'patternFill'),u,e;return r.setAttribute('patternType',t),!i||(u=n.createElementNS(f,'fgColor'),u.setAttribute('rgb','FF'+(i[0]==='#'?i.substring(1):i)),r.appendChild(u),e=n.createElementNS(f,'bgColor'),e.setAttribute('indexed','64'),r.appendChild(e)),o.appendChild(r),o}function bu(n,t,i,r,u,e){var o=n.createElementNS(f,'xf'),s;return o.setAttribute('xfId','0'),o.setAttribute('numFmtId',t.toString()),t>0&&o.setAttribute('applyNumberFormat','1'),o.setAttribute('borderId',i.toString()),i>0&&o.setAttribute('applyBorder','1'),o.setAttribute('fontId',r.toString()),r>0&&o.setAttribute('applyFont','1'),o.setAttribute('fillId',u.toString()),u>0&&o.setAttribute('applyFill','1'),(e.hAlign||e.vAlign||e.indent||e.wordWrap)&&(s=n.createElementNS(f,'alignment'),e.hAlign&&s.setAttribute('horizontal',e.hAlign),e.vAlign&&s.setAttribute('vertical',e.vAlign),e.indent&&s.setAttribute('indent',e.indent),e.wordWrap&&s.setAttribute('wrapText','1'),o.setAttribute('applyAlignment','1'),o.appendChild(s)),o}function fe(){var t=document.implementation.createDocument(st,'Types',null),i,n,r;for(ei&&(i=t.createElementNS(st,'Default'),i.setAttribute('Extension','bin'),i.setAttribute('ContentType','application/vnd.ms-office.vbaProject'),t.documentElement.appendChild(i)),i=t.createElementNS(st,'Default'),i.setAttribute('Extension','rels'),i.setAttribute('ContentType','application/vnd.openxmlformats-package.relationships+xml'),t.documentElement.appendChild(i),i=t.createElementNS(st,'Default'),i.setAttribute('Extension','xml'),i.setAttribute('ContentType','application/xml'),t.documentElement.appendChild(i),n=t.createElementNS(st,'Override'),n.setAttribute('PartName','/xl/workbook.xml'),n.setAttribute('ContentType',ei?'application/vnd.ms-excel.sheet.macroEnabled.main+xml':'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml'),t.documentElement.appendChild(n),r=0;r<wr.length;r++)t.documentElement.appendChild(wr[r]);return n=t.createElementNS(st,'Override'),n.setAttribute('PartName','/xl/theme/theme1.xml'),n.setAttribute('ContentType','application/vnd.openxmlformats-officedocument.theme+xml'),t.documentElement.appendChild(n),n=t.createElementNS(st,'Override'),n.setAttribute('PartName','/xl/styles.xml'),n.setAttribute('ContentType','application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml'),t.documentElement.appendChild(n),n=t.createElementNS(st,'Override'),n.setAttribute('PartName','/xl/sharedStrings.xml'),n.setAttribute('ContentType','application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml'),t.documentElement.appendChild(n),n=t.createElementNS(st,'Override'),n.setAttribute('PartName','/docProps/core.xml'),n.setAttribute('ContentType','application/vnd.openxmlformats-package.core-properties+xml'),t.documentElement.appendChild(n),n=t.createElementNS(st,'Override'),n.setAttribute('PartName','/docProps/app.xml'),n.setAttribute('ContentType','application/vnd.openxmlformats-officedocument.extended-properties+xml'),t.documentElement.appendChild(n),t}function ee(){var t='http://schemas.openxmlformats.org/officeDocument/2006/extended-properties',u='http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes',n=document.implementation.createDocument(t,'Properties',null),k=n.createElementNS(t,'Application'),s,h,c,r,f,e,l,a,o,d,v,y,p,w,b;for(k.textContent=i.application||'wijmo.xlsx',n.documentElement.appendChild(k),s=n.createElementNS(t,'DocSecurity'),s.textContent='0',n.documentElement.appendChild(s),h=n.createElementNS(t,'ScaleCrop'),h.textContent='false',n.documentElement.appendChild(h),c=n.createElementNS(t,'HeadingPairs'),r=n.createElementNS(u,'vt:vector'),r.setAttribute('size','2'),r.setAttribute('baseType','variant'),f=n.createElementNS(u,'vt:variant'),e=n.createElementNS(u,'vt:lpstr'),e.textContent='Worksheets',f.appendChild(e),r.appendChild(f),f=n.createElementNS(u,'vt:variant'),l=n.createElementNS(u,'vt:i4'),l.textContent=i.sheets.length,f.appendChild(l),r.appendChild(f),c.appendChild(r),n.documentElement.appendChild(c),a=n.createElementNS(t,'TitlesOfParts'),r=n.createElementNS(u,'vt:vector'),r.setAttribute('size',tr.length.toString()),r.setAttribute('baseType','lpstr'),o=0;o<tr.length;o++)e=n.createElementNS(u,'vt:lpstr'),e.textContent=tr[o],r.appendChild(e);return a.appendChild(r),n.documentElement.appendChild(a),d=n.createElementNS(t,'Manager'),n.documentElement.appendChild(d),v=n.createElementNS(t,'Company'),v.textContent=i.company||'GrapeCity, Inc.',n.documentElement.appendChild(v),y=n.createElementNS(t,'LinksUpToDate'),y.textContent='false',n.documentElement.appendChild(y),p=n.createElementNS(t,'SharedDoc'),p.textContent='false',n.documentElement.appendChild(p),w=n.createElementNS(t,'HyperlinksChanged'),w.textContent='false',n.documentElement.appendChild(w),b=n.createElementNS(t,'AppVersion'),b.textContent='1.0',n.documentElement.appendChild(b),n}function oe(){for(var n,t=document.implementation.createDocument(vt,'Relationships',null),i=0;i<dt.length;i++)t.documentElement.appendChild(dt[i]);return n=t.createElementNS(vt,'Relationship'),n.setAttribute('Id','rId'+(dt.length+1)),n.setAttribute('Type','http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings'),n.setAttribute('Target','sharedStrings.xml'),t.documentElement.appendChild(n),n=t.createElementNS(vt,'Relationship'),n.setAttribute('Id','rId'+(dt.length+2)),n.setAttribute('Type','http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles'),n.setAttribute('Target','styles.xml'),t.documentElement.appendChild(n),n=t.createElementNS(vt,'Relationship'),n.setAttribute('Id','rId'+(dt.length+3)),n.setAttribute('Type','http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme'),n.setAttribute('Target','theme/theme1.xml'),t.documentElement.appendChild(n),ei&&(n=t.createElementNS(vt,'Relationship'),n.setAttribute('Id','rId'+(dt.length+4)),n.setAttribute('Type','http://schemas.microsoft.com/office/2006/relationships/vbaProject'),n.setAttribute('Target','vbaProject.bin'),t.documentElement.appendChild(n)),t}function se(){var n=document.implementation.createDocument(f,'workbook',null),r,e,o,t,s,u,h;for(n.documentElement.setAttribute('xmlns:r','http://schemas.openxmlformats.org/officeDocument/2006/relationships'),r=n.createElementNS(f,'fileVersion'),r.setAttribute('appName','xl'),r.setAttribute('lastEdited','5'),r.setAttribute('lowestEdited','5'),r.setAttribute('rupBuild','9303'),n.documentElement.appendChild(r),e=n.createElementNS(f,'workbookPr'),e.setAttribute('defaultThemeVersion','124226'),n.documentElement.appendChild(e),o=n.createElementNS(f,'bookViews'),t=n.createElementNS(f,'workbookView'),t.setAttribute('activeTab',i.activeWorksheet!=null?i.activeWorksheet.toString():'0'),t.setAttribute('xWindow','480'),t.setAttribute('yWindow','60'),t.setAttribute('windowWidth','18195'),t.setAttribute('windowHeight','8505'),o.appendChild(t),n.documentElement.appendChild(o),s=n.createElementNS(f,'sheets'),u=0;u<br.length;u++)s.appendChild(br[u]);return n.documentElement.appendChild(s),h=n.createElementNS(f,'calcPr'),h.setAttribute('fullCalcOnLoad','1'),n.documentElement.appendChild(h),n}function he(){var n=document.implementation.createDocument(f,'sst',null),t,i,r;for(n.documentElement.setAttribute('count',rt[1]),n.documentElement.setAttribute('uniqueCount',rt[0].length),t=0;t<rt[0].length;t++)i=n.createElementNS(f,'si'),r=n.createElementNS(f,'t'),r.textContent=rt[0][t],i.appendChild(r),n.documentElement.appendChild(i);return n}var or,sr,hr,cr,lr;n.assert(JSZip!=null,'wijmo.c1xlsx requires the JSZip library.');var w,tt=new JSZip,di,ti,r,ar,o,u,l,ht,fu,a,it,rt,g,b,k,s,wt,li,vr,gi,v,h,ai,e,yr,ii,eu,pr,bt,ou,ct,su,wr=[],nr,tr=[],dt=[],vi,br=[],ri,y,ir,nt,et,ut,yi,c,p,rr,lt,ui,ur,pi,wi,fi,hu,ei,cu,kr,dr=['General','0','0.00','#,##0','#,##0.00',,,'$#,##0.00_);($#,##0.00)',,'0%','0.00%','0.00E+00','# ?/?','# ??/??','m/d/yyyy','d-mmm-yy','d-mmm','mmm-yy','h:mm AM/PM','h:mm:ss AM/PM','h:mm','h:mm:ss','m/d/yy h:mm',,,,,,,,,,,,,,,'#,##0 ;(#,##0)','#,##0 ;[Red](#,##0)','#,##0.00;(#,##0.00)','#,##0.00;[Red](#,##0.00)',,,,,'mm:ss','[h]:mm:ss','mmss.0','##0.0E+0','@'],gr,nu,tu,ft,iu,lu,fr,oi,er,yt,au='ABCDEFGHIJKLMNOPQRSTUVWXYZ',ku='Calibri',du=11,gu=['000000','FFFFFF','FF0000','00FF00','0000FF','FFFF00','FF00FF','00FFFF','000000','FFFFFF','FF0000','00FF00','0000FF','FFFF00','FF00FF','00FFFF','800000','008000','000080','808000','800080','008080','C0C0C0','808080','9999FF','993366','FFFFCC','CCFFFF','660066','FF8080','0066CC','CCCCFF','000080','FF00FF','FFFF00','00FFFF','800080','800000','008080','0000FF','00CCFF','CCFFFF','CCFFCC','FFFF99','99CCFF','FF99CC','CC99FF','FFCC99','3366FF','33CCCC','99CC00','FFCC00','FF9900','FF6600','666699','969696','003366','339966','003300','333300','993300','993366','333399','333333','000000','FFFFFF'],gt,ot,at='<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',d,ru,pt,kt,bi=/xmlns\:NS\d+=\"\"\s+NS\d+\:/g,f='http://schemas.openxmlformats.org/spreadsheetml/2006/main',st='http://schemas.openxmlformats.org/package/2006/content-types',vt='http://schemas.openxmlformats.org/package/2006/relationships';if(typeof i=='string'){if(di=Date.now(),gt=new DOMParser,tt=tt.load(i,{base64:!0}),w={sheets:[],zipTime:Date.now()-di},ti=Date.now(),rt=[],g=[],ii=[],fi=[],ft=[],r=tt.file('xl/sharedStrings.xml'))for(r=gt.parseFromString(r.asText(),'application/xml').querySelectorAll('sst>si'),u=r.length-1;u>=0;){for(l=0,ar=r[u].querySelectorAll('t'),rt[u]='';l<ar.length;)rt[u]+=ar[l].textContent,l++;u--}if((r=tt.file('docProps/core.xml'))&&(r=gt.parseFromString(r.asText(),'application/xml'),w.creator=r.querySelector('creator')?r.querySelector('creator').textContent:'',w.lastModifiedBy=r.querySelector('lastModifiedBy')?r.querySelector('lastModifiedBy').textContent:'',w.created=r.querySelector('created')?new Date(r.querySelector('created').textContent):null,w.modified=r.querySelector('modified')?new Date(r.querySelector('modified').textContent):null),r=tt.file('xl/workbook.xml'))for(r=gt.parseFromString(r.asText(),'application/xml'),b=r.querySelector('workbookView')?r.querySelector('workbookView').getAttribute('activeTab'):null,w.activeWorksheet=b!=null?+b:0,r=r.querySelectorAll('sheets>sheet'),u=r.length-1;u>=0;)y=r[u].getAttribute('name'),su=r[u].getAttribute('state')!=='hidden',w.sheets.unshift({name:y,visible:su,cols:[],columns:[],rows:[]}),u--;if((r=tt.file('xl/theme/theme1.xml'))&&(r=gt.parseFromString(r.asText(),'application/xml'),ft[0]=r.querySelector('themeElements>clrScheme>lt1>sysClr').getAttribute('lastClr'),ft[1]=r.querySelector('themeElements>clrScheme>dk1>sysClr').getAttribute('lastClr'),ft[2]=r.querySelector('themeElements>clrScheme>lt2>srgbClr').getAttribute('val'),ft[3]=r.querySelector('themeElements>clrScheme>dk2>srgbClr').getAttribute('val'),ft[4]=r.querySelector('themeElements>clrScheme>accent1>srgbClr').getAttribute('val'),ft[5]=r.querySelector('themeElements>clrScheme>accent2>srgbClr').getAttribute('val'),ft[6]=r.querySelector('themeElements>clrScheme>accent3>srgbClr').getAttribute('val'),ft[7]=r.querySelector('themeElements>clrScheme>accent4>srgbClr').getAttribute('val'),ft[8]=r.querySelector('themeElements>clrScheme>accent5>srgbClr').getAttribute('val'),ft[9]=r.querySelector('themeElements>clrScheme>accent6>srgbClr').getAttribute('val')),r=tt.file('xl/styles.xml')){for(r=gt.parseFromString(r.asText(),'application/xml'),gr=r.querySelectorAll('numFmts>numFmt'),u=gr.length-1;u>=0;)a=gr[u],dr[+a.getAttribute('numFmtId')]=a.getAttribute('formatCode'),u--;for(nu=r.querySelectorAll('fonts>font'),u=nu.length-1;u>=0;)a=nu[u],ii[u]={bold:a.querySelector('b')!=null,italic:a.querySelector('i')!=null,underline:a.querySelector('u')!=null,size:Math.round(+a.querySelector('sz').getAttribute('val')*96/72),family:a.querySelector('name').getAttribute('val'),color:yu(a,!1)},u--;for(tu=r.querySelectorAll('fills>fill'),u=tu.length-1;u>=0;)fi[u]=yu(tu[u],!0),u--;for(r=r.querySelectorAll('cellXfs>xf'),u=r.length-1;u>=0;)y=+r[u].getAttribute('numFmtId'),o=dr[y],a=o?/[hsmy\:]/i.test(o)?'date':o.indexOf('0')>-1?'number':o==='@'?'string':'unknown':'unknown',y=+r[u].getAttribute('fontId'),eu=y>0?ii[y]:null,y=+r[u].getAttribute('fillId'),hu=y>1?fi[y]:null,g.unshift({formatCode:o,type:a,font:eu,fillColor:hu,hAlign:r[u].querySelector('alignment')!=null?t.Workbook._parseStringToHAlign(r[u].querySelector('alignment').getAttribute('horizontal')):null,wordWrap:r[u].querySelector('alignment')!=null?r[u].querySelector('alignment').getAttribute('wrapText')==='1':null}),u--}for(w.styles=g,(r=tt.file('xl/vbaProject.bin'))&&(w.reservedContent==null&&(w.reservedContent={}),w.reservedContent.macros=r.asUint8Array()),u=w.sheets.length;u--;){if(r=tt.file('xl/worksheets/sheet'+(u+1)+'.xml').asText(),r=gt.parseFromString(r,'application/xml'),er=[],fr=r.querySelectorAll('mergeCells>mergeCell'),fr.length>0)for(l=fr.length-1;l>=0;)oi=fr[l].getAttribute('ref').split(':'),oi.length===2&&er.unshift({topRow:+oi[0].match(/\d*/g).join('')-1,leftCol:ki(oi[0].match(/[a-zA-Z]*/g)[0]),bottomRow:+oi[1].match(/\d*/g).join('')-1,rightCol:ki(oi[1].match(/[a-zA-Z]*/g)[0])}),l--;if(sf(r),it=w.sheets[u],a=r.querySelector('dimension')?r.querySelector('dimension').getAttribute('ref'):null,!a||(a=a.substr(a.indexOf(':')+1),it.maxCol=ki(a.match(/[a-zA-Z]*/g)[0])+1,it.maxRow=+a.match(/\d*/g).join('')),nt=r.querySelectorAll('cols>col'),iu=[],nt.length>0)for(lt=nt.length-1;lt>=0;lt--)for(ut=ff(+nt[lt].getAttribute('width')),o=null,nt[lt].hasAttribute('style')&&(o=g[+nt[lt].getAttribute('style')]||{type:'General',formatCode:null}),e=null,o&&(o.font||o.fillColor||o.hAlign||o.formatCode&&o.formatCode!=='General')&&(e={format:!o.formatCode||o.formatCode==='General'?null:o.formatCode,font:o.font,fill:{color:o.fillColor},hAlign:o.hAlign,wordWrap:o.wordWrap}),ui=+nt[lt].getAttribute('min')-1;ui<+nt[lt].getAttribute('max');ui++)iu[ui]={visible:nt[lt].getAttribute('hidden')!=='1',autoWidth:nt[lt].getAttribute('bestFit')==='1',width:ut,style:e};for(it.cols=it.columns=iu,yi=r.querySelector('pane'),!yi||yi.getAttribute('state')==='frozen'&&(pi=yi.getAttribute('ySplit'),pi=pi?+pi:NaN,wi=yi.getAttribute('xSplit'),wi=wi?+wi:NaN,it.frozenPane={rows:pi,columns:wi}),kr=r.querySelector('sheetPr>outlinePr'),it.summaryBelow=kr?kr.getAttribute('summaryBelow')!=='0':!0,r=r.querySelectorAll('sheetData>row'),it=it.rows,l=r.length-1;l>=0;){for(p=it[+r[l].getAttribute('r')-1]={visible:!0,groupLevel:NaN,cells:[]},r[l].hasAttribute('hidden')&&(p.visible=r[l].getAttribute('hidden')!=='1'),r[l].getAttribute('customHeight')==='1'&&(lu=+r[l].getAttribute('ht'),p.height=lu*96/72),r[l].getAttribute('customFormat')==='1'?(o=g[+r[l].getAttribute('s')]||{type:'General',formatCode:null},e=o.font||o.fillColor||o.hAlign||o.formatCode&&o.formatCode!=='General'?{format:!o.formatCode||o.formatCode==='General'?null:o.formatCode,font:o.font,fill:{color:o.fillColor},hAlign:o.hAlign,wordWrap:o.wordWrap}:null):e=null,p.style=e,ur=r[l].getAttribute('outlineLevel'),p.groupLevel=ur&&ur!==''?+ur:NaN,p.collapsed=r[l].getAttribute('collapsed')==='1',ir=r[l].querySelectorAll('row>c'),ht=ir.length-1;ht>=0;){c=ir[ht];o=g[+c.getAttribute('s')]||{type:'General',formatCode:null};e=o.font||o.fillColor||o.hAlign||o.formatCode&&o.formatCode!=='General'?{format:!o.formatCode||o.formatCode==='General'?null:o.formatCode,font:o.font,fill:{color:o.fillColor},hAlign:o.hAlign,wordWrap:o.wordWrap}:null;a=c.getAttribute('t')||o.type;s=c.querySelector('v');!s||(s=s.textContent);wt=c.querySelector('f');gi=null;vr=null;!wt||(wt.textContent?wt=wt.textContent:(gi=wt.getAttribute('si'),gi&&(vr=c.getAttribute('r'),wt=cf(gi,vr))));a!=='str'&&(s=s?+s:'');ui=ki(c.getAttribute('r').match(/[a-zA-Z]*/g)[0]);switch(a){case's':s=rt[s];break;case'b':s=s===1;break;case'date':s=s?vu(s):''}p.cells[ui]={value:s,isDate:a==='date',formula:rf(wt),style:e};ht--}l--}for(ht=0;ht<er.length;ht++)yt=er[ht],w.sheets[u].rows[yt.topRow].cells[yt.leftCol].rowSpan=yt.bottomRow-yt.topRow+1,w.sheets[u].rows[yt.topRow].cells[yt.leftCol].colSpan=yt.rightCol-yt.leftCol+1}w.processTime=Date.now()-ti}else{for(ti=Date.now(),ot=new XMLSerializer,rt=[[],0],tt.folder('_rels').file('.rels',at+ot.serializeToString(af())),pr=tt.folder('docProps'),bt=tt.folder('xl'),or=ot.serializeToString(vf()),n.isIE()&&(or=or.replace(bi,'')),bt.folder('theme').file('theme1.xml',at+or),ei=!!(i.reservedContent&&i.reservedContent.macros),ei&&bt.file('vbaProject.bin',i.reservedContent.macros),ou=bt.folder('worksheets'),sr=ot.serializeToString(ne()),n.isIE()&&(sr=sr.replace(bi,'')),pr.file('core.xml',at+sr),g=new Array(1),yr=new Array(1),ii=new Array(1),fi=new Array(2),it=i.sheets.length;it--;){if(y=it+1,ct=i.sheets[it],et=ct.columns||ct.cols,!ct)throw'Worksheet should not be empty!';for(d=document.implementation.createDocument(f,'worksheet',null),te(d,ct),ru=d.createElementNS(f,'sheetData'),ai=ct.style,k=ct.rows,r='',ir=[],rr=[],u=-1,fu=k?k.length:0;++u<fu;){for(l=-1,ht=k[u]&&k[u].cells?k[u].cells.length:0,v=null,p=d.createElementNS(f,'row'),p.setAttribute('r',u+1),p.setAttribute('x14ac:dyDescent','0.25'),!k[u]||(k[u].height&&(p.setAttribute('customHeight','1'),p.setAttribute('ht',+k[u].height*72/96)),k[u].groupLevel&&p.setAttribute('outlineLevel',k[u].groupLevel),v=k[u].style,v&&(v=hi(v),v.font&&v.font.color&&(v.font.color=ni(v.font.color)),v.fill&&v.fill.color&&(v.fill.color=ni(v.fill.color)),v.hAlign==null||n.isString(v.hAlign)||(v.hAlign=t.Workbook._parseHAlignToString(n.asEnum(v.hAlign,t.HAlign))),v.vAlign==null||n.isString(v.vAlign)||(v.vAlign=t.Workbook._parseVAlignToString(n.asEnum(v.vAlign,t.VAlign))),e=JSON.stringify(v),b=g.indexOf(e),e=b<0?g.push(e)-1:b,p.setAttribute('customFormat','1'),p.setAttribute('s',e))),k[u]&&k[u].visible===!1&&p.setAttribute('hidden','1'),k[u]&&k[u].collapsed===!0&&p.setAttribute('collapsed','1');++l<ht;)c=k[u].cells[l],s=undefined,e=undefined,a='',b=-1,s=c&&c.hasOwnProperty('value')?c.value:c,e=c&&c.style?JSON.parse(JSON.stringify(c.style)):{},s&&typeof s=='string'&&(+s).toString()!==s?(rt[1]++,b=rt[0].indexOf(s),b<0&&(b=rt[0].push(s)-1),s=b,a='s'):typeof s=='boolean'?(s=s?1:0,a='b'):nf(s)==='date'||c&&c.isDate?(s=vu(s),e.format=e.format||'mm-dd-yy'):typeof s=='object'&&(s=null),e=hi(e),h=et&&et[l]?et[l].style:null,h&&(h=hi(h),e=ci(e,h)),v&&(e=ci(e,v)),ai&&(ai=hi(ai),e=ci(e,ai)),e.hAlign==null||n.isString(e.hAlign)||(e.hAlign=t.Workbook._parseHAlignToString(n.asEnum(e.hAlign,t.HAlign))),e.vAlign==null||n.isString(e.vAlign)||(e.vAlign=t.Workbook._parseVAlignToString(n.asEnum(e.vAlign,t.VAlign))),e.font&&e.font.color&&(e.font.color=ni(e.font.color)),e.fill&&e.fill.color&&(e.fill.color=ni(e.fill.color)),e.borders&&of(e.borders),e=JSON.stringify(e),b=g.indexOf(e),e=b<0?g.push(e)-1:b,c&&(c.colSpan!=null&&c.colSpan>1||c.rowSpan!=null&&c.rowSpan>1)&&(c.colSpan=c.colSpan||1,c.rowSpan=c.rowSpan||1,rr.push([si(l)+(u+1),si(l+c.colSpan-1)+(u+c.rowSpan)])),p.appendChild(ie(d,u,l,e,a,s,c&&c.formula?c.formula:null));ru.appendChild(p)}if(nt=null,et)for(nt=d.createElementNS(f,'cols'),u=0;u<et.length;u++)lf(et[u])||(h=et[u].style,h&&(h=hi(h),h.font&&h.font.color&&(h.font.color=ni(h.font.color)),h.fill&&h.fill.color&&(h.fill.color=ni(h.fill.color)),h.hAlign==null||n.isString(h.hAlign)||(h.hAlign=t.Workbook._parseHAlignToString(n.asEnum(h.hAlign,t.HAlign))),h.vAlign==null||n.isString(h.vAlign)||(h.vAlign=t.Workbook._parseVAlignToString(n.asEnum(h.vAlign,t.VAlign))),h=JSON.stringify(h),b=g.indexOf(h),h=b<0?g.push(h)-1:b),ut=et[u].width,ut=ut!=null?typeof ut=='string'&&ut.indexOf('ch')>-1?ef(ut.substring(0,ut.indexOf('ch'))):uf(ut):8.43,pt=d.createElementNS(f,'col'),pt.setAttribute('min',u+1),pt.setAttribute('max',u+1),!h||pt.setAttribute('style',h),!ut||(pt.setAttribute('width',ut),pt.setAttribute('customWidth','1')),et[u].autoWidth!==!1&&pt.setAttribute('bestFit','1'),et[u].visible===!1&&pt.setAttribute('hidden','1'),nt.appendChild(pt));!nt||d.documentElement.appendChild(nt);d.documentElement.appendChild(ru);rr.length>0&&d.documentElement.appendChild(re(d,rr));kt=d.createElementNS(f,'pageMargins');kt.setAttribute('left','0.7');kt.setAttribute('right','0.7');kt.setAttribute('top','0.75');kt.setAttribute('bottom','0.75');kt.setAttribute('header','0.3');kt.setAttribute('footer','0.3');d.documentElement.appendChild(kt);hr=ot.serializeToString(d);n.isIE()&&(hr=hr.replace(bi,''));ou.file('sheet'+y+'.xml',at+hr);nr=d.createElementNS(st,'Override');nr.setAttribute('PartName','/xl/worksheets/sheet'+y+'.xml');nr.setAttribute('ContentType','application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml');wr.unshift(nr);tr.unshift(ct.name||'Sheet'+y);vi=d.createElementNS(vt,'Relationship');vi.setAttribute('Id','rId'+y);vi.setAttribute('Type','http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet');vi.setAttribute('Target','worksheets/sheet'+y+'.xml');dt.unshift(vi);ri=d.createElementNS(f,'sheet');ri.setAttribute('name',ct.name||'Sheet'+y);ri.setAttribute('sheetId',y.toString());ri.setAttribute('r:id','rId'+y);ct.visible===!1&&ri.setAttribute('state','hidden');br.unshift(ri)}cr=ot.serializeToString(ue());n.isIE()&&(cr=cr.replace(bi,''));bt.file('styles.xml',at+cr);tt.file('[Content_Types].xml',at+ot.serializeToString(fe()));pr.file('app.xml',at+ot.serializeToString(ee()));bt.folder('_rels').file('workbook.xml.rels',at+ot.serializeToString(oe()));bt.file('sharedStrings.xml',at+ot.serializeToString(he()));lr=ot.serializeToString(se());n.isIE()&&(lr=lr.replace(bi,''));bt.file('workbook.xml',at+lr);cu=ei?'application/vnd.ms-excel.sheet.macroEnabled.12;':'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;';ti=Date.now()-ti;di=Date.now();w={base64:tt.generate({compression:'DEFLATE'}),zipTime:Date.now()-di,processTime:ti,href:function(){return'data:'+cu+'base64,'+this.base64}}}return w}t._xlsx=i})(t=n.xlsx||(n.xlsx={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var p=function(){function e(){}return Object.defineProperty(e.prototype,"sheets",{get:function(){return this._sheets==null&&(this._sheets=[]),this._sheets},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"styles",{get:function(){return this._styles==null&&(this._styles=[]),this._styles},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"reservedContent",{get:function(){return this._reservedContent==null&&(this._reservedContent={}),this._reservedContent},set:function(n){this._reservedContent=n},enumerable:!0,configurable:!0}),e.prototype.save=function(n){var u,r,f,o=t._xlsx(this._serialize()),i=this._reservedContent&&this._reservedContent.macros?'xlsm':'xlsx',s=i==='xlsm'?'application/vnd.ms-excel.sheet.macroEnabled.12':'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';if(n){if(r=n.lastIndexOf('.'),r<0)n+='.'+i;else if(r===0)throw'Invalid file name.';else u=n.substring(r+1),u===''?n+='.'+i:u!==i&&(n+='.'+i);f=new Blob([e._base64DecToArr(o.base64)],{type:s});this._saveToFile(f,n)}return o.base64},e.prototype.load=function(n){var i;if(n==null||n.length===0)throw'Invalid xlsx file content.';i=n.search(/base64,/i);i!==-1&&(n=n.substring(i+7));this._deserialize(t._xlsx(n))},e.prototype._serialize=function(){var n={sheets:[]};return n.sheets=this._serializeWorkSheets(),this._styles&&this._styles.length>0&&(n.styles=this._serializeWorkbookStyles()),this._reservedContent&&(n.reservedContent=this._reservedContent),this.activeWorksheet!=null&&!isNaN(this.activeWorksheet)&&this.activeWorksheet>=0&&(n.activeWorksheet=this.activeWorksheet),this.application&&(n.application=this.application),this.company&&(n.company=this.company),this.created!=null&&(n.created=this.created),this.creator&&(n.creator=this.creator),this.lastModifiedBy&&(n.lastModifiedBy=this.lastModifiedBy),this.modified!=null&&(n.modified=this.modified),n},e.prototype._deserialize=function(n){this._deserializeWorkSheets(n.sheets);n.styles&&n.styles.length>0&&this._deserializeWorkbookStyles(n.styles);this.activeWorksheet=n.activeWorksheet;this.application=n.application;this.company=n.company;this.created=n.created;this.creator=n.creator;this.lastModifiedBy=n.lastModifiedBy;this.modified=n.modified;this.reservedContent=n.reservedContent},e.prototype._addWorkSheet=function(n,t){this._sheets==null&&(this._sheets=[]);t==null||isNaN(t)?this._sheets.push(n):this._sheets[t]=n},e.prototype._saveToFile=function(n,t){var r,i,u;navigator.msSaveBlob?navigator.msSaveBlob(n,t):(r=new FileReader,i=document.createElement('a'),u=function(n){var t=document.createEvent('MouseEvents');t.initMouseEvent('click',!0,!1,window,0,0,0,0,0,!1,!1,!1,!1,0,null);n.dispatchEvent(t)},r.onload=function(){i.download=t;i.href=r.result;u(i);i=null},r.readAsDataURL(n))},e.toXlsxDateFormat=function(t){var i;if(t.length===1)switch(t){case'r':case'R':return'ddd, dd MMM yyyy HH:mm:ss &quot;GMT&quot;';case'u':return'yyyy-MM-dd&quot;T&quot;HH:mm:ss&quot;Z&quot;';case'o':case'O':i=n.culture.Globalize.calendar.patterns[t];i=i.replace(/f+k/gi,'000');break;default:i=n.culture.Globalize.calendar.patterns[t]}return(i||(i=t),i=i.replace(/"/g,'').replace(/tt/,'AM/PM').replace(/t/,'A/P').replace(/M+/gi,function(n){return n.toLowerCase()}).replace(/g+y+/gi,function(n){return n.substring(0,n.indexOf('y'))+'e'}),/FY|Q/i.test(i))?'General':i},e.toXlsxNumberFormat=function(t){var u=-1,e=t?t.toLowerCase():'',o=e[0],i=this._formatMap[o],c=n.culture.Globalize.numberFormat.currency.symbol,h=e.split(','),f=[],s,r;if(i){if(o==='c'&&(i=i.replace(/\{1\}/g,c)),u=e.length>1?parseInt(h[0].substr(1)):2,!isNaN(u))for(r=0;r<u;r++)f.push(0);for(r=0;r<h.length-1;r++)f.push(',');s=f.length>0?o==='d'?i.replace(/\{0\}/g,f.join('')):i.replace(/\{0\}/g,(!isNaN(u)&&u>0?'.':'')+f.join('')):o==='d'?i.replace(/\{0\}/g,'0'):i.replace(/\{0\}/g,'')}else s=e;return s},e.fromXlsxFormat=function(t){var c=[],u,s,i,f,h,e,r,o,l,a=n.culture.Globalize.numberFormat.currency.symbol;if(!t||t==='General')return[''];for(t=t.replace(/;@/g,'').replace(/&quot;?/g,''),s=t.split(';'),f=0;f<s.length;f++){if(i=s[f],/[hsmy\:]/i.test(i))u=i.replace(/\[\$\-.+\]/g,'').replace(/(\\)(.)/g,'$2').replace(/H+/g,function(n){return n.toLowerCase()}).replace(/m+/g,function(n){return n.toUpperCase()}).replace(/S+/g,function(n){return n.toLowerCase()}).replace(/AM\/PM/gi,'tt').replace(/A\/P/gi,'t').replace(/\.000/g,'.fff').replace(/\.00/g,'.ff').replace(/\.0/g,'.f').replace(/\\[\-\s,]/g,function(n){return n.substring(1)}).replace(/Y+/g,function(n){return n.toLowerCase()}).replace(/D+/g,function(n){return n.toLowerCase()}).replace(/M+:?|:?M+/gi,function(n){return n.indexOf(':')>-1?n.toLowerCase():n}).replace(/g+e/gi,function(n){return n.substring(0,n.length-1)+'yy'});else if(e=i.lastIndexOf('.'),r=i.lastIndexOf('0'),o=i.lastIndexOf(','),u=i.search(/\[\$([^\-\]]+)[^\]]*\]/)>-1||i.indexOf(a)>-1&&i.search(/\[\$([\-\]]+)[^\]]*\]/)===-1?'c':i[t.length-1]==='%'?'p':'n',u+=e>-1&&e<r?i.substring(e,r).length:'0',/^0+,*$/.test(i)&&(r=i.lastIndexOf('0'),u='d'+(r+1)),o>-1&&r<o)for(l=i.substring(r+1,o+1).split(''),h=0;h<l.length;h++)u+=',';c.push(u)}return c},e._parseCellFormat=function(n,t){return t?this.toXlsxDateFormat(n):this.toXlsxNumberFormat(n)},e._parseExcelFormat=function(t){if(t===undefined||t===null||t.value===undefined||t.value===null||isNaN(t.value))return undefined;var i=t.style&&t.style.format?t.style.format:'';return t.isDate||n.isDate(t.value)?this.fromXlsxFormat(i)[0]:n.isNumber(t.value)?i&&i!=='General'?this.fromXlsxFormat(i)[0]:n.isInt(t.value)?'d':'f2':i},e.xlsxAddress=function(n,t,i,r){var u=i?'$':'',f=r==null?u:r?'$':'';return(isNaN(t)?'':f+this._numAlpha(t))+(isNaN(n)?'':u+(n+1).toString())},e.tableAddress=function(n){var t=n&&/^((\$?)([A-Za-z]+))?((\$?)(\d+))?$/.exec(n),i={};return t?(t[3]&&(i.col=this._alphaNum(t[3]),i.absCol=!!t[2]),t[6]&&(i.row=+t[6]-1,i.absRow=!!t[5]),i):null},e._parseHAlignToString=function(n){switch(n){case r.Left:return'left';case r.Center:return'center';case r.Right:return'right';default:return null}},e._parseStringToHAlign=function(n){var t=n?n.toLowerCase():'';return t==='left'?r.Left:t==='center'?r.Center:t==='right'?r.Right:null},e._parseVAlignToString=function(n){switch(n){case u.Bottom:return'bottom';case u.Center:return'center';case u.Top:return'top';default:return null}},e._parseStringToVAlign=function(n){var t=n?n.toLowerCase():'';return t==='top'?u.Top:t==='center'?u.Center:t==='bottom'?u.Bottom:null},e._parseBorderTypeToString=function(n){switch(n){case i.Dashed:return'dashed';case i.Dotted:return'dotted';case i.Double:return'double';case i.Hair:return'hair';case i.Medium:return'medium';case i.MediumDashDotDotted:return'mediumDashDotDot';case i.MediumDashDotted:return'mediumDashDot';case i.MediumDashed:return'mediumDashed';case i.SlantedMediumDashDotted:return'slantDashDot';case i.Thick:return'thick';case i.Thin:return'thin';case i.ThinDashDotDotted:return'dashDotDot';case i.ThinDashDotted:return'dashDot';case i.None:default:return'none'}},e._parseStringToBorderType=function(n){return n==='dashed'?i.Dashed:n==='dotted'?i.Dotted:n==='double'?i.Double:n==='hair'?i.Hair:n==='medium'?i.Medium:n==='mediumDashDotDot'?i.MediumDashDotDotted:n==='mediumDashDot'?i.MediumDashDotted:n==='mediumDashed'?i.MediumDashed:n==='slantDashDot'?i.SlantedMediumDashDotted:n==='thick'?i.Thick:n==='thin'?i.Thin:n==='dashDotDot'?i.ThinDashDotDotted:n==='dashDot'?i.ThinDashDotted:null},e._numAlpha=function(n){var t=Math.floor(n/26)-1;return(t>-1?this._numAlpha(t):'')+this._alphabet.charAt(n%26)},e._alphaNum=function(n){var t=0;return!n||(n=n.toUpperCase()),n.length===2&&(t=this._alphaNum(n.charAt(0))+1),t*26+this._alphabet.indexOf(n.substr(-1))},e._b64ToUint6=function(n){return n>64&&n<91?n-65:n>96&&n<123?n-71:n>47&&n<58?n+4:n===43?62:n===47?63:0},e._base64DecToArr=function(n,t){for(var s=n.replace(/[^A-Za-z0-9\+\/]/g,""),r=s.length,h=t?Math.ceil((r*3+1>>2)/t)*t:r*3+1>>2,c=new Uint8Array(h),u,f,e=0,o=0,i=0;i<r;i++)if(f=i&3,e|=this._b64ToUint6(s.charCodeAt(i))<<18-6*f,f===3||r-i==1){for(u=0;u<3&&o<h;u++,o++)c[o]=e>>>(16>>>u&24)&255;e=0}return c},e._uint6ToB64=function(n){return n<26?n+65:n<52?n+71:n<62?n-4:n===62?43:n===63?47:65},e._base64EncArr=function(n){for(var i=2,u="",f=n.length,r=0,t=0;t<f;t++)i=t%3,t>0&&t*4/3%76==0&&(u+="\r\n"),r|=n[t]<<(16>>>i&24),(i===2||n.length-t==1)&&(u+=String.fromCharCode(this._uint6ToB64(r>>>18&63),this._uint6ToB64(r>>>12&63),this._uint6ToB64(r>>>6&63),this._uint6ToB64(r&63)),r=0);return u.substr(0,u.length-2+i)+(i===2?'':i===1?'=':'==')},e.prototype._serializeWorkSheets=function(){for(var i=[],t,n=0;n<this._sheets.length;n++)t=this._sheets[n],t&&(i[n]=t._serialize());return i},e.prototype._serializeWorkbookStyles=function(){for(var i=[],t,n=0;n<this._styles.length;n++)t=this._styles[n],t&&(i[n]=t._serialize());return i},e.prototype._deserializeWorkSheets=function(n){var i,r,t;for(this._sheets=[],t=0;t<n.length;t++)r=n[t],r&&(i=new o,i._deserialize(r),this._sheets[t]=i)},e.prototype._deserializeWorkbookStyles=function(n){var i,r,t;for(this._styles=[],t=0;t<n.length;t++)r=n[t],r&&(i=new f,i._deserialize(r),this._styles[t]=i)},e._alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZ',e._formatMap={n:'#,##0{0}',c:'{1}#,##0{0}_);({1}#,##0{0})',p:'0{0}%',f:'0{0}',d:'{0}',g:'0{0}'},e}(),o,s,h,c,l,f,a,v,y,e,r,u,i;t.Workbook=p;o=function(){function t(){}return Object.defineProperty(t.prototype,"columns",{get:function(){return this._columns==null&&(this._columns=[]),this._columns},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"cols",{get:function(){return n._deprecated('WorkSheet.cols','WorkSheet.columns'),this.columns},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"rows",{get:function(){return this._rows==null&&(this._rows=[]),this._rows},enumerable:!0,configurable:!0}),t.prototype._serialize=function(){var n;return this._checkEmptyWorkSheet()?null:(n={},this.style&&(n.style=this.style._serialize()),this._columns&&this._columns.length>0&&(n.cols=n.columns=this._serializeWorkbookColumns()),this._rows&&this._rows.length>0&&(n.rows=this._serializeWorkbookRows()),this.frozenPane&&(n.frozenPane=this.frozenPane._serialize()),this.name&&(n.name=this.name),this.summaryBelow!=null&&(n.summaryBelow=this.summaryBelow),this.visible!=null&&(n.visible=this.visible),n)},t.prototype._deserialize=function(n){var t,i;n.style&&(i=new f,i._deserialize(n.style),this.style=i);n.columns&&n.columns.length>0&&this._deserializeWorkbookColumns(n.columns);n.rows&&n.rows.length>0&&this._deserializeWorkbookRows(n.rows);n.frozenPane&&(t=new l,t._deserialize(n.frozenPane),this.frozenPane=t);this.name=n.name;this.summaryBelow=n.summaryBelow;this.visible=n.visible},t.prototype._addWorkbookColumn=function(n,t){this._columns==null&&(this._columns=[]);t==null||isNaN(t)?this._columns.push(n):this._columns[t]=n},t.prototype._addWorkbookRow=function(n,t){this._rows==null&&(this._rows=[]);t==null||isNaN(t)?this._rows.push(n):this._rows[t]=n},t.prototype._serializeWorkbookColumns=function(){for(var i=[],t,n=0;n<this._columns.length;n++)t=this._columns[n],t&&(i[n]=t._serialize());return i},t.prototype._serializeWorkbookRows=function(){for(var i=[],t,n=0;n<this._rows.length;n++)t=this._rows[n],t&&(i[n]=t._serialize());return i},t.prototype._deserializeWorkbookColumns=function(n){var i,r,t;for(this._columns=[],t=0;t<n.length;t++)i=n[t],i&&(r=new s,r._deserialize(i),this._columns[t]=r)},t.prototype._deserializeWorkbookRows=function(n){var i,r,t;for(this._rows=[],t=0;t<n.length;t++)i=n[t],i&&(r=new h,r._deserialize(i),this._rows[t]=r)},t.prototype._checkEmptyWorkSheet=function(){return this._rows==null&&this._columns==null&&this.visible==null&&this.summaryBelow==null&&this.frozenPane==null&&this.style==null&&(this.name==null||this.name==='')},t}();t.WorkSheet=o;s=function(){function n(){}return n.prototype._serialize=function(){var n;return this._checkEmptyWorkbookColumn()?null:(n={},this.style&&(n.style=this.style._serialize()),this.autoWidth!=null&&(n.autoWidth=this.autoWidth),this.width!=null&&(n.width=this.width),this.visible!=null&&(n.visible=this.visible),n)},n.prototype._deserialize=function(n){var t;n.style&&(t=new f,t._deserialize(n.style),this.style=t);this.autoWidth=n.autoWidth;this.visible=n.visible;this.width=n.width},n.prototype._checkEmptyWorkbookColumn=function(){return this.style==null&&this.width==null&&this.autoWidth==null&&this.visible==null},n}();t.WorkbookColumn=s;h=function(){function n(){}return Object.defineProperty(n.prototype,"cells",{get:function(){return this._cells==null&&(this._cells=[]),this._cells},enumerable:!0,configurable:!0}),n.prototype._serialize=function(){var n;return this._checkEmptyWorkbookRow()?null:(n={},this._cells&&this._cells.length>0&&(n.cells=this._serializeWorkbookCells()),this.style&&(n.style=this.style._serialize()),this.collapsed!=null&&(n.collapsed=this.collapsed),this.groupLevel==null||isNaN(this.groupLevel)||(n.groupLevel=this.groupLevel),this.height==null||isNaN(this.height)||(n.height=this.height),this.visible!=null&&(n.visible=this.visible),n)},n.prototype._deserialize=function(n){var t;n.cells&&n.cells.length>0&&this._deserializeWorkbookCells(n.cells);n.style&&(t=new f,t._deserialize(n.style),this.style=t);this.collapsed=n.collapsed;this.groupLevel=n.groupLevel;this.height=n.height;this.visible=n.visible},n.prototype._addWorkbookCell=function(n,t){this._cells==null&&(this._cells=[]);t==null||isNaN(t)?this._cells.push(n):this._cells[t]=n},n.prototype._serializeWorkbookCells=function(){for(var i=[],t,n=0;n<this._cells.length;n++)t=this._cells[n],t&&(i[n]=t._serialize());return i},n.prototype._deserializeWorkbookCells=function(n){var i,r,t;for(this._cells=[],t=0;t<n.length;t++)i=n[t],i&&(r=new c,r._deserialize(i),this._cells[t]=r)},n.prototype._checkEmptyWorkbookRow=function(){return this._cells==null&&this.style==null&&this.collapsed==null&&this.visible==null&&(this.height==null||isNaN(this.height))&&(this.groupLevel==null||isNaN(this.groupLevel))},n}();t.WorkbookRow=h;c=function(){function n(){}return n.prototype._serialize=function(){var n;return this._checkEmptyWorkbookCell()?null:(n={},this.style&&(n.style=this.style._serialize()),this.value!=null&&(n.value=this.value),this.formula&&(n.formula=this.formula),this.isDate!=null&&(n.isDate=this.isDate),this.colSpan!=null&&!isNaN(this.colSpan)&&this.colSpan>1&&(n.colSpan=this.colSpan),this.rowSpan!=null&&!isNaN(this.rowSpan)&&this.rowSpan>1&&(n.rowSpan=this.rowSpan),n)},n.prototype._deserialize=function(n){var t;n.style&&(t=new f,t._deserialize(n.style),this.style=t);this.value=n.value;this.formula=n.formula;this.isDate=n.isDate;this.colSpan=n.colSpan;this.rowSpan=n.rowSpan},n.prototype._checkEmptyWorkbookCell=function(){return this.style==null&&this.value==null&&this.isDate==null&&(this.formula==null||this.formula==='')&&(this.colSpan==null||isNaN(this.colSpan)||this.colSpan<=1)&&(this.rowSpan==null||isNaN(this.rowSpan)||this.rowSpan<=1)},n}();t.WorkbookCell=c;l=function(){function n(){}return n.prototype._serialize=function(){return(this.columns==null||isNaN(this.columns)||this.columns===0)&&(this.rows==null||isNaN(this.rows)||this.rows===0)?null:{columns:this.columns,rows:this.rows}},n.prototype._deserialize=function(n){this.columns=n.columns;this.rows=n.rows},n}();t.WorkbookFrozenPane=l;f=function(){function t(){}return t.prototype._serialize=function(){var t;return this._checkEmptyWorkbookStyle()?null:(t={},this.basedOn&&(t.basedOn=this.basedOn._serialize()),this.fill&&(t.fill=this.fill._serialize()),this.font&&(t.font=this.font._serialize()),this.borders&&(t.borders=this.borders._serialize()),this.format&&(t.format=this.format),this.hAlign!=null&&(t.hAlign=n.asEnum(this.hAlign,r,!1)),this.vAlign!=null&&(t.vAlign=n.asEnum(this.vAlign,u,!1)),this.indent==null||isNaN(this.indent)||(t.indent=this.indent),!this.wordWrap||(t.wordWrap=this.wordWrap),t)},t.prototype._deserialize=function(i){var f,e,o,s;i.basedOn&&(f=new t,f._deserialize(i.basedOn),this.basedOn=f);i.fill&&(e=new v,e._deserialize(i.fill),this.fill=e);i.font&&(o=new a,o._deserialize(i.font),this.font=o);i.borders&&(s=new y,s._deserialize(i.borders),this.borders=s);this.format=i.format;i.hAlign!=null&&(this.hAlign=n.asEnum(i.hAlign,r,!1));i.vAlign!=null&&(this.vAlign=n.asEnum(i.vAlign,u,!1));i.indent==null||isNaN(i.indent)||(this.indent=i.indent);!i.wordWrap||(this.wordWrap=i.wordWrap)},t.prototype._checkEmptyWorkbookStyle=function(){return this.basedOn==null&&this.fill==null&&this.font==null&&this.borders==null&&(this.format==null||this.format==='')&&this.hAlign==null&&this.vAlign==null&&this.wordWrap==null},t}();t.WorkbookStyle=f;a=function(){function n(){}return n.prototype._serialize=function(){var n;return this._checkEmptyWorkbookFont()?null:(n={},this.bold!=null&&(n.bold=this.bold),this.italic!=null&&(n.italic=this.italic),this.underline!=null&&(n.underline=this.underline),this.color&&(n.color=this.color),this.family&&(n.family=this.family),this.size==null||isNaN(this.size)||(n.size=this.size),n)},n.prototype._deserialize=function(n){this.bold=n.bold;this.color=n.color;this.family=n.family;this.italic=n.italic;this.size=n.size;this.underline=n.underline},n.prototype._checkEmptyWorkbookFont=function(){return this.bold==null&&this.italic==null&&this.underline==null&&(this.color==null||this.color==='')&&(this.family==null||this.family==='')&&(this.size==null||isNaN(this.size))},n}();t.WorkbookFont=a;v=function(){function n(){}return n.prototype._serialize=function(){return this.color?{color:this.color}:null},n.prototype._deserialize=function(n){this.color=n.color},n}();t.WorkbookFill=v;y=function(){function n(){}return n.prototype._serialize=function(){var n;return this._checkEmptyWorkbookBorder()?null:(n={},this.top&&(n.top=this.top._serialize()),this.bottom&&(n.bottom=this.bottom._serialize()),this.left&&(n.left=this.left._serialize()),this.right&&(n.right=this.right._serialize()),this.diagonal&&(n.diagonal=this.diagonal._serialize()),n)},n.prototype._deserialize=function(n){var t,i,r,u,f;n.top&&(t=new e,t._deserialize(n.top),this.top=t);n.bottom&&(i=new e,i._deserialize(n.bottom),this.bottom=i);n.left&&(r=new e,r._deserialize(n.left),this.left=r);n.right&&(u=new e,u._deserialize(n.right),this.right=u);n.diagonal&&(f=new e,f._deserialize(n.diagonal),this.diagonal=f)},n.prototype._checkEmptyWorkbookBorder=function(){return this.top==null&&this.bottom==null&&this.left==null&&this.right==null&&this.diagonal==null},n}();t.WorkbookBorder=y;e=function(){function t(){}return t.prototype._serialize=function(){var t;return(this.color==null||this.color==='')&&this.style==null?null:(t={},this.color&&(t.color=this.color),this.style!=null&&(t.style=n.asEnum(this.style,i,!1)),t)},t.prototype._deserialize=function(t){this.color=t.color;t.style!=null&&(this.style=n.asEnum(t.style,i,!1))},t}();t.WorkbookBorderSetting=e,function(n){n[n.General=0]="General";n[n.Left=1]="Left";n[n.Center=2]="Center";n[n.Right=3]="Right";n[n.Fill=4]="Fill";n[n.Justify=5]="Justify"}(t.HAlign||(t.HAlign={}));r=t.HAlign,function(n){n[n.Top=0]="Top";n[n.Center=1]="Center";n[n.Bottom=2]="Bottom";n[n.Justify=3]="Justify"}(t.VAlign||(t.VAlign={}));u=t.VAlign,function(n){n[n.None=0]="None";n[n.Thin=1]="Thin";n[n.Medium=2]="Medium";n[n.Dashed=3]="Dashed";n[n.Dotted=4]="Dotted";n[n.Thick=5]="Thick";n[n.Double=6]="Double";n[n.Hair=7]="Hair";n[n.MediumDashed=8]="MediumDashed";n[n.ThinDashDotted=9]="ThinDashDotted";n[n.MediumDashDotted=10]="MediumDashDotted";n[n.ThinDashDotDotted=11]="ThinDashDotDotted";n[n.MediumDashDotDotted=12]="MediumDashDotDotted";n[n.SlantedMediumDashDotted=13]="SlantedMediumDashDotted"}(t.BorderStyle||(t.BorderStyle={}));i=t.BorderStyle})(t=n.xlsx||(n.xlsx={}))}(wijmo||(wijmo={})),function(n){var t;(function(t){'use strict';var i=function(){function i(){}return i.export=function(i){n._deprecated('XlsxConverter.export','Workbook.save');var r=t._xlsx(i);return r.base64Array=t.Workbook._base64DecToArr(r.base64),r},i.exportToFile=function(t,r){var f,e;if(n._deprecated('XlsxConverter.exportToFile','Workbook.save'),f=i.export(t),e=new Blob([f.base64Array]),r)if(navigator.msSaveBlob)navigator.msSaveBlob(e,r);else{var u=document.createElement('a'),s=function(n){var t=document.createEvent('MouseEvents');t.initMouseEvent('click',!0,!1,window,0,0,0,0,0,!1,!1,!1,!1,0,null);n.dispatchEvent(t)},o=new FileReader;o.onloadend=function(){u.download=r;u.href=f.href();s(u);u=null};o.readAsDataURL(e)}},i.import=function(i){n._deprecated('XlsxConverter.import','Workbook.load');var r=typeof i=='string'?i:t.Workbook._base64EncArr(new Uint8Array(i));return t._xlsx(r)},i.xlsxDateFormat=function(i){return n._deprecated('XlsxConverter.xlsxDateFormat','Workbook.toXlsxDateFormat'),t.Workbook.toXlsxDateFormat(i)},i.xlsxNumberFormat=function(i){return n._deprecated('XlsxConverter.xlsxNumberFormat','Workbook.toXlsxNumberFormat'),t.Workbook.toXlsxNumberFormat(i)},i.netFormat=function(i){return n._deprecated('XlsxConverter.netFormat','Workbook.fromXlsxFormat'),t.Workbook.fromXlsxFormat(i)},i.xlsxIndex=function(i,r,u,f){return n._deprecated('XlsxConverter.xlsxIndex','Workbook.xlsxAddress'),t.Workbook.xlsxAddress(i,r,u,f)},i.numericIndex=function(i){return n._deprecated('XlsxConverter.numericIndex','Workbook.numericAddress'),t.Workbook.tableAddress(i)},i}();t.XlsxConverter=i})(t=n.xlsx||(n.xlsx={}))}(wijmo||(wijmo={}))
/*
    *
    * Wijmo Library 5.20163.234
    * http://wijmo.com/
    *
    * Copyright(c) GrapeCity, Inc.  All rights reserved.
    *
    * Licensed under the Wijmo Commercial License.
    * sales@wijmo.com
    * http://wijmo.com/products/wijmo-5/license/
    *
    */
var wj,__extends,wijmo;(function(wj){var interop;(function(interop){function isSimpleType(type){return type<=PropertyType.Enum}var ControlMetaFactory=function(){function ControlMetaFactory(){}return ControlMetaFactory.CreateProp=function(propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority){return new PropDescBase(propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority)},ControlMetaFactory.CreateEvent=function(eventName,isPropChanged){return new EventDescBase(eventName,isPropChanged)},ControlMetaFactory.CreateComplexProp=function(propertyName,isArray,ownsObject){return new ComplexPropDescBase(propertyName,isArray,ownsObject)},ControlMetaFactory.findProp=function(propName,props){return this.findInArr(props,'propertyName',propName)},ControlMetaFactory.findEvent=function(eventName,events){return this.findInArr(events,'eventName',eventName)},ControlMetaFactory.findComplexProp=function(propName,props){return this.findInArr(props,'propertyName',propName)},ControlMetaFactory.getMetaData=function(metaDataId){switch(metaDataId){case wijmo.Control:return new MetaDataBase([this.CreateProp('isDisabled',PropertyType.Boolean),this.CreateProp('disabled',PropertyType.Boolean),],[this.CreateEvent('gotFocus'),this.CreateEvent('lostFocus')]);case wijmo.input&&wijmo.input.DropDown:return this.getMetaData(wijmo.Control).add([this.CreateProp('isDroppedDown',PropertyType.Boolean,'isDroppedDownChanged'),this.CreateProp('showDropDownButton',PropertyType.Boolean),this.CreateProp('autoExpandSelection',PropertyType.Boolean),this.CreateProp('placeholder',PropertyType.String),this.CreateProp('dropDownCssClass',PropertyType.String),this.CreateProp('isReadOnly',PropertyType.Boolean),this.CreateProp('isRequired',PropertyType.Boolean),this.CreateProp('required',PropertyType.Boolean),this.CreateProp('text',PropertyType.String,'textChanged',null,!0,1e3)],[this.CreateEvent('isDroppedDownChanging'),this.CreateEvent('isDroppedDownChanged',!0),this.CreateEvent('textChanged',!0)]);case wijmo.input&&wijmo.input.ComboBox:return this.getMetaData(wijmo.input.DropDown).add([this.CreateProp('displayMemberPath',PropertyType.String),this.CreateProp('selectedValuePath',PropertyType.String),this.CreateProp('headerPath',PropertyType.String),this.CreateProp('isContentHtml',PropertyType.Boolean),this.CreateProp('isEditable',PropertyType.Boolean),this.CreateProp('maxDropDownHeight',PropertyType.Number),this.CreateProp('maxDropDownWidth',PropertyType.Number),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('itemsSource',PropertyType.Any,'',null,!0,900),this.CreateProp('selectedIndex',PropertyType.Number,'selectedIndexChanged',null,!0,1e3),this.CreateProp('selectedItem',PropertyType.Any,'selectedIndexChanged',null,!0,1e3),this.CreateProp('selectedValue',PropertyType.Any,'selectedIndexChanged',null,!0,1e3),],[this.CreateEvent('selectedIndexChanged',!0)]).addOptions({ngModelProperty:'selectedValue'});case wijmo.input&&wijmo.input.AutoComplete:return this.getMetaData(wijmo.input.ComboBox).add([this.CreateProp('delay',PropertyType.Number),this.CreateProp('maxItems',PropertyType.Number),this.CreateProp('minLength',PropertyType.Number),this.CreateProp('cssMatch',PropertyType.String),this.CreateProp('itemsSourceFunction',PropertyType.Function),this.CreateProp('searchMemberPath',PropertyType.String)]);case wijmo.input&&wijmo.input.Calendar:return this.getMetaData(wijmo.Control).add([this.CreateProp('monthView',PropertyType.Boolean),this.CreateProp('showHeader',PropertyType.Boolean),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('itemValidator',PropertyType.Function),this.CreateProp('displayMonth',PropertyType.Date,'displayMonthChanged'),this.CreateProp('firstDayOfWeek',PropertyType.Number),this.CreateProp('max',PropertyType.Date),this.CreateProp('min',PropertyType.Date),this.CreateProp('selectionMode',PropertyType.Enum,'',wijmo.input.DateSelectionMode),this.CreateProp('isReadOnly',PropertyType.Boolean),this.CreateProp('value',PropertyType.Date,'valueChanged'),],[this.CreateEvent('valueChanged',!0),this.CreateEvent('displayMonthChanged',!0),this.CreateEvent('formatItem',!1)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.ColorPicker:return this.getMetaData(wijmo.Control).add([this.CreateProp('showAlphaChannel',PropertyType.Boolean),this.CreateProp('showColorString',PropertyType.Boolean),this.CreateProp('palette',PropertyType.Any),this.CreateProp('value',PropertyType.String,'valueChanged')],[this.CreateEvent('valueChanged',!0)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.ListBox:return this.getMetaData(wijmo.Control).add([this.CreateProp('isContentHtml',PropertyType.Boolean),this.CreateProp('maxHeight',PropertyType.Number),this.CreateProp('selectedValuePath',PropertyType.String),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('displayMemberPath',PropertyType.String),this.CreateProp('checkedMemberPath',PropertyType.String),this.CreateProp('itemsSource',PropertyType.Any),this.CreateProp('selectedIndex',PropertyType.Number,'selectedIndexChanged'),this.CreateProp('selectedItem',PropertyType.Any,'selectedIndexChanged'),this.CreateProp('selectedValue',PropertyType.Any,'selectedIndexChanged'),],[this.CreateEvent('formatItem',!1),this.CreateEvent('itemsChanged',!0),this.CreateEvent('itemChecked',!0),this.CreateEvent('selectedIndexChanged',!0)]).addOptions({ngModelProperty:'selectedValue'});case'ItemTemplate':return new MetaDataBase([],[],[],undefined,undefined,undefined,'owner');case wijmo.input&&wijmo.input.Menu:return this.getMetaData(wijmo.input.ComboBox).add([this.CreateProp('header',PropertyType.String),this.CreateProp('commandParameterPath',PropertyType.String),this.CreateProp('commandPath',PropertyType.String),this.CreateProp('isButton',PropertyType.Boolean),this.CreateProp('value',PropertyType.Any,'itemClicked',null,!1,1e3)],[this.CreateEvent('itemClicked')]);case'MenuItem':return new MetaDataBase([this.CreateProp('value',PropertyType.Any,''),this.CreateProp('cmd',PropertyType.Any,''),this.CreateProp('cmdParam',PropertyType.Any,'')],[],[],'itemsSource',!0);case'MenuSeparator':return new MetaDataBase([],[],[],'itemsSource',!0);case wijmo.input&&wijmo.input.InputDate:return this.getMetaData(wijmo.input.DropDown).add([this.CreateProp('selectionMode',PropertyType.Enum,'',wijmo.input.DateSelectionMode),this.CreateProp('format',PropertyType.String),this.CreateProp('mask',PropertyType.String),this.CreateProp('max',PropertyType.Date),this.CreateProp('min',PropertyType.Date),this.CreateProp('inputType',PropertyType.String),this.CreateProp('value',PropertyType.Date,'valueChanged',null,!0,1e3),this.CreateProp('itemValidator',PropertyType.Function),this.CreateProp('itemFormatter',PropertyType.Function)],[this.CreateEvent('valueChanged',!0)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.InputDateTime:return this.getMetaData(wijmo.input.InputDate).add([this.CreateProp('timeMax',PropertyType.Date),this.CreateProp('timeMin',PropertyType.Date),this.CreateProp('timeStep',PropertyType.Number),this.CreateProp('timeFormat',PropertyType.String),],[this.CreateEvent('valueChanged',!0)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.InputNumber:return this.getMetaData(wijmo.Control).add([this.CreateProp('showSpinner',PropertyType.Boolean),this.CreateProp('max',PropertyType.Number),this.CreateProp('min',PropertyType.Number),this.CreateProp('step',PropertyType.Number),this.CreateProp('isRequired',PropertyType.Boolean),this.CreateProp('required',PropertyType.Boolean),this.CreateProp('placeholder',PropertyType.String),this.CreateProp('inputType',PropertyType.String),this.CreateProp('format',PropertyType.String),this.CreateProp('isReadOnly',PropertyType.Boolean),this.CreateProp('value',PropertyType.Number,'valueChanged'),this.CreateProp('text',PropertyType.String,'textChanged')],[this.CreateEvent('valueChanged',!0),this.CreateEvent('textChanged',!0)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.InputMask:return this.getMetaData(wijmo.Control).add([this.CreateProp('mask',PropertyType.String),this.CreateProp('isRequired',PropertyType.Boolean),this.CreateProp('promptChar',PropertyType.String),this.CreateProp('placeholder',PropertyType.String),this.CreateProp('rawValue',PropertyType.String,'valueChanged'),this.CreateProp('value',PropertyType.String,'valueChanged')],[this.CreateEvent('valueChanged',!0),]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.InputTime:return this.getMetaData(wijmo.input.ComboBox).add([this.CreateProp('max',PropertyType.Date),this.CreateProp('min',PropertyType.Date),this.CreateProp('step',PropertyType.Number),this.CreateProp('format',PropertyType.String),this.CreateProp('mask',PropertyType.String),this.CreateProp('inputType',PropertyType.String),this.CreateProp('value',PropertyType.Date,'valueChanged',null,!0,1e3),],[this.CreateEvent('valueChanged',!0)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.InputColor:return this.getMetaData(wijmo.input.DropDown).add([this.CreateProp('showAlphaChannel',PropertyType.Boolean),this.CreateProp('value',PropertyType.String,'valueChanged')],[this.CreateEvent('valueChanged',!0)]).addOptions({ngModelProperty:'value'});case wijmo.input&&wijmo.input.Popup:return this.getMetaData(wijmo.Control).add([this.CreateProp('owner',PropertyType.String),this.CreateProp('showTrigger',PropertyType.Enum,'',wijmo.input.PopupTrigger),this.CreateProp('hideTrigger',PropertyType.Enum,'',wijmo.input.PopupTrigger),this.CreateProp('fadeIn',PropertyType.Boolean),this.CreateProp('fadeOut',PropertyType.Boolean),this.CreateProp('dialogResultEnter',PropertyType.String),this.CreateProp('modal',PropertyType.Boolean),],[this.CreateEvent('showing'),this.CreateEvent('shown'),this.CreateEvent('hiding'),this.CreateEvent('hidden'),]);case wijmo.input&&wijmo.input.MultiSelect:return this.getMetaData(wijmo.input.ComboBox).add([this.CreateProp('checkedMemberPath',PropertyType.String),this.CreateProp('maxHeaderItems',PropertyType.Number),this.CreateProp('headerFormat',PropertyType.String),this.CreateProp('headerFormatter',PropertyType.Function),this.CreateProp('checkedItems',PropertyType.Any,'checkedItemsChanged',BindingMode.TwoWay,!0,950),],[this.CreateEvent('checkedItemsChanged',!0)]);case'CollectionViewNavigator':return new MetaDataBase([this.CreateProp('cv',PropertyType.Any)]);case'CollectionViewPager':return new MetaDataBase([this.CreateProp('cv',PropertyType.Any)]);case wijmo.grid&&wijmo.grid.FlexGrid:return this.getMetaData(wijmo.Control).add([this.CreateProp('newRowAtTop',PropertyType.Boolean),this.CreateProp('allowAddNew',PropertyType.Boolean),this.CreateProp('allowDelete',PropertyType.Boolean),this.CreateProp('allowDragging',PropertyType.Enum,'',wijmo.grid.AllowDragging),this.CreateProp('allowMerging',PropertyType.Enum,'',wijmo.grid.AllowMerging),this.CreateProp('allowResizing',PropertyType.Enum,'',wijmo.grid.AllowResizing),this.CreateProp('allowSorting',PropertyType.Boolean),this.CreateProp('autoSizeMode',PropertyType.Enum,'',wijmo.grid.AutoSizeMode),this.CreateProp('autoGenerateColumns',PropertyType.Boolean),this.CreateProp('childItemsPath',PropertyType.Any),this.CreateProp('groupHeaderFormat',PropertyType.String),this.CreateProp('headersVisibility',PropertyType.Enum,'',wijmo.grid.HeadersVisibility),this.CreateProp('showSelectedHeaders',PropertyType.Enum,'',wijmo.grid.HeadersVisibility),this.CreateProp('showMarquee',PropertyType.Boolean),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('isReadOnly',PropertyType.Boolean),this.CreateProp('imeEnabled',PropertyType.Boolean),this.CreateProp('mergeManager',PropertyType.Any),this.CreateProp('selectionMode',PropertyType.Enum,'',wijmo.grid.SelectionMode),this.CreateProp('showGroups',PropertyType.Boolean),this.CreateProp('showSort',PropertyType.Boolean),this.CreateProp('showAlternatingRows',PropertyType.Boolean),this.CreateProp('showErrors',PropertyType.Boolean),this.CreateProp('validateEdits',PropertyType.Boolean),this.CreateProp('treeIndent',PropertyType.Number),this.CreateProp('itemsSource',PropertyType.Any),this.CreateProp('autoClipboard',PropertyType.Boolean),this.CreateProp('frozenRows',PropertyType.Number),this.CreateProp('frozenColumns',PropertyType.Number),this.CreateProp('deferResizing',PropertyType.Boolean),this.CreateProp('sortRowIndex',PropertyType.Number),this.CreateProp('stickyHeaders',PropertyType.Boolean),this.CreateProp('preserveSelection',PropertyType.Boolean),this.CreateProp('preserveOutlineState',PropertyType.Boolean)],[this.CreateEvent('beginningEdit'),this.CreateEvent('cellEditEnded'),this.CreateEvent('cellEditEnding'),this.CreateEvent('prepareCellForEdit'),this.CreateEvent('formatItem'),this.CreateEvent('resizingColumn'),this.CreateEvent('resizedColumn'),this.CreateEvent('autoSizingColumn'),this.CreateEvent('autoSizedColumn'),this.CreateEvent('draggingColumn'),this.CreateEvent('draggedColumn'),this.CreateEvent('sortingColumn'),this.CreateEvent('sortedColumn'),this.CreateEvent('resizingRow'),this.CreateEvent('resizedRow'),this.CreateEvent('autoSizingRow'),this.CreateEvent('autoSizedRow'),this.CreateEvent('draggingRow'),this.CreateEvent('draggedRow'),this.CreateEvent('deletingRow'),this.CreateEvent('loadingRows'),this.CreateEvent('loadedRows'),this.CreateEvent('rowEditStarting'),this.CreateEvent('rowEditStarted'),this.CreateEvent('rowEditEnding'),this.CreateEvent('rowEditEnded'),this.CreateEvent('rowAdded'),this.CreateEvent('groupCollapsedChanged'),this.CreateEvent('groupCollapsedChanging'),this.CreateEvent('itemsSourceChanged',!0),this.CreateEvent('selectionChanging'),this.CreateEvent('selectionChanged',!0),this.CreateEvent('scrollPositionChanged',!1),this.CreateEvent('updatingView'),this.CreateEvent('updatedView'),this.CreateEvent('updatingLayout'),this.CreateEvent('updatedLayout'),this.CreateEvent('pasting'),this.CreateEvent('pasted'),this.CreateEvent('pastingCell'),this.CreateEvent('pastedCell'),this.CreateEvent('copying'),this.CreateEvent('copied')]);case wijmo.grid&&wijmo.grid.Column:return new MetaDataBase([this.CreateProp('name',PropertyType.String),this.CreateProp('dataMap',PropertyType.Any),this.CreateProp('dataType',PropertyType.Enum,'',wijmo.DataType),this.CreateProp('binding',PropertyType.String),this.CreateProp('sortMemberPath',PropertyType.String),this.CreateProp('format',PropertyType.String),this.CreateProp('header',PropertyType.String),this.CreateProp('width',PropertyType.Number),this.CreateProp('minWidth',PropertyType.Number),this.CreateProp('maxWidth',PropertyType.Number),this.CreateProp('align',PropertyType.String),this.CreateProp('allowDragging',PropertyType.Boolean),this.CreateProp('allowSorting',PropertyType.Boolean),this.CreateProp('allowResizing',PropertyType.Boolean),this.CreateProp('allowMerging',PropertyType.Boolean),this.CreateProp('aggregate',PropertyType.Enum,'',wijmo.Aggregate),this.CreateProp('isReadOnly',PropertyType.Boolean),this.CreateProp('cssClass',PropertyType.String),this.CreateProp('isContentHtml',PropertyType.Boolean),this.CreateProp('isSelected',PropertyType.Boolean,'grid.selectionChanged'),this.CreateProp('visible',PropertyType.Boolean),this.CreateProp('wordWrap',PropertyType.Boolean),this.CreateProp('mask',PropertyType.String),this.CreateProp('inputType',PropertyType.String),this.CreateProp('isRequired',PropertyType.Boolean),this.CreateProp('required',PropertyType.Boolean),this.CreateProp('showDropDown',PropertyType.Boolean),this.CreateProp('dropDownCssClass',PropertyType.String),],[],[],'columns',!0);case'FlexGridCellTemplate':return new MetaDataBase([this.CreateProp('cellType',PropertyType.String,'',null,!1),this.CreateProp('cellOverflow',PropertyType.String,''),],[],[],undefined,undefined,undefined,'owner');case wijmo.grid&&wijmo.grid.filter&&wijmo.grid.filter.FlexGridFilter:return new MetaDataBase([this.CreateProp('showFilterIcons',PropertyType.Boolean),this.CreateProp('showSortButtons',PropertyType.Boolean),this.CreateProp('defaultFilterType',PropertyType.Enum,'',wijmo.grid.filter.FilterType),this.CreateProp('filterColumns',PropertyType.Any),],[this.CreateEvent('filterChanging'),this.CreateEvent('filterChanged'),this.CreateEvent('filterApplied')],[],undefined,undefined,undefined,'');case wijmo.grid&&wijmo.grid.grouppanel&&wijmo.grid.grouppanel.GroupPanel:return this.getMetaData(wijmo.Control).add([this.CreateProp('hideGroupedColumns',PropertyType.Boolean),this.CreateProp('maxGroups',PropertyType.Number),this.CreateProp('placeholder',PropertyType.String),this.CreateProp('grid',PropertyType.Any),]);case wijmo.grid&&wijmo.grid.detail&&wijmo.grid.detail.FlexGridDetailProvider:return new MetaDataBase([this.CreateProp('maxHeight',PropertyType.Number),this.CreateProp('detailVisibilityMode',PropertyType.Enum,'',wijmo.grid.detail.DetailVisibilityMode),this.CreateProp('rowHasDetail',PropertyType.Function),],[],[],undefined,undefined,undefined,'');case wijmo.grid&&wijmo.grid.sheet&&wijmo.grid.sheet.FlexSheet:return this.getMetaData(wijmo.grid.FlexGrid).add([this.CreateProp('isTabHolderVisible',PropertyType.Boolean),this.CreateProp('selectedSheetIndex',PropertyType.Number,'selectedSheetChanged'),],[this.CreateEvent('selectedSheetChanged',!0),this.CreateEvent('draggingRowColumn'),this.CreateEvent('droppingRowColumn'),this.CreateEvent('loaded'),this.CreateEvent('unknownFunction'),this.CreateEvent('sheetCleared')]);case wijmo.grid&&wijmo.grid.sheet&&wijmo.grid.sheet.Sheet:return new MetaDataBase([this.CreateProp('name',PropertyType.String),this.CreateProp('itemsSource',PropertyType.Any),this.CreateProp('visible',PropertyType.Boolean),this.CreateProp('rowCount',PropertyType.Number,'',null,!1),this.CreateProp('columnCount',PropertyType.Number,'',null,!1)],[this.CreateEvent('nameChanged'),]).addOptions({parentReferenceProperty:''});case wijmo.grid&&wijmo.grid.multirow&&wijmo.grid.multirow.MultiRow:return this.getMetaData(wijmo.grid.FlexGrid).add([this.CreateProp('layoutDefinition',PropertyType.Any),this.CreateProp('centerHeadersVertically',PropertyType.Boolean),this.CreateProp('collapsedHeaders',PropertyType.Boolean),this.CreateProp('showHeaderCollapseButton',PropertyType.Boolean)]);case wijmo.chart&&wijmo.chart.FlexChartBase:return this.getMetaData(wijmo.Control).add([this.CreateProp('binding',PropertyType.String),this.CreateProp('footer',PropertyType.String),this.CreateProp('header',PropertyType.String),this.CreateProp('selectionMode',PropertyType.Enum,'',wijmo.chart.SelectionMode),this.CreateProp('palette',PropertyType.Any),this.CreateProp('plotMargin',PropertyType.Any),this.CreateProp('footerStyle',PropertyType.Any),this.CreateProp('headerStyle',PropertyType.Any),this.CreateProp('tooltipContent',PropertyType.String,'',null,!1),this.CreateProp('itemsSource',PropertyType.Any)],[this.CreateEvent('rendering'),this.CreateEvent('rendered'),]);case wijmo.chart&&wijmo.chart.FlexChartCore:return this.getMetaData(wijmo.chart.FlexChartBase).add([this.CreateProp('bindingX',PropertyType.String),this.CreateProp('interpolateNulls',PropertyType.Boolean),this.CreateProp('legendToggle',PropertyType.Boolean),this.CreateProp('symbolSize',PropertyType.Number),this.CreateProp('options',PropertyType.Any),this.CreateProp('selection',PropertyType.Any,'selectionChanged'),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('labelContent',PropertyType.String,'',null,!1),],[this.CreateEvent('seriesVisibilityChanged'),this.CreateEvent('selectionChanged',!0),],[this.CreateComplexProp('axisX',!1,!1),this.CreateComplexProp('axisY',!1,!1),this.CreateComplexProp('axes',!0),this.CreateComplexProp('plotAreas',!0)]);case wijmo.chart&&wijmo.chart.FlexChart:return this.getMetaData(wijmo.chart.FlexChartCore).add([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.chart.ChartType),this.CreateProp('rotated',PropertyType.Boolean),this.CreateProp('stacking',PropertyType.Enum,'',wijmo.chart.Stacking),]);case wijmo.chart&&wijmo.chart.FlexPie:return this.getMetaData(wijmo.chart.FlexChartBase).add([this.CreateProp('bindingName',PropertyType.String),this.CreateProp('innerRadius',PropertyType.Number),this.CreateProp('isAnimated',PropertyType.Boolean),this.CreateProp('offset',PropertyType.Number),this.CreateProp('reversed',PropertyType.Boolean),this.CreateProp('startAngle',PropertyType.Number),this.CreateProp('selectedItemPosition',PropertyType.Enum,'',wijmo.chart.Position),this.CreateProp('selectedItemOffset',PropertyType.Number),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('labelContent',PropertyType.String,'',null,!1),]);case wijmo.chart&&wijmo.chart.FlexPie&&wijmo.chart.hierarchical&&wijmo.chart.hierarchical.Sunburst:return this.getMetaData(wijmo.chart.FlexChartBase).add([this.CreateProp('bindingName',PropertyType.Any),this.CreateProp('innerRadius',PropertyType.Number),this.CreateProp('isAnimated',PropertyType.Boolean),this.CreateProp('offset',PropertyType.Number),this.CreateProp('reversed',PropertyType.Boolean),this.CreateProp('startAngle',PropertyType.Number),this.CreateProp('selectedItemPosition',PropertyType.Enum,'',wijmo.chart.Position),this.CreateProp('selectedItemOffset',PropertyType.Number),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('labelContent',PropertyType.String,'',null,!1),this.CreateProp('childItemsPath',PropertyType.Any)]);case wijmo.chart&&wijmo.chart.Axis:return new MetaDataBase([this.CreateProp('axisLine',PropertyType.Boolean),this.CreateProp('format',PropertyType.String),this.CreateProp('labels',PropertyType.Boolean),this.CreateProp('majorGrid',PropertyType.Boolean),this.CreateProp('majorTickMarks',PropertyType.Enum,'',wijmo.chart.TickMark),this.CreateProp('majorUnit',PropertyType.Number),this.CreateProp('max',PropertyType.Number),this.CreateProp('min',PropertyType.Number),this.CreateProp('position',PropertyType.Enum,'',wijmo.chart.Position),this.CreateProp('reversed',PropertyType.Boolean),this.CreateProp('title',PropertyType.String),this.CreateProp('labelAngle',PropertyType.Number),this.CreateProp('minorGrid',PropertyType.Boolean),this.CreateProp('minorTickMarks',PropertyType.Enum,'',wijmo.chart.TickMark),this.CreateProp('minorUnit',PropertyType.Number),this.CreateProp('origin',PropertyType.Number),this.CreateProp('logBase',PropertyType.Number),this.CreateProp('plotArea',PropertyType.Any),this.CreateProp('labelAlign',PropertyType.String),this.CreateProp('name',PropertyType.String),this.CreateProp('overlappingLabels',PropertyType.Enum,'',wijmo.chart.OverlappingLabels),this.CreateProp('labelPadding',PropertyType.Number),this.CreateProp('itemFormatter',PropertyType.Function),this.CreateProp('itemsSource',PropertyType.Any),this.CreateProp('binding',PropertyType.String),],[this.CreateEvent('rangeChanged'),],[],'axes',!0);case wijmo.chart&&wijmo.chart.Legend:return new MetaDataBase([this.CreateProp('position',PropertyType.Enum,'',wijmo.chart.Position)],[],[],'legend',!1,!1);case wijmo.chart&&wijmo.chart.DataLabelBase:return new MetaDataBase([this.CreateProp('content',PropertyType.Any,''),this.CreateProp('border',PropertyType.Boolean),],[],[],'dataLabel',!1,!1);case wijmo.chart&&wijmo.chart.DataLabel:return this.getMetaData(wijmo.chart.DataLabelBase).add([this.CreateProp('position',PropertyType.Enum,'',wijmo.chart.LabelPosition),]);case wijmo.chart&&wijmo.chart.PieDataLabel:return this.getMetaData(wijmo.chart.DataLabelBase).add([this.CreateProp('position',PropertyType.Enum,'',wijmo.chart.PieLabelPosition),]);case wijmo.chart&&wijmo.chart.SeriesBase:return new MetaDataBase([this.CreateProp('axisX',PropertyType.Any),this.CreateProp('axisY',PropertyType.Any),this.CreateProp('binding',PropertyType.String),this.CreateProp('bindingX',PropertyType.String),this.CreateProp('cssClass',PropertyType.String),this.CreateProp('name',PropertyType.String),this.CreateProp('style',PropertyType.Any),this.CreateProp('altStyle',PropertyType.Any),this.CreateProp('symbolMarker',PropertyType.Enum,'',wijmo.chart.Marker),this.CreateProp('symbolSize',PropertyType.Number),this.CreateProp('symbolStyle',PropertyType.Any),this.CreateProp('visibility',PropertyType.Enum,'chart.seriesVisibilityChanged',wijmo.chart.SeriesVisibility),this.CreateProp('itemsSource',PropertyType.Any),],[this.CreateEvent('rendering'),this.CreateEvent('rendered')],[this.CreateComplexProp('axisX',!1,!0),this.CreateComplexProp('axisY',!1,!0),],'series',!0);case wijmo.chart&&wijmo.chart.Series:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.chart.ChartType)]);case wijmo.chart&&wijmo.chart.LineMarker:return new MetaDataBase([this.CreateProp('isVisible',PropertyType.Boolean),this.CreateProp('seriesIndex',PropertyType.Number),this.CreateProp('horizontalPosition',PropertyType.Number),this.CreateProp('content',PropertyType.Function),this.CreateProp('verticalPosition',PropertyType.Number),this.CreateProp('alignment',PropertyType.Enum,'',wijmo.chart.LineMarkerAlignment),this.CreateProp('lines',PropertyType.Enum,'',wijmo.chart.LineMarkerLines),this.CreateProp('interaction',PropertyType.Enum,'',wijmo.chart.LineMarkerInteraction),this.CreateProp('dragLines',PropertyType.Boolean),this.CreateProp('dragThreshold',PropertyType.Number),this.CreateProp('dragContent',PropertyType.Boolean),],[this.CreateEvent('positionChanged'),],[],undefined,undefined,undefined,'');case wijmo.chart&&wijmo.chart.DataPoint:return new MetaDataBase([this.CreateProp('x',PropertyType.AnyPrimitive),this.CreateProp('y',PropertyType.AnyPrimitive)],[],[],'');case wijmo.chart&&wijmo.chart.annotation&&wijmo.chart.annotation.AnnotationLayer:return new MetaDataBase([],[],[],undefined,undefined,undefined,'');case'FlexChartAnnotation':return new MetaDataBase([this.CreateProp('type',PropertyType.String,'',null,!1),this.CreateProp('attachment',PropertyType.Enum,'',wijmo.chart.annotation.AnnotationAttachment),this.CreateProp('position',PropertyType.Enum,'',wijmo.chart.annotation.AnnotationPosition),this.CreateProp('point',PropertyType.Any),this.CreateProp('seriesIndex',PropertyType.Number),this.CreateProp('pointIndex',PropertyType.Number),this.CreateProp('offset',PropertyType.Any),this.CreateProp('style',PropertyType.Any),this.CreateProp('isVisible',PropertyType.Boolean),this.CreateProp('tooltip',PropertyType.String),this.CreateProp('text',PropertyType.String),this.CreateProp('content',PropertyType.String),this.CreateProp('name',PropertyType.String),this.CreateProp('width',PropertyType.Number),this.CreateProp('height',PropertyType.Number),this.CreateProp('start',PropertyType.Any),this.CreateProp('end',PropertyType.Any),this.CreateProp('radius',PropertyType.Number),this.CreateProp('length',PropertyType.Number),this.CreateProp('href',PropertyType.String)],[],[this.CreateComplexProp('point',!1,!0),this.CreateComplexProp('start',!1,!0),this.CreateComplexProp('end',!1,!0),this.CreateComplexProp('points',!0),],'items',!0);case wijmo.chart&&wijmo.chart.interaction&&wijmo.chart.interaction.RangeSelector:return new MetaDataBase([this.CreateProp('isVisible',PropertyType.Boolean),this.CreateProp('min',PropertyType.Number),this.CreateProp('max',PropertyType.Number),this.CreateProp('orientation',PropertyType.Enum,'',wijmo.chart.interaction.Orientation),this.CreateProp('seamless',PropertyType.Boolean),this.CreateProp('minScale',PropertyType.Number),this.CreateProp('maxScale',PropertyType.Number),],[this.CreateEvent('rangeChanged'),],[],undefined,undefined,undefined,'');case wijmo.chart&&wijmo.chart.interaction&&wijmo.chart.interaction.ChartGestures:return new MetaDataBase([this.CreateProp('mouseAction',PropertyType.Enum,'',wijmo.chart.interaction.MouseAction),this.CreateProp('interactiveAxes',PropertyType.Enum,'',wijmo.chart.interaction.InteractiveAxes),this.CreateProp('enable',PropertyType.Boolean),this.CreateProp('scaleX',PropertyType.Number),this.CreateProp('scaleY',PropertyType.Number),this.CreateProp('posX',PropertyType.Number),this.CreateProp('posY',PropertyType.Number),],[],[],undefined,undefined,undefined,'');case wijmo.chart&&wijmo.chart.animation&&wijmo.chart.animation.ChartAnimation:return new MetaDataBase([this.CreateProp('animationMode',PropertyType.Enum,'',wijmo.chart.animation.AnimationMode),this.CreateProp('easing',PropertyType.Enum,'',wijmo.chart.animation.Easing),this.CreateProp('duration',PropertyType.Number),this.CreateProp('axisAnimation',PropertyType.Boolean)],[],[],undefined,undefined,undefined,'');case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.FinancialChart:return this.getMetaData(wijmo.chart.FlexChartCore).add([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.chart.finance.FinancialChartType),]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.FinancialSeries:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.chart.finance.FinancialChartType)]);case wijmo.chart&&wijmo.chart.radar&&wijmo.chart.radar.FlexRadar:return this.getMetaData(wijmo.chart.FlexChartCore).add([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.chart.radar.RadarChartType),this.CreateProp('startAngle',PropertyType.Number),this.CreateProp('totalAngle',PropertyType.Number),this.CreateProp('reversed',PropertyType.Boolean),this.CreateProp('stacking',PropertyType.Enum,'',wijmo.chart.Stacking)]);case wijmo.chart&&wijmo.chart.radar&&wijmo.chart.radar.FlexRadarSeries:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.chart.radar.RadarChartType)]);case wijmo.chart&&wijmo.chart.radar&&wijmo.chart.radar.FlexRadarAxis:return this.getMetaData(wijmo.chart.Axis);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.TrendLineBase:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('sampleCount',PropertyType.Number)]);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.TrendLine:return this.getMetaData(wijmo.chart.analytics.TrendLineBase).add([this.CreateProp('order',PropertyType.Number),this.CreateProp('fitType',PropertyType.Enum,'',wijmo.chart.analytics.TrendLineFitType)]);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.MovingAverage:return this.getMetaData(wijmo.chart.analytics.TrendLineBase).add([this.CreateProp('period',PropertyType.Number),this.CreateProp('type',PropertyType.Enum,'',wijmo.chart.analytics.MovingAverageType)]);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.FunctionSeries:return this.getMetaData(wijmo.chart.analytics.TrendLineBase).add([this.CreateProp('min',PropertyType.Number),this.CreateProp('max',PropertyType.Number),]);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.YFunctionSeries:return this.getMetaData(wijmo.chart.analytics.FunctionSeries).add([this.CreateProp('func',PropertyType.Function),]);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.ParametricFunctionSeries:return this.getMetaData(wijmo.chart.analytics.FunctionSeries).add([this.CreateProp('func',PropertyType.Function),this.CreateProp('xFunc',PropertyType.Function),this.CreateProp('yFunc',PropertyType.Function),]);case wijmo.chart&&wijmo.chart.analytics&&wijmo.chart.analytics.Waterfall:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('relativeData',PropertyType.Boolean),this.CreateProp('start',PropertyType.Number),this.CreateProp('startLabel',PropertyType.String),this.CreateProp('showTotal',PropertyType.Boolean),this.CreateProp('totalLabel',PropertyType.String),this.CreateProp('showIntermediateTotal',PropertyType.Boolean),this.CreateProp('intermediateTotalPositions',PropertyType.Any),this.CreateProp('intermediateTotalLabels',PropertyType.Any),this.CreateProp('connectorLines',PropertyType.Boolean),this.CreateProp('styles',PropertyType.Any)]);case wijmo.chart&&wijmo.chart.PlotArea:return new MetaDataBase([this.CreateProp('column',PropertyType.Number),this.CreateProp('height',PropertyType.String),this.CreateProp('name',PropertyType.String),this.CreateProp('row',PropertyType.Number),this.CreateProp('style',PropertyType.Any),this.CreateProp('width',PropertyType.String),],[],[],'plotAreas',!0);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.Fibonacci:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('high',PropertyType.Number),this.CreateProp('low',PropertyType.Number),this.CreateProp('labelPosition',PropertyType.Enum,'',wijmo.chart.LabelPosition),this.CreateProp('levels',PropertyType.Any),this.CreateProp('minX',PropertyType.AnyPrimitive),this.CreateProp('maxX',PropertyType.AnyPrimitive),this.CreateProp('uptrend',PropertyType.Boolean)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.FibonacciTimeZones:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('startX',PropertyType.Any),this.CreateProp('endX',PropertyType.Any),this.CreateProp('labelPosition',PropertyType.Enum,'',wijmo.chart.LabelPosition),this.CreateProp('levels',PropertyType.Any)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.FibonacciArcs:case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.FibonacciFans:return this.getMetaData(wijmo.chart.SeriesBase).add([this.CreateProp('start',PropertyType.Any),this.CreateProp('end',PropertyType.Any),this.CreateProp('labelPosition',PropertyType.Enum,'',wijmo.chart.LabelPosition),this.CreateProp('levels',PropertyType.Any)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.OverlayIndicatorBase:return this.getMetaData(wijmo.chart.SeriesBase);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.SingleOverlayIndicatorBase:return this.getMetaData(wijmo.chart.finance.analytics.OverlayIndicatorBase).add([this.CreateProp('period',PropertyType.Number)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.MacdBase:return this.getMetaData(wijmo.chart.finance.analytics.OverlayIndicatorBase).add([this.CreateProp('fastPeriod',PropertyType.Number),this.CreateProp('slowPeriod',PropertyType.Number),this.CreateProp('smoothingPeriod',PropertyType.Number)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.Macd:return this.getMetaData(wijmo.chart.finance.analytics.MacdBase).add([this.CreateProp('styles',PropertyType.Any)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.MacdHistogram:return this.getMetaData(wijmo.chart.finance.analytics.MacdBase);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.ATR:case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.RSI:case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.WilliamsR:return this.getMetaData(wijmo.chart.finance.analytics.SingleOverlayIndicatorBase);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.CCI:return this.getMetaData(wijmo.chart.finance.analytics.SingleOverlayIndicatorBase).add([this.CreateProp('constant',PropertyType.Number)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.Stochastic:return this.getMetaData(wijmo.chart.finance.analytics.OverlayIndicatorBase).add([this.CreateProp('dPeriod',PropertyType.Number),this.CreateProp('kPeriod',PropertyType.Number),this.CreateProp('smoothingPeriod',PropertyType.Number),this.CreateProp('styles',PropertyType.Any)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.Envelopes:return this.getMetaData(wijmo.chart.finance.analytics.OverlayIndicatorBase).add([this.CreateProp('period',PropertyType.Number),this.CreateProp('size',PropertyType.Number),this.CreateProp('type',PropertyType.Enum,'',wijmo.chart.finance.analytics.MovingAverageType)]);case wijmo.chart&&wijmo.chart.finance&&wijmo.chart.finance.analytics&&wijmo.chart.finance.analytics.BollingerBands:return this.getMetaData(wijmo.chart.finance.analytics.OverlayIndicatorBase).add([this.CreateProp('period',PropertyType.Number),this.CreateProp('multiplier',PropertyType.Number)]);case wijmo.gauge&&wijmo.gauge.Gauge:return this.getMetaData(wijmo.Control).add([this.CreateProp('value',PropertyType.Number,'valueChanged'),this.CreateProp('min',PropertyType.Number),this.CreateProp('max',PropertyType.Number),this.CreateProp('origin',PropertyType.Number),this.CreateProp('isReadOnly',PropertyType.Boolean),this.CreateProp('step',PropertyType.Number),this.CreateProp('format',PropertyType.String),this.CreateProp('thickness',PropertyType.Number),this.CreateProp('hasShadow',PropertyType.Boolean),this.CreateProp('isAnimated',PropertyType.Boolean),this.CreateProp('showText',PropertyType.Enum,'',wijmo.gauge.ShowText),this.CreateProp('showTicks',PropertyType.Boolean),this.CreateProp('showRanges',PropertyType.Boolean),this.CreateProp('thumbSize',PropertyType.Number),this.CreateProp('getText',PropertyType.Function)],[this.CreateEvent('valueChanged',!0)],[this.CreateComplexProp('ranges',!0),this.CreateComplexProp('pointer',!1,!1),this.CreateComplexProp('face',!1,!1)]).addOptions({ngModelProperty:'value'});case wijmo.gauge&&wijmo.gauge.LinearGauge:return this.getMetaData(wijmo.gauge.Gauge).add([this.CreateProp('direction',PropertyType.Enum,'',wijmo.gauge.GaugeDirection)]);case wijmo.gauge&&wijmo.gauge.BulletGraph:return this.getMetaData(wijmo.gauge.LinearGauge).add([this.CreateProp('target',PropertyType.Number),this.CreateProp('good',PropertyType.Number),this.CreateProp('bad',PropertyType.Number)]);case wijmo.gauge&&wijmo.gauge.RadialGauge:return this.getMetaData(wijmo.gauge.Gauge).add([this.CreateProp('autoScale',PropertyType.Boolean),this.CreateProp('startAngle',PropertyType.Number),this.CreateProp('sweepAngle',PropertyType.Number)]);case wijmo.gauge&&wijmo.gauge.Range:return new MetaDataBase([this.CreateProp('color',PropertyType.String),this.CreateProp('min',PropertyType.Number),this.CreateProp('max',PropertyType.Number),this.CreateProp('name',PropertyType.String),this.CreateProp('thickness',PropertyType.Number)],[],[],'ranges',!0);case wijmo.olap&&wijmo.olap.PivotGrid:return this.getMetaData(wijmo.grid.FlexGrid).add([this.CreateProp('showDetailOnDoubleClick',PropertyType.Boolean),this.CreateProp('customContextMenu',PropertyType.Boolean),this.CreateProp('collapsibleSubtotals',PropertyType.Boolean),this.CreateProp('centerHeadersVertically',PropertyType.Boolean),]);case wijmo.olap&&wijmo.olap.PivotChart:return new MetaDataBase([this.CreateProp('chartType',PropertyType.Enum,'',wijmo.olap.PivotChartType),this.CreateProp('showHierarchicalAxes',PropertyType.Boolean),this.CreateProp('showTotals',PropertyType.Boolean),this.CreateProp('stacking',PropertyType.Enum,'',wijmo.chart.Stacking),this.CreateProp('maxSeries',PropertyType.Number),this.CreateProp('maxPoints',PropertyType.Number),this.CreateProp('itemsSource',PropertyType.Any),]);case wijmo.olap&&wijmo.olap.PivotPanel:return new MetaDataBase([this.CreateProp('autoGenerateFields',PropertyType.Boolean),this.CreateProp('viewDefinition',PropertyType.String),this.CreateProp('engine',PropertyType.Any),this.CreateProp('itemsSource',PropertyType.Any),],[this.CreateEvent('itemsSourceChanged'),this.CreateEvent('viewDefinitionChanged'),this.CreateEvent('updatingView'),this.CreateEvent('updatedView')]);case wijmo.olap&&wijmo.olap.PivotField:return new MetaDataBase([this.CreateProp('binding',PropertyType.String),this.CreateProp('header',PropertyType.String),this.CreateProp('dataType',PropertyType.Enum,'',wijmo.DataType),],[],[],'',!0,!0,'');case wijmo.viewer&&wijmo.viewer.ViewerBase:return new MetaDataBase([this.CreateProp('serviceUrl',PropertyType.String),this.CreateProp('filePath',PropertyType.String),this.CreateProp('fullScreen',PropertyType.Boolean,'fullScreenChanged'),this.CreateProp('zoomFactor',PropertyType.Number,'zoomFactorChanged'),this.CreateProp('selectMouseMode',PropertyType.Boolean,'selectMouseModeChanged'),this.CreateProp('viewMode',PropertyType.Enum,'viewModeChanged',wijmo.viewer.ViewMode),],[this.CreateEvent('pageIndexChanged'),this.CreateEvent('viewModeChanged'),this.CreateEvent('selectMouseModeChanged'),this.CreateEvent('fullScreenChanged'),this.CreateEvent('zoomFactorChanged'),this.CreateEvent('queryLoadingData')]);case wijmo.viewer&&wijmo.viewer.ReportViewer:return this.getMetaData(wijmo.viewer.ViewerBase).add([this.CreateProp('paginated',PropertyType.Boolean),this.CreateProp('reportName',PropertyType.String),]);case wijmo.viewer&&wijmo.viewer.PdfViewer:return this.getMetaData(wijmo.viewer.ViewerBase)}return new MetaDataBase([])},ControlMetaFactory.getClassName=function(classRef){return(classRef.toString().match(/function (.+?)\(/)||[,''])[1]},ControlMetaFactory.toCamelCase=function(s){return s.toLowerCase().replace(/-(.)/g,function(match,group1){return group1.toUpperCase()})},ControlMetaFactory.findInArr=function(arr,propName,value){for(var i in arr)if(arr[i][propName]===value)return arr[i];return null},ControlMetaFactory}(),PropDescBase,PropertyType,BindingMode,EventDescBase,ComplexPropDescBase,MetaDataBase;interop.ControlMetaFactory=ControlMetaFactory;PropDescBase=function(){function PropDescBase(propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority){isNativeControlProperty===void 0&&(isNativeControlProperty=!0);priority===void 0&&(priority=0);this._priority=0;this._propertyName=propertyName;this._propertyType=propertyType;this._changeEvent=changeEvent;this._enumType=enumType;this._isNativeControlProperty=isNativeControlProperty;this._priority=priority}return Object.defineProperty(PropDescBase.prototype,"propertyName",{get:function(){return this._propertyName},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"propertyType",{get:function(){return this._propertyType},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"changeEvent",{get:function(){return this._changeEvent},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"enumType",{get:function(){return this._enumType},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"bindingMode",{get:function(){return this.changeEvent?BindingMode.TwoWay:BindingMode.OneWay},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"isNativeControlProperty",{get:function(){return this._isNativeControlProperty},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"priority",{get:function(){return this._priority},enumerable:!0,configurable:!0}),Object.defineProperty(PropDescBase.prototype,"shouldUpdateSource",{get:function(){return this.bindingMode===BindingMode.TwoWay&&this.propertyType!=PropertyType.EventHandler},enumerable:!0,configurable:!0}),PropDescBase.prototype.initialize=function(options){wijmo.copy(this,options)},PropDescBase.prototype.castValueToType=function(value){var type,pt,castVal;if(value==undefined)return value;if(type=this.propertyType,pt=PropertyType,type===pt.AnyPrimitive){if(!wijmo.isString(value))return value;if(value==='true'||value==='false')type=pt.Boolean;else return(castVal=+value,!isNaN(castVal))?castVal:(castVal=this._parseDate(value),!wijmo.isString(castVal))?castVal:value}switch(type){case pt.Number:if(typeof value=='string'){if(value.indexOf('*')>=0)return value;if(value.trim()==='')return null}return+value;case pt.Boolean:return value==='true'?!0:value==='false'?!1:!!value;case pt.String:return value+'';case pt.Date:return this._parseDate(value);case pt.Enum:return typeof value=='number'?value:this.enumType[value];default:return value}},PropDescBase.prototype._parseDate=function(value){if(value&&wijmo.isString(value)){value=value.replace(/["']/g,'');var dt=wijmo.changeType(value,wijmo.DataType.Date,'r');if(wijmo.isDate(dt))return dt}return value},PropDescBase}();interop.PropDescBase=PropDescBase,function(PropertyType){PropertyType[PropertyType.Boolean=0]="Boolean";PropertyType[PropertyType.Number=1]="Number";PropertyType[PropertyType.Date=2]="Date";PropertyType[PropertyType.String=3]="String";PropertyType[PropertyType.AnyPrimitive=4]="AnyPrimitive";PropertyType[PropertyType.Enum=5]="Enum";PropertyType[PropertyType.Function=6]="Function";PropertyType[PropertyType.EventHandler=7]="EventHandler";PropertyType[PropertyType.Any=8]="Any"}(interop.PropertyType||(interop.PropertyType={}));PropertyType=interop.PropertyType;interop.isSimpleType=isSimpleType,function(BindingMode){BindingMode[BindingMode.OneWay=0]="OneWay";BindingMode[BindingMode.TwoWay=1]="TwoWay"}(interop.BindingMode||(interop.BindingMode={}));BindingMode=interop.BindingMode;EventDescBase=function(){function EventDescBase(eventName,isPropChanged){this._eventName=eventName;this._isPropChanged=isPropChanged}return Object.defineProperty(EventDescBase.prototype,"eventName",{get:function(){return this._eventName},enumerable:!0,configurable:!0}),Object.defineProperty(EventDescBase.prototype,"isPropChanged",{get:function(){return this._isPropChanged===!0},enumerable:!0,configurable:!0}),EventDescBase}();interop.EventDescBase=EventDescBase;ComplexPropDescBase=function(){function ComplexPropDescBase(propertyName,isArray,ownsObject){ownsObject===void 0&&(ownsObject=!1);this.isArray=!1;this._ownsObject=!1;this.propertyName=propertyName;this.isArray=isArray;this._ownsObject=ownsObject}return Object.defineProperty(ComplexPropDescBase.prototype,"ownsObject",{get:function(){return this.isArray||this._ownsObject},enumerable:!0,configurable:!0}),ComplexPropDescBase}();interop.ComplexPropDescBase=ComplexPropDescBase;MetaDataBase=function(){function MetaDataBase(props,events,complexProps,parentProperty,isParentPropertyArray,ownsObject,parentReferenceProperty,ngModelProperty){this._props=[];this._events=[];this._complexProps=[];this.props=props;this.events=events;this.complexProps=complexProps;this.parentProperty=parentProperty;this.isParentPropertyArray=isParentPropertyArray;this.ownsObject=ownsObject;this.parentReferenceProperty=parentReferenceProperty;this.ngModelProperty=ngModelProperty}return Object.defineProperty(MetaDataBase.prototype,"props",{get:function(){return this._props},set:function(value){this._props=value||[]},enumerable:!0,configurable:!0}),Object.defineProperty(MetaDataBase.prototype,"events",{get:function(){return this._events},set:function(value){this._events=value||[]},enumerable:!0,configurable:!0}),Object.defineProperty(MetaDataBase.prototype,"complexProps",{get:function(){return this._complexProps},set:function(value){this._complexProps=value||[]},enumerable:!0,configurable:!0}),MetaDataBase.prototype.add=function(props,events,complexProps,parentProperty,isParentPropertyArray,ownsObject,parentReferenceProperty,ngModelProperty){return this.addOptions({props:props,events:events,complexProps:complexProps,parentProperty:parentProperty,isParentPropertyArray:isParentPropertyArray,ownsObject:ownsObject,parentReferenceProperty:parentReferenceProperty,ngModelProperty:ngModelProperty})},MetaDataBase.prototype.addOptions=function(options){var prop,thisValue,optionsValue;for(prop in options)thisValue=this[prop],optionsValue=options[prop],thisValue instanceof Array?this[prop]=thisValue.concat(optionsValue||[]):optionsValue!==undefined&&(this[prop]=optionsValue);return this},MetaDataBase.prototype.prepare=function(){var baseArr=[].concat(this._props);this._props.sort(function(a,b){var ret=a.priority-b.priority;return ret||(ret=baseArr.indexOf(a)-baseArr.indexOf(b)),ret})},MetaDataBase}();interop.MetaDataBase=MetaDataBase})(interop=wj.interop||(wj.interop={}))})(wj||(wj={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var MetaFactory=function(_super){function MetaFactory(){_super.apply(this,arguments)}return __extends(MetaFactory,_super),MetaFactory.CreateProp=function(propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority){return new PropDesc(propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority)},MetaFactory.CreateEvent=function(eventName,isPropChanged){return new EventDesc(eventName,isPropChanged)},MetaFactory.CreateComplexProp=function(propertyName,isArray,ownsObject){return new ComplexPropDesc(propertyName,isArray,ownsObject)},MetaFactory.findProp=function(propName,props){return wj.interop.ControlMetaFactory.findProp(propName,props)},MetaFactory.findEvent=function(eventName,events){return wj.interop.ControlMetaFactory.findEvent(eventName,events)},MetaFactory.findComplexProp=function(propName,props){return wj.interop.ControlMetaFactory.findComplexProp(propName,props)},MetaFactory}(wj.interop.ControlMetaFactory),PropDesc,EventDesc,ComplexPropDesc;angular.MetaFactory=MetaFactory;PropDesc=function(_super){function PropDesc(propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority){_super.call(this,propertyName,propertyType,changeEvent,enumType,isNativeControlProperty,priority);this._scopeBindingMode=this.propertyType===wj.interop.PropertyType.EventHandler?'&':this.bindingMode==wj.interop.BindingMode.OneWay&&wj.interop.isSimpleType(this.propertyType)?'@':'='}return __extends(PropDesc,_super),Object.defineProperty(PropDesc.prototype,"scopeBindingMode",{get:function(){return this._scopeBindingMode},set:function(value){this._scopeBindingMode=value},enumerable:!0,configurable:!0}),Object.defineProperty(PropDesc.prototype,"customHandler",{get:function(){return this._customHandler},set:function(value){this._customHandler=value},enumerable:!0,configurable:!0}),PropDesc}(wj.interop.PropDescBase);angular.PropDesc=PropDesc;EventDesc=function(_super){function EventDesc(){_super.apply(this,arguments)}return __extends(EventDesc,_super),EventDesc}(wj.interop.EventDescBase);angular.EventDesc=EventDesc;ComplexPropDesc=function(_super){function ComplexPropDesc(){_super.apply(this,arguments)}return __extends(ComplexPropDesc,_super),ComplexPropDesc}(wj.interop.ComplexPropDescBase);angular.ComplexPropDesc=ComplexPropDesc})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={})),function(wijmo){var angular;(function(angular){var WjDirective=function(){function WjDirective(){this.replace=!0;this.restrict='E';this.template='<div />';this.transclude=!1;this._props=[];this._events=[];this._complexProps=[];var self=this;this._dirId=++WjDirective._dirIdCounter+'';this.link=this._postLinkFn();this.controller=['$scope','$parse','$element',function($scope,$parse,$element){self._$parse=$parse;this[WjDirective._cntrlScopeProp]=$scope;$scope[WjDirective._scopeChildrenProp]=[];self._controllerImpl(this,$scope,$element)}];this._initDirective()}return Object.defineProperty(WjDirective.prototype,"_controlConstructor",{get:function(){throw'Abstract method call';},enumerable:!0,configurable:!0}),WjDirective.prototype._getMetaDataId=function(){return this._controlConstructor},WjDirective.prototype._getMetaData=function(){return angular.MetaFactory.getMetaData(this._getMetaDataId())},WjDirective.prototype._initDirective=function(){this._initSharedMeta();this._prepareProps();this._initEvents();this._initScopeEvents();this._initScopeDescription()},WjDirective.prototype._initSharedMeta=function(){var meta=this._getMetaData(),prop,idx,propDesc;this._props=meta.props;this._events=meta.events;this._complexProps=meta.complexProps;this._property=meta.parentProperty;this._isPropertyArray=meta.isParentPropertyArray;this._ownObject=meta.ownsObject;this._parentReferenceProperty=meta.parentReferenceProperty;this._ngModelProperty=meta.ngModelProperty;prop=angular.MetaFactory.findProp('required',this._props);prop&&(idx=this._props.indexOf(prop),idx>-1&&(propDesc=new angular.PropDesc('wjRequired',wj.interop.PropertyType.Boolean),propDesc.customHandler=function(scope,control,value){control.required=value},this._props.splice(idx+1,0,propDesc)))},WjDirective.prototype._initProps=function(){},WjDirective.prototype._initEvents=function(){},WjDirective.prototype._createLink=function(){return new WjLink},WjDirective.prototype._controllerImpl=function(){},WjDirective.prototype._initControl=function(element){try{var controlConstructor=this._controlConstructor;return new controlConstructor(element)}catch(e){return undefined}},WjDirective.prototype._isChild=function(){return this._isParentInitializer()||this._isParentReferencer()},WjDirective.prototype._isParentInitializer=function(){return this._property!=undefined},WjDirective.prototype._isParentReferencer=function(){return this._parentReferenceProperty!=undefined},WjDirective.prototype._scopeToAttrName=function(scopeName){var alias=this.scope[scopeName],bindMarkLen,aliasLen;return alias?(bindMarkLen=1,aliasLen=alias.length,aliasLen<2)?scopeName:(alias.charAt(1)==='?'&&(bindMarkLen=2),aliasLen===bindMarkLen)?scopeName:alias.substr(bindMarkLen):scopeName},WjDirective.prototype._getComplexPropDesc=function(propName){return angular.MetaFactory.findComplexProp(propName,this._complexProps)},WjDirective.prototype._initScopeEvents=function(){var i,event;for(i in this._events)event=this._events[i],this._props.push(new angular.PropDesc(event.eventName,wj.interop.PropertyType.EventHandler))},WjDirective.prototype._initScopeDescription=function(){var props=this._props,scope={},byRefMark=WjDirective._optionalAttr?'=?':'=',prop,i;if(props!=null){for(i=0;i<props.length;i++)prop=props[i],scope[prop.propertyName]=prop.scopeBindingMode,WjDirective._optionalAttr&&prop.scopeBindingMode=='='&&(scope[prop.propertyName]='=?');scope.required&&(scope.wjRequired=scope.required)}scope.control=byRefMark;scope[WjDirective._initPropAttr]=byRefMark;scope[WjDirective._initEventAttr]='&';scope[WjDirective._parPropAttr]='@';scope[WjDirective._wjModelPropAttr]='@';this.scope=scope},WjDirective.prototype._postLinkFn=function(){var self=this;return function(scope,tElement,tAttrs,controller){var link=self._createLink(),i,curCntrl;if(link.directive=self,link.scope=scope,link.tElement=tElement,link.tAttrs=tAttrs,wijmo.isArray(controller)){var parEl=tElement.parent(),scopeFunc=parEl.isolateScope||parEl.scope,parScope=scopeFunc.call(parEl);for(i in controller)if(curCntrl=controller[i],curCntrl!=undefined&&(curCntrl[WjDirective._cntrlScopeProp]===scope&&(curCntrl=tElement.parent().controller(self._stripRequire(+i))),curCntrl&&curCntrl[WjDirective._cntrlScopeProp]===parScope)){link.controller=curCntrl;break}}else link.controller=controller;link.ngModel=tElement.controller('ngModel');link._link()}},WjDirective.prototype._prepareProps=function(){this._initProps();var baseArr=[].concat(this._props);this._props.sort(function(a,b){var ret=a.priority-b.priority;return ret||(ret=baseArr.indexOf(a)-baseArr.indexOf(b)),ret})},WjDirective.prototype._stripRequire=function(index){if(this._stripReq||(this._stripReq=[],this._stripReq.length=this.require.length),!this._stripReq[index]){var res=/^[^A-Za-z]*(.*)/.exec(this.require[index]);this._stripReq[index]=res?res[1]:''}return this._stripReq[index]},WjDirective.prototype._getId=function(){return this._dirId},WjDirective._versionOk=function(minVer){var angVer=window.angular.version,angVerParts=[angVer.major,angVer.minor,angVer.dot],verParts=minVer.split("."),i;if(verParts.length!==angVerParts.length)throw'Unrecognizable version number.';for(i=0;i<verParts.length;i++){if(angVerParts[i]<verParts[i])return!1;if(angVerParts[i]>verParts[i])return!0}return!0},WjDirective._removeTransclude=function(html){var root,transNodes;return html?(root=document.createElement('div'),root.innerHTML=html,transNodes=root.querySelectorAll('[ng-transclude]'),[].forEach.call(transNodes,function(elem){elem.removeAttribute('ng-transclude')}),root.innerHTML):html},WjDirective._parPropAttr='wjProperty',WjDirective._wjModelPropAttr='wjModelProperty',WjDirective._initPropAttr='isInitialized',WjDirective._initEventAttr='initialized',WjDirective._cntrlScopeProp='_cntrlScope',WjDirective._cntrlLinkProp='$_thisLink',WjDirective._scopeChildrenProp='$_childLinks',WjDirective._dirIdAttr='wj-directive-id',WjDirective._optionalAttr=WjDirective._versionOk("1.1.4"),WjDirective._dynaTemplates=WjDirective._optionalAttr,WjDirective._angStripPrefixes=['data','x'],WjDirective._dirIdCounter=0,WjDirective}(),WjLink;angular.WjDirective=WjDirective;WjLink=function(){function WjLink(){this._nonAssignable={};this._definedProps={};this._definedEvents={};this._oldValues={};this._isInitialized=!1;this._hasTriggeredInitialized=!1;this._isNgModelInitialized=!1;this._scopeSuspend=0;this._suspendedEvents=[];this._areChlildrenReady=!1;this._isDestroyed=!1;this._isAppliedToParent=!1}return WjLink.prototype._link=function(){var dir=this.directive,self=this,parentScope,parentLink;this.tElement[0].setAttribute(WjDirective._dirIdAttr,dir._getId());this.directiveTemplateElement=dir.replace?this.tElement:window.angular.element(this.tElement.children()[0]);this._initNonAssignable();this._isChild()?(this._parentPropDesc=new angular.ComplexPropDesc(dir._property,dir._isPropertyArray,dir._ownObject),this.controller[WjDirective._cntrlScopeProp][WjDirective._scopeChildrenProp].push(this),parentScope=this.controller[WjDirective._cntrlScopeProp],parentLink=parentScope[WjDirective._cntrlLinkProp],parentLink&&parentLink._areChlildrenReady&&this._parentReady(parentLink)):(this._createInstance(),this._notifyReady(),this._prepareControl());this._destroyEhUnreg=this.scope.$on('$destroy',function(){for(var args=[],_i=1;_i<arguments.length;_i++)args[_i-1]=arguments[_i];self._destroy()})},WjLink.prototype._onChildrenReady=function(){},WjLink.prototype._createInstance=function(){this.control=this._initControl();this._safeApply(this.scope,'control',this.control)},WjLink.prototype._parentReady=function(parentLink){var self,parProp,parPropDescOverride;if(this._isChild()){if(self=this,this._isAttrDefined(WjDirective._parPropAttr)&&!this.scope[WjDirective._parPropAttr]){this.scope.$watch(WjDirective._parPropAttr,function(){self._parentReady(parentLink)});return}parProp=this._getParentProp();parPropDescOverride=parentLink.directive._getComplexPropDesc(parProp);parPropDescOverride?this._parentPropDesc=parPropDescOverride:this._parentPropDesc.propertyName=parProp;this.parent=parentLink;this._useParentObj()?(this.control=parentLink.control[parProp],this._safeApply(this.scope,'control',this.control)):this._createInstance();this._notifyReady();this._prepareControl();this._initParent();this.directiveTemplateElement[0].style.display='none';this._appliedToParent()}},WjLink.prototype._initParent=function(){var parArr,linkIdx,self;if(!this._useParentObj()){var dir=this.directive,propName=this._getParentProp(),parCtrl=this.parent.control,ctrl=this.control;this._isParentInitializer()&&(this._isParentArray()?(parArr=parCtrl[propName],linkIdx=this._getIndex(),(linkIdx<0||linkIdx>=parArr.length)&&(linkIdx=parArr.length),parArr.splice(linkIdx,0,ctrl),self=this,this._siblingInsertedEH=this._siblingInserted.bind(this),this.tElement[0].addEventListener('DOMNodeInserted',this._siblingInsertedEH)):parCtrl[propName]=ctrl);this._isParentReferencer()&&!this._parentInCtor()&&(ctrl[this._getParentReferenceProperty()]=parCtrl)}},WjLink.prototype._destroy=function(){var control,parControl,parProp,parArr,idx;this._isDestroyed||(this._isDestroyed=!0,control=this.control,this._destroyEhUnreg&&(this._destroyEhUnreg=null),this._siblingInsertedEH&&this.tElement[0].removeEventListener('DOMNodeInserted',this._siblingInsertedEH),this._isParentArray()&&!this.parent._isDestroyed&&(parControl=this.parent.control,parProp=this._getParentProp(),parControl&&parProp&&control&&(parArr=parControl[parProp],parArr&&(idx=parArr.indexOf(control),idx>=0&&parArr.splice(idx,1)))),control instanceof wijmo.Control&&setTimeout(function(){control.hostElement&&control.dispose()},0))},WjLink.prototype._siblingInserted=function(e){if(e.target===this.tElement[0]){var lIdx=this._getIndex(),parArr=this.parent.control[this._getParentProp()],ctrl=this.control,arrIdx=parArr.indexOf(ctrl);lIdx>=0&&arrIdx>=0&&lIdx!==arrIdx&&(parArr.splice(arrIdx,1),lIdx=Math.min(lIdx,parArr.length),parArr.splice(lIdx,0,ctrl))}},WjLink.prototype._notifyReady=function(){var childLinks,i;for(this.scope[WjDirective._cntrlLinkProp]=this,childLinks=[].concat(this.scope[WjDirective._scopeChildrenProp]),i=0;i<childLinks.length;i++)childLinks[i]._parentReady(this);this._areChlildrenReady=!0;this._onChildrenReady()},WjLink.prototype._initControl=function(){return this.directive._initControl(this._parentInCtor()?this.parent.control:this.directiveTemplateElement[0])},WjLink.prototype._prepareControl=function(){this._addEventHandlers();this._addWatchers()},WjLink.prototype._setupScopeWithControlProperties=function(){for(var isFunction,isEventHandler,prop,name,scopeValue,controlValue,control=this.control,scope=this.scope,props=this.directive._props,i=0;i<props.length;i++)prop=props[i],prop.scopeBindingMode==='='&&prop.isNativeControlProperty&&prop.shouldUpdateSource&&(name=prop.propertyName,scopeValue=scope[name],controlValue=control[name],isFunction=prop.propertyType==wj.interop.PropertyType.Function,isEventHandler=prop.propertyType==wj.interop.PropertyType.EventHandler,!this._canApply(scope,prop.propertyName)||controlValue==scopeValue||isFunction||isEventHandler||(scope[prop.propertyName]=controlValue));scope.$root.$$phase||scope.$apply()},WjLink.prototype._initNonAssignable=function(){var parse=this.directive._$parse,scopeDef=this.directive.scope,binding;for(var name in scopeDef)scopeDef[name].charAt(0)==='='&&(binding=this.tAttrs[this.directive._scopeToAttrName(name)],(binding===undefined||parse(binding).assign==undefined)&&(this._nonAssignable[name]=!0))},WjLink.prototype._suspendScope=function(){this._scopeSuspend++},WjLink.prototype._resumeScope=function(){this._scopeSuspend>0&&--this._scopeSuspend==0&&this._suspendedEvents.length>0&&this._updateScope()},WjLink.prototype._isScopeSuspended=function(){return this._scopeSuspend>0},WjLink.prototype._isAttrDefined=function(name){return this.tAttrs.$attr[this.directive._scopeToAttrName(name)]!=null},WjLink.prototype._childInitialized=function(child){var childLinks=this.scope[WjDirective._scopeChildrenProp],idx=childLinks.indexOf(child);idx>=0&&(childLinks.splice(idx,1),this._checkRaiseInitialized())},WjLink.prototype._thisInitialized=function(){this._checkRaiseInitialized()},WjLink.prototype._initialized=function(){},WjLink.prototype._appliedToParent=function(){this._isAppliedToParent=!0;this._checkRaiseInitialized()},WjLink.prototype._checkRaiseInitialized=function(){if(!this._hasTriggeredInitialized&&this.scope[WjDirective._scopeChildrenProp].length===0&&this._isInitialized&&(!this._isChild()||this._isAppliedToParent)){this._hasTriggeredInitialized=!0;this._initialized();this._safeApply(this.scope,WjDirective._initPropAttr,!0);var handler=this.scope[WjDirective._initEventAttr],self=this;handler&&setTimeout(function(){handler({s:self.control,e:undefined})},0);this._isChild()&&this.parent&&this.parent._childInitialized(this)}},WjLink.prototype._addWatchers=function(){var self=this,props=this.directive._props,scope=this.scope,ngModel,i,name,prop,control;if(props){for(this.ngModel&&(ngModel=this.ngModel,ngModel.$pristine&&wijmo.addClass(this.tElement[0],'ng-pristine'),ngModel.$valid&&wijmo.addClass(this.tElement[0],'ng-valid'),ngModel.$untouched&&wijmo.addClass(this.tElement[0],'ng-untouched'),ngModel.$render=this._ngModelRender.bind(this),this._updateNgModelPropDesc(),this._isAttrDefined(WjDirective._wjModelPropAttr)&&scope.$watch(WjDirective._wjModelPropAttr,function(){self._updateNgModelPropDesc();self._ngModelRender()})),i=0;i<props.length;i++)prop=props[i],name=prop.propertyName,prop.propertyType!==wj.interop.PropertyType.EventHandler&&this._isAttrDefined(name)&&(this._definedProps[name]=prop);control=this.control;scope.$watch(function(scope){var assignValues,name,newVal,oldVal,handled;if(!self._isDestroyed)try{assignValues={};for(name in self._definedProps)scope[name]!==self._oldValues[name]&&(assignValues[name]=scope[name]);for(name in assignValues)if(newVal=assignValues[name],oldVal=self._oldValues[name],newVal!==oldVal&&(self._oldValues[name]=newVal,self._isInitialized||newVal!==undefined)){var prop=self._definedProps[name],value=self._nullOrValue(self._castValueToType(newVal,prop)),oldCtrlVal=control[name];oldCtrlVal!=value&&(handled=!1,prop.customHandler!=null&&(handled=prop.customHandler(scope,control,value,oldCtrlVal,self)),prop.isNativeControlProperty&&handled!==!0&&(control[name]=value))}}finally{self._isInitialized||(self._isNgModelInitialized=!0,self.ngModel&&(self.ngModel.$viewValue!==undefined?self._ngModelRender():self._ngModelPropDesc&&(self.ngModel.$setViewValue(control[self._ngModelPropDesc.propertyName]),self.ngModel.$setPristine())),self._isInitialized=!0,self._setupScopeWithControlProperties(),self._thisInitialized())}})}},WjLink.prototype._addEventHandlers=function(){for(var event,evList=this.directive._events,i=0;i<evList.length;i++)event=evList[i],this._addEventHandler(event)},WjLink.prototype._addEventHandler=function(eventDesc){var self=this,eventName=eventDesc.eventName,controlEvent=this.control[eventName],isDefined;if(controlEvent==null)throw'Event "'+eventName+'" not found in '+self.constructor.name;if(isDefined=this._isAttrDefined(eventName),isDefined)this._definedEvents[eventName]=eventDesc;else if(!eventDesc.isPropChanged)return;var scope=this.scope,props=this.directive._props,control=this.control;controlEvent.addHandler(function(s,e){var eventInfo={eventDesc:eventDesc,s:s,e:e};self._isScopeSuspended()?self._suspendedEvents.push(eventInfo):self._updateScope(eventInfo)},control)},WjLink.prototype._updateScope=function(eventInfo){var update,self,props,i,p,name,value,raiseEvents,dispose;if(eventInfo===void 0&&(eventInfo=null),!this._isDestroyed){if(update=eventInfo?eventInfo.eventDesc.isPropChanged:this._suspendedEvents.some(function(value){return value.eventDesc.isPropChanged}),self=this,update)for(props=this.directive._props,i=0;i<props.length;i++)p=props[i],p.scopeBindingMode=='='&&p.isNativeControlProperty&&p.shouldUpdateSource&&(name=p.propertyName,value=this.control[name],this._shouldApply(this.scope,name,value)&&(this.scope[name]=value,this.directive._$parse(this.tAttrs[this.directive._scopeToAttrName(name)]).assign(this.scope.$parent,value)),this._ngModelPropDesc&&this._isInitialized&&this._ngModelPropDesc.propertyName==name&&this.ngModel.$viewValue!==value&&this.ngModel.$setViewValue(value));raiseEvents=function(){for(var suspEvArr=eventInfo?[eventInfo]:this._suspendedEvents,i=0;i<suspEvArr.length;i++){var suspInfo=suspEvArr[i],eventName=suspInfo.eventDesc.eventName,scopeHandler=this.scope[eventName];self._definedEvents[eventName]&&scopeHandler&&scopeHandler({s:suspInfo.s,e:suspInfo.e})}eventInfo||(this._suspendedEvents.length=0)}.bind(this);update&&(this.scope.$root.$$phase?dispose=this.scope.$watch('value',function(){dispose()}):this.scope.$apply());raiseEvents()}},WjLink.prototype._ngModelRender=function(){var viewValue,propDesc,value;this._isNgModelInitialized&&(viewValue=this.ngModel.$viewValue,propDesc=this._ngModelPropDesc,propDesc&&(viewValue!==undefined||this._isInitialized))&&(value=this._nullOrValue(this._castValueToType(viewValue,propDesc)),viewValue!==this.control[propDesc.propertyName]&&(this.control[propDesc.propertyName]=viewValue))},WjLink.prototype._castValueToType=function(value,prop){return prop.castValueToType(value)},WjLink.prototype._isChild=function(){return this.directive._isChild()},WjLink.prototype._isParentInitializer=function(){return this.directive._isParentInitializer()},WjLink.prototype._isParentReferencer=function(){return this.directive._isParentReferencer()},WjLink.prototype._getParentProp=function(){return this._isParentInitializer()?this.scope[WjDirective._parPropAttr]||this.directive._property:undefined},WjLink.prototype._getParentReferenceProperty=function(){return this.directive._parentReferenceProperty},WjLink.prototype._useParentObj=function(){return!this._isParentReferencer()&&this._isParentInitializer()&&!this._parentPropDesc.isArray&&!this._parentPropDesc.ownsObject},WjLink.prototype._isParentArray=function(){return this._isParentInitializer()&&this._parentPropDesc.isArray},WjLink.prototype._parentInCtor=function(){return this._isParentReferencer()&&this._getParentReferenceProperty()==''},WjLink.prototype._getNgModelProperty=function(){return this.scope[WjDirective._wjModelPropAttr]||this.directive._ngModelProperty},WjLink.prototype._updateNgModelPropDesc=function(){var ngModelProp=this._getNgModelProperty();this._ngModelPropDesc=wijmo.isNullOrWhiteSpace(ngModelProp)?null:angular.MetaFactory.findProp(ngModelProp,this.directive._props)},WjLink.prototype._safeApply=function(scope,name,value){return this._shouldApply(scope,name,value)?(scope[name]=value,scope.$root.$$phase||scope.$apply(),!0):!1},WjLink.prototype._shouldApply=function(scope,name,value){return this._canApply(scope,name)&&value!=scope[name]},WjLink.prototype._canApply=function(scope,name){return!this._nonAssignable[name]},WjLink.prototype._nullOrValue=function(value){return value!=undefined?value:null},WjLink.prototype._getIndex=function(){var thisEl=this.tElement[0],parEl=thisEl.parentElement,i,curEl;if(!parEl)return-1;var siblings=parEl.childNodes,idx=-1,dirId=this.directive._getId();for(i=0;i<siblings.length;i++)if(curEl=siblings[i],curEl.nodeType==1&&curEl.getAttribute(WjDirective._dirIdAttr)==dirId&&(++idx,curEl===thisEl))return idx;return-1},WjLink}();angular.WjLink=WjLink})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoContainers=window.angular.module('wj.container',[]);wijmoContainers.directive('wjTooltip',[function(){return new WjTooltip}]);wijmoContainers.directive('wjValidationError',[function(){return new WjValidationError}]);var WjTooltip=function(_super){function WjTooltip(){_super.call(this);this.restrict='A';this.template=''}return __extends(WjTooltip,_super),Object.defineProperty(WjTooltip.prototype,"_controlConstructor",{get:function(){return wijmo.Tooltip},enumerable:!0,configurable:!0}),WjTooltip.prototype._initControl=function(){return new wijmo.Tooltip},WjTooltip.prototype._createLink=function(){return new WjTooltipLink},WjTooltip}(angular.WjDirective),WjTooltipLink=function(_super){function WjTooltipLink(){_super.apply(this,arguments)}return __extends(WjTooltipLink,_super),WjTooltipLink.prototype._link=function(){_super.prototype._link.call(this);var tt=this.control,self=this;this.tAttrs.$observe('wjTooltip',function(value){tt.setTooltip(self.tElement[0],value)})},WjTooltipLink}(angular.WjLink),WjValidationError=function(_super){function WjValidationError(){_super.call(this);this.restrict='A';this.template='';this.require='ngModel';this.scope=!1}return __extends(WjValidationError,_super),WjValidationError.prototype._postLinkFn=function(){return function(scope,tElement,tAttrs,controller){var dn='wjValidationError';scope.$watch(tAttrs[dn],function(errorMsg){var e=tElement[0].tagName=='INPUT'?tElement[0]:tElement[0].querySelector('input');typeof errorMsg=='boolean'&&(errorMsg=errorMsg?'error':'');e&&e.setCustomValidity&&e.setCustomValidity(errorMsg);controller&&controller.$setValidity(dn,errorMsg?!1:!0)})}},WjValidationError.prototype._getMetaDataId=function(){return'ValidationError'},WjValidationError}(angular.WjDirective)})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoInput=window.angular.module('wj.input',[]);wijmo.input&&wijmo.input.InputNumber&&(wijmoInput.directive('wjAutoComplete',['$compile',function($compile){return new WjAutoComplete($compile)}]),wijmoInput.directive('wjCalendar',[function(){return new WjCalendar}]),wijmoInput.directive('wjColorPicker',[function(){return new WjColorPicker}]),wijmoInput.directive('wjComboBox',['$compile',function($compile){return new WjComboBox($compile)}]),wijmoInput.directive('wjInputDate',[function(){return new WjInputDate}]),wijmoInput.directive('wjInputDateTime',[function(){return new WjInputDateTime}]),wijmoInput.directive('wjInputNumber',[function(){return new WjInputNumber}]),wijmoInput.directive('wjInputMask',[function(){return new WjInputMask}]),wijmoInput.directive('wjInputTime',['$compile',function($compile){return new WjInputTime($compile)}]),wijmoInput.directive('wjInputColor',[function(){return new WjInputColor}]),wijmoInput.directive('wjListBox',[function(){return new WjListBox}]),wijmoInput.directive('wjItemTemplate',['$compile',function($compile){return new WjItemTemplate($compile)}]),wijmoInput.directive('wjMenu',['$compile',function($compile){return new WjMenu($compile)}]),wijmoInput.directive('wjMenuItem',[function(){return new WjMenuItem}]),wijmoInput.directive('wjMenuSeparator',[function(){return new WjMenuSeparator}]),wijmoInput.directive('wjContextMenu',[function(){return new WjContextMenu}]),wijmoInput.directive('wjCollectionViewNavigator',[function(){return new WjCollectionViewNavigator}]),wijmoInput.directive('wjCollectionViewPager',[function(){return new WjCollectionViewPager}]),wijmoInput.directive('wjPopup',[function(){return new WjPopup}]),wijmoInput.directive('wjMultiSelect',['$compile',function($compile){return new WjMultiSelect($compile)}]));var WjDropDown=function(_super){function WjDropDown(){_super.apply(this,arguments)}return __extends(WjDropDown,_super),Object.defineProperty(WjDropDown.prototype,"_controlConstructor",{get:function(){return wijmo.input.DropDown},enumerable:!0,configurable:!0}),WjDropDown}(angular.WjDirective),WjComboBox=function(_super){function WjComboBox($compile){_super.call(this);this._$compile=$compile;this.template='<div ng-transclude />';this.transclude=!0}return __extends(WjComboBox,_super),Object.defineProperty(WjComboBox.prototype,"_controlConstructor",{get:function(){return wijmo.input.ComboBox},enumerable:!0,configurable:!0}),WjComboBox}(WjDropDown),WjAutoComplete=function(_super){function WjAutoComplete($compile){_super.call(this,$compile)}return __extends(WjAutoComplete,_super),Object.defineProperty(WjAutoComplete.prototype,"_controlConstructor",{get:function(){return wijmo.input.AutoComplete},enumerable:!0,configurable:!0}),WjAutoComplete}(WjComboBox),WjCalendar=function(_super){function WjCalendar(){_super.apply(this,arguments)}return __extends(WjCalendar,_super),Object.defineProperty(WjCalendar.prototype,"_controlConstructor",{get:function(){return wijmo.input.Calendar},enumerable:!0,configurable:!0}),WjCalendar}(angular.WjDirective),WjColorPicker=function(_super){function WjColorPicker(){_super.apply(this,arguments)}return __extends(WjColorPicker,_super),Object.defineProperty(WjColorPicker.prototype,"_controlConstructor",{get:function(){return wijmo.input.ColorPicker},enumerable:!0,configurable:!0}),WjColorPicker}(angular.WjDirective),WjListBox=function(_super){function WjListBox(){_super.call(this);this.transclude=!0;this.template='<div ng-transclude />'}return __extends(WjListBox,_super),Object.defineProperty(WjListBox.prototype,"_controlConstructor",{get:function(){return wijmo.input.ListBox},enumerable:!0,configurable:!0}),WjListBox}(angular.WjDirective),WjItemTemplate=function(_super){function WjItemTemplate($compile){_super.call(this);this._$compile=$compile;this.require=['?^wjListBox','?^wjMenu'];this.terminal=!0;angular.WjDirective._dynaTemplates?(this.transclude=!1,this.priority=100,this.template=function(tElement,tAttrs){return tAttrs[WjItemTemplate._itemTemplateProp]=tElement[0].innerHTML,'<div />'}):(this.transclude=!0,this.template='<div ng-transclude/>')}return __extends(WjItemTemplate,_super),WjItemTemplate.prototype._initControl=function(){return{}},WjItemTemplate.prototype._createLink=function(){return new WjItemTemplateLink},WjItemTemplate.prototype._getMetaDataId=function(){return'ItemTemplate'},WjItemTemplate._itemTemplateProp='$__wjItemTemplate',WjItemTemplate._itemScopeProp='$_itemScope',WjItemTemplate}(angular.WjDirective),WjItemTemplateLink=function(_super){function WjItemTemplateLink(){_super.apply(this,arguments)}return __extends(WjItemTemplateLink,_super),WjItemTemplateLink.prototype._initParent=function(){_super.prototype._initParent.call(this);var dynaTempl=this.tAttrs[WjItemTemplate._itemTemplateProp],ownerControl=this.parent.control,listBox=this._getListBox();this.itemTemplate=dynaTempl!=null?dynaTempl:angular.WjDirective._removeTransclude(this.tElement[0].innerHTML);listBox.formatItem.addHandler(this._fmtItem,this);listBox.loadingItems.addHandler(this._loadingItems,this);this.parent._isInitialized&&ownerControl.invalidate()},WjItemTemplateLink.prototype._destroy=function(){var ownerControl=this.parent&&this.parent.control,listBox=this._getListBox();listBox&&(listBox.formatItem.removeHandler(this._fmtItem,this),listBox.loadingItems.removeHandler(this._loadingItems,this));_super.prototype._destroy.call(this);this._tmplLink=null;ownerControl&&ownerControl.invalidate()},WjItemTemplateLink.prototype._loadingItems=function(s){for(var itemEl,itemScope,items=s.hostElement.getElementsByClassName('wj-listbox-item'),i=items.length-1;i>=0;i--)itemEl=items[i],itemScope=itemEl[WjItemTemplate._itemScopeProp],itemScope&&(itemEl[WjItemTemplate._itemScopeProp]=null,itemScope.$destroy())},WjItemTemplateLink.prototype._fmtItem=function(s,e){var itemEl,itemScope,clonedElement,lag;this._tmplLink||(this._tmplLink=this.directive._$compile('<div>'+this.itemTemplate+'</div>'));itemEl=e.item;itemScope=this.scope.$parent.$new();itemEl[WjItemTemplate._itemScopeProp]=itemScope;itemScope.$control=s;itemScope.$item=e.data;itemScope.$itemIndex=e.index;clonedElement=this._tmplLink(itemScope,function(){})[0];itemEl.childNodes.length===1?itemEl.replaceChild(clonedElement,itemEl.firstChild):(itemEl.textContent='',itemEl.appendChild(clonedElement));lag=40;clearTimeout(this._closingApplyTimeOut);this._closingApplyTimeOut=setTimeout(function(){itemScope.$root.$$phase||itemScope.$apply()},lag)},WjItemTemplateLink._invalidateControl=function(parentControl){parentControl&&parentControl.invalidate()},WjItemTemplateLink.prototype._getListBox=function(){var ownerControl=this.parent&&this.parent.control;return ownerControl?ownerControl instanceof wijmo.input.ListBox?ownerControl:ownerControl.listBox:null},WjItemTemplateLink}(angular.WjLink),WjMenu=function(_super){function WjMenu($compile){_super.call(this,$compile)}return __extends(WjMenu,_super),Object.defineProperty(WjMenu.prototype,"_controlConstructor",{get:function(){return wijmo.input.Menu},enumerable:!0,configurable:!0}),WjMenu.prototype._createLink=function(){return new WjMenuLink},WjMenu.prototype._initProps=function(){_super.prototype._initProps.call(this);var self=this,valueDesc=angular.MetaFactory.findProp('value',this._props);valueDesc.customHandler=function(scope,control,value,oldValue,link){self.updateControlValue(scope,control,link)}},WjMenu.prototype.updateControlValue=function(scope,control,link){scope.value!=null&&(control.selectedValue=scope.value,link.directive.updateHeader(scope,control,link))},WjMenu.prototype.updateHeader=function(scope,control){var selItem,itemLink,currentValue;control.header=scope.header||'';selItem=control.selectedItem;typeof scope.value!='undefined'&&selItem&&control.displayMemberPath&&(itemLink=selItem[WjMenuItem._itemLinkProp],currentValue=itemLink?itemLink.linkedContent.innerHTML:selItem[control.displayMemberPath],currentValue!=null&&(control.header+=': <b>'+currentValue+'</b>'))},WjMenu}(WjComboBox),WjMenuLink=function(_super){function WjMenuLink(){_super.apply(this,arguments)}return __extends(WjMenuLink,_super),WjMenuLink.prototype._initControl=function(){var self=this,control=new wijmo.input.Menu(this.directiveTemplateElement[0],{itemsSource:new wijmo.collections.ObservableArray,selectedIndex:0,itemClicked:function(){self._safeApply(self.scope,'value',control.selectedValue)||self.scope.$root.$$phase||self.scope.$apply();self.directive.updateHeader(self.scope,control,self)}.bind(self)});return control.listBox.formatItem.addHandler(self._fmtItem,this),control.listBox.loadingItems.addHandler(this._loadingItems,this),control},WjMenuLink.prototype._initialized=function(){this.directive.updateControlValue(this.scope,this.control,this)},WjMenuLink.prototype._fmtItem=function(s,e){var itemLink=e.data[WjMenuItem._itemLinkProp],clonedElement,lag;if(itemLink){itemLink.contentLink||(itemLink.contentLink=this.directive._$compile('<div>'+itemLink.itemTemplate+'</div>'));var self=this,itemEl=e.item,itemScope=itemLink.scope.$parent.$new();itemEl[WjMenuItem._itemScopeProp]=itemScope;itemScope.$control=this.control;itemScope.$item=e.data;itemScope.$itemIndex=e.index;clonedElement=itemLink.linkedContent=itemLink.contentLink(itemScope,function(){})[0];itemEl.childNodes.length===1?itemEl.replaceChild(clonedElement,itemEl.firstChild):(itemEl.textContent='',itemEl.appendChild(clonedElement));lag=40;clearTimeout(this._closingApplyTimeOut);this._closingApplyTimeOut=setTimeout(function(){itemScope.$root.$$phase||itemScope.$apply();self.control.selectedItem&&self.directive.updateHeader(self.scope,self.control,self)},lag)}},WjMenuLink.prototype._loadingItems=function(s){for(var itemEl,itemScope,items=s.hostElement.getElementsByClassName('wj-listbox-item'),i=items.length-1;i>=0;i--)itemEl=items[i],itemScope=itemEl[WjMenuItem._itemScopeProp],itemScope&&(itemEl[WjItemTemplate._itemScopeProp]=null,itemScope.$destroy())},WjMenuLink}(angular.WjLink);angular.WjMenuLink=WjMenuLink;var WjMenuItem=function(_super){function WjMenuItem(){_super.call(this);this.require='^wjMenu';this.terminal=!0;angular.WjDirective._dynaTemplates?(this.transclude=!1,this.priority=100,this.template=function(tElement,tAttrs){return tAttrs[WjItemTemplate._itemTemplateProp]=tElement[0].innerHTML,'<div />'}):(this.transclude=!0,this.template='<div ng-transclude/>')}return __extends(WjMenuItem,_super),WjMenuItem.prototype._createLink=function(){return new WjMenuItemLink(!1)},WjMenuItem.prototype._getMetaDataId=function(){return'MenuItem'},WjMenuItem.prototype._getId=function(){return WjMenuItem._directiveId},WjMenuItem._itemTemplateProp='$__wjMenuItemTemplate',WjMenuItem._itemScopeProp='$_menuItemScope',WjMenuItem._itemLinkProp='$_menuItemLink',WjMenuItem._directiveId='menuItemDir',WjMenuItem}(angular.WjDirective),WjMenuItemLink=function(_super){function WjMenuItemLink(isSeparator){_super.call(this);this.isSeparator=isSeparator}return __extends(WjMenuItemLink,_super),WjMenuItemLink.prototype._initControl=function(){var dynaTempl=this.tAttrs[WjItemTemplate._itemTemplateProp],ret;return this.itemTemplate=this.isSeparator?'<div class="wj-state-disabled" style="width:100%;height:1px;background-color:lightgray"/>':dynaTempl!=null?dynaTempl:angular.WjDirective._removeTransclude(this.tElement[0].innerHTML),ret={value:null,cmd:null,cmdParam:null,header:this.itemTemplate},ret[WjMenuItem._itemLinkProp]=this,ret},WjMenuItemLink.prototype._initParent=function(){_super.prototype._initParent.call(this);var ownerControl=this.parent.control;ownerControl.itemsSource.length==1&&ownerControl.selectedIndex<0&&(ownerControl.selectedIndex=0);ownerControl.displayMemberPath||(ownerControl.displayMemberPath='header');ownerControl.selectedValuePath||(ownerControl.selectedValuePath='value');ownerControl.commandPath||(ownerControl.commandPath='cmd');ownerControl.commandParameterPath||(ownerControl.commandParameterPath='cmdParam')},WjMenuItemLink.prototype._destroy=function(){var ownerControl=this.parent&&this.parent.control;_super.prototype._destroy.call(this);ownerControl&&ownerControl.invalidate()},WjMenuItemLink}(angular.WjLink),WjMenuSeparator=function(_super){function WjMenuSeparator(){_super.call(this);this.template='<span />';this.require='^wjMenu'}return __extends(WjMenuSeparator,_super),WjMenuSeparator.prototype._getMetaDataId=function(){return'MenuSeparator'},WjMenuSeparator.prototype._createLink=function(){return new WjMenuItemLink(!0)},WjMenuSeparator.prototype._getId=function(){return WjMenuItem._directiveId},WjMenuSeparator}(angular.WjDirective),WjContextMenu=function(_super){function WjContextMenu(){_super.call(this);this.template=undefined;this.restrict='A';this.scope=!1}return __extends(WjContextMenu,_super),WjContextMenu.prototype._getMetaDataId=function(){return'WjContextMenu'},WjContextMenu.prototype._postLinkFn=function(){return function(scope,tElement,tAttrs){var host=wijmo.getElement(tAttrs.wjContextMenu);tElement[0].addEventListener('contextmenu',function(e){var menu=wijmo.Control.getControl(host),dropDown=menu.dropDown;menu&&dropDown&&!wijmo.closest(e.target,'[disabled]')&&(e.preventDefault(),menu.owner=tElement[0],menu.selectedIndex=-1,menu.onIsDroppedDownChanging(new wijmo.CancelEventArgs)&&(wijmo.showPopup(dropDown,e),menu.onIsDroppedDownChanged(),dropDown.focus()))})}},WjContextMenu}(angular.WjDirective),WjInputDate=function(_super){function WjInputDate(){_super.apply(this,arguments)}return __extends(WjInputDate,_super),Object.defineProperty(WjInputDate.prototype,"_controlConstructor",{get:function(){return wijmo.input.InputDate},enumerable:!0,configurable:!0}),WjInputDate}(WjDropDown),WjInputDateTime=function(_super){function WjInputDateTime(){_super.apply(this,arguments)}return __extends(WjInputDateTime,_super),Object.defineProperty(WjInputDateTime.prototype,"_controlConstructor",{get:function(){return wijmo.input.InputDateTime},enumerable:!0,configurable:!0}),WjInputDateTime}(WjInputDate),WjInputNumber=function(_super){function WjInputNumber(){_super.apply(this,arguments)}return __extends(WjInputNumber,_super),Object.defineProperty(WjInputNumber.prototype,"_controlConstructor",{get:function(){return wijmo.input.InputNumber},enumerable:!0,configurable:!0}),WjInputNumber}(angular.WjDirective),WjInputMask=function(_super){function WjInputMask(){_super.apply(this,arguments)}return __extends(WjInputMask,_super),Object.defineProperty(WjInputMask.prototype,"_controlConstructor",{get:function(){return wijmo.input.InputMask},enumerable:!0,configurable:!0}),WjInputMask}(angular.WjDirective),WjInputTime=function(_super){function WjInputTime($compile){_super.call(this,$compile)}return __extends(WjInputTime,_super),Object.defineProperty(WjInputTime.prototype,"_controlConstructor",{get:function(){return wijmo.input.InputTime},enumerable:!0,configurable:!0}),WjInputTime}(WjComboBox),WjInputColor=function(_super){function WjInputColor(){_super.apply(this,arguments)}return __extends(WjInputColor,_super),Object.defineProperty(WjInputColor.prototype,"_controlConstructor",{get:function(){return wijmo.input.InputColor},enumerable:!0,configurable:!0}),WjInputColor}(WjDropDown),WjPopup=function(_super){function WjPopup(){_super.call(this);this.transclude=!0;this.template='<div ng-transclude/>'}return __extends(WjPopup,_super),Object.defineProperty(WjPopup.prototype,"_controlConstructor",{get:function(){return wijmo.input.Popup},enumerable:!0,configurable:!0}),WjPopup.prototype._initProps=function(){_super.prototype._initProps.call(this);angular.MetaFactory.findProp('owner',this._props).customHandler=function(scope,control,value){var modal=scope.modal;modal==null&&(control.modal=value?!1:!0)}},WjPopup}(angular.WjDirective),WjMultiSelect=function(_super){function WjMultiSelect($compile){_super.call(this,$compile)}return __extends(WjMultiSelect,_super),Object.defineProperty(WjMultiSelect.prototype,"_controlConstructor",{get:function(){return wijmo.input.MultiSelect},enumerable:!0,configurable:!0}),WjMultiSelect}(WjComboBox),WjCollectionViewNavigator=function(_super){function WjCollectionViewNavigator(){_super.call(this);this.template='<div class="wj-control wj-content wj-pager"><div class="wj-input-group"><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button" ng-click="cv.moveCurrentToFirst()" ng-disabled="cv.currentPosition <= 0"><span class="wj-glyph-left" style="margin-right:-4px"><\/span><span class="wj-glyph-left"><\/span> <\/button><\/span><span class="wj-input-group-btn"> <button class="wj-btn wj-btn-default" type="button" ng-click="cv.moveCurrentToPrevious()" ng-disabled="cv.currentPosition <= 0"><span class="wj-glyph-left"><\/span> <\/button><\/span><input type="text" class="wj-form-control" value=" {{cv.currentPosition + 1 | number}} / {{cv.itemCount | number}} " disabled /><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button" ng-click="cv.moveCurrentToNext()" ng-disabled="cv.currentPosition >= cv.itemCount - 1"><span class="wj-glyph-right"><\/span><\/button><\/span><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button" ng-click="cv.moveCurrentToLast()" ng-disabled="cv.currentPosition >= cv.itemCount - 1"><span class="wj-glyph-right"><\/span><span class="wj-glyph-right" style="margin-left:-4px"><\/span><\/button><\/span><\/div><\/div>'}return __extends(WjCollectionViewNavigator,_super),WjCollectionViewNavigator.prototype._getMetaDataId=function(){return'CollectionViewNavigator'},WjCollectionViewNavigator.prototype._postLinkFn=function(){return function(){}},WjCollectionViewNavigator}(angular.WjDirective),WjCollectionViewPager=function(_super){function WjCollectionViewPager(){_super.call(this);this.template='<div class="wj-control wj-content wj-pager"><div class="wj-input-group"><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button"ng-click="cv.moveToFirstPage()"ng-disabled="cv.pageIndex <= 0"><span class="wj-glyph-left" style="margin-right:-4px"><\/span><span class="wj-glyph-left"><\/span><\/button><\/span><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button"ng-click="cv.moveToPreviousPage()"ng-disabled="cv.pageIndex <= 0"><span class="wj-glyph-left"><\/span><\/button><\/span><input type="text" class="wj-form-control" value="{{cv.pageIndex + 1 | number}} / {{cv.pageCount | number}}" disabled /><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button"ng-click="cv.moveToNextPage()"ng-disabled="cv.pageIndex >= cv.pageCount - 1"><span class="wj-glyph-right"><\/span><\/button><\/span><span class="wj-input-group-btn"><button class="wj-btn wj-btn-default" type="button"ng-click="cv.moveToLastPage()"ng-disabled="cv.pageIndex >= cv.pageCount - 1"><span class="wj-glyph-right"><\/span><span class="wj-glyph-right" style="margin-left:-4px"><\/span><\/button><\/span><\/div><\/div>'}return __extends(WjCollectionViewPager,_super),WjCollectionViewPager.prototype._getMetaDataId=function(){return'CollectionViewPager'},WjCollectionViewPager.prototype._postLinkFn=function(){return function(){}},WjCollectionViewPager}(angular.WjDirective)})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoChart=window.angular.module('wj.chart',[]);wijmo.chart&&wijmo.chart.FlexChart&&(wijmoChart.directive('wjFlexChart',[function(){return new WjFlexChart}]),wijmoChart.directive('wjFlexChartAxis',[function(){return new WjFlexChartAxis}]),wijmoChart.directive('wjFlexChartSeries',[function(){return new WjFlexChartSeries}]),wijmoChart.directive('wjFlexChartLegend',[function(){return new WjFlexChartLegend}]),wijmoChart.directive('wjFlexChartDataLabel',[function(){return new WjFlexChartDataLabel}]),wijmoChart.directive('wjFlexPieDataLabel',[function(){return new WjFlexPieDataLabel}]),wijmoChart.directive('wjFlexChartLineMarker',[function(){return new WjFlexChartLineMarker}]),wijmoChart.directive('wjFlexChartPlotArea',[function(){return new WjFlexChartPlotArea}]),wijmoChart.directive('wjFlexChartDataPoint',[function(){return new WjFlexChartDataPoint}]),wijmo.chart.interaction&&(wijmoChart.directive('wjFlexChartRangeSelector',[function(){return new WjFlexChartRangeSelector}]),wijmoChart.directive('wjFlexChartGestures',[function(){return new WjFlexChartChartGestures}]),wijmoChart.directive('wjFlexChartChartGestures',[function(){return new WjFlexChartChartGestures}])),wijmo.chart.annotation&&(wijmoChart.directive('wjFlexChartAnnotationLayer',[function(){return new WjFlexChartAnnotationLayer}]),wijmoChart.directive('wjFlexChartAnnotation',[function(){return new WjFlexChartAnnotation}])),wijmoChart.directive('wjFlexPie',[function(){return new WjFlexPie}]),wijmo.chart.hierarchical&&wijmoChart.directive('wjSunburst',[function(){return new WjSunburst}]),wijmo.chart.radar&&(wijmoChart.directive('wjFlexRadar',[function(){return new WjFlexRadar}]),wijmoChart.directive('wjFlexRadarSeries',[function(){return new WjFlexRadarSeries}])),wijmo.chart.finance&&(wijmoChart.directive('wjFinancialChart',[function(){return new WjFinancialChart}]),wijmoChart.directive('wjFinancialChartSeries',[function(){return new WjFinancialChartSeries}]),wijmo.chart.finance.analytics&&(wijmoChart.directive('wjFlexChartFibonacci',[function(){return new WjFlexChartFibonacci}]),wijmoChart.directive('wjFlexChartFibonacciArcs',[function(){return new WjFlexChartFibonacciArcs}]),wijmoChart.directive('wjFlexChartFibonacciFans',[function(){return new WjFlexChartFibonacciFans}]),wijmoChart.directive('wjFlexChartFibonacciTimeZones',[function(){return new WjFlexChartFibonacciTimeZones}]),wijmoChart.directive('wjFlexChartAtr',[function(){return new WjFlexChartAtr}]),wijmoChart.directive('wjFlexChartCci',[function(){return new WjFlexChartCci}]),wijmoChart.directive('wjFlexChartRsi',[function(){return new WjFlexChartRsi}]),wijmoChart.directive('wjFlexChartWilliamsR',[function(){return new WjFlexChartWilliamsR}]),wijmoChart.directive('wjFlexChartMacd',[function(){return new WjFlexChartMacd}]),wijmoChart.directive('wjFlexChartMacdHistogram',[function(){return new WjFlexChartMacdHistogram}]),wijmoChart.directive('wjFlexChartStochastic',[function(){return new WjFlexChartStochastic}]),wijmoChart.directive('wjFlexChartBollingerBands',[function(){return new WjFlexChartBollingerBands}]),wijmoChart.directive('wjFlexChartEnvelopes',[function(){return new WjFlexChartEnvelopes}]))),wijmo.chart.analytics&&(wijmoChart.directive('wjFlexChartTrendLine',[function(){return new WjFlexChartTrendLine}]),wijmoChart.directive('wjFlexChartMovingAverage',[function(){return new WjFlexChartMovingAverage}]),wijmoChart.directive('wjFlexChartYFunctionSeries',[function(){return new WjFlexChartYFunctionSeries}]),wijmoChart.directive('wjFlexChartParametricFunctionSeries',[function(){return new WjFlexChartParametricFunctionSeries}]),wijmoChart.directive('wjFlexChartWaterfall',[function(){return new WjFlexChartWaterfall}])),wijmo.chart.animation&&wijmoChart.directive('wjFlexChartAnimation',[function(){return new WjFlexChartAnimation}]));var WjFlexChartBase=function(_super){function WjFlexChartBase(){_super.call(this);var self=this;this.template='<div ng-transclude />';this.transclude=!0}return __extends(WjFlexChartBase,_super),Object.defineProperty(WjFlexChartBase.prototype,"_controlConstructor",{get:function(){return wijmo.chart.FlexChartBase},enumerable:!0,configurable:!0}),WjFlexChartBase.prototype._initProps=function(){_super.prototype._initProps.call(this);var self=this,tooltipDesc=angular.MetaFactory.findProp('tooltipContent',this._props);tooltipDesc.customHandler=function(scope,control,value){value!=null&&(control.tooltip.content=value)}},WjFlexChartBase}(angular.WjDirective),WjFlexChartCore=function(_super){function WjFlexChartCore(){_super.apply(this,arguments)}return __extends(WjFlexChartCore,_super),Object.defineProperty(WjFlexChartCore.prototype,"_controlConstructor",{get:function(){return wijmo.chart.FlexChartCore},enumerable:!0,configurable:!0}),WjFlexChartCore.prototype._initProps=function(){_super.prototype._initProps.call(this);var self=this,lblContentDesc=angular.MetaFactory.findProp('labelContent',this._props);lblContentDesc.customHandler=function(scope,control,value){value!=null&&(control.dataLabel.content=value)}},WjFlexChartCore}(WjFlexChartBase),WjFlexChart=function(_super){function WjFlexChart(){_super.apply(this,arguments)}return __extends(WjFlexChart,_super),Object.defineProperty(WjFlexChart.prototype,"_controlConstructor",{get:function(){return wijmo.chart.FlexChart},enumerable:!0,configurable:!0}),WjFlexChart}(WjFlexChartCore),WjFlexChartAxis=function(_super){function WjFlexChartAxis(){_super.call(this);this.require=['?^wjFlexChartSeries','?^wjFinancialChartSeries','?^wjFlexChart','?^wjFinancialChart','?^wjFlexRadar'];this.template='<div class="wjFlexChartAxis" />'}return __extends(WjFlexChartAxis,_super),Object.defineProperty(WjFlexChartAxis.prototype,"_controlConstructor",{get:function(){return wijmo.chart.Axis},enumerable:!0,configurable:!0}),WjFlexChartAxis.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexChartAxis}(angular.WjDirective),WjFlexChartLegend=function(_super){function WjFlexChartLegend(){_super.call(this);this.require=['?^wjFlexChart','?^wjFlexPie','?^wjSunburst','?^wjFinancialChart','?^wjFlexRadar'];this.template='<div />'}return __extends(WjFlexChartLegend,_super),Object.defineProperty(WjFlexChartLegend.prototype,"_controlConstructor",{get:function(){return wijmo.chart.Legend},enumerable:!0,configurable:!0}),WjFlexChartLegend}(angular.WjDirective),WjFlexChartDataLabelBase=function(_super){function WjFlexChartDataLabelBase(){_super.call(this);this.require=['?^wjFlexChart','?^wjFlexPie','?^wjSunburst'];this.template='<div />'}return __extends(WjFlexChartDataLabelBase,_super),Object.defineProperty(WjFlexChartDataLabelBase.prototype,"_controlConstructor",{get:function(){return wijmo.chart.DataLabelBase},enumerable:!0,configurable:!0}),WjFlexChartDataLabelBase}(angular.WjDirective),WjFlexChartDataLabel=function(_super){function WjFlexChartDataLabel(){_super.call(this);this.require='^wjFlexChart'}return __extends(WjFlexChartDataLabel,_super),Object.defineProperty(WjFlexChartDataLabel.prototype,"_controlConstructor",{get:function(){return wijmo.chart.DataLabel},enumerable:!0,configurable:!0}),WjFlexChartDataLabel}(WjFlexChartDataLabelBase),WjFlexPieDataLabel=function(_super){function WjFlexPieDataLabel(){_super.call(this);this.require=['^wjFlexPie','?^wjSunburst']}return __extends(WjFlexPieDataLabel,_super),Object.defineProperty(WjFlexPieDataLabel.prototype,"_controlConstructor",{get:function(){return wijmo.chart.PieDataLabel},enumerable:!0,configurable:!0}),WjFlexPieDataLabel}(WjFlexChartDataLabelBase),WjSeriesBase=function(_super){function WjSeriesBase(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart','?^wjFlexRadar'];this.template='<div class="wjSeriesBase" ng-transclude />';this.transclude=!0}return __extends(WjSeriesBase,_super),Object.defineProperty(WjSeriesBase.prototype,"_controlConstructor",{get:function(){return wijmo.chart.SeriesBase},enumerable:!0,configurable:!0}),WjSeriesBase.prototype._getId=function(){return'series'},WjSeriesBase}(angular.WjDirective),WjFlexChartSeries=function(_super){function WjFlexChartSeries(){_super.call(this);this.require='^wjFlexChart';this.template='<div class="wjFlexChartSeries" ng-transclude />'}return __extends(WjFlexChartSeries,_super),Object.defineProperty(WjFlexChartSeries.prototype,"_controlConstructor",{get:function(){return wijmo.chart.Series},enumerable:!0,configurable:!0}),WjFlexChartSeries}(WjSeriesBase),WjFlexChartLineMarker=function(_super){function WjFlexChartLineMarker(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart']}return __extends(WjFlexChartLineMarker,_super),Object.defineProperty(WjFlexChartLineMarker.prototype,"_controlConstructor",{get:function(){return wijmo.chart.LineMarker},enumerable:!0,configurable:!0}),WjFlexChartLineMarker}(angular.WjDirective),WjFlexChartDataPoint=function(_super){function WjFlexChartDataPoint(){_super.call(this);this.require=['?^wjFlexChartAnnotation']}return __extends(WjFlexChartDataPoint,_super),Object.defineProperty(WjFlexChartDataPoint.prototype,"_controlConstructor",{get:function(){return wijmo.chart.DataPoint},enumerable:!0,configurable:!0}),WjFlexChartDataPoint}(angular.WjDirective),WjFlexChartAnnotationLayer=function(_super){function WjFlexChartAnnotationLayer(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart'];this.template='<div class="wjFlexChartAnnotationLayer" ng-transclude />';this.transclude=!0}return __extends(WjFlexChartAnnotationLayer,_super),Object.defineProperty(WjFlexChartAnnotationLayer.prototype,"_controlConstructor",{get:function(){return wijmo.chart.annotation.AnnotationLayer},enumerable:!0,configurable:!0}),WjFlexChartAnnotationLayer}(angular.WjDirective),WjFlexChartAnimation=function(_super){function WjFlexChartAnimation(){_super.call(this);this.require=['?^wjFlexChart','?^wjFlexPie','?^wjSunburst','?^wjFinancialChart','?^wjFlexRadar']}return __extends(WjFlexChartAnimation,_super),Object.defineProperty(WjFlexChartAnimation.prototype,"_controlConstructor",{get:function(){return wijmo.chart.animation.ChartAnimation},enumerable:!0,configurable:!0}),WjFlexChartAnimation}(angular.WjDirective),WjFlexChartAnnotation=function(_super){function WjFlexChartAnnotation(){_super.call(this);this.require='^wjFlexChartAnnotationLayer';this.template='<div class="wjFlexChartAnnotation" ng-transclude />';this.transclude=!0}return __extends(WjFlexChartAnnotation,_super),WjFlexChartAnnotation.prototype._createLink=function(){return new WjFlexChartAnnotationLink},WjFlexChartAnnotation.prototype._getMetaDataId=function(){return'FlexChartAnnotation'},WjFlexChartAnnotation}(angular.WjDirective),WjFlexChartAnnotationLink=function(_super){function WjFlexChartAnnotationLink(){_super.apply(this,arguments)}return __extends(WjFlexChartAnnotationLink,_super),WjFlexChartAnnotationLink.prototype._initControl=function(){return new wijmo.chart.annotation[this.scope.type]},WjFlexChartAnnotationLink}(angular.WjLink),WjFlexChartRangeSelector=function(_super){function WjFlexChartRangeSelector(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart']}return __extends(WjFlexChartRangeSelector,_super),Object.defineProperty(WjFlexChartRangeSelector.prototype,"_controlConstructor",{get:function(){return wijmo.chart.interaction.RangeSelector},enumerable:!0,configurable:!0}),WjFlexChartRangeSelector}(angular.WjDirective),WjFlexChartChartGestures=function(_super){function WjFlexChartChartGestures(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart']}return __extends(WjFlexChartChartGestures,_super),Object.defineProperty(WjFlexChartChartGestures.prototype,"_controlConstructor",{get:function(){return wijmo.chart.interaction.ChartGestures},enumerable:!0,configurable:!0}),WjFlexChartChartGestures}(angular.WjDirective),WjFlexPie=function(_super){function WjFlexPie(){_super.apply(this,arguments)}return __extends(WjFlexPie,_super),Object.defineProperty(WjFlexPie.prototype,"_controlConstructor",{get:function(){return wijmo.chart.FlexPie},enumerable:!0,configurable:!0}),WjFlexPie.prototype._initProps=function(){_super.prototype._initProps.call(this);var self=this,lblContentDesc=angular.MetaFactory.findProp('labelContent',this._props);lblContentDesc.customHandler=function(scope,control,value){value!=null&&(control.dataLabel.content=value)}},WjFlexPie}(WjFlexChartBase),WjSunburst=function(_super){function WjSunburst(){_super.apply(this,arguments)}return __extends(WjSunburst,_super),Object.defineProperty(WjSunburst.prototype,"_controlConstructor",{get:function(){return wijmo.chart.hierarchical.Sunburst},enumerable:!0,configurable:!0}),WjSunburst}(WjFlexPie),WjFlexRadar=function(_super){function WjFlexRadar(){_super.apply(this,arguments)}return __extends(WjFlexRadar,_super),Object.defineProperty(WjFlexRadar.prototype,"_controlConstructor",{get:function(){return wijmo.chart.radar.FlexRadar},enumerable:!0,configurable:!0}),WjFlexRadar}(WjFlexChartCore),WjFlexRadarSeries=function(_super){function WjFlexRadarSeries(){_super.call(this);this.require='^wjFlexRadar';this.template='<div class="wjFlexRadarSeries" ng-transclude />'}return __extends(WjFlexRadarSeries,_super),Object.defineProperty(WjFlexRadarSeries.prototype,"_controlConstructor",{get:function(){return wijmo.chart.radar.FlexRadarSeries},enumerable:!0,configurable:!0}),WjFlexRadarSeries}(WjSeriesBase),WjFlexRadarAxis=function(_super){function WjFlexRadarAxis(){_super.call(this);this.require=['?^wjFlexRadarSeries','?^wjFlexRadar'];this.template='<div class="wjFlexRadarAxis" />'}return __extends(WjFlexRadarAxis,_super),Object.defineProperty(WjFlexRadarAxis.prototype,"_controlConstructor",{get:function(){return wijmo.chart.radar.FlexRadarAxis},enumerable:!0,configurable:!0}),WjFlexRadarAxis.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexRadarAxis}(angular.WjDirective),WjFinancialChart=function(_super){function WjFinancialChart(){_super.apply(this,arguments)}return __extends(WjFinancialChart,_super),Object.defineProperty(WjFinancialChart.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.FinancialChart},enumerable:!0,configurable:!0}),WjFinancialChart}(WjFlexChartCore),WjFinancialChartSeries=function(_super){function WjFinancialChartSeries(){_super.call(this);this.require='^wjFinancialChart';this.template='<div class="wjFinancialChartSeries" ng-transclude />'}return __extends(WjFinancialChartSeries,_super),Object.defineProperty(WjFinancialChartSeries.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.FinancialSeries},enumerable:!0,configurable:!0}),WjFinancialChartSeries}(WjSeriesBase),WjTrendLineBase=function(_super){function WjTrendLineBase(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart'];this.template='<div class="wjTrendLineBase" ng-transclude />'}return __extends(WjTrendLineBase,_super),Object.defineProperty(WjTrendLineBase.prototype,"_controlConstructor",{get:function(){return wijmo.chart.analytics.TrendLineBase},enumerable:!0,configurable:!0}),WjTrendLineBase}(WjSeriesBase),WjFlexChartTrendLine=function(_super){function WjFlexChartTrendLine(){_super.call(this);this.template='<div class="wjTrendLine" ng-transclude />'}return __extends(WjFlexChartTrendLine,_super),Object.defineProperty(WjFlexChartTrendLine.prototype,"_controlConstructor",{get:function(){return wijmo.chart.analytics.TrendLine},enumerable:!0,configurable:!0}),WjFlexChartTrendLine}(WjTrendLineBase),WjFlexChartMovingAverage=function(_super){function WjFlexChartMovingAverage(){_super.call(this);this.template='<div class="wjMovingAverage" ng-transclude />'}return __extends(WjFlexChartMovingAverage,_super),Object.defineProperty(WjFlexChartMovingAverage.prototype,"_controlConstructor",{get:function(){return wijmo.chart.analytics.MovingAverage},enumerable:!0,configurable:!0}),WjFlexChartMovingAverage}(WjTrendLineBase),WjFlexChartYFunctionSeries=function(_super){function WjFlexChartYFunctionSeries(){_super.call(this);this.template='<div class="wjYFunctionSeries" ng-transclude />'}return __extends(WjFlexChartYFunctionSeries,_super),Object.defineProperty(WjFlexChartYFunctionSeries.prototype,"_controlConstructor",{get:function(){return wijmo.chart.analytics.YFunctionSeries},enumerable:!0,configurable:!0}),WjFlexChartYFunctionSeries}(WjTrendLineBase),WjFlexChartParametricFunctionSeries=function(_super){function WjFlexChartParametricFunctionSeries(){_super.call(this);this.template='<div class="wjParametricFunctionSeries" ng-transclude />'}return __extends(WjFlexChartParametricFunctionSeries,_super),Object.defineProperty(WjFlexChartParametricFunctionSeries.prototype,"_controlConstructor",{get:function(){return wijmo.chart.analytics.ParametricFunctionSeries},enumerable:!0,configurable:!0}),WjFlexChartParametricFunctionSeries.prototype._initProps=function(){_super.prototype._initProps.call(this);var self=this,funcDesc=angular.MetaFactory.findProp('func',this._props);funcDesc.customHandler=function(scope,control,value){value!=null&&(control.xFunc=value)}},WjFlexChartParametricFunctionSeries}(WjTrendLineBase),WjFlexChartWaterfall=function(_super){function WjFlexChartWaterfall(){_super.call(this);this.require=['?^wjFlexChart','?^wjFinancialChart'];this.template='<div class="wjWaterfall" ng-transclude />'}return __extends(WjFlexChartWaterfall,_super),Object.defineProperty(WjFlexChartWaterfall.prototype,"_controlConstructor",{get:function(){return wijmo.chart.analytics.Waterfall},enumerable:!0,configurable:!0}),WjFlexChartWaterfall}(WjSeriesBase),WjFlexChartPlotArea=function(_super){function WjFlexChartPlotArea(){_super.call(this);this.require=['?^wjFlexChartPlotArea','?^wjFlexChart','?^wjFinancialChart'];this.template='<div class="wjFlexChartPlotArea" />'}return __extends(WjFlexChartPlotArea,_super),Object.defineProperty(WjFlexChartPlotArea.prototype,"_controlConstructor",{get:function(){return wijmo.chart.PlotArea},enumerable:!0,configurable:!0}),WjFlexChartPlotArea.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexChartPlotArea}(angular.WjDirective),WjFlexChartFibonacci=function(_super){function WjFlexChartFibonacci(){_super.call(this);this.require=['?^wjFinancialChart'];this.template='<div class="wjFlexChartFibonacci" ng-transclude />'}return __extends(WjFlexChartFibonacci,_super),Object.defineProperty(WjFlexChartFibonacci.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.Fibonacci},enumerable:!0,configurable:!0}),WjFlexChartFibonacci.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexChartFibonacci}(WjSeriesBase),WjFlexChartFibonacciArcs=function(_super){function WjFlexChartFibonacciArcs(){_super.call(this);this.require=['?^wjFinancialChart'];this.template='<div class="wjFlexChartFibonacciArcs" ng-transclude />'}return __extends(WjFlexChartFibonacciArcs,_super),Object.defineProperty(WjFlexChartFibonacciArcs.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.FibonacciArcs},enumerable:!0,configurable:!0}),WjFlexChartFibonacciArcs.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexChartFibonacciArcs}(WjSeriesBase),WjFlexChartFibonacciFans=function(_super){function WjFlexChartFibonacciFans(){_super.call(this);this.require=['?^wjFinancialChart'];this.template='<div class="wjFlexChartFibonacciFans" ng-transclude />'}return __extends(WjFlexChartFibonacciFans,_super),Object.defineProperty(WjFlexChartFibonacciFans.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.FibonacciFans},enumerable:!0,configurable:!0}),WjFlexChartFibonacciFans.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexChartFibonacciFans}(WjSeriesBase),WjFlexChartFibonacciTimeZones=function(_super){function WjFlexChartFibonacciTimeZones(){_super.call(this);this.require=['?^wjFinancialChart'];this.template='<div class="wjFlexChartFibonacciTimeZones" ng-transclude />'}return __extends(WjFlexChartFibonacciTimeZones,_super),Object.defineProperty(WjFlexChartFibonacciTimeZones.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.FibonacciTimeZones},enumerable:!0,configurable:!0}),WjFlexChartFibonacciTimeZones.prototype._initControl=function(){return _super.prototype._initControl.call(this,undefined)},WjFlexChartFibonacciTimeZones}(WjSeriesBase),WjBaseOverlayIndicator=function(_super){function WjBaseOverlayIndicator(){_super.call(this);this.require='^wjFinancialChart';this.template='<div class="wjBaseOverlayIndicator" ng-transclude />'}return __extends(WjBaseOverlayIndicator,_super),Object.defineProperty(WjBaseOverlayIndicator.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.OverlayIndicatorBase},enumerable:!0,configurable:!0}),WjBaseOverlayIndicator}(WjSeriesBase),WjBaseSingleOverlayIndicator=function(_super){function WjBaseSingleOverlayIndicator(){_super.call(this);this.template='<div class="wjBaseSingleOverlayIndicator" ng-transclude />'}return __extends(WjBaseSingleOverlayIndicator,_super),Object.defineProperty(WjBaseSingleOverlayIndicator.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.SingleOverlayIndicatorBase},enumerable:!0,configurable:!0}),WjBaseSingleOverlayIndicator}(WjBaseOverlayIndicator),WjFlexChartAtr=function(_super){function WjFlexChartAtr(){_super.call(this);this.template='<div class="wjFlexChartAtr" ng-transclude />'}return __extends(WjFlexChartAtr,_super),Object.defineProperty(WjFlexChartAtr.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.ATR},enumerable:!0,configurable:!0}),WjFlexChartAtr}(WjBaseSingleOverlayIndicator),WjFlexChartCci=function(_super){function WjFlexChartCci(){_super.call(this);this.template='<div class="wjFlexChartCci" ng-transclude />'}return __extends(WjFlexChartCci,_super),Object.defineProperty(WjFlexChartCci.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.CCI},enumerable:!0,configurable:!0}),WjFlexChartCci}(WjBaseSingleOverlayIndicator),WjFlexChartRsi=function(_super){function WjFlexChartRsi(){_super.call(this);this.template='<div class="wjFlexChartRsi" ng-transclude />'}return __extends(WjFlexChartRsi,_super),Object.defineProperty(WjFlexChartRsi.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.RSI},enumerable:!0,configurable:!0}),WjFlexChartRsi}(WjBaseSingleOverlayIndicator),WjFlexChartWilliamsR=function(_super){function WjFlexChartWilliamsR(){_super.call(this);this.template='<div class="wjFlexChartWilliamsR" ng-transclude />'}return __extends(WjFlexChartWilliamsR,_super),Object.defineProperty(WjFlexChartWilliamsR.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.WilliamsR},enumerable:!0,configurable:!0}),WjFlexChartWilliamsR}(WjBaseSingleOverlayIndicator),WjFlexChartMacdBase=function(_super){function WjFlexChartMacdBase(){_super.call(this);this.template='<div class="wjFlexChartBaseMacd" ng-transclude />'}return __extends(WjFlexChartMacdBase,_super),Object.defineProperty(WjFlexChartMacdBase.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.MacdBase},enumerable:!0,configurable:!0}),WjFlexChartMacdBase}(WjBaseOverlayIndicator),WjFlexChartMacd=function(_super){function WjFlexChartMacd(){_super.call(this);this.template='<div class="wjFlexChartMacd" ng-transclude />'}return __extends(WjFlexChartMacd,_super),Object.defineProperty(WjFlexChartMacd.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.Macd},enumerable:!0,configurable:!0}),WjFlexChartMacd}(WjFlexChartMacdBase),WjFlexChartMacdHistogram=function(_super){function WjFlexChartMacdHistogram(){_super.call(this);this.template='<div class="wjFlexChartMacdHistogram" ng-transclude />'}return __extends(WjFlexChartMacdHistogram,_super),Object.defineProperty(WjFlexChartMacdHistogram.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.MacdHistogram},enumerable:!0,configurable:!0}),WjFlexChartMacdHistogram}(WjFlexChartMacdBase),WjFlexChartStochastic=function(_super){function WjFlexChartStochastic(){_super.call(this);this.template='<div class="wjFlexChartStochastic" ng-transclude />'}return __extends(WjFlexChartStochastic,_super),Object.defineProperty(WjFlexChartStochastic.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.Stochastic},enumerable:!0,configurable:!0}),WjFlexChartStochastic}(WjBaseOverlayIndicator),WjFlexChartBollingerBands=function(_super){function WjFlexChartBollingerBands(){_super.call(this);this.template='<div class="wjFlexChartBollingerBands" ng-transclude />'}return __extends(WjFlexChartBollingerBands,_super),Object.defineProperty(WjFlexChartBollingerBands.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.BollingerBands},enumerable:!0,configurable:!0}),WjFlexChartBollingerBands}(WjBaseOverlayIndicator),WjFlexChartEnvelopes=function(_super){function WjFlexChartEnvelopes(){_super.call(this);this.template='<div class="wjFlexChartEnvelopes" ng-transclude />'}return __extends(WjFlexChartEnvelopes,_super),Object.defineProperty(WjFlexChartEnvelopes.prototype,"_controlConstructor",{get:function(){return wijmo.chart.finance.analytics.Envelopes},enumerable:!0,configurable:!0}),WjFlexChartEnvelopes}(WjBaseOverlayIndicator)})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoGauge=window.angular.module('wj.gauge',[]);wijmo.gauge&&wijmo.gauge.LinearGauge&&(wijmoGauge.directive('wjLinearGauge',[function(){return new WjLinearGauge}]),wijmoGauge.directive('wjBulletGraph',[function(){return new WjBulletGraph}]),wijmoGauge.directive('wjRadialGauge',[function(){return new WjRadialGauge}]),wijmoGauge.directive('wjRange',[function(){return new WjRange}]));var WjGauge=function(_super){function WjGauge(){_super.call(this);this.template='<div ng-transclude />';this.transclude=!0}return __extends(WjGauge,_super),Object.defineProperty(WjGauge.prototype,"_controlConstructor",{get:function(){return wijmo.gauge.Gauge},enumerable:!0,configurable:!0}),WjGauge}(angular.WjDirective),WjLinearGauge=function(_super){function WjLinearGauge(){_super.call(this)}return __extends(WjLinearGauge,_super),Object.defineProperty(WjLinearGauge.prototype,"_controlConstructor",{get:function(){return wijmo.gauge.LinearGauge},enumerable:!0,configurable:!0}),WjLinearGauge}(WjGauge),WjBulletGraph=function(_super){function WjBulletGraph(){_super.call(this)}return __extends(WjBulletGraph,_super),Object.defineProperty(WjBulletGraph.prototype,"_controlConstructor",{get:function(){return wijmo.gauge.BulletGraph},enumerable:!0,configurable:!0}),WjBulletGraph}(WjLinearGauge),WjRadialGauge=function(_super){function WjRadialGauge(){_super.call(this)}return __extends(WjRadialGauge,_super),Object.defineProperty(WjRadialGauge.prototype,"_controlConstructor",{get:function(){return wijmo.gauge.RadialGauge},enumerable:!0,configurable:!0}),WjRadialGauge}(WjGauge),WjRange=function(_super){function WjRange(){_super.call(this);this.require=['?^wjLinearGauge','?^wjRadialGauge','?^wjBulletGraph'];this.template='<div ng-transclude />';this.transclude=!0;this._property='ranges';this._isPropertyArray=!0}return __extends(WjRange,_super),Object.defineProperty(WjRange.prototype,"_controlConstructor",{get:function(){return wijmo.gauge.Range},enumerable:!0,configurable:!0}),WjRange}(angular.WjDirective)})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoGrid=window.angular.module('wj.grid',[]),WjFlexGrid,WjFlexGridLink,gridModule,DirectiveCellFactory,_RowHeightUpdateQueue,WjFlexGridColumn,WjFlexGridColumnLink;wijmo.grid&&wijmo.grid.FlexGrid&&(wijmoGrid.directive('wjFlexGrid',['$compile','$interpolate',function($compile,$interpolate){return new WjFlexGrid($compile,$interpolate)}]),wijmoGrid.directive('wjFlexGridColumn',['$compile',function($compile){return new WjFlexGridColumn($compile)}]),wijmoGrid.directive('wjFlexGridCellTemplate',[function(){return new WjFlexGridCellTemplate}]),wijmo.grid.filter&&wijmoGrid.directive('wjFlexGridFilter',[function(){return new WjFlexGridFilter}]),wijmo.grid.grouppanel&&wijmoGrid.directive('wjGroupPanel',[function(){return new WjGroupPanel}]),wijmo.grid.detail&&wijmoGrid.directive('wjFlexGridDetail',['$compile',function($compile){return new WjFlexGridDetail($compile)}]),wijmo.grid.sheet&&(wijmoGrid.directive('wjFlexSheet',['$compile','$interpolate',function($compile,$interpolate){return new WjFlexSheet($compile,$interpolate)}]),wijmoGrid.directive('wjSheet',[function(){return new WjSheet}])),wijmo.grid.multirow&&wijmoGrid.directive('wjMultiRow',['$compile','$interpolate',function($compile,$interpolate){return new WjMultiRow($compile,$interpolate)}]));WjFlexGrid=function(_super){function WjFlexGrid($compile,$interpolate){_super.call(this);this._$compile=$compile;this._$interpolate=$interpolate;var self=this;this.transclude=!0;this.template='<div ng-transclude />'}return __extends(WjFlexGrid,_super),Object.defineProperty(WjFlexGrid.prototype,"_controlConstructor",{get:function(){return wijmo.grid.FlexGrid},enumerable:!0,configurable:!0}),WjFlexGrid.prototype._createLink=function(){return new WjFlexGridLink},WjFlexGrid.prototype._initProps=function(){var childPathDesc=angular.MetaFactory.findProp('childItemsPath',this._props);childPathDesc.scopeBindingMode='@';childPathDesc.customHandler=function(scope,control,value){if(value&&(value=value.trim(),value&&value[0]==='[')){var arr=scope.$parent.$eval(value);return control.childItemsPath=arr,!0}return!1}},WjFlexGrid}(angular.WjDirective);angular.WjFlexGrid=WjFlexGrid;WjFlexGridLink=function(_super){function WjFlexGridLink(){_super.apply(this,arguments)}return __extends(WjFlexGridLink,_super),WjFlexGridLink.prototype._initControl=function(){var grid=_super.prototype._initControl.call(this);return new DirectiveCellFactory(grid,this),grid},WjFlexGridLink}(angular.WjLink);angular.WjFlexGridLink=WjFlexGridLink;gridModule=wijmo.grid&&wijmo.grid.CellFactory;gridModule||(wijmo.grid={},wijmo.grid.CellFactory=function(){});DirectiveCellFactory=function(_super){function DirectiveCellFactory(grid,gridLink){var templateType,self;if(_super.call(this),this._lastApplyTimeStamp=0,this._noApplyLag=!1,this._startingEditing=!1,this._cellStampCounter=0,this._gridLink=gridLink,this._rowHeightUpdates=new _RowHeightUpdateQueue(this),!DirectiveCellFactory._templateTypes){DirectiveCellFactory._templateTypes=[];for(templateType in CellTemplateType)isNaN(templateType)&&DirectiveCellFactory._templateTypes.push(templateType)}self=this;this._baseCf=grid.cellFactory;grid.cellFactory=this;this._evtInput=document.createEvent('HTMLEvents');this._evtInput.initEvent('input',!0,!1);this._evtBlur=document.createEvent('HTMLEvents');this._evtBlur.initEvent('blur',!1,!1);grid.prepareCellForEdit.addHandler(function(){self._noApplyLag=!0});grid.cellEditEnded.addHandler(function(s,e){(e.range.col<0||!grid.columns[e.range.col][WjFlexGridCellTemplate._getTemplContextProp(CellTemplateType.CellEdit)])&&(self._editChar=null);setTimeout(function(){self._noApplyLag=!1},300)});grid.beginningEdit.addHandler(function(){self._startingEditing=!0});grid.hostElement.addEventListener('keydown',function(){self._startingEditing=!1},!0);grid.hostElement.addEventListener('keypress',function(e){var char=e.charCode>32?String.fromCharCode(e.charCode):null;char&&(!grid.activeEditor||self._startingEditing?self._editChar=char:self._editChar&&(self._editChar+=char))},!0)}return __extends(DirectiveCellFactory,_super),DirectiveCellFactory.prototype.updateCell=function(panel,rowIndex,colIndex,cell,rng){var cellStamp,isHierNonGroup,isUpdated,col,templContextProp,templContext,measureAttr,isMeasuring,scopeChanged,cellLink,clonedElement,dispose,replaceFirst,rootEl,lag,closingLag,editEndingEH,rootElement,key,classArr,clStr,i,curPart,clName;this._cellStampCounter=(this._cellStampCounter+1)%1e7;cellStamp=cell[DirectiveCellFactory._cellStampProp]=this._cellStampCounter;cell.style.overflow&&(cell.style.overflow='');var self=this,grid=panel.grid,editRange=grid.editRange,templateType,row=panel.rows[rowIndex],dataItem=row.dataItem,isGridCtx=!1,needCellValue=!1,isEdit=!1,isCvGroup=!1;switch(panel.cellType){case wijmo.grid.CellType.Cell:editRange&&editRange.row===rowIndex&&editRange.col===colIndex?(templateType=CellTemplateType.CellEdit,needCellValue=isEdit=!0):row instanceof wijmo.grid.GroupRow?(isCvGroup=dataItem instanceof wijmo.collections.CollectionViewGroup,isHierNonGroup=!(isCvGroup||row.hasChildren),colIndex==panel.columns.firstVisibleIndex?templateType=isHierNonGroup?CellTemplateType.Cell:CellTemplateType.GroupHeader:(templateType=isHierNonGroup?CellTemplateType.Cell:CellTemplateType.Group,needCellValue=!0)):wijmo.grid.detail&&wijmo.grid.detail.DetailRow&&row instanceof wijmo.grid.detail.DetailRow||(templateType=CellTemplateType.Cell);break;case wijmo.grid.CellType.ColumnHeader:templateType=CellTemplateType.ColumnHeader;break;case wijmo.grid.CellType.RowHeader:templateType=grid.collectionView&&grid.collectionView.currentEditItem===dataItem?CellTemplateType.RowHeaderEdit:CellTemplateType.RowHeader;isGridCtx=!0;break;case wijmo.grid.CellType.TopLeft:templateType=CellTemplateType.TopLeft;isGridCtx=!0;break;case wijmo.grid.CellType.ColumnFooter:templateType=CellTemplateType.ColumnFooter;needCellValue=!0;break;case wijmo.grid.CellType.BottomLeft:templateType=CellTemplateType.BottomLeft;isGridCtx=!0}if(isUpdated=!1,templateType!=null&&(col=isCvGroup&&templateType==CellTemplateType.GroupHeader?grid.columns.getColumn(dataItem.groupDescription.propertyName):colIndex>=0&&colIndex<panel.columns.length?panel.columns[colIndex]:null,col&&(templContextProp=WjFlexGridCellTemplate._getTemplContextProp(templateType),templContext=(isGridCtx?grid:col)[templContextProp],templContext||(templateType===CellTemplateType.RowHeaderEdit?(templateType=CellTemplateType.RowHeader,templContextProp=WjFlexGridCellTemplate._getTemplContextProp(templateType),templContext=grid[templContextProp]):(templateType===CellTemplateType.Group||templateType===CellTemplateType.GroupHeader)&&(isCvGroup||(templateType=CellTemplateType.Cell,templContextProp=WjFlexGridCellTemplate._getTemplContextProp(templateType),templContext=col[templContextProp]))),templContext))){var tpl=self._getCellTemplate(templContext.cellTemplate),cellStyle=templContext.cellStyle,cellClass=templContext.cellClass,isTpl=!wijmo.isNullOrWhiteSpace(tpl),isStyle=!wijmo.isNullOrWhiteSpace(cellStyle),isClass=!wijmo.isNullOrWhiteSpace(cellClass),cellValue;if(needCellValue&&(cellValue=panel.getCellData(rowIndex,colIndex,!1)),isTpl){measureAttr=cell.getAttribute(wijmo.grid.FlexGrid._WJS_MEASURE);isMeasuring=measureAttr&&measureAttr.toLowerCase()==='true';isUpdated=!0;isEdit&&this._baseCf.updateCell(panel,rowIndex,colIndex,cell,rng,!0);var cellContext=cell[templContextProp]||{},isForeignCell=cellContext.column!==col||!cellContext.cellScope||!cellContext.cellScope.$root,cellScope=cellContext.cellScope;isForeignCell&&(this._doDisposeCell(cell),cellContext.cellScope=cellScope=templContext.templLink.scope.$parent.$new(),cellContext.column=col,cell[templContextProp]=cellContext);scopeChanged=cellScope.$row!==row||cellScope.$col!==col||cellScope.$item!==dataItem||cellScope.$value!==cellValue;scopeChanged&&self._initCellScope(cellScope,row,col,dataItem,cellValue);cellLink=templContext.cellLink;cellLink||(cellLink=templContext.cellLink=this._gridLink.directive._$compile('<div style="display:none"'+(isStyle?' ng-style="'+cellStyle+'"':'')+(isClass?' ng-class="'+cellClass+'"':'')+'>'+tpl+'</div>'));clonedElement=cellContext.clonedElement;isForeignCell&&(dispose=cellScope.$watch(function(){if(clonedElement&&(dispose(),clonedElement[0].style.display='',panel.cellType===wijmo.grid.CellType.ColumnHeader||panel.cellType===wijmo.grid.CellType.TopLeft)){var clonedStyle=clonedElement[0].style,prevColor=clonedStyle.outlineColor,prevWidth=clonedStyle.outlineWidth;clonedStyle.outlineColor='white';clonedStyle.outlineWidth='0px';setTimeout(function(){clonedStyle.outlineColor=prevColor;clonedStyle.outlineWidth=prevWidth},0)}}),cellContext.clonedElement=clonedElement=cellLink(cellScope,function(){}));isMeasuring&&(clonedElement[0].style.display='');replaceFirst=!1;isEdit?(rootEl=cell.firstElementChild,rootEl&&(cell.focus(),rootEl.style.display='none')):(replaceFirst=cell.childNodes.length==1,replaceFirst||(cell.textContent=''));replaceFirst?clonedElement[0]!==cell.firstChild&&cell.replaceChild(clonedElement[0],cell.firstChild):cell.appendChild(clonedElement[0]);templContext.cellOverflow&&(cell.style.overflow=templContext.cellOverflow);lag=40;closingLag=10;this._closingApplyTimeOut&&clearTimeout(this._closingApplyTimeOut);self._rowHeightUpdates.add({panel:panel,cell:cell,rng:rng,cellStamp:cellStamp});isMeasuring||editRange||this._noApplyLag||scopeChanged&&Date.now()-this._lastApplyTimeStamp>lag?(clearTimeout(this._closingApplyTimeOut),cellScope.$root.$$phase||cellScope.$apply(),editRange||isMeasuring||self._rowHeightUpdates.execute(),this._lastApplyTimeStamp=Date.now()):(clearTimeout(this._closingApplyTimeOut),this._closingApplyTimeOut=setTimeout(function(){clearTimeout(this._closingApplyTimeOut);cellScope.$root.$$phase||cellScope.$apply();self._rowHeightUpdates.execute()},closingLag));setTimeout(function(){var inputs,i,input,inpSt,inpFocusEh;if(self._updateRowHeight(panel,cell,rng,cellStamp)){if(isEdit){self._rowHeightUpdates.clear();grid.refresh();grid.startEditing();return}}else if(isEdit&&(inputs=clonedElement[0].querySelectorAll('input'),inputs))for(i=0;i<inputs.length;i++)if(input=inputs[i],inpSt=window.getComputedStyle(input),inpSt.display!=='none'&&inpSt.visibility==='visible'){inpFocusEh=function(){input.removeEventListener('focus',inpFocusEh);setTimeout(function(){self._editChar&&(input.value=self._editChar,self._editChar=null,wijmo.setSelectionRange(input,input.value.length),input.dispatchEvent(self._evtInput))},50)};input.addEventListener('focus',inpFocusEh);input.focus();break}},0);isEdit?(self._cellEditorScope=cellScope,editEndingEH=function(s,e){var activeElement,dropDowns;grid.cellEditEnding.removeHandler(editEndingEH);e.stayInEditMode||(activeElement=wijmo.getActiveElement(),activeElement&&activeElement.dispatchEvent(self._evtBlur),cell.focus());e.cancel||e.stayInEditMode||(e.cancel=!0,panel.grid.setCellData(rowIndex,colIndex,cellScope.$value));dropDowns=cell.querySelectorAll('.wj-dropdown');[].forEach.call(dropDowns,function(el){var ctrl=wijmo.Control.getControl(el);ctrl&&ctrl instanceof wijmo.input.DropDown&&(ctrl.isDroppedDown=!1)})},grid.cellEditEnding.addHandler(editEndingEH),grid.cellEditEnded.addHandler(function(){self._cellEditorScope=null})):this._baseCf.updateCell(panel,rowIndex,colIndex,cell,rng,!1)}}if(isUpdated||(this._doDisposeCell(cell),this._baseCf.updateCell(panel,rowIndex,colIndex,cell,rng)),!isTpl&&(isStyle||isClass)){var cellScopeSt=self._initCellScope({},row,col,dataItem,cellValue),style=isStyle?this._gridLink.scope.$parent.$eval(cellStyle,cellScopeSt):null,classObj=isClass?this._gridLink.scope.$parent.$eval(cellClass,cellScopeSt):null;if(style||classObj){for(rootElement=document.createElement('div');cell.firstChild;)rootElement.appendChild(cell.firstChild);if(cell.appendChild(rootElement),style)for(key in style)rootElement.style[key]=style[key];if(classObj){for(classArr=wijmo.isArray(classObj)?classObj:[classObj],clStr='',i=0;i<classArr.length;i++)if(curPart=classArr[i],curPart)if(wijmo.isString(curPart))clStr+=' '+curPart;else for(clName in curPart)curPart[clName]&&(clStr+=' '+clName);rootElement.className=clStr}}}},DirectiveCellFactory.prototype.getEditorValue=function(g){return this._cellEditorScope?this._cellEditorScope.$value:_super.prototype.getEditorValue.call(this,g)},DirectiveCellFactory.prototype.disposeCell=function(cell){this._doDisposeCell(cell)},DirectiveCellFactory.prototype._doDisposeCell=function(cell){for(var templContextProp,cellContext,ttm=DirectiveCellFactory._templateTypes,i=0;i<ttm.length;i++)templContextProp=WjFlexGridCellTemplate._getTemplContextProp(CellTemplateType[ttm[i]]),cellContext=cell[templContextProp],cellContext&&cellContext.cellScope&&cellContext.cellScope.$root&&(cellContext.cellScope.$destroy(),cellContext.clonedElement&&(cellContext.clonedElement.remove(),cellContext.clonedElement=null),cell[templContextProp]=null)},DirectiveCellFactory.prototype._updateRowHeight=function(panel,cell,rng,cellStamp){var cellHeight=cell.scrollHeight,panelRows=panel.rows,rowSpan=rng&&rng.rowSpan||1;return cellStamp===cell[DirectiveCellFactory._cellStampProp]&&panelRows.defaultSize*rowSpan<cellHeight?(panelRows.defaultSize=cellHeight/rowSpan,!0):!1},DirectiveCellFactory.prototype._initCellScope=function(scope,row,col,dataItem,cellValue){return scope.$row=row,scope.$col=col,scope.$item=dataItem,scope.$value=cellValue,scope},DirectiveCellFactory.prototype._getCellTemplate=function(tpl){return tpl&&(tpl=tpl.replace(/ class\=\"ng\-scope\"( \"ng\-binding\")?/g,''),tpl=tpl.replace(/<span>\s*<\/span>/g,''),tpl=tpl.trim()),tpl},DirectiveCellFactory._cellStampProp='__wjCellStamp',DirectiveCellFactory}(wijmo.grid.CellFactory);_RowHeightUpdateQueue=function(){function _RowHeightUpdateQueue(cellFactory){this._requests=[];this._timeOuts=[];this._cellFactory=cellFactory}return _RowHeightUpdateQueue.prototype.add=function(request){this._requests.push(request)},_RowHeightUpdateQueue.prototype.execute=function(){for(var requests=this._requests;requests.length>0;){var request=this._requests.shift(),self=this,timeOut=function(request){return setTimeout(function(){if(self._cellFactory._updateRowHeight(request.panel,request.cell,request.rng,request.cellStamp))self.clear();else{var toIdx=self._timeOuts.indexOf(timeOut);toIdx>-1&&self._timeOuts.splice(toIdx,1)}},0)}(request);this._timeOuts.push(timeOut)}},_RowHeightUpdateQueue.prototype.clear=function(){this._requests.splice(0,this._requests.length);this._clearTimeouts()},_RowHeightUpdateQueue.prototype._clearTimeouts=function(){for(var timeOuts=this._timeOuts,i=0;i<timeOuts.length;i++)clearTimeout(timeOuts[i]);timeOuts.splice(0,timeOuts.length)},_RowHeightUpdateQueue}();gridModule||(wijmo.grid=null);WjFlexGridColumn=function(_super){function WjFlexGridColumn($compile){_super.call(this);this._$compile=$compile;this.scope.dataMap+="map";this.scope.dataType+="type";this.require='^wjFlexGrid';this.terminal=!0;angular.WjDirective._dynaTemplates?(this.transclude=!1,this.priority=100,this.template=function(tElement,tAttrs){return tAttrs[WjFlexGridColumn._colTemplateProp]=tElement[0].innerHTML,'<div class="wjGridColumn"/>'}):(this.transclude=!0,this.template='<div class="wjGridColumn" ng-transclude/>')}return __extends(WjFlexGridColumn,_super),Object.defineProperty(WjFlexGridColumn.prototype,"_controlConstructor",{get:function(){return wijmo.grid.Column},enumerable:!0,configurable:!0}),WjFlexGridColumn.prototype._initControl=function(){return new wijmo.grid.Column},WjFlexGridColumn.prototype._createLink=function(){return new WjFlexGridColumnLink},WjFlexGridColumn._colTemplateProp='$__wjColTemplate',WjFlexGridColumn._colWjLinkProp='$__wjLink',WjFlexGridColumn._cellCtxProp='$_cellCtxProp',WjFlexGridColumn}(angular.WjDirective);WjFlexGridColumnLink=function(_super){function WjFlexGridColumnLink(){_super.apply(this,arguments)}return __extends(WjFlexGridColumnLink,_super),WjFlexGridColumnLink.prototype._initParent=function(){var grid=this.parent.control;grid.autoGenerateColumns&&(grid.autoGenerateColumns=!1,this._safeApply(this.scope,'autoGenerateColumns',!1),grid.columns.clear());_super.prototype._initParent.call(this);var cellCtxProp=WjFlexGridCellTemplate._getTemplContextProp(CellTemplateType.Cell),cellCtxByTag=this.control[cellCtxProp],cellCtxWoTag=this[WjFlexGridColumn._cellCtxProp];!cellCtxByTag&&cellCtxWoTag&&(this.control[cellCtxProp]=cellCtxWoTag);this.control[WjFlexGridColumn._colWjLinkProp]=this},WjFlexGridColumnLink.prototype._link=function(){var rootEl=this.tElement[0],dynaTempl=this.tAttrs[WjFlexGridColumn._colTemplateProp],template=dynaTempl!=null?dynaTempl:angular.WjDirective._removeTransclude(rootEl.innerHTML),cellTemplContext={},templRoot,childElements,linkScope,i,curTempl,cleanCellTempl,style,ngClass;if(!wijmo.isNullOrWhiteSpace(template)){for(templRoot=document.createElement('div'),templRoot.innerHTML=template,childElements=[],[].forEach.call(templRoot.children,function(value){childElements.push(value)}),i=0;i<childElements.length;i++)curTempl=childElements[i],curTempl.tagName.toLocaleLowerCase()===WjFlexGridCellTemplate._tagName&&(linkScope||(linkScope=this.scope.$parent.$new()),templRoot.removeChild(curTempl),rootEl.appendChild(curTempl),this.directive._$compile(curTempl)(linkScope));cleanCellTempl=templRoot.innerHTML;wijmo.isNullOrWhiteSpace(cleanCellTempl)||(cellTemplContext.cellTemplate=cleanCellTempl)}style=this.tAttrs.ngStyle;ngClass=this.tAttrs.ngClass;style&&(cellTemplContext.cellStyle=style);ngClass&&(cellTemplContext.cellClass=ngClass);(cellTemplContext.cellTemplate||cellTemplContext.cellStyle||cellTemplContext.cellClass)&&(cellTemplContext.templLink=this,this[WjFlexGridColumn._cellCtxProp]=cellTemplContext);_super.prototype._link.call(this)},WjFlexGridColumnLink}(angular.WjLink),function(CellTemplateType){CellTemplateType[CellTemplateType.Cell=0]="Cell";CellTemplateType[CellTemplateType.CellEdit=1]="CellEdit";CellTemplateType[CellTemplateType.ColumnHeader=2]="ColumnHeader";CellTemplateType[CellTemplateType.RowHeader=3]="RowHeader";CellTemplateType[CellTemplateType.RowHeaderEdit=4]="RowHeaderEdit";CellTemplateType[CellTemplateType.TopLeft=5]="TopLeft";CellTemplateType[CellTemplateType.GroupHeader=6]="GroupHeader";CellTemplateType[CellTemplateType.Group=7]="Group";CellTemplateType[CellTemplateType.ColumnFooter=8]="ColumnFooter";CellTemplateType[CellTemplateType.BottomLeft=9]="BottomLeft"}(angular.CellTemplateType||(angular.CellTemplateType={}));var CellTemplateType=angular.CellTemplateType,WjFlexGridCellTemplate=function(_super){function WjFlexGridCellTemplate(){_super.call(this);this.require=['?^wjFlexGridColumn','?^wjFlexGrid'];this.terminal=!0;angular.WjDirective._dynaTemplates?(this.transclude=!1,this.priority=100,this.template=function(tElement,tAttrs){return tAttrs[WjFlexGridColumn._colTemplateProp]=tElement[0].innerHTML,'<div />'}):(this.transclude=!0,this.template='<div ng-transclude/>')}return __extends(WjFlexGridCellTemplate,_super),WjFlexGridCellTemplate._getTemplContextProp=function(templateType){return'$__cellTempl'+CellTemplateType[templateType]},WjFlexGridCellTemplate.prototype._initControl=function(){return{}},WjFlexGridCellTemplate.prototype._createLink=function(){return new WjFlexGridCellTemplateLink},WjFlexGridCellTemplate.prototype._getMetaDataId=function(){return'FlexGridCellTemplate'},WjFlexGridCellTemplate._tagName='wj-flex-grid-cell-template',WjFlexGridCellTemplate}(angular.WjDirective),WjFlexGridCellTemplateLink=function(_super){function WjFlexGridCellTemplateLink(){_super.apply(this,arguments)}return __extends(WjFlexGridCellTemplateLink,_super),WjFlexGridCellTemplateLink.prototype._initParent=function(){var cts,cellType,style,ngClass;if(_super.prototype._initParent.call(this),cts=this.scope.cellType,cts)cellType=CellTemplateType[cts];else return;var dynaTempl=this.tAttrs[WjFlexGridColumn._colTemplateProp],template=dynaTempl!=null?dynaTempl:angular.WjDirective._removeTransclude(this.tElement[0].innerHTML),control=this.control;wijmo.isNullOrWhiteSpace(template)||(control.cellTemplate=template);style=this.tAttrs.ngStyle;ngClass=this.tAttrs.ngClass;style&&(control.cellStyle=style);ngClass&&(control.cellClass=ngClass);(control.cellTemplate||control.cellStyle||control.cellClass)&&(control.templLink=this,this.parent.control[WjFlexGridCellTemplate._getTemplContextProp(cellType)]=control);WjFlexGridCellTemplateLink._invalidateGrid(this.parent.control)},WjFlexGridCellTemplateLink.prototype._destroy=function(){var parentControl=this.parent&&this.parent.control,cts=this.scope.cellType;_super.prototype._destroy.call(this);cts&&(parentControl[WjFlexGridCellTemplate._getTemplContextProp(CellTemplateType[cts])]=undefined,WjFlexGridCellTemplateLink._invalidateGrid(parentControl))},WjFlexGridCellTemplateLink._invalidateGrid=function(parentControl){var grid=parentControl;grid&&(grid instanceof wijmo.grid.Column&&(grid=grid.grid),grid&&grid.invalidate())},WjFlexGridCellTemplateLink}(angular.WjLink),WjFlexGridFilter=function(_super){function WjFlexGridFilter(){_super.call(this);this.require='^wjFlexGrid';this.template='<div />'}return __extends(WjFlexGridFilter,_super),Object.defineProperty(WjFlexGridFilter.prototype,"_controlConstructor",{get:function(){return wijmo.grid.filter.FlexGridFilter},enumerable:!0,configurable:!0}),WjFlexGridFilter}(angular.WjDirective),WjGroupPanel=function(_super){function WjGroupPanel(){_super.apply(this,arguments)}return __extends(WjGroupPanel,_super),Object.defineProperty(WjGroupPanel.prototype,"_controlConstructor",{get:function(){return wijmo.grid.grouppanel.GroupPanel},enumerable:!0,configurable:!0}),WjGroupPanel}(angular.WjDirective),WjFlexGridDetail=function(_super){function WjFlexGridDetail($compile){_super.call(this);this._$compile=$compile;this.require='^wjFlexGrid';this.terminal=!0;angular.WjDirective._dynaTemplates?(this.transclude=!1,this.priority=100,this.template=function(tElement,tAttrs){return tAttrs[WjFlexGridDetail._detailTemplateProp]=tElement[0].innerHTML,'<div />'}):(this.transclude=!0,this.template='<div ng-transclude/>')}return __extends(WjFlexGridDetail,_super),Object.defineProperty(WjFlexGridDetail.prototype,"_controlConstructor",{get:function(){return wijmo.grid.detail.FlexGridDetailProvider},enumerable:!0,configurable:!0}),WjFlexGridDetail.prototype._createLink=function(){return new WjFlexGridDetailLink},WjFlexGridDetail._detailTemplateProp='$__wjDetailTemplate',WjFlexGridDetail._detailScopeProp='$_detailScope',WjFlexGridDetail}(angular.WjDirective),WjFlexGridDetailLink=function(_super){function WjFlexGridDetailLink(){_super.apply(this,arguments)}return __extends(WjFlexGridDetailLink,_super),WjFlexGridDetailLink.prototype._initParent=function(){var tpl;_super.prototype._initParent.call(this);var self=this,dynaTempl=this.tAttrs[WjFlexGridDetail._detailTemplateProp],dp=this.control;this.itemTemplate=this._getCellTemplate(dynaTempl!=null?dynaTempl:angular.WjDirective._removeTransclude(this.tElement[0].innerHTML));tpl=this._getCellTemplate(this.itemTemplate);this._tmplLink=this.directive._$compile('<div>'+tpl+'</div>');dp.createDetailCell=function(row,col){var cellScope=self._getCellScope(self.scope.$parent,row,col),clonedElement=self._tmplLink(cellScope,function(){})[0];return dp.grid.hostElement.appendChild(clonedElement),cellScope.$root.$$phase||cellScope.$apply(),clonedElement.parentElement.removeChild(clonedElement),clonedElement};dp.disposeDetailCell=function(row){row.detail&&window.angular.element(row.detail).scope().$destroy()};this.parent._isInitialized&&this.control&&this.control.invalidate()},WjFlexGridDetailLink.prototype._destroy=function(){var ownerControl=this.parent&&this.parent.control,dp=this.control;dp.createDetailCell=null;dp.disposeDetailCell=null;_super.prototype._destroy.call(this);this._tmplLink=null;ownerControl&&ownerControl.invalidate()},WjFlexGridDetailLink.prototype._getCellScope=function(parentScope,row,col){var ret=parentScope.$new();return ret.$row=row,ret.$col=col,ret.$item=row.dataItem,ret},WjFlexGridDetailLink.prototype._getCellTemplate=function(tpl){return tpl&&(tpl=tpl.replace(/ng\-style/g,'style'),tpl=tpl.replace(/ class\=\"ng\-scope\"( \"ng\-binding\")?/g,''),tpl=tpl.replace(/<span>\s*<\/span>/g,'')),tpl},WjFlexGridDetailLink}(angular.WjLink),WjFlexSheet=function(_super){function WjFlexSheet($compile,$interpolate){_super.call(this,$compile,$interpolate)}return __extends(WjFlexSheet,_super),Object.defineProperty(WjFlexSheet.prototype,"_controlConstructor",{get:function(){return wijmo.grid.sheet.FlexSheet},enumerable:!0,configurable:!0}),WjFlexSheet}(WjFlexGrid),WjSheet=function(_super){function WjSheet(){_super.call(this);this.require='^wjFlexSheet'}return __extends(WjSheet,_super),Object.defineProperty(WjSheet.prototype,"_controlConstructor",{get:function(){return wijmo.grid.sheet.Sheet},enumerable:!0,configurable:!0}),WjSheet.prototype._createLink=function(){return new WjSheetLink},WjSheet}(angular.WjDirective),WjSheetLink=function(_super){function WjSheetLink(){_super.apply(this,arguments)}return __extends(WjSheetLink,_super),WjSheetLink.prototype._initControl=function(){var sheet=_super.prototype._initControl.call(this),scope=this.scope,flexSheet=this.parent.control;return sheet.name=scope.name,scope.itemsSource?sheet.itemsSource=scope.itemsSource:(sheet.rowCount=+scope.rowCount,sheet.columnCount=+scope.columnCount),flexSheet.sheets.push(sheet),sheet.selectionRanges.push(flexSheet.selection),sheet},WjSheetLink}(angular.WjLink),WjMultiRow=function(_super){function WjMultiRow($compile,$interpolate){_super.call(this,$compile,$interpolate)}return __extends(WjMultiRow,_super),Object.defineProperty(WjMultiRow.prototype,"_controlConstructor",{get:function(){return wijmo.grid.multirow.MultiRow},enumerable:!0,configurable:!0}),WjMultiRow}(WjFlexGrid)})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoOlap=window.angular.module('wj.olap',['wj.grid','wj.chart']),WjPivotGrid,WjPivotChart,WjPivotPanel;wijmo.olap&&wijmo.olap.PivotGrid&&(wijmoOlap.directive('wjPivotGrid',['$compile','$interpolate',function($compile,$interpolate){return new WjPivotGrid($compile,$interpolate)}]),wijmoOlap.directive('wjPivotChart',[function(){return new WjPivotChart}]),wijmoOlap.directive('wjPivotPanel',[function(){return new WjPivotPanel}]));WjPivotGrid=function(_super){function WjPivotGrid($compile,$interpolate){_super.call(this,$compile,$interpolate)}return __extends(WjPivotGrid,_super),Object.defineProperty(WjPivotGrid.prototype,"_controlConstructor",{get:function(){return wijmo.olap.PivotGrid},enumerable:!0,configurable:!0}),WjPivotGrid}(angular.WjFlexGrid);angular.WjPivotGrid=WjPivotGrid;WjPivotChart=function(_super){function WjPivotChart(){_super.apply(this,arguments)}return __extends(WjPivotChart,_super),Object.defineProperty(WjPivotChart.prototype,"_controlConstructor",{get:function(){return wijmo.olap.PivotChart},enumerable:!0,configurable:!0}),WjPivotChart}(angular.WjDirective);angular.WjPivotChart=WjPivotChart;WjPivotPanel=function(_super){function WjPivotPanel(){_super.call(this);this.transclude=!0;this.template='<div ng-transclude />'}return __extends(WjPivotPanel,_super),Object.defineProperty(WjPivotPanel.prototype,"_controlConstructor",{get:function(){return wijmo.olap.PivotPanel},enumerable:!0,configurable:!0}),WjPivotPanel}(angular.WjDirective);angular.WjPivotPanel=WjPivotPanel})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}));__extends=this&&this.__extends||function(d,b){function __(){this.constructor=d}for(var p in b)b.hasOwnProperty(p)&&(d[p]=b[p]);d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __)},function(wijmo){var angular;(function(angular){var wijmoViewer=window.angular.module('wj.viewer',[]);wijmo.viewer&&wijmo.viewer.ReportViewer&&wijmoViewer.directive('wjReportViewer',[function(){return new WjReportViewer}]);wijmo.viewer&&wijmo.viewer.PdfViewer&&wijmoViewer.directive('wjPdfViewer',[function(){return new WjPdfViewer}]);var WjViewerBase=function(_super){function WjViewerBase(){_super.call(this);this.template='<div ng-transclude />';this.transclude=!0}return __extends(WjViewerBase,_super),Object.defineProperty(WjViewerBase.prototype,"_controlConstructor",{get:function(){return wijmo.viewer.ViewerBase},enumerable:!0,configurable:!0}),WjViewerBase}(angular.WjDirective),WjReportViewer=function(_super){function WjReportViewer(){_super.call(this)}return __extends(WjReportViewer,_super),Object.defineProperty(WjReportViewer.prototype,"_controlConstructor",{get:function(){return wijmo.viewer.ReportViewer},enumerable:!0,configurable:!0}),WjReportViewer}(WjViewerBase),WjPdfViewer=function(_super){function WjPdfViewer(){_super.call(this)}return __extends(WjPdfViewer,_super),Object.defineProperty(WjPdfViewer.prototype,"_controlConstructor",{get:function(){return wijmo.viewer.PdfViewer},enumerable:!0,configurable:!0}),WjPdfViewer}(WjViewerBase)})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={})),function(wijmo){var angular;(function(){var wijModule=window.angular.module('wj',['wj.input','wj.grid','wj.chart','wj.container','wj.gauge','wj.olap','wj.viewer'])})(angular=wijmo.angular||(wijmo.angular={}))}(wijmo||(wijmo={}))