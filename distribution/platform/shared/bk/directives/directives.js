//Body
(function () {
    angular.module('SMART2').directive('body', function () {
        return {
            restrict: 'E',
            link: function postLink(scope, elem, attrs) {
                function _wheelDelta(a) {
                    if (a.originalEvent.wheelDelta == undefined) {
                        return a.originalEvent.deltaY;
                    } else {
                        return -a.originalEvent.wheelDelta;
                    }
                }
                IEscroll = function (event) {
                    if ($(event.target).closest(".dropdown-content").length == 0 && $(event.target).closest("smart-scroll").length == 0 && $(event.target).closest(".scroll-inner-wrapp").length == 0) {
                        var dy = _wheelDelta(event);
                        if ($("body").css("overflow") == "hidden") {
                            return;
                        };
                        var evDelta = function () {
                            if (dy < 0) {
                                return dy < -90 ? 60 : 40;
                            } else {
                                return dy > 90 ? 60 : 40;
                            }
                        }();
                        event.preventDefault();
                        var wheelDelta = dy < 0 ? dy - evDelta : dy + evDelta;
                        var currentScrollPosition = window.pageYOffset;
                        $(this).scrollTop(currentScrollPosition + wheelDelta);
                        
                    }
                }

                //function IEscrollfn() {
                //    if (attrs.customWheelForie == "true") {
                //        $('html,body').bind("mousewheel", IEscroll);
                //    } else {
                //        $('html,body').unbind("mousewheel", IEscroll);
                //    }
                //};

                if (navigator.appName == 'Microsoft Internet Explorer' || !!(navigator.userAgent.match(/Trident/) || navigator.userAgent.match(/rv:11/)) || (typeof $.browser !== "undefined" && $.browser.msie == 1)) {
                    $('html,body').bind("mousewheel", IEscroll);

                    //attrs.$observe("customWheelForie", function () {
                    //    IEscrollfn();
                    //});
                };
            }
        }
    });
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('ckEditor', ['APPCONSTANTS', function (APPCONSTANTS) {
        return {
            require: '?ngModel',
            link: function (scope, elm, attr, ngModel) {
                var lang = "en";
                if (APPCONSTANTS.userPreferences.UserBasicDetails.Culture) {
                    lang = APPCONSTANTS.userPreferences.UserBasicDetails.Culture;
                }
                var ckeditor = CKEDITOR.replace(
					elm[0],
					{
					    "toolbar": "Basic",
					    "language": lang
					}
				);
                if (!ngModel)
                    return;

                var updateModel = false;
                ckeditor.on('instanceReady', function () {
                    ckeditor.setData(ngModel.$viewValue);
                });

                function update() {
                    if (updateModel) {
                        ngModel.$setViewValue(ckeditor.getData());
                    }
                };

                ngModel.$render = function (value) {
                    ckeditor.setData(ngModel.$viewValue);
                };

                ckeditor.on('change', update);
                ckeditor.on('focus', function (event) {
                    updateModel = true;
                });

                scope.$on('$destroy', function () {
                	ckeditor.removeAllListeners();
                	CKEDITOR.remove(ckeditor);
                });
            }
        };
    }]);
})();
(function () {
	'use strict';

	angular.module('SMART2').directive('colorPicker', ['$parse', '$timeout', function ($parse, $timeout) {
		return {
			restrict: 'E',
			replace: true,
			transclude: true,
			scope: {
				onSelect: '&'
			},
			link: function (scope, element, attrs) {

				var $colorPicker = $(element).find('.colorPicker');
				$colorPicker.on("change.color", function (event, color) {
					if (color) {
						scope.$apply(function () {
							scope.onSelect({
								$event: { color: color }
							});
						});
					}
				});

				$colorPicker.colorpicker({
					showOn: "button",
					history: false
				});

				$(element).bind('click', function (e) {
					e.stopImmediatePropagation();
					$(this).find(".colorPicker").colorpicker("showPalette");
				});

				attrs.$observe('color', function (value) {
					$colorPicker.colorpicker('val', value);
				});
			},
			templateUrl: 'shared/directives/colorPicker/colorPickerTemplate.html'
		};
	}]);
})();
angular.module('SMART2')
.directive("sidenav", [sideNavFunc])
.directive("tabs", [tabsFunc])
.directive("dropdown", ["$compile", "$timeout", dropdownFunc])
.directive('inputDate', ["$compile", "$timeout", inputDateFunc])
.directive("modal", ["$compile", "$timeout", modal])
.directive("slideToggle", [slideToggleFunc])
.directive("collapsible", [collapsibleFunc]);

/*side nav*/
function sideNavFunc() {
    return {
        scope: {
            menuwidth: "@",
            closeonclick: "@"
        },
        link: function (scope, element, attrs) {
            
            element.sideNav({
                menuWidth: (angular.isDefined(scope.menuwidth)) ? scope.menuwidth : undefined,
                edge: attrs.sidenav ? attrs.sidenav : "left",
                closeOnClick: (angular.isDefined(scope.closeonclick)) ? scope.closeonclick == "true" : undefined
            });
        }
    };
}
/*tabs*/
function tabsFunc() {
    return {
        link: function (scope, element, attrs) {
            element.tabs();
            
        }
    };
}

function dropdownFunc($compile, $timeout) {
    return {
        scope: {
            inDuration: "@",
            outDuration: "@",
            constrainWidth: "@",
            hover: "@",
            alignment: "@",
            gutter: "@",
            belowOrigin: "@"
        },
        link: function (scope, element, attrs) {
            var dropdownCode;
            $timeout(function () {
                $compile(element.contents())(scope);
                dropdownCode = element.attr("data-activates");
                element.dropdown({
                    inDuration: (angular.isDefined(scope.inDuration)) ? scope.inDuration : undefined,
                    outDuration: (angular.isDefined(scope.outDuration)) ? scope.outDuration : undefined,
                    constrain_width: (angular.isDefined(scope.constrainWidth)) ? scope.constrainWidth : undefined,
                    hover: (angular.isDefined(scope.hover)) ? scope.hover : undefined,
                    alignment: (angular.isDefined(scope.alignment)) ? scope.alignment : undefined,
                    gutter: (angular.isDefined(scope.gutter)) ? scope.gutter : undefined,
                    belowOrigin: (angular.isDefined(scope.belowOrigin)) ? scope.belowOrigin : undefined
                });
            });
            
            scope.$on('closeDropdown', function(e, obj){
                  if(obj.ddname===dropdownCode){
                    element.trigger("close");  
                  }
            });
        }
    };
};


function inputDateFunc($compile, $timeout) {
   
    var style = $('<style>#inputCreated_root {outline: none;}</style>');
    $('html > head').append(style);

    var dateFormat = function () {

        var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function (val, len) {
                val = String(val);
                len = len || 2;
                while (val.length < len) {
                    val = "0" + val;
                }
                return val;
            };

        return function (date, mask, utc) {

            var dF = dateFormat;

            if (arguments.length === 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }

                    
            date = date ? new Date(date) : new Date();
            if (isNaN(date)) throw SyntaxError("invalid date");

            mask = String(dF.masks[mask] || mask || dF.masks["default"]);

             
            if (mask.slice(0, 4) == "UTC:") {
                mask = mask.slice(4);
                utc = true;
            }

            var _ = utc ? "getUTC" : "get",
                d = date[_ + "Date"](),
                D = date[_ + "Day"](),
                m = date[_ + "Month"](),
                y = date[_ + "FullYear"](),
                H = date[_ + "Hours"](),
                M = date[_ + "Minutes"](),
                s = date[_ + "Seconds"](),
                L = date[_ + "Milliseconds"](),
                o = utc ? 0 : date.getTimezoneOffset(),
                flags = {
                    d: d,
                    dd: pad(d),
                    ddd: dF.i18n.dayNames[D],
                    dddd: dF.i18n.dayNames[D + 7],
                    m: m + 1,
                    mm: pad(m + 1),
                    mmm: dF.i18n.monthNames[m],
                    mmmm: dF.i18n.monthNames[m + 12],
                    yy: String(y).slice(2),
                    yyyy: y,
                    h: H % 12 || 12,
                    hh: pad(H % 12 || 12),
                    H: H,
                    HH: pad(H),
                    M: M,
                    MM: pad(M),
                    s: s,
                    ss: pad(s),
                    l: pad(L, 3),
                    L: pad(L > 99 ? Math.round(L / 10) : L),
                    t: H < 12 ? "a" : "p",
                    tt: H < 12 ? "am" : "pm",
                    T: H < 12 ? "A" : "P",
                    TT: H < 12 ? "AM" : "PM",
                    Z: utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                    o: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                    S: ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
                };

            return mask.replace(token, function ($0) {
                return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
            });
        };
    }();


    dateFormat.masks = {
        "default": "ddd mmm dd yyyy HH:MM:ss",
        shortDate: "m/d/yy",
        mediumDate: "mmm d, yyyy",
        longDate: "mmmm d, yyyy",
        fullDate: "dddd, mmmm d, yyyy",
        shortTime: "h:MM TT",
        mediumTime: "h:MM:ss TT",
        longTime: "h:MM:ss TT Z",
        isoDate: "yyyy-mm-dd",
        isoTime: "HH:MM:ss",
        isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
        isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
    };

        
    dateFormat.i18n = {
        dayNames: [
            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
            "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
        ],
        monthNames: [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
            "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
        ]
    };

       
    Date.prototype.format = function (mask, utc) {
        return dateFormat(this, mask, utc);
    };

       
    var isValidDate = function (date) {
        if (Object.prototype.toString.call(date) === '[object Date]') {
            return !isNaN(date.getTime());
        }
        return false;
    };

    return {
        require: 'ngModel',
        scope: {
            container: "@",
            format: "@",
            formatSubmit: "@",
            monthsFull: "@",
            monthsShort: "@",
            weekdaysFull: "@",
            weekdaysLetter: "@",
            firstDay: "=",
            disable: "=",
            today: "=",
            clear: "=",
            close: "=",
            selectYears: "=",
            onStart: "&",
            onRender: "&",
            onOpen: "&",
            onClose: "&",
            onSet: "&",
            onStop: "&",
            ngReadonly: "=?",
            max: "@",
            min: "@"
        },
        link: function (scope, element, attrs, ngModelCtrl) {

            ngModelCtrl.$formatters.unshift(function (modelValue) {
                if (modelValue) {
                    var date = new Date(modelValue);
                    return (angular.isDefined(scope.format)) ? date.format(scope.format) : date.format('d mmmm, yyyy');
        }
                return null;
            });

            var monthsFull = (angular.isDefined(scope.monthsFull)) ? scope.$eval(scope.monthsFull) : undefined,
                monthsShort = (angular.isDefined(scope.monthsShort)) ? scope.$eval(scope.monthsShort) : undefined,
                weekdaysFull = (angular.isDefined(scope.weekdaysFull)) ? scope.$eval(scope.weekdaysFull) : undefined,
                weekdaysLetter = (angular.isDefined(scope.weekdaysLetter)) ? scope.$eval(scope.weekdaysLetter) : undefined;


            $compile(element.contents())(scope);
            if (!(scope.ngReadonly)) {
                $timeout(function () {
                    var pickadateInput = element.pickadate({
                        container: (angular.isDefined(scope.container)) ? scope.container : 'body',
                        format: (angular.isDefined(scope.format)) ? scope.format : undefined,
                        formatSubmit: (angular.isDefined(scope.formatSubmit)) ? scope.formatSubmit : undefined,
                        monthsFull: (angular.isDefined(monthsFull)) ? monthsFull : undefined,
                        monthsShort: (angular.isDefined(monthsShort)) ? monthsShort : undefined,
                        weekdaysFull: (angular.isDefined(weekdaysFull)) ? weekdaysFull : undefined,
                        weekdaysLetter: (angular.isDefined(weekdaysLetter)) ? weekdaysLetter : undefined,
                        firstDay: (angular.isDefined(scope.firstDay)) ? scope.firstDay : 0,
                        disable: (angular.isDefined(scope.disable)) ? scope.disable : undefined,
                        today: (angular.isDefined(scope.today)) ? scope.today : undefined,
                        clear: (angular.isDefined(scope.clear)) ? scope.clear : undefined,
                        close: (angular.isDefined(scope.close)) ? scope.close : undefined,
                        selectYears: (angular.isDefined(scope.selectYears)) ? scope.selectYears : undefined,
                        onStart: (angular.isDefined(scope.onStart)) ? function () { scope.onStart(); } : undefined,
                        onRender: (angular.isDefined(scope.onRender)) ? function () { scope.onRender(); } : undefined,
                        onOpen: (angular.isDefined(scope.onOpen)) ? function () { scope.onOpen(); } : undefined,
                        onClose: (angular.isDefined(scope.onClose)) ? function () { scope.onClose(); } : undefined,
                        onSet: (angular.isDefined(scope.onSet)) ? function () { scope.onSet(); } : undefined,
                        onStop: (angular.isDefined(scope.onStop)) ? function () { scope.onStop(); } : undefined
                    });
                 
                    var picker = pickadateInput.pickadate('picker');

            
                    scope.$watch('max', function (newMax) {
                        if (picker) {
                            var maxDate = new Date(newMax);
                            picker.set({ max: isValidDate(maxDate) ? maxDate : false });
                        }
                    });
                    scope.$watch('min', function (newMin) {
                        if (picker) {
                            var minDate = new Date(newMin);
                            picker.set({ min: isValidDate(minDate) ? minDate : false });
                        }
                    });
                });
            }
        }
    };
};
/*modal*/
var modalCounter = 0;


function modal($compile, $timeout) {
    return {
        restrict: 'E',
        scope: {},
        link: function (scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl;
            scope.title = attrs.title;
            modalCounter = modalCounter + 1;
            scope.modalCounter = modalCounter;

            setTimeout(function () {
                angular.element('#modalButton' + modalCounter).leanModal();
            });
        },
        template: '<div><a id="modalButton{{modalCounter}}" class="waves-effect waves-light btn modal-trigger" href="#modal{{modalCounter}}" modal>{{title}}</a><div id="modal{{modalCounter}}" class="modal modal-sm" ng-include="templateUrl"></div>'
    };
}

function slideToggleFunc() {
    return {
        restrict: 'A',
        scope: {},
        controller: function ($scope) { },
        link: function (scope, element, attr) {
            element.bind('click', function () {
                var $slideBox = angular.element(attr.slideToggle);
                var slideDuration = parseInt(attr.slideToggleDuration, 10) || 200;
                $slideBox.stop().slideToggle(slideDuration);
            });
        }
    };
}

/*tabs*/
function collapsibleFunc() {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            element.collapsible();
        }
    };
}
(function () {
    'use strict';
    angular.module('SMART2').factory('notification', [function () {
        var Obj = {};
        Obj.show = false;
        Obj.onCallback = undefined;

        Obj.on = function (callback) {
            Obj.onCallback = callback;
        };

        Obj.notify = function (config, callback) {
            this.show = true;
            this.config = config;
            this.broadcastItem();
            this.resultCallBack = function (result) {
                if (typeof (callback) == 'function') {
                    setTimeout(function () {
                        callback(result);
                    });
                }
            };
        };

        Obj.broadcastItem = function () {
            angular.isFunction(Obj.onCallback) && Obj.onCallback();
        };

        return Obj;
    }]);

    angular.module('SMART2').directive('smartNotification', ['$rootScope', 'notification', '$translate', '$sce', '$timeout', '$focusOnField', 'browserSniffing', function ($rootScope, notification, $translate, $sce, $timeout, $focusOnField, browserSniffing) {
        return {
            restrict: 'EA',
            replace: true,
            scope: {
                showN: "@"
            },
            link: function (scope, element, attrs) {
                var topPositionBeforeModalOpen = 0;
                scope.isChrome = (navigator.userAgent.indexOf("Chrome") != -1) ? "remindMeOption" : "";
                /*
                 *  Unbind window keyup listener and assign tabindex back to .picker elements
                 */
                var reset = function () {
                    $(window).off('keyup', onWindowKeyUp);
                    angular.element('.picker').attr("tabindex", 0);
                    angular.element(document).scrollTop(topPositionBeforeModalOpen);
                };

                /*
                 *  window on key up event listener
                 */
                var onWindowKeyUp = function (e) {
                    if (angular.element(e.target).closest('.modal').length == 0 && e.keyCode == 9) {
                        angular.element(element.find(':focusable')[0]).focus();
                    }
                };

                /*
                 *  hide notification pop up when route changed
                 */

                scope.$on('$stateChangeSuccess', function () {
                    if (scope.showN && !(scope.config.type == "unsupportedBrowserVersion" || scope.config.type == "unsupportedBrowser")) {
                        scope.showN = false;
                        cleanUpNotificationPopup();
                    }
                });

                /*
                 *  On notification listener
                 */
                scope.dismissible = true;
                notification.on(function () {
                    scope.dismissible = angular.isDefined(notification.config.dismissible) ? notification.config.dismissible : true;
                    scope.config = notification.config;
                    scope.buttons = scope.config.buttons;
                    switch (scope.config.type) {
                        case "success":
                            scope.notifyClass = 'notify-success';
                            scope.title = $translate.instant("notificationSuccessMsg");
                            scope.icon = "#icon_CircleCheck";
                            break;
                        case "error":
                            scope.notifyClass = 'notify-error';
                            scope.title = $translate.instant("notificationErrorMsg");
                            scope.icon = "#icon_Exclamation";
                            break;
                        case "warning":
                            scope.notifyClass = 'notify-warning';
                            scope.icon = "#icon_Warning";
                            scope.title = $translate.instant("notificationWarningMsg");
                            break;
                        case "confirm":
                            scope.notifyClass = 'notify-confirm';
                            scope.icon = "#icon_Help";
                            scope.title = $translate.instant("notificationConfirmationMsg");
                            break;
                        case "inform":
                            scope.notifyClass = 'notify-information';
                            scope.icon = "#icon_Info";
                            scope.title = $translate.instant("notificationInformationMsg");
                            break;
                        case "sessionTimeOut":
                            scope.notifyClass = 'notify-session-timeout';
                            scope.icon = "#icon_AlertTimer";
                            scope.title = $translate.instant("notificationSessionTimeOut");
                            scope.dismissible = false;
                            break;
                        case "sessionExpire":
                            scope.notifyClass = 'notify-session-expire';
                            scope.icon = "#icon_AlertTimer";
                            scope.title = $translate.instant("notificationSessionExpiredMsg");
                            scope.dismissible = false;
                            break;
                        case "unsupportedBrowserVersion":
                            scope.notifyClass = "notify-unsupported-browser-version";
                            scope.titleTextColor = "browser-version-header-text";
                            scope.title = $translate.instant("notificationUnsupportedBrowserVersionMsg");
                            break;
                        case "unsupportedBrowser":
                            scope.notifyClass = "notify-unsupported-browser";
                            scope.titleTextColor = "browser-unsupported-header-text";
                            scope.title = $translate.instant("notificationUnsupportedBrowserMsg");
                    };

                    scope.onChange = function (remindMeDate) {
                        scope.showN = false;
                        scope.$digest();
                    };


                    //scope.dismissible = (typeof notification.config.dismissible != "undefined")?(notification.config.dismissible) ? true : false : scope.dismissible;
                    scope.message = $sce.trustAsHtml(scope.config.message);
                    scope.checkboxText = scope.config.checkMessage;
                    scope.customTemplate = false;
                    if (typeof scope.config["isMultipleCheck"] != "undefined" && scope.config["isMultipleCheck"]) {
                        scope.customTemplate = true;
                        if (typeof scope.config.modalType == "undefined") {
                            scope.config.modalType = "small"
                        }
                        for (var i in scope.config.multipleCheckList) {
                            scope.config.multipleCheckList[i].model = {};
                            scope.config.multipleCheckList[i].model.modelName = scope.config.multipleCheckList[i]["checkContext"];
                            switch (scope.config.multipleCheckList[i].type) {
                                case "check":
                                    scope.config.multipleCheckList[i].model.isCheck = false;
                                    break;
                                case "radio":
                                    scope.config.multipleCheckList[i].model.isCheck = {
                                        "title": ""
                                    };
                                case "select":
                                    if (typeof scope.config.multipleCheckList[i].preSelected != "undefined") {
                                        scope.config.multipleCheckList[i].model.isCheck = scope.config.multipleCheckList[i].preSelected;
                                    } else {
                                        scope.config.multipleCheckList[i].model.isCheck = {
                                            "title": ""
                                        };
                                    }
                                    break;
                            }
                            if (typeof scope.config.multipleCheckList[i]["header"] != "undefined" && typeof scope.config.multipleCheckList[i]["header"] == "string") {
                                scope.config.multipleCheckList[i]["header"] = $sce.trustAsHtml(scope.config.multipleCheckList[i]["header"]);
                            }
                            if (typeof scope.config.multipleCheckList[i]["label"] == "string") {
                                scope.config.multipleCheckList[i]["label"] = $sce.trustAsHtml(scope.config.multipleCheckList[i]["label"]);
                            }
                        }
                        for (var i in scope.config.buttons) {
                            if (typeof scope.config.buttons[i].disableBtn != "undefined") {
                                scope.config.buttons[i].disableBtn = true;
                            }
                        }
                    }
                    scope.isCheckSelect = false;
                    if (typeof scope.config.isCheckSelect != 'undefined') {
                        scope.isCheckSelect = scope.config.isCheckSelect;
                    }
                    scope.showN = notification.show;

                    angular.element('body').css('overflow', 'hidden');
                    $timeout(function () {
                        var $firstField = element.find(':focusable')[0];
                        $focusOnField($firstField);
                        $(window).on('keyup', onWindowKeyUp);
                        //  remove picker tabindex when popup to avoid focus on picker element
                        angular.element('.picker').removeAttr("tabindex");
                        scope.notifyClass = scope.notifyClass + ' notificationanimate--active';
                    }, 250);
                    topPositionBeforeModalOpen = angular.element(document).scrollTop();
                });

                scope.showN = false;
                scope.bindforTab = false;
                scope.overlayCLicked = function () {
                    if (scope.dismissible) {
                        //scope.showN = false;
                        //cleanUpNotificationPopup();
                    }
                }
                scope.$on('LastRepeaterElement', function () {
                    scope.bindforTab = true;
                });
                scope.onChangeNotification = function () {
                    var cnt = 0;
                    for (var i in scope.config.multipleCheckList) {
                        if (scope.config.multipleCheckList[i].model.isCheck) {
                            cnt++;
                        }
                    }
                    for (var i in scope.config.buttons) {
                        if (typeof scope.config.buttons[i].disableBtn != "undefined") {
                            if (cnt > 0) {
                                scope.config.buttons[i].disableBtn = false;
                            } else {
                                scope.config.buttons[i].disableBtn = true;
                            }
                        }
                    }

                }
                scope.clickCallbackFunction = function (e) {
                    $timeout(function () {
                        scope.showN = false;
                        scope.bindforTab = false;
                        var responceObj = {
                            "result": e
                        };
                        if (scope.customTemplate) {
                            for (var i in scope.config.multipleCheckList) {
                                responceObj[scope.config.multipleCheckList[i].model.modelName] = scope.config.multipleCheckList[i].model.isCheck
                            }
                        } else {
                            responceObj["isChecked"] = scope.isCheckSelect;
                        }
                        cleanUpNotificationPopup();
                        notification.resultCallBack(responceObj);
                        $rootScope.$broadcast("closedPopup");
                    });
                };
                function cleanUpNotificationPopup() { // empty 'scope.buttons' object to avoid getting display multiple notification buttons
                    scope.notifyClass = '';
                    scope.buttons = [];
                    angular.element('body').css('overflow', '');
                    angular.element('.notification-massage .modal-content').css('display', 'none');
                    angular.element('.notification-massage .modal-footer').css('display', 'none');
                }
                scope.$on('$destroy', function () {
                    reset();
                });
            },
            templateUrl: 'shared/directives/notification/notificationTemplate.html',
        }
    }]);
})();
(function() {
	'use strict';
	angular
    .module('SMART2')
    .directive('onCaptureClick', ['$parse', function ($parse) {
      return {
        restrict: 'A',
        compile: function(element, attrs) {
          var fn = $parse(attrs.onCaptureClick);
          return function(scope, element) {
            element[0].addEventListener('click', function(event) {
              scope.$apply(function() {
                fn(scope, {
                  $event: event
                });
              });
            }, true);
          };
        }
      }
    }]);
})(angular);
(function () {
    'use strict';
    angular.module('SMART2').directive('onLoad', ['$timeout', function ($timeout) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                onLoadCallback: '&',
            },
            link: function (scope, element, attrs) {
                (scope.onLoadCallback) ? scope.onLoadCallback = scope.$eval(scope.onLoadCallback) : null;
                if (angular.isFunction(scope.onLoadCallback)) {
                    $timeout(function () {
                        scope.onLoadCallback();
                    }, 0);
                }
            }
        };
    }]);
})();

    (function() {
    	'use strict';        
    	angular.module('SMART2').directive('profilePic', ['notification', '$translate', function (notification, $translate) {
    return {
        restrict: 'E',
        replace: true,
        scope: {
        },
        link: function (scope, element, attrs) {
            scope.isProfilePicEditable = false;
            scope.isUserProfile = false;
            if (attrs.circular == 'true') {
                scope.isUserProfile = true;
            }
            if (attrs.editable == 'true') {
                scope.isProfilePicEditable = true;
            }
            scope.dummyimg = false;
            if (attrs.dummyimg == 'true') {
                scope.dummyimg = true;
            }
     
            //var imgsrc = typeof attrs.imgsrc === 'undefined' ? 'shared/resources/images/dummyImage.jpg' : attrs.imgsrc;
            //var imgsrc = typeof attrs.imgsrc === 'undefined' ? scope.dummyimg = true : scope.dummyimg = false;
            //var dummySrc = typeof attrs.dummysrc === 'undefined' ? 'shared/resources/images/user_default_BIG.PNG' : attrs.dummysrc;
            //scope.dummyimg = typeof attrs.dummyimg === 'undefined' ? false : attrs.dummyimg;
            //scope.imgsrc = !JSON.parse(scope.dummyimg) ? imgsrc : dummyimg;
            //debugger;
            if (scope.isUserProfile == true) {
                if (!scope.dummyimg) {
                    scope.imgsrc = 'shared/resources/images/dummyImage.jpg';
                    //scope.imgsrc = !JSON.parse(scope.dummyimg) ? imgsrc : dummyimg;
                }
            }
            else {
                if (!scope.dummyimg) {
                    scope.imgsrc = 'shared/resources/images/kelloggs_logo.png';
                }
            }
            var readURL = function (input) {
                if (input.files && input.files[0]) {
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        angular.element('.user-profile').addClass('is-profile-pic');
                        scope.dummyimg = false;
                        scope.imgsrc = e.target.result;
                        scope.$apply();
                    }
                    reader.readAsDataURL(input.files[0]);
                }
            }

            element.find("#callFileFOrProfile").on('change', function () {
                readURL(this);
            });

            scope.profilePicEdit = function () {
               element.find("#callFileFOrProfile").get(0).click();
            }

            //var imgsrc = typeof attrs.imgsrc === 'undefined' ? 'shared/resources/images/dummyImage.jpg' : attrs.imgsrc;
            // var imgsrc = typeof attrs.imgsrc === 'undefined' ? scope.dummyimg = true : scope.dummyimg = false;
            //var dummySrc = typeof attrs.dummysrc === 'undefined' ? 'shared/resources/images/user_default_BIG.PNG' : attrs.dummysrc;
            //scope.dummyimg = typeof attrs.dummyimg === 'undefined' ? false : attrs.dummyimg;
            //scope.imgsrc = !JSON.parse(scope.dummyimg) ? imgsrc : dummyimg;
            // scope.isDeleted = false;

            scope.clearProfilePicEdit = function () {
            	var confi = {
            		type: "confirm",
            		message: "<p class='left-align'>" + $translate.instant("confirmationMsg") + "</p>",
            		//checkMessage: "Do not show again.",
            		buttons: [
		    			{
		    			    "title": $translate.instant("notificationButtonYes"),
		    				"result": "yes"
		    			},
		    			{
		    			    "title": $translate.instant("cancelBtn"),
		    				"result": "no"
		    			}
            		]
            	};
            	notification.notify(confi, function (responce) {
            		if (responce.result == "yes") {
            			angular.element('.overL').prev().toggleClass('changeImage');
            			

            			//if (angular.element('.overL').prev().hasClass("changeImage") == true) {
            			//    scope.imgsrc = imgsrc;
            				
            			//	//scope.isDeleted = true;
            			//}
            			if (angular.element('.user-profile img').hasClass("changeImage")) {
            			    scope.imgsrc = false;
            			   element.find("#callFileFOrProfile").val('');
            			    scope.dummyimg = true;
            			    //scope.isDeleted = true;
            			    if (scope.isUserProfile == true) {            			       
            			        scope.imgsrc = 'shared/resources/images/user_default_BIG.PNG';
            			        angular.element('.user-profile').removeClass('is-profile-pic');
            			            //scope.imgsrc = !JSON.parse(scope.dummyimg) ? imgsrc : dummyimg;            			        
            			    }
            			}
            			else {
            				scope.imgsrc = dummySrc;
            				scope.isDeleted = false;
            				angular.element('.user-profile').addClass('is-profile-pic');
            				//console.log(isDeleted)
            			}
            		} else {
            			return;
            		}
            	});
            }
        },
        templateUrl: 'shared/components/directives/profilePic/profilePic.html'
    };
}]);
    })();
angular.module('SMART2').directive('progressMeter', ['$timeout', function ($timeout) {
	return {
		restrict: 'EA',
		replace: true,
		scope: {
			percent: "=?"
		},
		link: function (scope, element, attrs) {

			var unbindPercent = scope.$watch('percent', function (newVal, oldVal) {
				//if (newVal) {
					getMeter();
				//}
			});

			function getMeter() {
				scope.value = parseInt(scope.percent);
				if (scope.value) {
					scope.c = Math.PI * (25 * 2);
					scope.pct = 156;
					if (scope.value < 0)
						scope.value = 0;
					if (scope.value > 100)
						scope.value = 100;
					$timeout(function () {
						scope.pct = ((100 - scope.value) / 100) * scope.c;
						scope.strokeStyle = { "stroke-dashoffset": scope.pct }
					}, 500);
				}
			}

			scope.$on('$destroy', function () {
				unbindPercent();
			});
		},
		templateUrl: 'shared/directives/progressMeter/progressMeterTemplate.html'
	}
}]);
//div resizer
angular.module('SMART2').directive('isResizable', function () {
    return {
        restrict: 'A',
        scope: {
            'handle': '@',
            'onresize': '&',
            'onstart': '&',
            'onstop': '&'
        },
        link: function postLink(scope, elem, attrs) {
            elem.resizable({
                handles: scope.handle,
                resize: function (event, ui) {
                    scope.onresize({ event: event, ui: ui })
                },
                start: function (event, ui) {
                    scope.onstart({ event: event, ui: ui });
                }
                 ,
                stop: function (event, ui) {

                    scope.onstop({ event: event, ui: ui });
                }
            });

            if (attrs.maxheight != undefined) {
                attrs.$observe('maxheight', function () {
                    elem.resizable("option", "maxHeight", attrs.maxheight);
                });
            }
            if (attrs.minheight != undefined) {
                attrs.$observe('minheight', function () {
                    elem.resizable("option", "minHeight", attrs.minheight);
                });

            }
            if (attrs.maxwidth != undefined) {
                attrs.$observe('maxwidth', function () {
                    elem.resizable("option", "maxWidth", attrs.maxwidth);
                });
            }
            if (attrs.minwidth != undefined) {
                attrs.$observe('minwidth', function () {
                    elem.resizable("option", "minWidth", attrs.minwidth);
                });

            }
            if (attrs.alsoResizeRevert != undefined) {
                elem.resizable("option", "alsoResizeReverse", attrs.alsoResizeRevert);
            }
            if (attrs.alsoResize != undefined) {
                elem.resizable("option", "alsoResize", attrs.alsoResizeRevert);
            }
        }
    }
});

//window resizer
angular.module('SMART2').directive('smartWindowResizer', ['$window', function ($window) {
    return {
        restrict: 'AE',
        replace:false,
        scope: {
            'pageHeight': '@'
        },
        link: function postLink(scope, elem, attrs) {
            
            scope.pageHeight = ($window.innerHeight - 114) + 'px';
            elem.css('height', scope.pageHeight);

            angular.element($window).bind('resize', function (e) {
                if (scope.fixedSubHeader) {
                    scope.pageHeight = ($window.innerHeight - 50) + 'px';
                }
                else {
                    scope.pageHeight = ($window.innerHeight - 114) + 'px';
                }

                scope.$apply();
                console.log(scope.pageHeight);
                elem.css('height', scope.pageHeight);
            });

        }
    };
}]);
angular.module('SMART2').directive('scrollContent', ['$window', '$filter', '$rootScope', 'scrollPosition', function ($window, $filter, $rootScope, scrollPosition) {
	return {
		restrict: 'A',
		scope: true,
		link: function ($scope, elem, $attrs) {
			$rootScope.$on('$locationChangeSuccess', function() {
				if (scrollPosition.getEnableScroll() == true) {
					var foundItem = $filter('filter')(scrollPosition.get(), { 'currentUrl': $window.location.hash }, true)[0];
					if(foundItem)
						scrollPosition.performScroll(scrollPosition.get()[scrollPosition.get().indexOf(foundItem)].scroll, 500);
				}
			});
			angular.element($window).bind('scroll', function (e) {
				var windowScrollTop = this.scrollY || this.pageYOffset;
				if (windowScrollTop > 0)
				scrollPosition.set(windowScrollTop, $window.location.hash);
			});
		}
	};
}]);
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Sliding-menu
   * @description This directive is useful for creating a sliding menu.
   * 
   * @attr {Number} right
   *    Menu's right position
   * @attr {Number} top
   *    Menu's top position
   * @attr {Boolean} show
   *    Sliding menu will toggle as soon as value of this attribute changes
   * @attr {Boolean} modify-parent-style
   *    This attribute is useful when parent does not need to animated. For e.g. Default behaviour is when 'show' is set to true, 
   *    parent element gets resized depending upon the width of sliding-menu.
   * @attr {Boolean} detach-default-class
   *    If this attribute is set to true, default class will not be applied to directive's template
   * @attr {String} include-template
   *    Template to be used
   * @attr {Object} tabData
   *    used for two-way communication based on this property
   *
   * @example
   Usage:
   <smart-sliding-menu>
        //  Contents will go here
   </smart-sliding-menu>
   */

(function () {
    'use strict';
    angular.module('SMART2').directive('smartSlidingMenu', ['RuleEngine', '$timeout', '$compile', '$translate', '$rootScope', function (RuleEngine, $timeout, $compile, $translate, $rootScope) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            scope: {
                right: '@',
                top: '@',
                show: '=',
                detachDefaultClass: '@',
                includeTemplate: '@',
                model: '@',
                modifyParentStyle: '@',
                tabData: '='
            },
            link: function (scope, $element, $attrs, controller) {
                scope.getModel = function () {
                    return JSON.parse(scope.model);
                };
                scope.logoutSession = function () {
                    requestClicked.navCircle("request", '#', null);
                };
                if (scope.detachDefaultClass) {
                    if (scope.detachDefaultClass.toLowerCase() === "true") {
                    } else {
                        $element.addClass('secondary-navigation white');
                    }
                } else {
                    $element.addClass('secondary-navigation white');
                }

                scope.slidingMenuId = 'sliding-menu-' + new Date().getTime();
                scope.rightPos = scope.right ? scope.right : 0;
                scope.leftPos = window.innerWidth - scope.rightPos;

                scope.$watch('show', function (newValue, oldValue) {
                    if (newValue != undefined || newValue != null) {
                        if (newValue) {
                            if (scope.modifyParentStyle) {
                                if (scope.modifyParentStyle.toLowerCase() !== 'false') {
                                    $element.parent().css({
                                        width: 'calc(100% - ' + $element.outerWidth(true) + 'px)'
                                    });
                                }
                            }
                            $element.css({
                                transform: 'translateX(-' + ($element.outerWidth(true) - scope.rightPos) + 'px)'
                            });
                            $('body').addClass('is-overflowHidden');
                        }
                        else {
                            if (scope.modifyParentStyle) {
                                if (scope.modifyParentStyle.toLowerCase() !== 'false') {
                                    $element.parent().css({
                                        width: 'calc(100% - ' + scope.rightPos + 'px)'
                                    });
                                }
                            }
                            $element.css({
                                transform: 'translateX(0px)'
                            });
                            $('body').removeClass('is-overflowHidden');
                        }
                    }
                });
            },
            templateUrl: 'shared/directives/slidingMenu/slidingMenuTemplate.html'
        };
    }]);
})();


(function () {
    'use strict';
    angular.module('SMART2').directive('smartAccordion', ['$timeout','$parse','$rootScope', function ($timeout,$parse,$rootScope) {
        return {
            restrict: 'EA',
            transclude: true,
            replace: true,
            scope: true,
            link: function (scope, elem, attr) {
                var accordian = {
                    target: elem.find('.accordion-header'),
                    content: elem.find('.accordion-content')
                }, onChange = $parse(attr.onChange);

                accordian.target.data('isOpen', false);
                accordian.content.hide(0).slideUp(0);

                attr.$observe('show', function (a, b) {
                    showHideAccordian.call(accordian.target, a == 'true' ? true : false);
                });

                accordian.target.click(function () {
                    showHideAccordian.call(this, !$(this).data('isOpen'));
                    accEvents();
                    scope.$digest();
                });
                function accEvents() {
                    onChange(scope, {
                        e: {
                            isOpen: accordian.target.data('isOpen')
                        }
                    });
                   
                }
                function showHideAccordian(val) {
                    var _this = $(this),
                        _isOpen = _this.data("isOpen");
                    if (val && !_isOpen) {
                        _this.data("isOpen", true);
                        accordian.content.slideDown();
                    } else if (!val && _isOpen) {
                        _this.data("isOpen", false);
                        accordian.content.slideUp();
                    };
                };
            },
            template: "<div class='smart-accordion-container' ng-transclude></div>"
        }
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartAccumulator', ['$timeout', function ($timeout) {
		return {
			restrict: 'E',
			replace: true,
			scope: {
				ngModel: '=?',
				options: '=',
				isSearch: '=',
				leftLoader: '=',
				rightLoader: '=',
				modelCount: '=?',
				optionCount: '=?',
				columnMappingError: '=',
				selectionCallback: '&',
				searchCallback: '&',
				maxLimit: '=',
				scrollEndRightCallback: '&',
				scrollEndLeftCallback: '&'
                },
			link: function (scope, element, attrs) {
			    scope.label = attrs.label;
			    scope.optionCount = angular.isDefined(scope.optionCount) ? scope.optionCount : true;
			    scope.modelCount = angular.isDefined(scope.modelCount) ? scope.modelCount : true;
			    scope.iconInfo = scope.$eval(attrs.iconInfo);
				scope.accumulatorHeight = attrs.height + 'px';
				scope.accumulatorLeftScrollHeight = (attrs.height - 48) + 'px';
			    scope.loaderFlag = {
				    plain: true,
				    center: true,
				    message:"",
				    top:'50',
                    left:'131'
				};
				//if (scope.isSearch) {
				//	scope.accumulatorLeftScrollHeight = (attrs.height - 48) + 'px';            		
				//}           	
				scope.focusAccumulatorSearch = false;
				scope.isAccumulatorSearchActive = false;
				scope.showAccumulatorSearch = false;
				scope.accumulatorSearchModel = "";
				scope.showAccumulatorSearch = function () {
					scope.isAccumulatorSearchActive = true;
					scope.focusAccumulatorSearch = true;
					setTimeout(function () {
					    $("#searchLeftTextbox").find("input").focus();
				}, 500);
					//scope.showMe = true;
					scope.hideAccumulatorSearchClose = true;
				}
				scope.hideAcccumulatorSearch = function () {
				    scope.leftCheckedCount = 0;
					if (scope.accumulatorSearchModel != "") {
					    scope.accumulatorSearchModel = "";
					} else {
					    scope.isAccumulatorSearchActive = false;
					    scope.focusAccumulatorSearch = false;
					    scope.hideAccumulatorSearchClose = false;
					    $("#accumulatorLeftShowSearch").focus();

					}
					if ($.isFunction(scope.searchCallback)) {
					    scope.searchCallback({ $data: { text: scope.accumulatorSearchModel, type: "close" } });
					}
				}

			    // Right side Search
				scope.smartScrollLeftEnd = function () {
				    if ($.isFunction(scope.scrollEndLeftCallback)) {
				        scope.scrollEndLeftCallback();
				    }
				}

				scope.smartScrollRightEnd = function () {
				    if ($.isFunction(scope.scrollEndRightCallback)) {
				        scope.scrollEndRightCallback();
				    }
				}

				scope.focusRightAccumulatorSearch = false;
				scope.isRightAccumulatorSearchActive = false;
				scope.showRightAccumulatorSearch = false;
				scope.showRightAccumulatorSearch = function () {
					scope.isRightAccumulatorSearchActive = true;
					scope.focusRightAccumulatorSearch = true;
					setTimeout(function () {
					    $("#searchRightTextbox").find("input").focus();
					}, 500);
					//scope.showMe = true;
					scope.hideRightAccumulatorSearchClose = true;
				}
				scope.hideRightAcccumulatorSearch = function () {
					scope.isRightAccumulatorSearchActive = false;
					scope.focusRightAccumulatorSearch = false;
					scope.hideRightAccumulatorSearchClose = false;
					$("#accumulatorRightShowSearch").focus();

				}
				scope.searchTextKeyUpFn = function (e) {
				    if ($.isFunction(scope.searchCallback)) {
				        scope.searchCallback({ $data: { text: e.target.value, type: "textfield", "e": e } });
				    }
				    scope.leftCheckedCount = 0;
				}

				
				scope.leftCheckedCount = 0;
				scope.rightCheckedCount = 0;
				scope.leftBoxListCheck = function (arg) {
				    if (arg.isChecked)
				        scope.leftCheckedCount++;
				    else
				        scope.leftCheckedCount--;

				    for (var i = 0; i < scope.options.length; i++) {
				        if (((scope.leftCheckedCount + scope.ngModel.length >= scope.maxLimit) && !scope.options[i].isChecked) || (scope.maxLimit == scope.leftCheckedCount && !scope.options[i].isChecked)) {
				            scope.options[i].isDisabled = true;
				        } else {
				            if (scope.ngModel.length >= scope.maxLimit && scope.options[i].$$hashKey == arg.$$hashKey)
				                scope.options[i].isChecked = false;
				                 scope.options[i].isDisabled = false;
				        }

				    }
				}
				scope.rightBoxListCheck = function () {
					scope.rightCheckedCount = 0;
					for (var i = 0; i < scope.ngModel.length; i++) {
						if (!scope.ngModel[i].isDisabled) {
							if (scope.ngModel[i].isChecked) {
								scope.rightCheckedCount++;
							}
						}
					}
				}
            function generateKey(obj) {
					var getProperty = "";
					var getKey = "";
					var addedKeys = scope.$eval(attrs.addKeys);
					for (var i = 0; i < addedKeys.length; i++) {
						getProperty = addedKeys[i];
						getKey = getKey + " " + obj[getProperty];
					}
					return getKey;
				}
				scope.$watch('options', function (newOptions) {
					scope.options = newOptions;
					for (var i = 0; i < scope.options.length; i++) {
						if (scope.options[i].isGroup) {
							for (var j = 0; j < scope.options[i].group.length; j++) {
								scope.options[i].group[j].optionKey = generateKey(scope.options[i].group[j]);
							}
						}
						else
							scope.options[i].optionKey = generateKey(scope.options[i]);
					}
				}, true);
				
				// move the selected item to the right
				scope.moveRight = function (accData) {
					var selectedOptions = [];
					if (scope.leftCheckedCount > 0) {
						for (var i = 0; i < scope.options.length; i++) {
							if (scope.options[i].isChecked) {
								if (scope.options[i].isGroup) {
									for (var j = 0; j < scope.options[i].group.length; j++) {
										scope.ngModel.push(scope.options[i].group[j]);
										scope.options[i].group[j].isChecked = true;
									}
								}
								else {
									scope.options[i].isChecked = true;
									selectedOptions.push(scope.options[i]);
									scope.ngModel.push(scope.options[i]);
								}
								// get the add objects
								//scope.addscope.push(scope.leftBoxList[i]);
								var index = scope.options.indexOf(scope.options[i]);
								scope.options.splice(index, 1);
								i--;
							}
						}
						if ($.isFunction(scope.selectionCallback)) {
							scope.selectionCallback({ e: selectedOptions, direction: 'LTR' });
						}
					}
					scope.rightBoxListCheck();
					scope.leftCheckedCount = 0;
				    //scope.leftSelectAll = false;
				};

				// move the selected item to the left
				var selectedOptions = [];
				scope.moveLeft = function (accData) {
					
					if (scope.rightCheckedCount > 0) {
						for (var i = 0; i < scope.ngModel.length; i++) {
							if (!scope.ngModel[i].isDisabled) {
								if (scope.ngModel[i].isChecked) {

									scope.ngModel[i].isChecked = false;
									scope.options.push(scope.ngModel[i]);
									for (var j = 0; j < scope.options.length; j++) {
									    scope.options[j].isDisabled = false;
									    scope.rightCheckedCount--;

									}
									selectedOptions.push(scope.ngModel[i]);

									// get the remove objects
									//scope.removescope.push(scope.rightBoxList[i]);
									var index = scope.ngModel.indexOf(scope.ngModel[i]);
									scope.ngModel.splice(index, 1);
									i--;
								}
							}
						}
						if ($.isFunction(scope.selectionCallback)) {
							scope.selectionCallback({ e: selectedOptions, direction: 'RTL' });
						}
					}
					scope.rightCheckedCount = 0;
					//scope.rightSelectAll = false;
				};
				scope.$watch('ngModel', function (newModel) {
				    scope.accumulatorSearchModel = "";
				    scope.accumulatorRightSearchModel = "";
					scope.ngModel = newModel;
					if (scope.ngModel.length <= 0) {
						scope.rightCheckedCount = 0;
					}
				});
				scope.$watch('rightLoader', function (rightLoaderUpdate) {
				    scope.rightLoader = rightLoaderUpdate;
				});
				scope.$watch('leftLoader', function (leftLoaderUpdate) {
				    scope.leftLoader = leftLoaderUpdate;
				});


			},
			templateUrl: 'shared/directives/smartAccumulator/smartAccumulatorTemplate.html'
		};
	}]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartCarousel', ['$timeout', function ($timeout) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                "apiObj": "=",
                "carouselArr": "=",
                "arrowClick": "&",
                "getItem": "&"
            },
            link: function (scope, element, attrs) {
                var margin = 0;
                var marginToChange = "margin-left";
                var dimensionToChange = "width";
                var textAlign = "left";
                var stepSize = 94;

                scope.scrollBarClass = "scrollBarClass " + scope.carouselArr.classes;
                scope.arrowClass = "icon iconMedium reqNavArrow " + scope.carouselArr.arrow;

                if (scope.carouselArr.type === "horizontal" && scope.carouselArr.id === "leftBar") {
                    textAlign = "right";
                }

                if (scope.carouselArr.type == "vertical") {
                    marginToChange = "margin-top";
                    dimensionToChange = "height";
                    textAlign = "top";
                    stepSize = 94;
                }

                scope.internalAPIObj = scope.apiObj || {};
                scope.internalAPIObj.arrowClick = function (item) {
                    scope.arrowClick(scope, {
                        e: item
                    });
                };

                scope.getClickedItem = function (item) {
                    scope.getItem({ e: item });
                }
                scope.animate = false;

                scope.internalAPIObj.resetUI = function (availableLength, addAnimation) {
                    var collectionEle = angular.element(element.children()[1]);

                    var length = scope.carouselArr.items.length * stepSize;

                    scope.animate = true;

                    if (dimensionToChange == "height") {
                        collectionEle.css("height", availableLength);
                    } else {
                        collectionEle.css("width", "100%");
                    }

                    if ((availableLength) <= length) {

                        if (scope.carouselArr.id === "topBar") {
                            collectionEle.removeClass('topBarOverflow').addClass('topBarOverflowHidden');
                        }
                        scope.carouselArr.showArrow = true;
                    } else {

                        if (scope.carouselArr.id === "topBar") {
                            collectionEle.removeClass('topBarOverflowHidden').addClass('topBarOverflow');
                        }
                        scope.carouselArr.showArrow = false;
                    }
                };
            },
            templateUrl: 'shared/directives/smartCarousel/smartCarousel.html'
        };
    }]);
})();

(function () {
	'use strict';

	angular.module('SMART2').directive('countdown', ['$interval', function ($interval) {
		return {
			restrict: 'E',
			replace: true,
			transclude: true,
			scope: {
			    date: '@',
                timeoutCallback: '&'
			},
			link: function (scope, element, attrs) {

				var from = new Date(attrs.date);

				function timer(t) {
					var days = Math.floor(t / 86400);
					t -= days * 86400;
					var hours = Math.floor(t / 3600) % 24;
					t -= hours * 3600;
					var minutes = Math.floor(t / 60) % 60;
					t -= minutes * 60;
					var seconds = t % 60;
					if (!days && !hours && !minutes && !seconds) {
						if (angular.isDefined(timerObj)) {
							$interval.cancel(timerObj);
						}

						if (attrs.timeoutCallback && angular.isFunction(scope.timeoutCallback)) {
						    scope.timeoutCallback();
						}
						return;
					}
					return days + 'd ' + hours + 'h ' + minutes + 'm ' + seconds + 's';
				}
				var timerObj = $interval(function () {
					var diff = Math.floor((from.getTime() - new Date().getTime()) / 1000);
					$(element).text(timer(diff));
				}, 1000)

			}
		};
	}]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartDocSlider', ['$parse', '$focusOnField', function ($parse, $focusOnField) {
        return {
            restrict: 'E',
            replace: true,
             scope: true,
            link: function (scope, element, attrs) {

                var onHide = $parse(attrs.onHide);
                scope.commonSelectedOptionInside = { title: '' };

                attrs.$observe("slideObj", function (value) {
                    if (attrs.slideObj) {

                        var slideObj = JSON.parse(attrs.slideObj);
                        scope.src = slideObj.src;
                        scope.list = slideObj.list;
                        scope.index = slideObj.index;
                        scope.commonSelectedOptionInside.title = scope.list[scope.index];
                        scope.updateTheIndexInController = function (obj) {
                            scope.index = scope.list.indexOf(obj);
                            scope.nextIndex = (angular.copy(scope.index)) + 1;
                            scope.prevIndex = (angular.copy(scope.index)) - 1;
                            var listLength = scope.list.length;
                            if (scope.index == 0) {
                                scope.prevIndex = listLength - 1;
                            }
                            else if (scope.index == listLength - 1) {
                                scope.nextIndex = 0;
                            }

                        }

                        scope.nextIndex = angular.copy(scope.index);
                        scope.prevIndex = angular.copy(scope.index);

                        var listLength = scope.list.length;

                        if (scope.index == 0) {
                            scope.nextIndex++;
                            scope.prevIndex = listLength - 1;
                        }
                        else if (scope.index == listLength - 1) {
                            scope.nextIndex = 0;
                            scope.prevIndex--;
                        }
                        else if (scope.index < listLength - 1) {
                            scope.nextIndex++;
                            scope.prevIndex--;
                        }
                    }
                });
                scope.tabbingFocus = false;
                //Need to change the code
                scope.$watch(attrs.ngShow, function (value) {
                    if (value) {
                        angular.element('body').css('overflow', 'hidden');
                        angular.element(document.activeElement).addClass("sliderDocTrigger");
                        setTimeout(function () { firstFieldFocused();}, 500);
                      
                    } else {
                        angular.element('body').css('overflow', '');
                        angular.element('.sliderDocTrigger').focus().removeClass('sliderDocTrigger');
                        scope.tabbingFocus = false;
                    }
                });

                scope.next = function () {
                    scope.tabbingFocus = false;
                    var listLength = scope.list.length;
                    var modal = angular.element('.slide-view-modal');

                    modal.css('left', '-50%');

                    if (scope.index < listLength - 1)
                        scope.index++;
                    else if (scope.index == listLength - 1)
                        scope.index = 0;

                    if (scope.index == 0) {
                        scope.nextIndex = (angular.copy(scope.index)) + 1;
                        scope.prevIndex = listLength - 1;
                    }
                    else if (scope.index == listLength - 1) {
                        scope.nextIndex = 0;
                        scope.prevIndex = (angular.copy(scope.index)) - 1;
                    }
                    else if (scope.index < listLength - 1) {
                        scope.nextIndex = (angular.copy(scope.index)) + 1;
                        scope.prevIndex = (angular.copy(scope.index)) - 1;
                    }
                    setTimeout(function () {
                        modal.css('transition', 'none');
                        modal.css('display', 'none');
                        modal.css('left', '150%');
                        modal.css('display', 'block');
                    }, 350);
                    setTimeout(function () {
                        modal.css('transition', '0.5s ease-in-out');
                        modal.css('left', '50%');
                        firstFieldFocused();
                    }, 370);
                    scope.commonSelectedOptionInside.title = scope.list[scope.index];
                 
                }

                scope.prev = function () {
                    scope.tabbingFocus = false;
                    var listLength = scope.list.length;
                    var modal = angular.element('.slide-view-modal');

                    modal.css('left', '150%');

                    if (scope.index > 0)
                        scope.index--;
                    else if (scope.index == 0)
                        scope.index = listLength - 1;

                    if (scope.index == 0) {
                        scope.prevIndex = (angular.copy(scope.index)) + 1;
                        scope.prevIndex = listLength - 1;
                    }
                    else if (scope.index == listLength - 1) {
                        scope.prevIndex = 0;
                        scope.prevIndex = (angular.copy(scope.index)) - 1;
                    }
                    else if (scope.index < listLength - 1) {
                        scope.nextIndex = (angular.copy(scope.index)) + 1;
                        scope.prevIndex = (angular.copy(scope.index)) - 1;
                    }
                    setTimeout(function () {
                        modal.css('transition', 'none');
                        modal.css('display', 'none');
                        modal.css('left', '-50%');
                        modal.css('display', 'block');
                    }, 350);
                    setTimeout(function () {
                        modal.css('transition', '0.7s ease-in-out');
                        modal.css('left', '50%');
                        firstFieldFocused();
                    
                    }, 370);
                    scope.commonSelectedOptionInside.title = scope.list[scope.index];
                   
                };


                scope.close = function () {

                    if (angular.isFunction(onHide)) {
                        //scope.$apply(function () {
                        onHide(scope, { e: "" });
                        //});
                    };
                    scope.tabbingFocus = false;
                };

                var firstFieldFocused = function () {
                    scope.tabbingFocus = true;
                    var $fistField = angular.element('.docSlider-content').find("a, input, button, textarea").first();
                    $focusOnField($fistField);
                };

                scope.funcOnKeyDown = function (e) {
                    if (e.keyCode == 27) {
                        scope.close();
                    } else if (e.keyCode == 37) {
                        scope.prev()
                    } else if (e.keyCode == 39) {
                        scope.next()
                    }
                };
              
            },
            templateUrl: 'shared/directives/smartDocSlider/smartDocSlider.html'
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').factory('httpLoaderInterceptor', ['$rootScope', '$timeout', function ($rootScope, $timeout) {

        $rootScope.$on('$stateChangeStart', function (event, toState, toParams, fromState, fromParams) {
            $rootScope.pageLoaderFlagController = true;
        });

        $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
            //$timeout(function () {
                $rootScope.pageLoaderFlagController = false;
            //}, 2000);
        });

        var requestCount = 0;
        function startRequest(config) {
            if (!requestCount) {
                //$rootScope.pageLoaderFlagController = true;
            }
            requestCount++;
            return config;
        }
        function endRequest(arg) {
            if (!requestCount)
                return;
            requestCount--;
            if (!requestCount) {
                //$rootScope.pageLoaderFlagController = false;
            }
            return arg;
        }
        return {
            'request': startRequest,
            'requestError': endRequest,
            'response': endRequest,
            'responseError': endRequest
        };
    }]);

    angular.module('SMART2').config(['$httpProvider', function ($httpProvider) {
        $httpProvider.interceptors.push('httpLoaderInterceptor');
    }]);

    angular.module('SMART2').directive('smartGlobalLoader', ['$timeout', '$translate', function ($timeout, $translate) {
        return {
            restrict: 'AE',
            replace: true,
            scope: {
                isFixed: '=?',
                config: '=?',
                onCancel: "&",
            },
            link: function (scope, element, attrs) {
            	var message = $translate.instant("loadingMsg");
            	
                scope.conf = angular.extend({
                    message: message,
                    center: false,
                    plain: false,
                    bgwhite: false,
                    top: undefined,
                    left: undefined
                }, scope.config);
                scope.messageArray = scope.conf.message.split("\n");
                //Count left
                $timeout(function () {
                    var widthCount = angular.element(element[0].querySelector('.relative-loader-container')).width();
                    var heightCount = angular.element(element[0].querySelector('.relative-loader-container')).height();
                    scope.leftTopCount = {
                        left: (scope.conf.left == undefined || scope.conf.left == null || scope.conf.left == '') ? "calc(50% - " + widthCount / 2 + "px)" : scope.conf.left + "px",
                        top: (scope.conf.top == undefined || scope.conf.top == null || scope.conf.top == '') ? "calc(50% - " + heightCount / 2 + "px)" : scope.conf.top+"px"
                    };
                });
				
                if (angular.isDefined(attrs.onCancel)) {
                	scope.cancelBtn = { title: $translate.instant("cancelBtn") };
                	scope.conf.isCancel = true;
                }

                scope.cancelCallback = function (e) {
                	scope.onCancel({ $event: e });
                };
            },
            templateUrl: 'shared/directives/smartGlobalLoader/smartGlobalLoader.html'
        };
    }]);
})();
angular
    .module("SMART2")
    .directive("smartHeight", ["$timeout", smartHeightFun]);

function smartHeightFun($timeout) {
    return {
        restrict: "A",
        link: function (scope, element, attrs) {
            var config = {
                relativeTo: returnVal(attrs.relativeTo, "relativeTo"),
                plusThis: returnVal(attrs.plusThis, "plusThis"),
                minusThis: returnVal(attrs.minusThis, "minusThis")
            };
            var height = function () {
                var h = 0, m = 0, p = 0;
                if (config.relativeTo == window) {
                    h = window.innerHeight;
                } else {
                    h = $(config.relativeTo).get(0).outerHeight;
                }
                if (config.plusThis) {
                    p = normalizeNumber(config.plusThis);
                    h += p;
                } else {
                    m = normalizeNumber(config.minusThis);
                    h -= m;
                }
                return h;
            }();

            element.css("height", height);

            function normalizeNumber(val) {
                var v = 0;
                if (val) {
                    if (Number(val) == NaN) {
                        if (val.indecOf(',') > -1) {
                            $(val).each(function () {
                                v += this.outerHeight;
                            });
                        } else {
                            v = $(val).get(0).outerHeight;
                        }
                    } else {
                        v = Number(val)
                    }
                } else {
                    v = 0;
                }
                return v;
            }

            function returnVal(val, attribute) {
                var r;
                switch (attribute) {
                    case "relativeTo":
                        if (!val) r = window
                        else r = val;
                        break;
                    case "plusThis":
                        if (!val) r = false;
                        else r = val;
                        break;
                    case "minusThis":
                        if (!val) r = false;
                        else r = val;
                        break;
                }

                return r;
            };
        }
    };
}
/**
 * @memberof SMART2
 * @ngdoc directive
 * @name SmartHierarchy
 * @description This directive is useful for creating hierarchical structure.
 * 
 * @attr {Object} config
 *    Config object is expected to decide the behaviour of the component.
 * @attr {Function} callback
 *    Callback function when selections are done in component
 * 
 * @example
Controller : 
    config :
     $scope.treeComponentConfig = {
                selectedNodes: "", // Coma seperated codes string given to component for pre selection, 
                				   // so the default selections can be shown selected when the component 
                				   // in initialized.
                isRadio: false, // Boolean values to toggle between checkBox & radioButton
                getHierarchyOnSelection: true, // If set to true , selection hierarchy
                                               // (uptil the relevent parent) also will be recieved 
                                               // in selection callback.
                isLazyLoad: true, // If set to true, data would be fetched from the server on demand 
                                  // (lazyLoading on scroll & node expansion)
                data: null, // Custom data can also be passed to component, representation would be in hierarchical manner.
                disableLevelSelection: '', // comma seperated string values of levels to be shown disabled eg. "1,2,3".
                title: 'Category', // Title of the component.
                getSelections: false, // On setting it true, it will call the callback function 
                                      // provided to the component with seleted values in the ouput.
                clearCache: false, // On setting it true, it will clear the Java script heap 
                                   // runtime memory which will reduce the memory foot print of the web page.
                height: '328px', // Height can be set to the component.
                isSearchEnabled : true, // Bollean value to toggle the visibility of search bar.
                requestParameter: { // Request parameter is expected to fetch the data from the server. 
                    navigationContext: "PAS",
                    userExecutionContext: '{"ClientName":"abc,....}',
                    documentCode: null,
                    contactCode: null,
                }
            };
    callback :
         $scope.treeComponentCallback = function (e) {
                console.log(e);

                // Un comment the below logic to see admin use case.
                // TODO : getHierarchyOnSelection:true (in tree config)

                // var obj = { 'PASList': [] };
                // var levelData = _.groupBy(_.flatten(e.selectionHierarchy), "Level");
                // _.each(levelData, function (data, key) {
                    // _.each(data, function (n) {
                        // n['selection'] = "0";
                    // });
                    // obj['PASList'].push({
                        // "Level": key,
                        // "PASDetails": data
                    // });
                // });
                // $scope.treeComponentConfig.isRadio = true;
                // $scope.treeComponentConfig.data = obj;
                // $scope.treeComponentConfig.selectedNodes = e.selections[0]['ID'].toString();
         }
  Usage:
      <smart-hierarchy-component config="treeComponentConfig" callback="treeComponentCallback"></smart-hierarchy-component>
      */
(function (angular) {
    'use strict';
    var hierarchyCounter = 0;
    angular.module('smartHierarchyComponent', [])
    .directive('smartHierarchyComponent', ['$timeout', 'RESTApi', '$q', '$rootScope', 'APPCONSTANTS', '$translate',
      function ($timeout, RESTApi, $q, $rootScope, APPCONSTANTS, $translate) {
          return {
              restrict: 'E',
              replace: true,
              scope: {
                  config: '=',
                  callback: '&'
              },
              link: function (scope, element, attrs) {
                  /*config for the directive*/
                  scope.hierarchyCounter = hierarchyCounter++;
                  scope.treeConfig = scope.config;
                  scope.searchFieldVal = '';
                  scope.cancelTitle = scope.searchFieldVal == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                  scope.checkCondForTemplate = function (a_data) {
                      var boolTemplate = false;
                      if (scope.searchFieldVal.length <= 2 && !scope.treeConfig.isReadOnly) {
                          boolTemplate = true;
                      } else if (scope.searchFieldVal.length <= 2 && scope.treeConfig.isReadOnly && a_data.selection != '0' && !scope.treeConfig.selectAllToggle) {
                          boolTemplate = true;
                      } else if (scope.searchFieldVal.length <= 2 && scope.treeConfig.isReadOnly && scope.treeConfig.selectAllToggle) {
                          boolTemplate = true;
                      }
                      return boolTemplate;
                  }
                  scope.templateCheck2 = function (a_category) {
                      var boolTemplate = false;
                      if (scope.treeConfig.isReadOnly && a_category.selection != '0') {
                          boolTemplate = true;
                      } else if(!scope.treeConfig.isReadOnly) {
                          boolTemplate = true;
                      }
                      return boolTemplate;
                  }
                  scope.secondaryLinkCallback = function () {
                      scope.treeConfig.secondaryLink.callback();
                  }
                  scope.treeConfig.isSelectedOnly = false;
                  scope.noRecordsFound = false;
                  if (!scope.treeConfig.hasOwnProperty('modalButtonShow')) {
                      scope.treeConfig.modalButtonShow = false;
                  }

                  if (!scope.treeConfig.hasOwnProperty('isMandatory')) {
                      scope.treeConfig.isMandatory = true;
                  }
                  if (!scope.treeConfig.hasOwnProperty('listIcon')) {
                      scope.treeConfig.listIcon = null;
                  }
                  if (!scope.treeConfig.hasOwnProperty('selectAllToggle')) {
                      scope.treeConfig.selectAllToggle = false;
                  }


                  var doneCallback = scope.$eval(scope.callback);

                  scope.config.refreshConfig = function (newData) {
                      scope.treeConfig = newData;
                      resetValue(scope.treeConfig);

                  }

                  var resetValue = function (data) {
                      if (scope.treeConfig.isRadio) {

                          scope.uniqueRadioGroupName = uniqueIDGenerator();
                      }

                      if (scope.treeConfig.clearCache) {
                          resetDataSourcesAndPromises();
                          scope.isLoading = false;
                          scope.treeConfig.clearCache = false;
                      }

                      dataRecievedCallPromise;
                      preselectionRecievedPromise;
                      promises = [];

                      /*Local variables*/
                      navContext = scope.treeConfig.navigationContext;
                      isLazyLoadServerData = (scope.treeConfig.isLazyLoad == true || scope.treeConfig.isLazyLoad == false) ? scope.treeConfig.isLazyLoad : false;
                      dataSet;
                      searchBucket = 50;
                      lazyLoadingBucket = 50;
                      maxLevel = 1;
                      lazyLoadOffset;
                      lazyLoadMarker = [];
                      levelKey = 'level';

                      //levelWiseData = {};
                      parentStringConstant = "parentString";
                      parentCodeStringConstant = "parentCodeString";
                      preselection;
                      isInitialServiceCalled = false;
                      searchCategories = [];
                      baseLevelExpectNode = [];

                      nodeExpandingCodeProperty;
                      dataProperty;
                      levelWiseDataProperty;
                      searchProperty;
                      modelProperty;

                      //scope.totalSelection = 0;
                      //totalID = [];
                      //totalName = [];

                      selectAllBool = false;

                      scope.getUserSelectionArray = [];
                      scope.selectionAndCountOptions = false;

                      scope.treeType = scope.treeConfig.treeType;

                      scope.isReadOnly = scope.treeConfig.isReadOnly;
                      scope.isDisabled = scope.treeConfig.isDisabled;
                      scope.isSingleSelect = scope.treeConfig.isRadio ? scope.treeConfig.isRadio : false;



                      // if(scope.treeConfig.requestParameter)
                      // {

                      //           //scope.treeConfig.requestParameter = n;
                      //           RESTApi.setDocumentId(scope.treeConfig.requestParameter.documentCode);
                      //           RESTApi.setContactCode(scope.treeConfig.requestParameter.contactCode);
                      //           RESTApi.setUserContext(scope.treeConfig.requestParameter.userExecutionContext);
                      //           RESTApi.setEnvironment(scope.treeConfig.requestParameter.environment);
                      //           RESTApi.setRequestObject(scope.treeConfig.requestParameter.requestObject);
                      //           setKeysAsPerNavigationContext(scope.treeConfig.requestParameter.navigationContext);
                      //           navContext = scope.treeConfig.requestParameter.navigationContext;

                      //         init();

                      // }

                      scope.showSelectAll = scope.treeConfig.showSelectAll;
                      scope.showClearSelection = scope.treeConfig.showClearSelection;
                      scope.showSelectionCount = scope.treeConfig.showSelectionCount;
                      scope.enableLastLevelSelection = scope.treeConfig.enableLastLevelSelection;

                  };


                  /* scope.$watch('config', function (n, o) {
                    if (n) {
                      scope.treeConfig = null;
                      scope.treeConfig = scope.config;
                      clearAllsearch();
                     
                      dataRecievedCallPromise;
                      preselectionRecievedPromise;
                      promises = [];
                     
                      navContext = scope.treeConfig.navigationContext;
                      isLazyLoadServerData = (scope.treeConfig.isLazyLoad == true || scope.treeConfig.isLazyLoad == false) ? scope.treeConfig.isLazyLoad : false;
                      dataSet;
                      searchBucket = 50;
                      lazyLoadingBucket = 50;
                      maxLevel = 1;
                      lazyLoadOffset;
                      lazyLoadMarker = [];
                      levelKey = 'level';
                      levelWiseData = {};
                      parentStringConstant = "parentString";
                      parentCodeStringConstant = "parentCodeString";
                      preselection;
                      isInitialServiceCalled = false;
                      searchCategories = [];
                      baseLevelExpectNode = [];
                      nodeExpandingCodeProperty;
                      dataProperty;
                      levelWiseDataProperty;
                      searchProperty;
                      modelProperty;
                      scope.totalSelection = 0;
                      totalID = [];
                      totalName = [];
                      selectAllBool = false;
                      scope.getUserSelectionArray =[];
                      scope.treeType = scope.treeConfig.treeType;
                      scope.isReadOnly = scope.treeConfig.isReadOnly;
                      scope.isDisabled = scope.treeConfig.isDisabled;
                    }
                  });*/

                  function clearAllsearch() {
                      serverSearchVal = "";
                      scope.searchResults.length = 0;
                      searchDataYetToBeDisplayed.length = 0;
                      searchWithContainsHitResult.length = 0;
                      scope.searchText = '';
                      scope.searchFieldVal = '';
                  }


                  /*scope.$watch('config.clearCache', function (n, o) {
                    if (n) {
                     resetDataSourcesAndPromises();
                     scope.isLoading = false;
                     scope.config.clearCache = false;
                   }
                });*/


                  var deregisterConfigSelection = scope.$watch('config.getSelections', function (n, o) {
                      if (n) {
                          getSelections();
                          scope.config.getSelections = false;
                      }
                  });


                  var deregReqContactCode = scope.$watch('config.requestParameter.contactCode', function (n, o) {
                      if (n != o) {
                          RESTApi.setContactCode(n);
                          init();
                      }
                  });
                  var deregReqParam = scope.$watch('config.requestParameter', function (n, o) {
                      //if (!scope.treeConfig.data && n) {
                      if (n) {
                          scope.treeConfig.requestParameter = n;

                          RESTApi.setDocumentId(n.documentCode);
                          RESTApi.setContactCode(n.contactCode);
                          RESTApi.setUserContext(n.userExecutionContext);
                          RESTApi.setEnvironment(APPCONSTANTS.userPreferences.URLs.AppURL);
                          RESTApi.setRequestObject(n.requestObject);

                          setKeysAsPerNavigationContext(n.navigationContext);
                          navContext = n.navigationContext;

                          if (n.hasOwnProperty('url')) {
                              RESTApi.setUrl(n.url);
                          }

                          //request params than it must go in 
                          //if (!isInitialServiceCalled)
                          init();
                      }
                      //scope.treeConfig.requestParameter = null;
                  });
                  scope.selectOptions = [{
                      "code": 1,
                      "name": "Select All"
                  }, {
                      "code": 0,
                      "name": "Single Select"
                  }];

                  scope.selectType = { "code": 0, "name": "Single Select" };

                  var initSelectallModel = function () {
                      //----SelectAllToggle----//
                      scope.onSelectTypeChange = function (selectType) {
                          scope.selectType = selectType;

                          if (selectType.code == 1) {
                              scope.clearAllSelection();
                              //scope.treeConfig.isReadOnly = true;
                          }
                      }
                      if (scope.treeConfig.selectType === 1) {
                          scope.clearAllSelection();
                          scope.selectType = { "code": 1, "name": "Select All" };
                      } else {
                          scope.selectType = { "code": 0, "name": "Single Select" };
                      }
                  }

                  var deregConfigData = scope.$watch('config.data', function (n, o) {
                      if (n) {
                          initSelectallModel();
                          if (scope.config.selectedNodes && scope.selectedData.length > 0) {
                              scope.config.isReadOnly = typeof scope.config.isShowSelected !== 'undefined' ? scope.config.isShowSelected : !scope.treeConfig.isRadio;
                          } else if (!scope.config.selectedNodes || !scope.config.selectedNodes) {
                              scope.config.isReadOnly = false;
                          }
                          setKeysAsPerNavigationContext(scope.treeConfig.navigationContext);
                          navContext = scope.treeConfig.navigationContext;
                          resetDataSourcesAndPromises(true);
                          createLevelWiseDataSet(_.sortBy(n[dataProperty], 'Level'));
                          dataRecievedCallPromise.resolve();
                          renderLevels();
                      }
                      scope.config.data = null;
                  });

                  var deregSelectedNodes = scope.$watch('config.selectedNodes', function (n, o) {
                      if (n) {
                          preselection = n.split(',');
                          if (preselection && preselection.length == 0) {
                              scope.treeConfig.isReadOnly = false;
                          }
                          if (preselectionRecievedPromise)
                              preselectionRecievedPromise.resolve();
                      }
                      scope.config.selectedNodes = null;
                  });



                  /*scope.$watch('config.isRadio', function(n, o) {
                    scope.isSingleSelect = n;
                    if (scope.isSingleSelect) {
                     scope.uniqueRadioGroupName = uniqueIDGenerator();
                   }
                   scope.config.isRadio = false;
                 });*/





                  var navContext;
                  /*promise*/
                  var dataRecievedCallPromise;
                  var preselectionRecievedPromise;
                  var promises = [];
                  var selectAllBool = false;
                  /*Local variables*/
                  var isLazyLoadServerData = (scope.treeConfig.isLazyLoad == true || scope.treeConfig.isLazyLoad == false) ? scope.treeConfig.isLazyLoad : false;
                  var dataSet;
                  var searchBucket = 50;
                  var lazyLoadingBucket = 50;
                  var maxLevel = 1;
                  var lazyLoadOffset;
                  var lazyLoadMarker = [];
                  var levelKey = 'level';
                  var levelWiseData = {};
                  var parentStringConstant = "parentString";
                  var parentCodeStringConstant = "parentCodeString";
                  var preselection;
                  var isInitialServiceCalled = false;
                  var searchCategories = [];
                  var baseLevelExpectNode = [];
                  var nodeExpandingCodeProperty;
                  var dataProperty;
                  var levelWiseDataProperty;
                  var searchProperty;
                  var modelProperty;
                  var treeTypeObject = "Generic";
                  scope.codeProperty = 'ID';
                  scope.titleProperty = 'Name';
                  scope.levelProperty = 'Level';
                  scope.parentProperty = 'ParentID';
                  scope.getUserSelectionArray = [];
                  scope.treeType = "Generic";
                  scope.totalSelection = 0;

                  scope.isReadOnly = false;
                  scope.isDisabled = false;

                  scope.showSelectAll = false;
                  scope.showClearSelection = false;
                  scope.showSelectionCount = false;
                  scope.enableLastLevelSelection = false;




                  scope.isReadOnly = scope.treeConfig.isReadOnly;
                  scope.isDisabled = scope.treeConfig.isDisabled;
                  scope.isSingleSelect = scope.treeConfig.isRadio;

                  scope.showSelectAll = scope.treeConfig.showSelectAll;
                  scope.showClearSelection = scope.treeConfig.showClearSelection;
                  scope.showSelectionCount = scope.treeConfig.showSelectionCount;
                  scope.enableLastLevelSelection = scope.treeConfig.enableLastLevelSelection;


                  scope.selectionAndCountOptions = false;

                  scope.closeButton = { title: $translate.instant("closeBtn") };
                  scope.cancelButton = { title: $translate.instant("cancelBtn") };
                  scope.doneButton = { title: $translate.instant("doneBtn") };
                  scope.resetButton = { title: $translate.instant("resetButton") };
                  scope.editButton = { title: $translate.instant("editButton") };
                  scope.isPartiallySelected = false;

                  var totalID = [];
                  var totalName = [];

                  function setKeysAsPerNavigationContext(mode) {
                      switch (mode) {
                          case 'PAS':
                              nodeExpandingCodeProperty = 'PASCodes';
                              dataProperty = 'PASList';
                              levelWiseDataProperty = 'PASDetails';
                              searchProperty = 'PAS_SearchList';
                              scope.codeProperty = 'ID';
                              scope.titleProperty = 'Name';
                              scope.levelProperty = 'Level';
                              scope.parentProperty = 'ParentID';
                              modelProperty = 'SelectedPasCodeList';
                              break;
                          case 'REG':
                              nodeExpandingCodeProperty = 'RegionId';
                              levelWiseDataProperty = 'RegionDetails';
                              dataProperty = 'RegionList';
                              searchProperty = 'Region_SearchList';
                              scope.codeProperty = 'ID';
                              scope.titleProperty = 'Name';
                              scope.levelProperty = 'Level';
                              scope.parentProperty = 'ParentID';
                              modelProperty = 'SelectedRegionList';
                              break;
                          case 'ORG':
                              nodeExpandingCodeProperty = 'EntityDetailCode';
                              levelWiseDataProperty = 'EntityDetails';
                              dataProperty = 'Org_DetailsList';
                              searchProperty = 'Org_SearchList';
                              scope.codeProperty = 'EntityDetailCode';
                              scope.titleProperty = 'EntityDisplayName';
                              scope.levelProperty = 'Level';
                              scope.parentProperty = 'ParentEntityDetailCode';
                              modelProperty = 'SelectedORGList';
                              break;
                      };
                  };

                  scope.selectedData = [];

                  /*Local member fuctions*/

                  function resetDataSourcesAndPromises(isPromiseInit) {
                      levelWiseData = {};
                      scope.categories = [];
                      lazyLoadMarker = [];
                      scope.isLoading = true;
                      scope.isError = false;

                      scope.selectedData = [];
                      scope.getUserSelectionArray = [];

                      scope.totalSelection = 0;
                      totalID = [];
                      totalName = [];

                      if (isPromiseInit) initializePromise(true, true);
                  };

                  function init() {
                      initSelectallModel();
                      scope.isError = false;
                      scope.noRecordsFound = false;
                      scope.selectionAndCountOptions = false;
                      scope.isPartiallySelected = false;
                      //scope.treeConfig.isReadOnly = typeof scope.config.isReadOnly !== 'undefined' ? scope.config.isReadOnly : false;
                      scope.treeConfig.isReadOnly = function () {
                          var isReadOnly, sn;
                          if (scope.selectedData.length == 0 || scope.config.selectedNodes === null) {
                              isReadOnly = false;
                          } else {
                              isReadOnly = scope.config.isReadOnly
                          }

                          if (!scope.treeConfig.selectAllToggle) {
                              //.requestParameter.requestObject.selectedNodes
                              sn = scope.treeConfig.requestParameter.requestObject && scope.treeConfig.requestParameter.requestObject.selectedNodes && scope.treeConfig.requestParameter.requestObject.selectedNodes.length;
                              if (sn) {
                                  isReadOnly = true;
                              } else {
                                  isReadOnly = false;
                              }
                          }

                          return isReadOnly;
                      }();
                      isInitialServiceCalled = true;
                      resetDataSourcesAndPromises(true);
                      RESTApi.getData(navContext,
function (response) {
                          var respData = response.data,
                              data = respData.data;
                          isInitialServiceCalled = false;
                          if (response.action == 'success' && (respData && respData.status != 404)) {
                              scope.noRecordsFound = !data[dataProperty] || data[dataProperty].length <= 0;
                              if (!scope.noRecordsFound) {
                                  if (isLazyLoadServerData) {
                                      //setLevelWiseData(response.data.data);
                                      setLevelWiseDataSource(data);
                                  } else {
                                      createLevelWiseDataSet(_.sortBy(data[dataProperty], 'Level'));
                                  }
                                  if (data[modelProperty] && data[modelProperty].length > 0) {
                                      scope.treeConfig.isReadOnly = typeof scope.config.isShowSelected !== 'undefined' ? scope.config.isShowSelected : true;
                                  }
                                  renderLevels();

                                  //createSelectedModelIfRecieved(response.data.data.SelectedPasCodeList);
                                  createSelectedModelIfRecieved(data[modelProperty]);
                                  dataRecievedCallPromise.resolve();

                                  if (scope.treeType == treeTypeObject) {
                                  } else { //working perfect in porject team case
                                      scope.totalSelection = scope.selectedData.length;
                                  }
                              }
                              else {
                                  scope.isLoading = false;
                              }

                          } else {
                              if (scope.isLoading) scope.isLoading = false;
                              if (!scope.categories.length) scope.isError = true;
                          }
                      }, (isLazyLoadServerData) ? {
                          "LevelAt": "1",
                          "PageNumber": 1,
                          "PageSize": lazyLoadingBucket
                      } : {},false, scope.treeType);
                  };

                  scope.getSelectAllBool = function () {
                      if (scope.categories && scope.categories.length > 0) {
                          var selectedNodes = _.filter(scope.categories, function (node) {
                              return (node.selection == "1" || node.disabled == true)
                          });
                          if (scope.categories.length > 0 && selectedNodes.length == scope.categories.length) {
                              selectAllBool = true;
                          } else {
                              selectAllBool = false;
                          }

                      } else {
                          selectAllBool = false;
                      }
                      return selectAllBool;
                  }

                  scope.doneClickHandler = function () {
                      scope.treeConfig.getSelections = true;

                      // timeout required for delaying the $digest cycle
                      var cancelTimer = $timeout(function () {
                          scope.treeConfig.isReadOnly = false;
                          $timeout.cancel(cancelTimer);
                          cancelTimer = null;
                      }, 10);
                  }
                  function createSelectedModelIfRecieved(data) {

                      if (data && data.length > 0) {
                          scope.selectedData = getLeafNodeWithParentHierarchy(data);
                          scope.treeConfig.isReadOnly = typeof scope.config.isShowSelected !== 'undefined' ? scope.config.isShowSelected : true;
                      }
                  };

                  function renderLevels() {
                      if (levelWiseData[levelKey + '1'] != undefined) {
                          scope.categories = !scope.treeConfig.isReadOnly ? levelWiseData[levelKey + '1'].slice(0, lazyLoadingBucket) : levelWiseData[levelKey + '1'];
                          if (!scope.treeConfig.isReadOnly && scope.categories.length % lazyLoadingBucket == 0)
                              lazyLoadMarker.push(scope.categories[scope.categories.length - 1]);
                          scope.isLoading = false;
                          if (scope.categories.length > 0) {
                              scope.selectionAndCountOptions = true;
                          }
                      }
                      scope.config.levelWiseData = levelWiseData;
                  };


                  function initializePromise(dataRievedPromiseBool, preselectionRecievedPromiseBool) {
                      dataRecievedCallPromise = null;
                      preselectionRecievedPromise = null;
                      promises.length = 0;
                      if (dataRievedPromiseBool) {
                          dataRecievedCallPromise = $q.defer();
                          promises.push(dataRecievedCallPromise.promise);
                      }
                      if (preselectionRecievedPromiseBool) {
                          preselectionRecievedPromise = $q.defer();
                          promises.push(preselectionRecievedPromise.promise);
                      }
                      $q.all(promises).then(promiseResolved);
                  }



                  function promiseResolved() {
                      initatePreSelection();
                      initializePromise(false, true);
                  }

                  function createLevelWiseDataSet(dataSet) {
                      if (dataSet.length > 0) {
                          var level = 1;
                          var parentNodes = dataSet[level - 1][levelWiseDataProperty];
                          insertParentHierarchyForFlatStrucure(parentNodes);
                          while (parentNodes) {
                              var instance = levelWiseData[levelKey + level];
                              levelWiseData[levelKey + level] = (instance) ? _.map(_.groupBy(_.union(instance, parentNodes), function (doc) {
                                  return doc[scope.codeProperty];
                              }), function (grouped) {
                                  return grouped[0];
                              }) : parentNodes;
                              if (dataSet[level]) {
                                  insertParentHierarchyForFlatStrucure(parentNodes, level, dataSet);
                              };
                              maxLevel = level;
                              level = level + 1;
                              if (typeof (scope.treeConfig.to) !== 'undefined') {
                                  if (level > scope.treeConfig.to) {
                                      var len = parentNodes.length;
                                      for (var levelDataIndex = 0; levelDataIndex < len; levelDataIndex++) {
                                          parentNodes[levelDataIndex].ChildCount = 0;
                                      }
                                      parentNodes = null;
                                  } else {
                                      parentNodes = (dataSet[level - 1]) ? dataSet[level - 1][levelWiseDataProperty] : null;
                                  }
                              } else {
                                  parentNodes = (dataSet[level - 1]) ? dataSet[level - 1][levelWiseDataProperty] : null;
                              }
                          };
                      }
                  };

                  function insertParentHierarchyForFlatStrucure(parentNodes, level, dataSet) {
                      var fetchedData = (level) ? _.groupBy(dataSet[level][levelWiseDataProperty], scope.parentProperty) : null;
                      _.each(parentNodes, function (parent) {
                          var childForParent = (fetchedData) ? fetchedData[parent[scope.codeProperty]] : parentNodes;
                          if (childForParent) {
                              _.each(childForParent, function (node, index) {
                                  node[parentStringConstant] = parent[parentStringConstant] ? parent[parentStringConstant] + ' > ' + node[scope.titleProperty] : (node[scope.levelProperty] > 1) ? parent[scope.titleProperty] + ' > ' + node[scope.titleProperty] : "";
                                  node[parentCodeStringConstant] = parent[parentCodeStringConstant] ? parent[parentCodeStringConstant] + '>' + node[scope.codeProperty] : (node[scope.levelProperty] > 1) ? parent[scope.codeProperty] + '>' + node[scope.codeProperty] : "";
                                  node['isExpanded'] = false;
                                  var nodeSelection = node.selection,
                                      isNodeSelected = node.IsSelected;
                                  node['selection'] = (node && nodeSelection && (nodeSelection == "1" || nodeSelection == "0") /*&& !scope.isSingleSelect*/) ? nodeSelection : (isNodeSelected == false || isNodeSelected == null || isNodeSelected) ? getSelectionState(isNodeSelected) : '0',
                                  //checkDisableForPartialNode(node);
                                  node['index'] = index;

                                  if (nodeSelection == "1") {

                                      var index = totalID.indexOf(node[scope.codeProperty]);
                                      if (index > -1) {
                                      } else {
                                          totalID.push(node[scope.codeProperty]);
                                          totalName.push(node[scope.titleProperty]);
                                          scope.totalSelection++;
                                      }
                                  }


                              });
                          }
                      });
                  };



                  function checkDisableForPartialNode(node) {
                      if (scope.treeConfig.requestParameter) {
                          if (!scope.treeConfig.requestParameter.getComplete && scope.treeConfig.requestParameter.contactCode && node.selection == '2') {

                              node.disabled = true;

                          } else {
                              node.disabled = false;
                          }
                      } else {
                          node.disabled = false;
                      }

                  };

                  function setLevelWiseDataSource(data, parent) {
                      _.each(data[dataProperty], function (n) {
                          _.each(n[levelWiseDataProperty], function (d) {
                              d.selection = (parent && parent.selection && (parent.selection == "1" || parent.selection == "0") /*&& !scope.isSingleSelect*/) ? parent.selection : (d.IsSelected == false || d.IsSelected == null || d.IsSelected) ? getSelectionState(d.IsSelected) : '0';
                              //checkDisableForPartialNode(d);
                              d[parentCodeStringConstant] = parent && parent[parentCodeStringConstant] ? parent[parentCodeStringConstant] + '>' + d[scope.codeProperty] : (d[scope.levelProperty] > 1) ? parent[scope.codeProperty] + '>' + d[scope.codeProperty] : "";
                              d[parentStringConstant] = parent && parent[parentStringConstant] ? parent[parentStringConstant] + ' > ' + d[scope.titleProperty] : (d[scope.levelProperty] > 1) ? parent[scope.titleProperty] + ' > ' + d[scope.titleProperty] : "";
                              if (baseLevelExpectNode[d[scope.codeProperty]]) {
                                  d.selection = getStateForNode(d);
                                  scope.expandNode(d);
                                  delete baseLevelExpectNode[d[scope.codeProperty]];
                              }
                          });
                          levelWiseData[levelKey + n.Level] = _.isArray(levelWiseData[levelKey + n.Level]) ? levelWiseData[levelKey + n.Level].concat(n[levelWiseDataProperty]) : n[levelWiseDataProperty];
                      });
                  };
                  function setLevelWiseData(data, parent) {
                      _.each(data[dataProperty], function (n) {
                          _.each(n[levelWiseDataProperty], function (d) {
                              if (scope.treeType == treeTypeObject) {
                                  var parentSelection = parent.selection,
                                      dIsSelected = d.IsSelected;
                                  d.selection = (parent && parentSelection && (parentSelection == "1" || parentSelection == "0") /*&& !scope.isSingleSelect*/) ? parent.selection : (dIsSelected == false || dIsSelected == null || dIsSelected) ? getSelectionState(dIsSelected) : '0';

                              }
                              else {
                                  d.selection = '0';
                              }
                              if (scope.treeType == treeTypeObject) {
                                  if (isLazyLoadServerData) {
                                      totalID.push(d[scope.codeProperty]);
                                      totalName.push(d[scope.titleProperty]);
                                      scope.totalSelection++;
                                  }
                              }

                              d[parentCodeStringConstant] = parent && parent[parentCodeStringConstant] ? parent[parentCodeStringConstant] + '>' + d[scope.codeProperty] : (d[scope.levelProperty] > 1) ? parent[scope.codeProperty] + '>' + d[scope.codeProperty] : "";
                              d[parentStringConstant] = parent && parent[parentStringConstant] ? parent[parentStringConstant] + ' > ' + d[scope.titleProperty] : (d[scope.levelProperty] > 1) ? parent[scope.titleProperty] + ' > ' + d[scope.titleProperty] : "";
                              if (baseLevelExpectNode[d[scope.codeProperty]]) {
                                  d.selection = getStateForNode(d);
                                  scope.expandNode(d);
                                  delete baseLevelExpectNode[d[scope.codeProperty]];
                              }
                          });
                          levelWiseData[levelKey + n.Level] = _.isArray(levelWiseData[levelKey + n.Level]) ? levelWiseData[levelKey + n.Level].concat(n[levelWiseDataProperty]) : n[levelWiseDataProperty];
                      });
                  };

                  /*function createLevelWiseDataSet(dataSet) {
                      var level = 1;
                      var parentNodes = dataSet[level - 1][levelWiseDataProperty];
                      insertParentHierarchyForFlatStrucure(parentNodes);
                      while (parentNodes) {
                          levelWiseData[levelKey + level] = parentNodes;
                          if (dataSet[level]) {
                              insertParentHierarchyForFlatStrucure(parentNodes, level, dataSet);
                          };
                          maxLevel = level;
                          level = level + 1;
                          parentNodes = (dataSet[level - 1]) ? dataSet[level - 1][levelWiseDataProperty] : null;
                      };
                  };
      
                  function insertParentHierarchyForFlatStrucure(parentNodes, level, dataSet) {
                      var fetchedData = (level) ? _.groupBy(dataSet[level][levelWiseDataProperty], scope.parentProperty) : null;
                      _.each(parentNodes, function(parent) {
                          var childForParent = (fetchedData) ? fetchedData[parent[scope.codeProperty]] : parentNodes;
                          if (childForParent) {
                              _.each(childForParent, function(node, index) {
                                  node[parentStringConstant] = parent[parentStringConstant] ? parent[parentStringConstant] + ' > ' + node[scope.titleProperty] : (node[scope.levelProperty] > 1) ? parent[scope.titleProperty] + ' > ' + node[scope.titleProperty] : "";
                                  node[parentCodeStringConstant] = parent[parentCodeStringConstant] ? parent[parentCodeStringConstant] + '>' + node[scope.codeProperty] : (node[scope.levelProperty] > 1) ? parent[scope.codeProperty] + '>' + node[scope.codeProperty] : "";
                                  node['isExpanded'] = false;
                                  node['selection'] = node['selection'] ? node['selection'] : "0";
                                  node['index'] = index;
                              });
                          }
                      });
                  };
      
                  function setLevelWiseData(data, parent) {
                      _.each(data[dataProperty], function(n) {
                          _.each(n[levelWiseDataProperty], function(d) {
                              d.selection = (parent && parent.selection && (parent.selection == "1" || parent.selection == "0") && !scope.isSingleSelect) ? parent.selection : (d.IsSelected == false || d.IsSelected == null || d.IsSelected) ? getSelectionState(d.IsSelected) : '0';
                              d[parentCodeStringConstant] = parent && parent[parentCodeStringConstant] ? parent[parentCodeStringConstant] + '>' + d[scope.codeProperty] : (d[scope.levelProperty] > 1) ? parent[scope.codeProperty] + '>' + d[scope.codeProperty] : "";
                              d[parentStringConstant] = parent && parent[parentStringConstant] ? parent[parentStringConstant] + ' > ' + d[scope.titleProperty] : (d[scope.levelProperty] > 1) ? parent[scope.titleProperty] + ' > ' + d[scope.titleProperty] : "";
      
                              if (baseLevelExpectNode[d[scope.codeProperty]]) {
                                  d.selection = getStateForNode(d);
                                  scope.expandNode(d);
                                  delete baseLevelExpectNode[d[scope.codeProperty]];
                              }
                          });
                          levelWiseData[levelKey + n.Level] = _.isArray(levelWiseData[levelKey + n.Level]) ? levelWiseData[levelKey + n.Level].concat(n[levelWiseDataProperty]) : n[levelWiseDataProperty];
                      });
                  };*/

                  function getSelectionState(val) {
                      if (val) {
                          return '1';
                      } else if (val == false) {
                          return '2';
                      } else if (val == null) {
                          return '0';
                      }
                  };

                  function resetSelectionState() {
                      _.each(scope.selectedData, function (_node) {
                          scope.selectNode(_node, '0');
                      });
                  };

                  function initatePreSelection() {
                      resetSelectionState();
                      _.each(preselection, function (preselectionNode) {
                          var searchLevel = 1;
                          while (searchLevel <= maxLevel) {
                              var foundNode = _.groupBy(levelWiseData[levelKey + searchLevel], scope.codeProperty)[preselectionNode];
                              if (foundNode) {
                                  scope.selectNode(foundNode[0], '1');
                                  break;
                              }
                              searchLevel = searchLevel + 1;
                          }
                      });
                  };

                  function getNodesFromServer(parent, level, bucket, pageIndex, callback) {
                      scope.isLoading = true;
                      if (scope.isError) scope.isError = false;
                      if (parent)
                          parent.childLoading = true;

                      var reqPayLoad = {
                          "LevelAt": level,
                          "PageNumber": (!parent) ? pageIndex : null,
                          "PageSize": (!parent) ? bucket : null
                      };
                      reqPayLoad[nodeExpandingCodeProperty] = (parent) ? parent[scope.codeProperty] : null;
                      //RESTApi.getData(scope.treeConfig.navigationContext, function (responseData) {
                      //RESTApi.getData(scope.treeConfig.requestParameter.navigationContext, function (responseData) {
                      RESTApi.getData(navContext,
                          function (responseData) {
                          if (responseData.action == 'success') {
                              scope.isLoading = false;
                          } else {
                              scope.isError = true;
                              scope.noRecordsFound = true;
                          }
                          var level = (responseData.data.data[dataProperty] && responseData.data.data[dataProperty].length > 0) ? responseData.data.data[dataProperty][0].Level : null;
                          maxLevel = (level && maxLevel < level) ? level : maxLevel;
                          callback(parent, responseData, true, bucket, pageIndex);
                      }, reqPayLoad, false, scope.treeType);
                  };


                  function getRequestedDataFromCache(parent, bucket, pageIndex) {
                      var childSearchLevel = (parent) ? parent[scope.levelProperty] + 1 : 1;
                      var parentCodeStringIterator;
                      var result = (parent) ? _.groupBy(levelWiseData[levelKey + childSearchLevel], scope.parentProperty)[parent[scope.codeProperty]] : levelWiseData[levelKey + childSearchLevel];
                      if (scope.treeConfig.isReadOnly) {
                          result = result ? result : [];
                          return {
                              "data": result,
                              "searchLevel": childSearchLevel
                          };
                      }
                      var startIndex = (pageIndex - 1) * bucket;
                      var bucketData = (bucket && result) ? result.slice(startIndex, startIndex + bucket) : (result) ? result : [];
                      return {
                          "data": bucketData,
                          "searchLevel": childSearchLevel
                      };
                  };

                  function getChildsForParentAsPerBucket(parent, bucket, pageIndex, callback) {
                      if (parent != undefined) {
                          if (parent.ChildCount != undefined && parent.ChildCount > 0) {
                              bucket = parent.ChildCount;
                          }
                      }
                      var cachedDataSet = getRequestedDataFromCache(parent, bucket, pageIndex);
                      var bucketData = cachedDataSet.data;
                      var searchLevel = cachedDataSet.searchLevel;

                      if (bucketData.length > 0) {
                          callback(parent, bucketData, false, bucket, pageIndex);
                      } else {
                          getNodesFromServer(parent, searchLevel, bucket, pageIndex, callback);
                      }
                  };

                  function lazyLoadLevelWiseData(markerNode) {
                      var parentSearchLevel = markerNode[scope.levelProperty] - 1;
                      var markerNodeParent = markerNode[scope.parentProperty];
                      var parent = _.find(levelWiseData[levelKey + parentSearchLevel], function (node) {
                          return node[scope.codeProperty] == markerNodeParent;
                      });

                      if (parent && parent.children && parent.children.length % lazyLoadingBucket != 0) {
                          return;
                      };

                      getChildsForParentAsPerBucket(parent, lazyLoadingBucket, (parent) ? (parent.children.length / lazyLoadingBucket) + 1 : (scope.categories.length / lazyLoadingBucket) + 1, createTreeStructure);
                  };

                  var searchString = "";
                  var searchLevel;
                  var searchDataYetToBeDisplayed = [];
                  var searchWithContainsHitResult = [];
                  scope.searchResults = [];

                  function searchAsPerBucketSize(searchStr, bucket, isMaintainSearchPointer) {
                      if (!isMaintainSearchPointer) {
                          if (searchString != searchStr) {
                              searchString = searchStr;
                              searchLevel = maxLevel;
                              searchDataYetToBeDisplayed.length = 0;
                              searchWithContainsHitResult.length = 0;
                              scope.searchResults.length = 0;
                          };
                      }
                      var searchData = getDataAsPerBucketSize(searchStr, bucket);
                      if (!isMaintainSearchPointer && searchData.length == 0 && scope.searchResults.length === 0) {
                          scope.noRecordsFound = true;
                      } else {
                          scope.noRecordsFound = false;
                      }

                      var cancelTout = $timeout(function () {
                          scope.searchResults = scope.searchResults.concat(searchData);
                          if (scope.searchResults.length > 0) {
                              scope.noRecordsFound = false;
                          } else {
                              scope.noRecordsFound = true;
                          }
                          $timeout.cancel(cancelTout);
                          cancelTout = null;
                      });
                  };

                  function getOffsetSearchData(bucket) {
                      var partitionedData = _.partition(searchDataYetToBeDisplayed, function (data, index) {
                          return index > (bucket - 1);
                      });
                      searchDataYetToBeDisplayed = partitionedData[0];
                      return partitionedData[1];
                  };

                  function getOffsetSearchDataForContainsSearch(bucket) {
                      var partitionedData = _.partition(searchWithContainsHitResult, function (data, index) {
                          return index > (bucket - 1);
                      });
                      searchWithContainsHitResult = partitionedData[0];
                      return partitionedData[1];
                  };

                  function getDataAsPerBucketSize(searchStr, bucket) {
                      var bucketData = [];
                      while (bucketData.length < bucket && searchLevel > 0) {
                          var offsetSearchData = getOffsetSearchData(bucket);
                          if (offsetSearchData.length == bucket) {
                              bucketData = offsetSearchData;
                              break;
                          }
                          var searchData = _.filter(levelWiseData[levelKey + searchLevel], function (node) {
                              return -1 != node[scope.titleProperty].toLowerCase().indexOf(searchString.toLowerCase());
                          });

                          var containsSarchResult = _.filter(levelWiseData[levelKey + searchLevel], function (node) {
                              return new RegExp("(" + _.compact(searchString.split(' ')).join('|') + ")", "gi").test(node[scope.titleProperty]) && -1 == node[scope.titleProperty].toLowerCase().indexOf(searchString.toLowerCase());
                          });
                          searchWithContainsHitResult = searchWithContainsHitResult.concat(containsSarchResult);
                          var qumulativeData = offsetSearchData.concat(searchData);
                          var partitionedData = _.partition(qumulativeData, function (data, index) {
                              return index > (bucket - 1);
                          });
                          searchDataYetToBeDisplayed = searchDataYetToBeDisplayed.concat(partitionedData[0]);
                          bucketData = bucketData.concat(partitionedData[1]);
                          searchLevel = searchLevel - 1;
                      }
                      if (searchLevel == 0) {
                          while (bucketData.length < bucket) {
                              var containsSearchDataToBeAppended = getOffsetSearchDataForContainsSearch(bucket);
                              if (containsSearchDataToBeAppended.length > 0) {
                                  bucketData = bucketData.concat(containsSearchDataToBeAppended);
                              } else {
                                  break;
                              }
                          }
                      }
                      return bucketData;
                  };

                  function closeChildsForParent(parent) {
                      getChildsForParentAsPerBucket(parent, null, null, function (parent, data) {
                          var childs = _.filter(data, function (childNode) {
                              return childNode.isExpanded;
                          });
                          _.each(childs, function (child) {
                              child.isExpanded = false;
                              child.children = [];
                              closeChildsForParent(child);
                          });
                      });

                  };

                  scope.searchText = '';
                  scope.searchFieldVal = '';

                  scope.expandNode = function (node, index) {
                      node.isExpanded = !node.isExpanded;
                      if (node.isExpanded) {
                          getChildsForParentAsPerBucket(node, lazyLoadingBucket, 1, createTreeStructure);
                      } else {
                          node.children = [];
                          removeMarkerForParent(node);
                      }
                  };

                  var createTreeStructure = function (node, data, isService, bucket, pageIndex) {
                      if (isService) {
                          if (node) {
                              node.childLoading = false;
                              node.lazyLoading = false;
                          }
                          if (data.action == 'success') {
                              setLevelWiseData(data.data.data, node);
                              if (node && data.data.data[dataProperty][0]) {
                                  if (!node.children) {
                                      node.children = getRequestedDataFromCache(node, bucket, pageIndex).data;
                                  } else {
                                      node.children = node.children.concat(getRequestedDataFromCache(node, bucket, pageIndex).data);
                                  }
                                  if (node.children.length % lazyLoadingBucket == 0) {
                                      lazyLoadMarker.push(node.children[node.children.length - 1]);
                                  }
                              } else {
                                  scope.categories[scope.categories.length - 1].lazyLoading = false;
                                  scope.categories = scope.categories.concat(data.data.data[dataProperty][0][levelWiseDataProperty]);
                                  if (scope.categories.length % lazyLoadingBucket == 0) {
                                      lazyLoadMarker.push(scope.categories[scope.categories.length - 1]);
                                  }
                              }
                          } else {
                              console.log('service failure');
                          }
                      } else {
                          var toutCancel = $timeout(function () {
                              if (node) {
                                  if (node && node.children && node.children.length > 0)
                                      node.children[node.children.length - 1].lazyLoading = false;
                                  //node.children = (node.children) ? node.children.concat(data) : data;
                                  node.children = (node.children) ? ((scope.treeConfig.getAllLazyLoadedData) ? data : node.children.concat(data)) : data;

                                  if ((!scope.treeConfig.isReadOnly) && (node.children.length % lazyLoadingBucket == 0)) {
                                      lazyLoadMarker.push(node.children[node.children.length - 1]);
                                  }
                              } else {
                                  scope.categories[scope.categories.length - 1].lazyLoading = false;
                                  scope.categories = scope.categories.concat(data);
                                  if ((!scope.treeConfig.isReadOnly) && (scope.categories.length % lazyLoadingBucket == 0)) {
                                      lazyLoadMarker.push(scope.categories[scope.categories.length - 1]);
                                  }
                              }
                              $timeout.cancel(toutCancel);
                              toutCancel = null;
                          });
                      }
                  };

                  function removeMarkerForParent(parent) {
                      var childMarkers = _.filter(lazyLoadMarker, function (node, index) {
                          return -1 != node[parentCodeStringConstant].indexOf(parent[scope.codeProperty]);
                      });
                      lazyLoadMarker = _.difference(lazyLoadMarker, childMarkers);
                      closeChildsForParent(parent);
                  };

                  var filterTextTimeout;
                  scope.searchAndSelectNode = function (e) {
                      
                      //scope.$apply();
                      //if (filterTextTimeout) {
                          //$timeout.cancel(filterTextTimeout);
                          //filterTextTimeout = null;
                      //}
                      //if (scope.searchFieldVal.length <= 2) {
                         // scope.noRecordsFound = false;
                          //serverSearchVal = "";
                         // scope.searchResults.length = 0;
                          //searchDataYetToBeDisplayed.length = 0;
                          //searchWithContainsHitResult.length = 0;
                      //} else {
                          //scope.noRecordsFound = false;
                      var filterTextTimeout = $timeout(function () {
                          scope.noRecordsFound = false;
                              if (scope.searchFieldVal.length <= 2) {
                                  // scope.noRecordsFound = false;
                                  serverSearchVal = "";
                                  // scope.searchResults.length = 0;
                                  searchDataYetToBeDisplayed.length = 0;
                                  searchWithContainsHitResult.length = 0;
                              } else if (scope.searchFieldVal.length >= 3) {
                                  if (!isLazyLoadServerData) {
                                  searchAsPerBucketSize(scope.searchFieldVal, searchBucket, false);
                              } else {
                                  getSearchDataFromServer(searchBucket, createModelForSearchData, scope.searchFieldVal);
                              }
                              }
                              $timeout.cancel(filterTextTimeout);
                              filterTextTimeout = null;
                              scope.cancelTitle = e.target.value == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                          }, 500);
                      //}
                  };


                  scope.selectAll = function () {
                      scope.isPartiallySelected = false;
                      if (selectAllBool) {
                          for (var key in levelWiseData) {
                              _.each(levelWiseData[key], function (data, n) {
                                  //if (data.disabled == false) {
                                      data.selection = "0";
                                  //}
                                  scope.selectedData = (key == (levelKey + '1')) ? [] : [];
                              });
                          }
                          scope.getUserSelectionArray = [];
                          scope.totalSelection = 0;
                          totalID = [];
                          totalName = [];
                      } else {
                          for (var key in levelWiseData) {
                              _.each(levelWiseData[key], function (data, n) {
                                  if (data.disabled != true) {
                                      data.selection = "1";
                                  }
                                  scope.selectedData = (key == (levelKey + '1')) ? levelWiseData[levelKey + '1'] : scope.selectedData;
                                  var index = totalID.indexOf(data[scope.codeProperty]);
                                  if (index > -1) {
                                  } else {
                                      totalID.push(data[scope.codeProperty]);
                                      totalName.push(data[scope.titleProperty]);
                                      scope.totalSelection++;
                                  }
                              });
                          }
                      }
                  }

                  scope.clearAllSelection = function () {
                      for (var key in levelWiseData) {
                          _.each(levelWiseData[key], function (data, n) {
                              data.selection = "0";
                              //scope.selectedData = (key == (levelKey + '1'))  ? [] : [];
                              //scope.getUserSelectionArray = [];
                          });
                      }
                      scope.selectedData = [];
                      scope.getUserSelectionArray = [];
                      scope.totalSelection = 0;
                      totalID = [];
                      totalName = [];
                      scope.isPartiallySelected = false;
                  }


                  scope.selectNode = function (node, selectionState, byPassIsLazyLoadCheck, recursive, siblingNods) {
                      if (isLazyLoadServerData && scope.searchFieldVal.length > 0 && !byPassIsLazyLoadCheck) {
                          completeModelFromServerIfNeeded(node);
                          if (scope.config.useAs == 'inline') {
                              getSelections();
                          }
                          return;
                      }

                      //updateSelectionObject(node, selectionState);
                      if (scope.isSingleSelect) {
                          if (scope.selectedData.length > 0 && scope.selectedData[0][scope.codeProperty] == node[scope.codeProperty]) {
                              if (scope.config.useAs == 'inline') {
                                  getSelections();
                              }
                              return;
                          }
                          if (scope.selectedData.length > 0 && scope.selectedData[0][scope.codeProperty] != node[scope.codeProperty]) {
                              scope.clearAllSelection();
                          };
                          node.selection = selectionState;
                          scope.selectedData = [node];
                          scope.totalSelection = scope.selectedData.length;
                      } else {
                          node.selection = selectionState;
                          updateSelectionObject(node, selectionState);
                          updateChildsForNode(node, selectionState);
                      }
                      //updateChildsForNode(node, selectionState);
                      updateParentForNode(node, selectionState, recursive);
                      updateUserSelection(node, selectionState);
                      if (scope.treeType == treeTypeObject) {
                      } else {
                          //working perfect in project team
                          scope.totalSelection = scope.selectedData.length;
                      }

                      if (scope.config.useAs == 'inline') {
                          getSelections();
                      }

                      if (scope.totalSelection == 0) {
                          scope.isPartiallySelected = false;
                      } else {
                          scope.isPartiallySelected = !scope.getSelectAllBool();
                      }
                  };
                  function getInsSelectedNode(siblingNods) {
                      var r,
                          len = siblingNods.length;
                      for (var x = 0; x < len; x++) {
                          var selection = siblingNods[x].selection;
                          if (selection == "1" || selection == "2") {
                              r = siblingNods[x];
                              break;
                          }
                      }
                      return r;
                  };
                  function updateSelectionObject(node, selectionState) {
                      switch (selectionState) {
                          case '0':
                              //scope.selectedData = _.without(scope.selectedData, node);
                              scope.selectedData = _.filter(scope.selectedData, function (data) {
                                  return data[scope.codeProperty] != node[scope.codeProperty];
                              });
                              scope.totalSelection = scope.totalSelection - 1;
                              var index = totalID.indexOf(node[scope.codeProperty]);
                              if (index > -1) {
                                  totalID.splice(index, 1);
                                  totalName.splice(index, 1);
                              }
                              break;
                          case '1':
                              scope.selectedData.push(node);
                              scope.totalSelection = scope.totalSelection + 1;
                              totalID.push(node[scope.codeProperty]);
                              totalName.push(node[scope.titleProperty]);
                              break;
                      }
                  };
                  function updateUserSelection(node, selectionState) {
                      switch (selectionState) {
                          case '0':
                              scope.getUserSelectionArray = _.filter(scope.getUserSelectionArray, function (data) { return data[scope.codeProperty] != node[scope.codeProperty] });//_.without(scope.getUserSelectionArray, node);
                              break;
                          case '1':
                              scope.getUserSelectionArray.push(node);
                              break;
                      }
                  }

                  /*function updateParentForNode(node, selectionState) {
                   var depthLevel = node[scope.levelProperty] - 1;
                   var immediateParentCode = node[scope.parentProperty].toString();
                   while (depthLevel > 0) {
                    var parent = _.find(levelWiseData[levelKey + depthLevel], function(node) {
                     return node[scope.codeProperty] == immediateParentCode;
                   });
                    if (!parent && depthLevel == 1) {
                     baseLevelExpectNode[node[parentCodeStringConstant].split('>')[0]] = true;
                     parent = {};
                     parent[scope.codeProperty] = node[parentCodeStringConstant].split('>')[0];
                     parent[scope.levelProperty] = 1;
                     parent[scope.parentProperty] = parent[scope.codeProperty];
                   }
                   if (parent) {
                     immediateParentCode = parent[scope.parentProperty].toString();
                     if (!parent['isExpanded']) {
                      scope.expandNode(parent);
                    }
                    if (!scope.isSingleSelect) {
                      parent.selection = getStateForNode(parent);
                    }
                  }
                  depthLevel = depthLevel - 1;
                }
              };*/

                  function updateParentForNode(node, selectionState, recursive) {

                      var depthLevel = node[scope.levelProperty] - 1;
                      var immediateParentCode = node[scope.parentProperty].toString();

                      while (depthLevel > 0) {
                          var parent = _.find(levelWiseData[levelKey + depthLevel], function (node) {
                              return node[scope.codeProperty] == immediateParentCode;
                          });
                          if (!parent && depthLevel == 1) {
                              baseLevelExpectNode[node[parentCodeStringConstant].split('>')[0]] = true;
                              parent = {};
                              parent[scope.codeProperty] = node[parentCodeStringConstant].split('>')[0];
                              parent[scope.levelProperty] = 1;
                              parent[scope.parentProperty] = parent[scope.codeProperty];
                          }
                          //if (parent && !parent.disabled) {
                          if (parent && !parent.disabled) {
                              immediateParentCode = parent[scope.parentProperty].toString();
                              if (!parent['isExpanded']) {
                                  scope.expandNode(parent);
                              }
                              //if (!scope.isSingleSelect) {
                              parent.selection = getStateForNode(parent, parent.selection);
                              //}
                          } else {
                              immediateParentCode = parent[scope.parentProperty].toString();
                              if (!parent['isExpanded']) {
                                  scope.expandNode(parent);
                              }
                              //if (!scope.isSingleSelect) {
                              var tempSelection = getStateForNode(parent, parent.selection);
                              parent.selection = "2";
                              //}
                          }
                          depthLevel = depthLevel - 1;

                          immediateParentCode = parent[scope.parentProperty].toString();
                      }
                  };

                  function getStateForNode(node, parentSelection) {

                      var depthLevel = node[scope.levelProperty] + 1;
                      var parentCode = node[scope.codeProperty];
                      var groupByData = _.groupBy(levelWiseData[levelKey + depthLevel], scope.parentProperty);
                      var childCount = groupByData[parentCode].length;
                      var selectedChild = _.filter(groupByData[parentCode], function (node) {
                          return node.selection == '1';
                      });
                      var partiallySelectedChild = _.filter(groupByData[parentCode], function (node) {
                          return node.selection == '2';
                      });


                      /*
                        if (childCount == selectedChild.length) {
                          //scope.selectedData = _.difference(scope.selectedData, selectedChild);
                          //JJ Add Later
                          scope.selectedData = _.filter(scope.selectedData,function(data,n)
                          {
                            return data[scope.parentProperty] !=parentCode;
                          });
                      
                          scope.selectedData.push(node);
                          return "1";
                        } else if ((selectedChild.length + partiallySelectedChild.length) > 0) {
                         scope.selectedData = _.union(scope.selectedData, selectedChild);
                      
                         scope.selectedData = _.uniq(scope.selectedData,function(item,jey,a) {
                          return item[scope.codeProperty]; 
                        });
                         //scope.selectedData = _.without(scope.selectedData, node);
                         scope.selectedData = _.filter(scope.selectedData,function(data,n)
                         {
                          return data[scope.codeProperty] != node[scope.codeProperty];
                        });
                      
                         return "2";
                       } else {
                         scope.selectedData = _.union(scope.selectedData, selectedChild);
                         scope.selectedData = _.filter(scope.selectedData, function(data)
                         {
                          return data[scope.codeProperty] != node[scope.codeProperty];
                        });
                         //scope.selectedData = _.without(scope.selectedData, node);
                         return "0";
                       }
                       */

                      if (scope.isSingleSelect) {
                          return "0";
                      } else {
                          if (scope.treeType == treeTypeObject) {
                              if (childCount == selectedChild.length) {

                                  ///scope.selectedData = _.difference(scope.selectedData, selectedChild);

                                  scope.selectedData = _.filter(scope.selectedData, function (data) {
                                      return data[scope.parentProperty] != parentCode;
                                  });

                                  scope.selectedData.push(node);
                                  //Manage Total Selection and TotalName nd ID  
                                  scope.totalSelection = scope.totalSelection + 1;
                                  var index = totalID.indexOf(node[scope.codeProperty]);
                                  if (index > -1) {
                                  } else {
                                      totalID.push(node[scope.codeProperty]);
                                      totalName.push(node[scope.titleProperty]);
                                  }//Ends

                                  return "1";

                              } else if ((selectedChild.length + partiallySelectedChild.length) > 0) {

                                  scope.selectedData = _.union(scope.selectedData, selectedChild);

                                  scope.selectedData = _.uniq(scope.selectedData, function (item, key, a) {
                                      return item[scope.codeProperty];
                                  });

                                  scope.selectedData = _.filter(scope.selectedData, function (data) {
                                      return data[scope.codeProperty] != node[scope.codeProperty]
                                  }); //_.without(scope.selectedData, node);



                                  //Manage Total Selection and TotalName nd ID
                                  if (parentSelection != "0" && parentSelection != "2") {
                                      scope.totalSelection = scope.totalSelection - 1;
                                  }
                                  var index = totalID.indexOf(node[scope.codeProperty]);
                                  if (index > -1) {
                                      totalID.splice(index, 1);
                                      totalName.splice(index, 1);
                                  }
                                  //Ends


                                  return "2";
                              } else {

                                  scope.selectedData = _.union(scope.selectedData, selectedChild);

                                  scope.selectedData = _.filter(scope.selectedData, function (data) {
                                      return data[scope.codeProperty] != node[scope.codeProperty]
                                  });

                                  //_.without(scope.selectedData, node);

                                  //Manage Total Selection and TotalName nd ID
                                  var index = totalID.indexOf(node[scope.codeProperty]);
                                  if (index > -1) {
                                      totalID.splice(index, 1);
                                      totalName.splice(index, 1);
                                      scope.totalSelection = scope.totalSelection - 1;
                                  }//Ends
                                  return "0";
                              }
                          } else {

                              //Non Generic Tree management
                              //it will not having parent selection full means 1 even if all childs are selected.
                              if (childCount == selectedChild.length) {
                                  //scope.selectedData = selectedChild;
                                  scope.selectedData = _.union(scope.selectedData, selectedChild);
                                  return "2";

                              } else if ((selectedChild.length + partiallySelectedChild.length) > 0) {

                                  scope.selectedData = _.union(scope.selectedData, selectedChild);

                                  scope.selectedData = _.uniq(scope.selectedData, function (item, key, a) {
                                      return item[scope.codeProperty];
                                  });

                                  scope.selectedData = _.filter(scope.selectedData, function (data) { return data[scope.codeProperty] != node[scope.codeProperty] });
                                  //_.without(scope.selectedData, node);
                                  return "2";
                              } else {
                                  scope.selectedData = _.union(scope.selectedData, selectedChild);
                                  scope.selectedData = _.filter(scope.selectedData, function (data) { return data[scope.codeProperty] != node[scope.codeProperty] });//_.without(scope.selectedData, node);
                                  return "0";
                              }
                          }
                      }


                  };



                  /*
                  function updateChildsForNode(node, selectionState) {
                    var depthLevel = node[scope.levelProperty] + 1;
                    var parentCode = node[scope.codeProperty].toString();
                    while (depthLevel <= maxLevel) {
                     var childs = _.filter(levelWiseData[levelKey + depthLevel], function(node) {
                      return -1 != node[parentCodeStringConstant].indexOf(parentCode);
                    });
                     _.each(childs, function(child) {
                      child.selection = selectionState;
                      if (selectionState == "1") {
                       //scope.selectedData = _.without(scope.selectedData, child);
                       scope.selectedData =_.filter(scope.selectedData,function(data)
                       {
                        return data[scope.codeProperty] != child[scope.codeProperty];
                      });
                     };
                   });
                     depthLevel = depthLevel + 1;
                   }
                   if (isLazyLoadServerData) {
                     updateChildsForSelectedData(node);
                   }
                  }*/

                  function updateChildsForNode(node, selectionState) {

                      var depthLevel = node[scope.levelProperty] + 1;
                      var parentCode = node[scope.codeProperty].toString();
                      var tempNode = node;
                      while (depthLevel <= maxLevel) {
                          var childs = _.filter(levelWiseData[levelKey + depthLevel], function (node) {
                              //return -1 != node[parentCodeString].indexOf(parentCode)
                              var parentCodesofNode = node[parentCodeStringConstant].split(">");
                              return -1 != parentCodesofNode.indexOf(parentCode);
                          });


                          _.each(childs, function (child) {
                              if (scope.treeType == treeTypeObject) {
                                  var codeProp = child[scope.codeProperty];
                                  if (selectionState == "1") {
                                      //Work in laziloading false
                                      scope.totalSelection = (child.selection == "1") ? scope.totalSelection : scope.totalSelection + 1;
                                      scope.selectedData = _.filter(scope.selectedData, function (data) {
                                          return data[scope.codeProperty] != codeProp;
                                      });
                                      //closed//_.without(scope.selectedData, child);
                                      var index = totalID.indexOf(codeProp);
                                      if (index > -1) {
                                      } else {
                                          totalID.push(codeProp);
                                          totalName.push(codeProp);
                                      }
                                  } else {
                                      scope.totalSelection = scope.totalSelection - 1;
                                      var index = totalID.indexOf(codeProp);
                                      if (index > -1) {
                                          totalID.splice(index, 1);
                                          totalName.splice(index, 1);
                                      }
                                  }

                                  if (!(selectionState == "1" && scope.isSingleSelect)) {
                                      child.selection = selectionState;
                                  }

                                  scope.getUserSelectionArray = _.filter(scope.getUserSelectionArray, function (data) {
                                      return data[scope.codeProperty] != child[scope.codeProperty]
                                  });//_.without(scope.selectedData, child);
                                  //jayesh add
                              } else {
                                  child.selection = "0";
                                  scope.selectedData = _.filter(scope.selectedData, function (data) {
                                      return data[scope.codeProperty] != child[scope.codeProperty]
                                  });//_.without(scope.selectedData, child);
                              }
                              /*scope.getUserSelectionArray = _.filter(scope.getUserSelectionArray,function(data){
                              
                                return data[scope.codeProperty] != child[scope.codeProperty]
                              });//_.without(scope.selectedData, child);*/
                          });

                          depthLevel = depthLevel + 1;
                      }
                      //if (isLazyLoadServerData) {
                      updateChildsForSelectedData(node);
                      //}
                  }



                  function updateChildsForSelectedData(node) {
                      var searchHits = [];
                      _.each(scope.selectedData, function (data) {
                          if (-1 != data[parentCodeStringConstant].indexOf(node[scope.codeProperty].toString())) {
                              searchHits.push(data);
                          }
                      });
                      _.each(searchHits, function (hits) {

                          //scope.selectedData = _.without(scope.selectedData, hits);
                          scope.selectedData = _.filter(scope.selectedData, function (data) {
                              return data[scope.codeProperty] != hits[scope.codeProperty];
                          });


                      });
                  }

                  var uniqueIDGenerator = function () {
                      var d = new Date().getTime();
                      var uniqueID = 'xxx2xxxpxxxoxxx'.replace(/[xy]/g, function (c) {
                          var r = (d + Math.random() * 16) % 16 | 0;
                          d = Math.floor(d / 16);
                          return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                      });
                      return uniqueID;
                  };
                  var cancelToutOnScroll;
                  scope.scroll = function () {
                      if (cancelToutOnScroll) {
                          $timeout.cancel(cancelToutOnScroll);
                          cancelToutOnScroll = null;
                      }
                      cancelToutOnScroll = $timeout(function () {
                          if (!lazyLoadOffset) {
                              //lazyLoadOffset = angular.element("#treeComponentContainer-" + scope.hierarchyCounter)[0].getBoundingClientRect().bottom;
                              var link = (angular.element("#treeComponentContainer"));
                              var position = link.position();
                              var right = $(window).width();
                              lazyLoadOffset = $(window).height();
                          };
                          var lazyLoadLen = lazyLoadMarker.length;
                          if (lazyLoadLen > 0 && scope.searchFieldVal.length == 0) {
                              var markerNode = lazyLoadMarker[lazyLoadLen - 1],
                                  markerNodeSelect = angular.element("#" + markerNode[scope.codeProperty]);
                              if ((markerNodeSelect.length > 0) && markerNodeSelect[0].getBoundingClientRect().top <= lazyLoadOffset) {
                                  markerNode.lazyLoading = true;
                                  lazyLoadMarker.length = (lazyLoadLen > 0) ? lazyLoadLen - 1 : 0;
                                  lazyLoadLevelWiseData(markerNode);
                              }
                          }
                      }, 20);                      
                  };
                  var scrollEndTout;
                  scope.scrollEnd = function () {
                      if (scrollEndTout) {
                          $timeout.cancel(scrollEndTout);
                          scrollEndTout = null;
                      }
                      scrollEndTout = $timeout(function () {
                          if (scope.searchFieldVal.length > 2) {
                              if (!isLazyLoadServerData) {
                                  searchAsPerBucketSize(scope.searchFieldVal, searchBucket, true);
                              } else {
                                  getSearchDataFromServer(searchBucket, createModelForSearchData, scope.searchFieldVal, true);
                              }
                           }                              
                      }, 20);
                      
                  };

                  /*lazyLoadOffset = angular.element("#treeComponentContainer")[0].getBoundingClientRect().bottom;
                  console.log(lazyLoadOffset);
                  angular.element('.scrollbar-outer').scrollbar({
                      onScroll : function(y, x) {
                          //console.log('marker length -- '+lazyLoadMarker.length);
                          if (lazyLoadMarker.length > 0 && scope.searchFieldVal.length == 0) {
                              var markerNode = lazyLoadMarker[lazyLoadMarker.length - 1];
                              if (angular.element("#"+markerNode[scope.codeProperty])[0].getBoundingClientRect().top <= lazyLoadOffset) {
                                  console.log(markerNode);
                                  markerNode.lazyLoading = true;
                                  lazyLoadMarker.length = (lazyLoadMarker.length > 0) ? lazyLoadMarker.length - 1 : 0;
                                  lazyLoadLevelWiseData(markerNode);
                                  console.log(lazyLoadMarker.length);
                              }
                          }
                          if (y.maxScroll > 0 && y.scroll == y.maxScroll && scope.searchFieldVal.length > 0) {
                              if (!isLazyLoadServerData) {
                                  searchAsPerBucketSize(scope.searchFieldVal, searchBucket);
                              } else {
                                  getSearchDataFromServer(searchBucket, createModelForSearchData, scope.searchFieldVal, true);
                              }
                          }
                      }
                  });*/

                  var massageSelectedData = function (data) {
                      _.each(data, function (e) {
                          if (e['children'])
                              delete e['children'];
                      });
                      return data;
                  };


                  var newtotalID = [];
                  var newtotalName = [];


                  var getSelections = function () {

                      _.each(scope.selectedData, function (node) {
                          if (node.disabled) {
                              scope.selectedData = _.without(scope.selectedData, node);
                          }
                      });

                      newtotalID = [];
                      newtotalName = [];

                      var tCancel = $timeout(function () {
                          scope.treeConfig.selectType = scope.selectType.code;
                          var outPutObject = {
                              'selectType': scope.selectType.code,
                              'selections': massageSelectedData(scope.selectedData)
                          };

                          _.each(outPutObject.selections, function (data) {
                              newtotalID.push(data[scope.codeProperty]);
                              newtotalName.push(data[scope.titleProperty]);
                          });

                          outPutObject["selectionIds"] = newtotalID;
                          outPutObject["selectionNames"] = newtotalName;
                          if (scope.treeType == treeTypeObject) {
                              outPutObject["selectionAllIds"] = totalID;
                              outPutObject["selectionAllNames"] = totalName;
                          }

                          var hierarchyCollection = [];
                          _.each(scope.selectedData, function (node) {
                              if (node[scope.levelProperty] > 1) {
                                  var parentHierarchy = node[parentCodeStringConstant].split('>');
                                  var parentTraversalArray = [];
                                  _.each(parentHierarchy, function (parentNode, index) {
                                      var found = _.clone(_.find(levelWiseData[levelKey + (index + 1)], function (data) {
                                          return data[scope.codeProperty] == parentNode;
                                      }));
                                      if (found && found['children'])
                                          delete found['children'];
                                      parentTraversalArray.push(found);
                                  });
                                  hierarchyCollection.push(parentTraversalArray);
                              } else {
                                  hierarchyCollection.push([node]);
                              }
                          });

                          /*if(scope.treeConfig.getHierarchyOnSelection)
                          {
                            outPutObject['selectionHierarchy'] =  massageSelectedData(hierarchyCollection);
                          }
                          if(scope.treeConfig.getAllLazyLoadedData)
                          {
                            outPutObject['allLazyLoadedData'] = levelWiseData;
                          }*/


                          if (scope.treeConfig.getHierarchyOnSelection && (scope.treeType == treeTypeObject)) {
                              outPutObject['selectionHierarchy'] = massageSelectedData(hierarchyCollection);
                          }
                          if (scope.treeConfig.getUserSelection && (scope.treeType == treeTypeObject)) {
                              outPutObject['userSelection'] = massageSelectedData(scope.getUserSelectionArray);
                          }
                          if (scope.treeConfig.getAllLazyLoadedData) {
                              outPutObject['allLazyLoadedData'] = levelWiseData;
                          }
                          if (scope.isActive) {
                              scope.searchFieldVal = '';
                              scope.hideSearch();
                          }

                          doneCallback(outPutObject);
                          $timeout.cancel(tCancel);
                          tCancel = null;
                      });
                  };

                  /** seacrh for server **/

                  var searchResultPageNumber = 0;
                  var serverSearchVal = "";
                  var isLazyLoadingNode;
                  var ongoingService;
                  function getSearchDataFromServer(searchBucket, callback, searchVal, isLazyLoad) {
                      if (searchVal != serverSearchVal) {
                          serverSearchVal = searchVal;
                          searchResultPageNumber = 0;
                          scope.searchResults.length = 0;
                      }

                      scope.isLoading = true;
                      if (scope.isError) scope.isError = false;

                      if (scope.searchResults.length > 0) {
                          isLazyLoadingNode = scope.searchResults[scope.searchResults.length - 1];
                          isLazyLoadingNode.lazyLoading = true;
                      }

                      if (ongoingService && !isLazyLoad) {
                          RESTApi.abort(ongoingService);
                      }

                      ongoingService = {
                          "PageNumber": searchResultPageNumber = searchResultPageNumber + 1,
                          "PageSize": searchBucket,
                          "SearchText": scope.searchFieldVal
                      };

                      //RESTApi.getData(scope.treeConfig.navigationContext, function(responseData) {
                      //RESTApi.getData(scope.treeConfig.requestParameter.navigationContext, function(responseData) {
                      RESTApi.getData(navContext,
                          function (responseData) {
                          ongoingService = null;
                          if (responseData.action == 'success') {
                              scope.isLoading = false;
                          } else {
                              scope.isError = true;
                              scope.noRecordsFound = true;
                          }
                          callback(responseData);
                      }, ongoingService, false, scope.treeType);
                  }

                  function createModelForSearchData(data) {
                      if (isLazyLoadingNode)
                          isLazyLoadingNode.lazyLoading = false;
                      scope.searchResults = scope.searchResults.concat(getLeafNodeWithParentHierarchy(data.data.data[searchProperty]));
                  };

                  function getLeafNodeWithParentHierarchy(data) {
                      var searchList = data;
                      var searchDataCollection = [];
                      var selectedData = _.groupBy(scope.selectedData, scope.codeProperty);
                      _.each(searchList, function (searchData) {
                          var searchDataHierarchy = searchData[levelWiseDataProperty];
                          var sortedLevelSearchedData = _.sortBy(searchDataHierarchy, 'Level');
                          var searchHitNode = sortedLevelSearchedData[sortedLevelSearchedData.length - 1];
                          var parentString = "";
                          var parentCodeString = "";

                          _.each(sortedLevelSearchedData, function (data) {
                              parentString = (parentString.length > 0) ? parentString + ' > ' + data[scope.titleProperty] : data[scope.titleProperty];
                              parentCodeString = (parentCodeString.length > 0) ? parentCodeString + '>' + data[scope.codeProperty].toString() : data[scope.codeProperty].toString();
                              data[parentStringConstant] = parentString;
                              data[parentCodeStringConstant] = parentCodeString;
                              data.selection = getSelectionFromLevelWiseData(data);
                          });

                          //searchHitNode.serverData = _.groupBy(sortedLevelSearchedData, scope.codeProperty);
                          searchDataCollection.push(searchHitNode);
                      });
                      return searchDataCollection;
                  };

                  function resetSelectionForSearchNodes(node) {
                      _.each(scope.searchResults, function (searchNode) {
                          if (node[scope.codeProperty] != searchNode[scope.codeProperty] && searchNode[parentCodeStringConstant].indexOf((node[parentCodeStringConstant].length > 0) ? node[parentCodeStringConstant] : node[scope.codeProperty].toString()) != -1) {
                              searchNode.selection = node.selection;
                          } else {
                              searchNode.selection = getSelectionFromLevelWiseData(searchNode);
                          }
                      });
                  };

                  function getSelectionFromLevelWiseData(node) {
                      var searchLevel = node[scope.levelProperty];
                      var groupedLevelData = _.groupBy(levelWiseData[levelKey + searchLevel], scope.codeProperty);
                      var selectionState = (groupedLevelData[node[scope.codeProperty]]) ? groupedLevelData[node[scope.codeProperty]][0].selection : isPresentInInternalHierarchy(node) ? '1' : (node.IsSelected == false || node.IsSelected == null || node.IsSelected) ? getSelectionState(node.IsSelected) : '0';
                      return selectionState;
                  };

                  function isPresentInInternalHierarchy(searchNode) {
                      var retVal = false,
                          len = scope.selectedData.length;
                      for (var i = 0; i < len; i++) {
                          var node = scope.selectedData[i];
                          if (searchNode[parentCodeStringConstant].indexOf((node[parentCodeStringConstant].length > 0) ? node[parentCodeStringConstant] : node[scope.codeProperty].toString()) != -1) {
                              retVal = true;
                              break;
                          }
                      }
                      return retVal;
                  };

                  /*function completeModelFromServerIfNeeded(node) {
                      var parentHierarchy = node[parentCodeStringConstant].split('>');
                      var dataRetrivalCount = parentHierarchy.length;
                      parentHierarchy.length = dataRetrivalCount - 1;
                      var recievedData = [];
                      if (parentHierarchy.length > 0) {
                          _.each(parentHierarchy, function(PASCode, index) {
                              getChildsForParentAsPerBucket(node.serverData[PASCode][0], lazyLoadingBucket, 1, function(_node, data, isService, bucket, pageIndex) {
                                  if (isService) {
                                      if (data.action == 'success')
                                          setLevelWiseData(data.data.data, _node);
                                  };
                                  dataRetrivalCount = dataRetrivalCount - 1;
                                  if (dataRetrivalCount == 1) {
                                      updateSelectionInDataSource(node);
                                  }
                              });
                          });
                      } else {
                          updateSelectionInDataSource(node);
                      }
                  }*/

                  function completeModelFromServerIfNeeded(node) {

                      var parentHierarchy = node[parentCodeStringConstant].split('>');
                      var levelNumber = node['Level'];
                      var recievedData = [];

                      if (!(levelWiseData[levelKey + node[scope.levelProperty]] && _.find(levelWiseData[levelKey + node[scope.levelProperty]], function (data) {
                          return node[scope.codeProperty] == data[scope.codeProperty];
                      }))) {
                          var reqObj = {};
                          reqObj[nodeExpandingCodeProperty] = [parseInt(parentHierarchy[parentHierarchy.length - 1])];

                          //RESTApi.getData(scope.treeConfig.requestParameter.navigationContext, function(responseData) {
                          RESTApi.getData(navContext,
                              function (responseData) {
                              if (responseData.action == 'success') {
                                  var allResultData = responseData.data.data.PAS_SearchList[0][levelWiseDataProperty];
                                  var result = _.groupBy(allResultData, "Level");
                                  var level = 1;
                                  var levelData = [];
                                  while (level) {
                                      var obj = {};
                                      obj[levelWiseDataProperty] = result[level];
                                      obj['Level'] = level;
                                      levelData.push(obj);
                                      level = level + 1;
                                      if (!result[level])
                                          break;
                                  };
                                  createLevelWiseDataSet(levelData);
                                  updateSelectionInDataSource(node);
                              } else {
                                  console.log('error');
                              }
                          }, reqObj, true, scope.treeType);
                      } else {
                          updateSelectionInDataSource(node);
                      }
                  }

                  function updateSelectionInDataSource(node) {
                      scope.selectNode(_.find(levelWiseData[levelKey + node.Level], function (data) {
                          return data[scope.codeProperty] == node[scope.codeProperty];
                      }), (node.selection == "1") ? "0" : "1", true);
                      resetSelectionForSearchNodes(node);
                  };

                  scope.focusSearch = false;
                  scope.isActive = false;
                  scope.showMe = false;
                  scope.showSearch = function () {
                      scope.isActive = true;
                      scope.showMe = true;
                      scope.hideClose = true;
                      $timeout(function () {
                          scope.focusSearch = true;
                      }, 100); 
                  }

                  scope.hideSearch = function () {
                    if(scope.searchFieldVal != "")
                    {
                        scope.searchFieldVal = "";    
                        scope.noRecordsFound = false;
                    }
                    else
                    {
                            scope.searchFieldVal = "";
                            scope.isActive = false;
                            scope.focusSearch = false;
                            scope.hideClose = false;
                            scope.noRecordsFound = false;
                            $("#SearchBtn").focus();
                    }
                    scope.cancelTitle = scope.searchFieldVal == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                  }
                  scope.editCallback = function () {

                      scope.treeConfig.isReadOnly = false;
                      scope.categories = [];
                      lazyLoadMarker = [];
                      scope.isLoading = true;
                      scope.isError = false;
                      totalID = [];
                      totalName = [];

                      initializePromise(true, true);
                      renderLevels();
                  }

                  if (scope.config.useAs == "inline" && scope.config.export) {
                      var exportLen = scope.config.export.length;
                      for (var ex = 0; ex < exportLen; ex++) {
                          setExport(scope.config.export[ex]);
                      };
                  }

                  function setExport(key) { // setExport allow to access the isolated scope's functionality outside of directive
                      if (scope.config.useAs != "inline") return; // if not useAs inline;
                      !scope.config._export && (scope.config._export = {});
                      if (key !== undefined) {
                          scope.config._export[key] = typeof scope[key] == "function" ? function () {
                              scope[key]()
                          } : function () { return scope[key]; };
                      }
                  };

                  scope.$on('$destroy', function () {
                      deregisterConfigSelection();
                      deregReqParam();
                      deregReqContactCode();
                      deregConfigData();
                      deregSelectedNodes();
                  });
              },
              templateUrl: 'shared/directives/smartHierarchy/smartHierarchyTemplate.html'
          };
      }])
    .directive('myTemplate', function () {
            return {
                restrict: 'EA',
                templateUrl: function (elem, attr) {
                    return attr.type;
                }
            };
        })
.directive('ngIndeterminate', ["$compile", function ($compile) {
    return {
        restrict: 'A',
        link: function (scope, element, attributes) {
            scope.$watch(attributes['ngIndeterminate'], function (value) {
                element.prop('indeterminate', value);
            });
        }
    };
}])
.directive('ngHighlight', ['$compile', 'hilitor', function ($compile, hilitor) {
    return {
        restrict: 'A',
        link: function (scope, element, attributes) {
            scope.$watch(attributes['ngHighlight'], function (value) {
                new Hilitor("treeComponentContainer-" + scope.hierarchyCounter).apply(value);
            });
        }
    };
}])
.service('RESTApi', ['$http', '$q','APPCONSTANTS',
function ($http, $q, APPCONSTANTS) {
    var baseUrl;
    var documenttype='';
    if (APPCONSTANTS != undefined) {
        if (APPCONSTANTS.userPreferences.OrderData != undefined) {
            documenttype = APPCONSTANTS.userPreferences.OrderData.type.id;
        }
        if (APPCONSTANTS.userPreferences.RequisitionData != undefined) {
            documenttype = APPCONSTANTS.userPreferences.RequisitionData.type.id;
        }
        if (APPCONSTANTS.userPreferences.ProcurementProfileData != undefined) {
            documenttype = APPCONSTANTS.userPreferences.ProcurementProfileData.type.id;
        }

    }
    var callbackTracker = [];
    var userExecutionContext;
    var documentId;
    var contactCode;
    var requestObjectToBeExtended = null;
    var customeURL;

    /*if(windows.location.origin.indexOf('smartdev') > -1 || windows.location.origin.indexOf('127') > -1)
    {
      env = "DEV";
    }else if(windows.location.origin.indexOf('smartqc') > -1)
    {
      env = "QC";
    }else if(windows.location.origin.indexOf('smartuat') > -1)
    {
      env = "UAT";
    }else
    {
      env = "PROD";
    }*/

    /*this.setEnvironment = function(env)
    {
      switch(env) {
        case "DEV":
        baseUrl = 'https://gepdevsmart-rest.servicebus.windows.net/PortalRestService/';
        break;
        case "QC":
        baseUrl = 'https://gepqcsmart-rest.servicebus.windows.net/PortalRestService/';
        break;
        case "UAT":
        baseUrl = 'https://gepuatsmart-rest.servicebus.windows.net/PortalRestService/';
        break;
        case "PROD":
        baseUrl = 'https://gepsmart-rest.servicebus.windows.net/PortalRestService/';
      }
    }*/
    this.setEnvironment = function (newURL) {
        baseUrl = newURL + "PortalRestService/";
    };
    //baseUrl = APPCONSTANTS.userPreferences.URLs.AppURL;

    this.setDocumentId = function (val) {
        documentId = val;
    };
    this.setContactCode = function (val) {
        contactCode = val;
    };
    this.setUserContext = function (val) {
        userExecutionContext = val;
    };
    this.setRequestObject = function (val) {
        requestObjectToBeExtended = val;
    };
    this.setUrl = function (val) {
        customeURL = val;
    };
    function createRequest(mode, data, isOverrideInputPayload, treeType) {
        var contactPasMappingMethod,
             bpcCode ='&c=' + APPCONSTANTS.userPreferences.EncryptedBPC,
            getPasDetailsMethod,
            inputParameterKey,
            getParentForNodeUrl;
        if (!baseUrl) {
            return null;
        }
        switch (mode) {
            case "PAS":
                if (treeType == 'nonGeneric') {
                    contactPasMappingMethod = "GetContactPASMappingDetilsForProject?oloc=218" + bpcCode;
                } else {
                    contactPasMappingMethod = 'GetContactPASMappingDetails?oloc=218' + bpcCode;
                }
                getPasDetailsMethod = 'GetPASDetails?oloc=218' + bpcCode;
                inputParameterKey = 'PASInputParam_Levels';
                getParentForNodeUrl = "GetPASLevelDetailsByPASCodes?oloc=218" + bpcCode;
                break;
            case "REG":
                if (treeType == 'nonGeneric') {
                    contactPasMappingMethod = "GetContactRegionMappingDetailsForProject?oloc=218" + bpcCode;
                } else {
                    contactPasMappingMethod = 'GetContactRegionMappingDetails?oloc=218' + bpcCode;
                }
                getPasDetailsMethod = 'GetRegionDetails?oloc=218' + bpcCodes;
                inputParameterKey = 'RegionInputParam_Levels';
                getParentForNodeUrl = "GetREGIONLevelDetailsByRegionIds";
                break;

            case "ORG":
                if (treeType == 'nonGeneric') {
                    contactPasMappingMethod = "GetContactORGMappingDetailsForProject?oloc=218" + bpcCode;
                } else {
                    contactPasMappingMethod = 'GetContactOrgMappingDetails?oloc=218' + bpcCode;
                }
                getPasDetailsMethod = 'GetORGDetails?oloc=218' + bpcCode;
                inputParameterKey = 'ORG_InputParams';
                getParentForNodeUrl = "GetOrgEntityLevelDetailsByEntityDetailCodes";
                break;
        }


        var propmiseForThisInstance = $q.defer();
        var requestObject = {
            'url': baseUrl,
            'headers': {
                'Content-Type': 'application/json',
                'UserExecutionContext': null
            },
            'data': {},
            'method': 'POST',
            'timeout': propmiseForThisInstance.promise
        };
        requestObject['data'][inputParameterKey] = {
            'ContactCode': null,
            'DocumentCode': null
        };
        if (mode != undefined) {
            if (mode.toLowerCase() == 'pas' && (documenttype == '8' || documenttype == '7' || documenttype == '38')) {
                var userRestrictCategoryTree = _.where(APPCONSTANTS.userPreferences.CommonSettings.lstSettings, { "FieldName": "RestrictUserMappedCategorySelection" });
                if (userRestrictCategoryTree != undefined && userRestrictCategoryTree.length > 0) {
                    if (userRestrictCategoryTree[0].FieldValue.toLowerCase() == 'false') {
                        contactCode = null;
                    }
                }
            }
        }
        if (isOverrideInputPayload == true) {
            requestObject.url = requestObject.url + getParentForNodeUrl;
            requestObject.data = data;
        } else {
            if (contactCode) {
                requestObject.data[inputParameterKey].ContactCode = contactCode;
                requestObject.url = requestObject.url + contactPasMappingMethod;
            } else {
                requestObject.data[inputParameterKey].ContactCode = null;
                requestObject.url = requestObject.url + getPasDetailsMethod;
            }
            requestObject.data[inputParameterKey].DocumentCode = (documentId) ? documentId : null;

        }

        if (customeURL) {
            requestObject.url = customeURL;
            //getPasDetailsMethod = 'GetORGDetails';
            //inputParameterKey = 'ORG_InputParams';
            //getParentForNodeUrl = "GetOrgEntityLevelDetailsByEntityDetailCodes";
        }
        requestObject.headers.UserExecutionContext = userExecutionContext;
        requestObject.promise = propmiseForThisInstance;
        if (requestObjectToBeExtended == null && contactCode == null) {
            requestObject.data[inputParameterKey] = _.extend(requestObject.data[inputParameterKey], data);
        } else {
            requestObject.data[inputParameterKey] = _.extend(_.extend(requestObject.data[inputParameterKey], data), requestObjectToBeExtended)
        }
        return requestObject;
    };
    this.abort = function (reqParam) {
        var dataFoundOnIndex;
        var promise = _.find(callbackTracker, function (reqObj, index) {
            dataFoundOnIndex = index;
            return _.isEqual(reqParam, reqObj.data);
        }).promise;
        if (promise) {
            promise.resolve();
            console.log('canceled - ' + reqParam);
        }
    };

    this.getData = function (mode, callback, data, isOverrideInputPayload, treeType) {
        var requestObject = new createRequest(mode, data, isOverrideInputPayload, treeType);
        if (!(_.isEmpty(requestObject))) {
            callbackTracker.push({
                'key': JSON.stringify(requestObject.data),
                'callback': callback,
                'promise': requestObject.promise,
                'data': data
            });
            serviceCall(requestObject);
        }
    };

    function serviceCall(req) {
        $http(req).then(function (response) {
            var dataFoundOnIndex;
            var Callback = _.find(callbackTracker, function (reqObj, index) {
                dataFoundOnIndex = index;
                return _.isEqual(JSON.parse(reqObj.key), req.data);
            }).callback;
            callbackTracker.splice(dataFoundOnIndex, 1);
            Callback({
                'action': 'success',
                'data': response
            });
        }, function (error) {
            var dataFoundOnIndex;
            var Callback = _.find(callbackTracker, function (reqObj, index) {
                dataFoundOnIndex = index;
                return _.isEqual(JSON.parse(reqObj.key), req.data);
            }).callback;
            callbackTracker.splice(dataFoundOnIndex, 1);
            Callback({
                'action': 'failure',
                'data': error
            });
        });
    };
}]);

})(angular);
// Original JavaScript code by Chirp Internet: www.chirp.com.au
// Please acknowledge use of this code by including this header.
// 2/2013 jon: modified regex to display any match, not restricted to word boundaries.

// License at http://www.the-art-of-web.com/copyright.html

(function ( window, factory ) {

  if ( typeof module === "object" && typeof module.exports === "object" ) {
    // Expose a factory as module.exports in loaders that implement the Node
    // module pattern (including browserify).
    // This accentuates the need for a real window in the environment
    // e.g. var jQuery = require("jquery")(window);
    module.exports = function( w ) {
      w = w || window;
      if ( !w.document ) {
        throw new Error("Hilitor requires a window with a document");
      }
      return factory( w.document );
    };
  } else {
    if ( typeof define === "function" && define.amd ) {
      // AMD. Register as a named module.
      define( [], function() {
        return factory(document);
      });
    } else {
        // Browser globals
        window.Hilitor = factory(document);
    }
  }

// Pass this, window may not be defined yet
}(this, function ( document, undefined ) {


function Hilitor(id, tag, options)
{
  var targetNode = document.getElementById(id) || document.body;
  var hiliteTag = tag || "EM";
  var skipTags = new RegExp("^(?:SCRIPT|FORM|INPUT|TEXTAREA|IFRAME|VIDEO|AUDIO)$");
  var colors = ["#ff6"];
  var wordColor = [];
  var colorIdx = 0;
  var matchRegex = "";
  var openLeft = true;
  var openRight = true;
  options = options || {};
  if (typeof options.onStart !== 'function') {
    options.onStart = function () { /* return FALSE when you want to abort */ };
  }
  if (typeof options.onFinish !== 'function') {
    options.onFinish = function () { /* What you return here is returned by Hilitor.apply() */ return true; };
  }
  if (typeof options.onDoOne !== 'function') {
    options.onDoOne = function (node) { /* return FALSE when you want to skip the highlighting change for this node */ };
  }

  this.setMatchType = function(type)
  {
    switch(type)
    {
    case "left":
      openLeft = false;
      openRight = true;
      break;
    case "right":
      openLeft = true;
      openRight = false;
      break;
    default:
    case "open":
      openLeft = openRight = true;
      break;
    case "complete":
      openLeft = openRight = false;
      break;
    }
  };

  this.setRegex = function (input)
  {
    input = input.replace(/^[^\w]+|[^\w]+$/g, "").replace(/[^\w'\-]+/g, "|");
    var re = "(" + input + ")";
    if(!openLeft) re = "\\b" + re;
    if(!openRight) re = re + "\\b";
    matchRegex = new RegExp(re, "i");
  };

  this.getRegex = function ()
  {
    var retval = matchRegex.toString();
    retval = retval.replace(/^\/(\\b)?|(\\b)?\/i$/g, "");
    retval = retval.replace(/\|/g, " ");
    return retval;
  };

  // recursively apply word highlighting
  this.hiliteWords = function (node)
  {
    var i;

    if(!node)
      return;
    if(!matchRegex)
      return;
    if(skipTags.test(node.nodeName))
       return;
    if(node.nodeName === hiliteTag && node.className === "hilitor")
      return;

    if(node.hasChildNodes()) {
      for(i = 0; i < node.childNodes.length; i++) {
        this.hiliteWords(node.childNodes[i]);
      }
    }
    if(node.nodeType === 3) { // NODE_TEXT
      if((nv = node.nodeValue) && (regs = matchRegex.exec(nv))) {
        if (false !== options.onDoOne.call(this, node)) {
          if(!wordColor[regs[0].toLowerCase()]) {
            wordColor[regs[0].toLowerCase()] = colors[colorIdx++ % colors.length];
          }

          var match = document.createElement(hiliteTag);
          match.appendChild(document.createTextNode(regs[0]));
          match.className = "hilitor";
          match.style.backgroundColor = wordColor[regs[0].toLowerCase()];
          match.style.fontStyle = "inherit";
          match.style.color = "#000";

          var after = node.splitText(regs.index);
          after.nodeValue = after.nodeValue.substring(regs[0].length);
          node.parentNode.insertBefore(match, after);
        }
      }
    }
  };

  // remove highlighting
  this.remove = function ()
  {
    var arr, i;
    do {
      arr = document.querySelectorAll(hiliteTag + ".hilitor");
      i = 0;
      while (i < arr.length && (el = arr[i])) {
        // store the reference to the parent of the hilite tag as that node itself, 
        // and all its links, is invalidated in the next .replaceChild() call:
        var parentNode = el.parentNode;
        if (!parentNode) {
          i++;      
          // this entry would otherwise crash in the code below; we can however improve 
          // on the total run-time costs by cutting back on the number of times we trigger
          // the outer loop (which serves as a recovery mechanism anyway) by continuing
          // with this querySelectorAll()'s results, but at it's higher indexes, which
          // are very probably still valid/okay. This saves a number of outer loops and 
          // thus a number of querySelectorAll calls.
          continue;
        }
        // Note that this stuff can crash (due to the parentNode being nuked) when multiple
        // snippets in the same text node sibling series are merged. That's what the
        // parentNode check is for. Ugly. Even while the .querySelectorAll() 'array' is updated
        // automatically, which would imply that this never occurs, yet: it does. :-(
        parentNode.replaceChild(el.firstChild, el);
        // and merge the text snippets back together again.
        parentNode.normalize();
      }
    } while (arr.length > 0);
  };

  // start highlighting at target node
  this.apply = function (input)
  {
    // always remove all highlight markers which have been done previously
    this.remove();
    if(!input) {
      return false;
    }
    this.setRegex(input);
    var rv = options.onStart.call(this);
    if (rv === false) {
      return rv;
    }
    // ensure all text node series are merged, etc. so that we don't have to bother with fragmented texts in the search/scan.
    targetNode.normalize();
    this.hiliteWords(targetNode);
    return options.onFinish.call(this);
  };
}


  return Hilitor;
}));

(function (angular) {
	'use strict';
	angular.module('SMART2').directive('smartLastRepeaterElement', function () {
		return function (scope, element, attrs) {
		    if (attrs.callbackOnItem === 'true') {
		        scope.$emit('AllRepeaterElement', element, attrs);
		    }
		    if (scope.$last) {
		        scope.$emit('LastRepeaterElement', element, attrs);
		    }
		};
	});
})(angular);
(function (angular) {
    'use strict';
    angular.module('SMART2').directive('smartMaps', ["$compile", "$sce", "$templateRequest", "$timeout", "$translate", function ($compile, $sce, $templateRequest, $timeout, $translate) {
        return {
            restrict: 'E',
            template: '<div><div ng-if="!mapLoaded" class="row"><div class="mapinfocontainer center-align"> <i class="icon grey-text"><svg><use xlink:href="#icon_Info"></use></svg></i> <span class="center-align displayBlock">' + $translate.instant('couldNotLoadMap') + '</span> <span class="center-align displayBlock">' + $translate.instant('checkAccessPermission') + '<a href="javascript:void(0)" ng-click="viewSwitcher()">' + $translate.instant('tableView') + '</a>.</span></div></div></div>',
            scope: true,
            replace: true,
            link: function (scope, element, attrs) {

                //scope.locations = scope[attrs.locations];
                var locationsOpt = scope.$eval(attrs.locations);
                scope.locations = scope[locationsOpt[0]][locationsOpt[1]];

                scope.mapLoaded = true;
                if (typeof window.google !== 'object' || typeof window.google.maps !== 'object') {
                    scope.mapLoaded = false;
                    scope.viewSwitcher = function () {
                        scope.locations.viewSwitcherFlag.flag = false;
                    };
                    return false;
                }

                var myLatLng = new google.maps.LatLng(21, 78);
                var mapOptions = {
                    center: myLatLng,
                    maxZoom: 14,
                    minZoom: 2,
                    streetViewControl: false,
                    mapTypeControl: false,
                    mapTypeId: google.maps.MapTypeId.ROADMAP,
                    styles: [
						 {
						     "elementType": "labels.text.fill",
						     "stylers": [
                               {
                                   "visibility": "on"
                               },
                               {
                                   "color": "#6fa4e4",
                                   "font-weight": "normal"
                               }
						     ]
						 },
						   {
						       "elementType": "labels.text.stroke",
						       "stylers": [
                                 {
                                     "visibility": "off"
                                 }
						       ]
						   },
						 {
						     "featureType": "administrative.country",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.country",
						     "elementType": "geometry",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.country",
						     "elementType": "geometry.fill",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.country",
						     "elementType": "geometry.stroke",
						     "stylers": [
                             {
                                 "color": "#e6ebf1",
                                 "font-weight": "normal"
                             },
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.country",
						     "elementType": "labels",
						     "stylers": [
                             {
                                 "color": "#6fa4e4",
                                 "font-weight": "normal"
                             },
                             {
                                 "visibility": "simplified"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.land_parcel",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.locality",
						     "stylers": [
                              {
                                  "color": "#6fa4e4",
                                  "font-weight": "normal"
                              },
                               {
                                   "visibility": "simplified"
                               }
						     ]
						 },
						 {
						     "featureType": "administrative.neighborhood",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.province",
						     "stylers": [
                             {
                                 "color": "e6ebf1",
                                 "font-weight": "normal"
                             },
                             {
                                 "visibility": "simplified"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.province",
						     "elementType": "geometry.stroke",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "administrative.province",
						     "elementType": "labels",
						     "stylers": [
                             {
                                 "color": "#6fa4e4",
                                 "font-weight": "normal"
                             },
                             {
                                 "visibility": "simplified"
                             }
						     ]
						 },
						 {
						     "featureType": "landscape.man_made",
						     "stylers": [
                             {
                                 "color": "#e6ebf1",
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "landscape.natural",
						     "stylers": [
                             {
                                 "color": "#e6ebf1"
                             },
                             {
                                 "visibility": "on"
                             }
						     ]
						 },
						 {
						     "featureType": "landscape.natural.landcover",
						     "stylers": [
                             {
                                 "color": "#e6ebf1",
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "landscape.natural.terrain",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "poi",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "road",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "transit",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "transit.station",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "transit.station.airport",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "transit.station.bus",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "transit.station.rail",
						     "stylers": [
                             {
                                 "visibility": "off"
                             }
						     ]
						 },
						 {
						     "featureType": "water",
						     "stylers": [
                             {
                                 "color": "#ffffff"
                             }
						     ]
						 }
                    ]
                };
                element.height(480);

                var map = new google.maps.Map(document.getElementById(attrs.id), mapOptions);

                var mcOptions = { gridSize: 50, maxZoom: 14, imagePath: scope.locations.baseImgUrl + 'm' };

                var infowindow = new google.maps.InfoWindow({
                    maxWidth: 360
                });
                var latlngbounds = new google.maps.LatLngBounds();
                var markers = [];
                var img;
                var key;
                var mapDataLeng = scope.locations.locData.length,
                    dataGeoDataTemp,
			        markerCluster;

                markerCluster = new MarkerClusterer(map, markers, mcOptions);
                markerCluster.styles_.forEach(function (val, ind) {
                    val.textColor = "white";
                });

                // onClickZoom OVERRIDE
                markerCluster.onClickZoom = function (event) { return multiChoice(markerCluster, event); };
                scope.locationClusterMarker = {};
                for (key = 0; key < mapDataLeng; key++) {
                    var geocoder = new google.maps.Geocoder();
                    (function (value, key) {
                        mapGeocodeFn(value, key, mapDataLeng)

                    })(scope.locations.locData[key], key);
                };

                function infoWindowStyle() {

                    var iwOuter = $('.gm-style-iw');
                    var iwBackground = iwOuter.prev();
                    var $infoWin = iwOuter.parent('div').parent('div').parent('div');

                    $infoWin.css({ visibility: 'hidden' });
                    iwOuter.next().css('display', 'none');
                    iwOuter.children(':nth-child(1)').css({ 'overflow': 'visible' });
                    iwBackground.children(':nth-child(2)').css({ 'display': 'none' });
                    iwBackground.children(':nth-child(4)').css({ 'display': 'none' });
                    iwOuter.parent().css({ width: '360px' });
                    iwOuter.css({ 'z-index': '-1' });
                    $infoWin.css({ visibility: 'visible' });

                }

                function mapGeocodeFn(value, key, mapDataLeng) {
                    var addressData = value.countryInfo ? value.countryInfo.CountryCode.toString() : value.state ? value.state.toString() : '',
                        zipcode = value.zipcode ? value.zipcode.toString() : '';
                    geocoder.geocode({
                        componentRestrictions: {
                            country: addressData,
                            postalCode: zipcode
                        }
                    }, function (results, status) {
                        if (status == google.maps.GeocoderStatus.OK) {

                            if (key >= 7) {
                                img = key % 7;
                            } else {
                                img = key;
                            }

                            var marker = new google.maps.Marker({
                                position: new google.maps.LatLng(results[0].geometry.location.lat(), results[0].geometry.location.lng()),
                                map: map,
                                title: value.state,
                                id: key,
                                //animation: google.maps.Animation.DROP,
                                icon: scope.locations.baseImgUrl + "cmarker" + img + ".png"
                            });
                            marker.setMap(map);
                            markers.push(marker);

                            markerCluster.addMarkers(markers);

                            google.maps.event.addListener(marker, 'click', function () {
                                var marker = this;
                                //infowindow.setContent($compile(linker)(scope)[0]);
                                scope.locations.id = marker.id;
                                infowindow.open(map, marker);
                                infoWindowStyle();
                            });

                            //AutoZoom map to fit all markers
                            latlngbounds.extend(new google.maps.LatLng(results[0].geometry.location.lat(), results[0].geometry.location.lng()));
                            map.fitBounds(latlngbounds);
                        }
                        dataGeoDataTemp = markers.length ? false : true;
                        if (dataGeoDataTemp != scope.locations.dataGeoData) {
                            scope.$apply(function () {
                                scope.locations.dataGeoData = dataGeoDataTemp;
                            });
                        }

                        if (dataGeoDataTemp && scope.locations.viewSwitcherFlag.flag) {
                            scope.$apply(function () {
                                scope.locations.viewSwitcherFlag.flag = false;
                            });
                        }
                    });
                };
                function multiChoice(mc, event) {

                    scope.locationClusterMarker = event.cluster_;

                    //map.panTo(event.cluster_.markers_[0].position);

                    var clusterDom = '<ul id="dropdown1" class="dropdown-content clusterDomContainer"><li ng-click="clusterListFn(marker)" ng-repeat="marker in locationClusterMarker.markers_"><a href="javascript:void(0)" class="grey-text text-darken-4">{{locations.locData[marker.id].locname}}</a></li></ul>';
                    clusterDom = $compile(clusterDom)(scope);
                    if (!angular.element(event.div_).hasClass('clusterDomContainer-dropdown-button')) {
                        angular.element(event.div_).addClass('clusterDomContainer-dropdown-button').attr({ 'data-activates': 'dropdown1', 'data-stoppropagation': true }).append(clusterDom);
                        setTimeout(function () {
                            var $dropBtn = angular.element('.clusterDomContainer-dropdown-button');
                            $dropBtn.dropdown({
                                constrain_width: false
                            });
                            $dropBtn.trigger('click');

                        }, 10)
                    }
                    return false;
                };

                var unbindWatch = scope.$watch('locations.mapReinit', function (val) {
                    if (val.reinit) {
                        mapDataLeng = scope.locations.locData.length;
                        infowindow.close();
                        if (markerCluster) {
                            markerCluster.clearMarkers();
                            markers = [];
                        }
                        for (key = 0; key < mapDataLeng; key++) {
                            var geocoder = new google.maps.Geocoder();
                            (function (value, key) {
                                mapGeocodeFn(value, key, mapDataLeng);
                            })(scope.locations.locData[key], key);
                        };
                    }

                    if (val.refresh) {
                        setTimeout(function () {
                            google.maps.event.trigger(map, "resize");
                            map.fitBounds(latlngbounds);
                            var zoom = map.getZoom();
                            map.setZoom(zoom > 14 ? 14 : zoom);
                        }, 100);
                    }
                });

                scope.$on('$destroy', function () {
                    unbindWatch();
                    scope.dataOption = null;
                    infowindow = null;
                    latlngbounds = null;
                    markers = null;
                    mapOptions = null;
                    map = null;
                    geocoder = null;
                });

                scope.clusterListFn = function (data) {
                    var marker = data;
                    $timeout(function () {
                        scope.locations.id = marker.id;
                        infowindow.setPosition(marker.position);
                        infowindow.open(map);
                        infoWindowStyle();
                    }, 10);
                };

                google.maps.event.addListener(map, 'click', function (event) {
                    if (infowindow) {
                        var $locationCardDropdown = angular.element('.mapdropdownbtn');
                        if ($locationCardDropdown.hasClass('active')) {
                            $locationCardDropdown.trigger('click');
                        }
                        infowindow.close();
                    }
                });
                var templateUrl = $sce.getTrustedResourceUrl(scope.locations.infoTemplateURL);
                var linker;
                $templateRequest(templateUrl).then(function (template) {
                    linker = template;
                    infowindow.setContent($compile(linker)(scope)[0]);
                });
                google.maps.event.addDomListener(map, 'zoom_changed', function () {
                    if (infowindow) {
                        var $locationCardDropdown = angular.element('.mapdropdownbtn');
                        if ($locationCardDropdown.hasClass('active')) {
                            $locationCardDropdown.trigger('click');
                        }
                        infowindow.close();
                    }
                    angular.element('#dropdown1').remove();
                });
            }
        };
    }]);
})(angular);
(function (angular) {
	'use strict';
	angular.module('SMART2').directive('smartMetadataChips', ['debouncer', function (debouncer) {
		return {
			restrict: 'E',
			replace: true,
			scope: {
				"smartmetadata": "=metadata",
				"metadatatitle": "@",
				"maxlength": "@",
				"callBack": "&"
			},
			link: function (scope, element, attrs) {

				scope.fieldClass = typeof attrs.fieldClass === 'undefined' ? 's4' : attrs.fieldClass;
				scope.itemTotal = typeof attrs.itemTotal === 'undefined' ? 3 : (parseInt(attrs.itemTotal, 10) <= 0 ? 0 : parseInt(attrs.itemTotal, 10));
				scope.fieldkey = typeof attrs.fieldkey === 'undefined' ? 'name' : attrs.fieldkey;
				scope.showMoreChips = 0;

				attrs.$observe('optionId', function () {
					scope.optionId = attrs.optionId;
				});

				scope.$on('LastRepeaterElement', function (scope, element, attrs) {
					debouncer.add(function () {
						var $chipsActiceContainer;
						$chipsActiceContainer = typeof $chipsActiceContainer !== 'undefined' ? $chipsActiceContainer : angular.element('#' + scope.targetScope.$parent.optionId + '-chips-0');
						if ($chipsActiceContainer) {
							$chipsActiceContainer.css({ 'transition': 'all .5s ease-in-out', 'background': '#e4e4e4', 'color': '#000' });
							$chipsActiceContainer.find('.chips-icon').css({ 'transition': 'all .5s ease-in-out', 'color': '#9e9e9e' });
							setTimeout(function () {
								$chipsActiceContainer.css('transition', 'none').find('.chips-icon').css('transition', 'none');
							}, 500);
						}
					}, 100);
				});

				scope.metadataAdd = function (data, $e) {
					var metadataContainer = angular.element('#' + scope.optionId).width() - 200,
						$chipsActiceContainer,
						fieldKey = scope.fieldkey;
					if (angular.isString(data.displayfield.title)) {
					    data.displayfield.title = data.displayfield.title.trim();
					}
					if (!data.displayfield.title) {
					    data.displayfield.isfocus = true;
					    return 0;
					}
					$chipsActiceContainer = angular.element('#' + scope.optionId + '-chips-0');
					if ($chipsActiceContainer) {
						$chipsActiceContainer.css({ 'transition': 'none', 'background': '#159dfc', 'color': '#fff' });
						$chipsActiceContainer.find('.chips-icon').css({ 'transition': 'none', 'color': '#fff' });
					}
					data.options.unshift({});
					data.options[0][fieldKey] = data.displayfield.title;
					data.displayfield.title = "";
					data.displayfield.isfocus = true;
				};
				scope.metadataCheck = function (data, $e) {
					var char = $e.which || $e.keyCode,
						charReq = [13, 188, 186],
						charReqLength = charReq.length,
						charReqKey,
						i;

					if (data.displayfield.title) {
						for (i = 0; i < charReqLength; i++) {
							if (char === charReq[i]) {
								charReqKey = charReq[i] === 188 ? ',' : charReq[i] === 186 ? ';' : '';
								if (charReqKey) {
									data.displayfield.title = data.displayfield.title.replace(charReqKey, '');
								}
								angular.element($e.currentTarget).blur();
								scope.metadataAdd(data, $e);
							}
						}
					}
				};

				var beforeDelete = function (obj) {
				    scope.callBack({
				        data: {
				            'data': obj.data.chipData.options[obj.data.index],
				            'type': 'delete', callback: deleteCallback
				        }
				    });
				    function deleteCallback(a) {
				        if (a) { obj.success() }
				        else { obj.reject() }
				    }
				}

				scope.metadataDelete = function (data, ind) {
				    if (attrs.callBack) {
				        beforeDelete({
				            data: { chipData: data, index: ind },
				            success: function () {
				                // user wants to delete
				                data.options.splice(ind, 1);
				                scope.$apply();
				            },
				            reject: function () {
				                // deletion rejected!
				            }
				        });
				    } else {
				        data.options.splice(ind, 1);
				    }
				};
				scope.smartmetachipTitleClick = function (data, ind) {
					angular.isFunction(scope.callBack) && scope.callBack({ data: { 'data': data.options[ind], 'type': 'add' } });
				};
				scope.metadataShowMore = function (cont) {
					angular.element('#' + cont).css('transition', '1s ease-in-out');
					debouncer.add(function () {
						scope.showMoreChips = 1;
					}, 10);
				};
				scope.metadataLessMore = function (cont) {
					angular.element('#' + cont).css('transition', 'none');
					scope.showMoreChips = 0;
				};
			},
			templateUrl: 'shared/directives/smartMetadataChips/smartMetadataChipsTemplate.html'
		};
	}]);
})(angular);
(function () {
	'use strict';
	angular.module('SMART2').value('uiSliderConfig', {}).directive('smartRangeSlider', ['uiSliderConfig', '$timeout', function (uiSliderConfig, $timeout) {
		uiSliderConfig = uiSliderConfig || {};
		return {
			require: 'ngModel',
			compile: function () {
				var preLink = function (scope, elm, attrs, ngModel) {

					function parseNumber(n, decimals) {
						return (decimals) ? parseFloat(n) : parseInt(n, 10);
					}

					var directiveOptions = angular.copy(scope.$eval(attrs.uiSlider));
					var options = angular.extend(directiveOptions || {}, uiSliderConfig);
					// Object holding range values
					var prevRangeValues = {
						min: null,
						max: null
					};

					// convenience properties
					var properties = ['min', 'max', 'step', 'lowerBound', 'upperBound'];
					var useDecimals = (!angular.isUndefined(attrs.useDecimals)) ? true : false;
					var updateOn = (angular.isDefined(options['updateOn'])) ? options['updateOn'] : 'slide'

					var init = function () {
						// When ngModel is assigned an array of values then range is expected to be true.
						// Warn user and change range to true else an error occurs when trying to drag handle
						if (angular.isArray(ngModel.$viewValue) && options.range !== true) {
							console.warn('Change your range option of ui-slider. When assigning ngModel an array of values then the range option should be set to true.');
							options.range = true;
						}

						// Ensure the convenience properties are passed as options if they're defined
						// This avoids init ordering issues where the slider's initial state (eg handle
						// position) is calculated using widget defaults
						// Note the properties take precedence over any duplicates in options
						angular.forEach(properties, function (property) {
							if (angular.isDefined(attrs[property])) {
								options[property] = parseNumber(attrs[property], useDecimals);
							}
						});

						elm.slider(options);
						init = angular.noop;
					};

					// Find out if decimals are to be used for slider
					angular.forEach(properties, function (property) {
						// support {{}} and watch for updates
						attrs.$observe(property, function (newVal) {
							if (!!newVal) {
								init();
								options[property] = parseNumber(newVal, useDecimals);
								elm.slider('option', property, parseNumber(newVal, useDecimals));
								ngModel.$render();
							}
						});
					});
					attrs.$observe('disabled', function (newVal) {
						init();
						elm.slider('option', 'disabled', !!newVal);
					});

					// Watch ui-slider (byVal) for changes and update
					scope.$watch(attrs.uiSlider, function (newVal) {
						init();
						if (newVal !== undefined) {
							elm.slider('option', newVal);
						}
					}, true);

					// Late-bind to prevent compiler clobbering
					$timeout(init, 0, true);

					// Update model value from slider
					elm.bind(updateOn, function (event, ui) {
						var valuesChanged;

						if (ui.values) {
							var boundedValues = ui.values.slice();

							if (options.lowerBound && boundedValues[0] < options.lowerBound) {
								boundedValues[0] = Math.max(boundedValues[0], options.lowerBound);
							}
							if (options.upperBound && boundedValues[1] > options.upperBound) {
								boundedValues[1] = Math.min(boundedValues[1], options.upperBound);
							}

							if (boundedValues[0] !== ui.values[0] || boundedValues[1] !== ui.values[1]) {
								valuesChanged = true;
								ui.values = boundedValues;
							}
						} else {
							var boundedValue = ui.value;

							if (options.lowerBound && boundedValue < options.lowerBound) {
								boundedValue = Math.max(boundedValue, options.lowerBound);
							}
							if (options.upperBound && boundedValue > options.upperBound) {
								boundedValue = Math.min(boundedValue, options.upperBound);
							}

							if (boundedValue !== ui.value) {
								valuesChanged = true;
								ui.value = boundedValue;
							}
						}


						ngModel.$setViewValue(ui.values || ui.value);
						$(ui.handle).find('.ui-slider-tip').text(ui.value);
						scope.$apply();

						if (valuesChanged) {
							setTimeout(function () {
								elm.slider('value', ui.values || ui.value);
							}, 0);

							return false;
						}
					});

					// Update slider from model value
					ngModel.$render = function () {
						init();
						var method = options.range === true ? 'values' : 'value';

						if (options.range !== true && isNaN(ngModel.$viewValue) && !(ngModel.$viewValue instanceof Array)) {
							ngModel.$viewValue = 0;
						}
						else if (options.range && !angular.isDefined(ngModel.$viewValue)) {
							ngModel.$viewValue = [0, 0];
						}

						// Do some sanity check of range values
						if (options.range === true) {
							// previously, the model was a string b/c it was in a text input, need to convert to a array.
							// make sure input exists, comma exists once, and it is a string.
							if (ngModel.$viewValue && angular.isString(ngModel.$viewValue) && (ngModel.$viewValue.match(/,/g) || []).length === 1) {
								// transform string model into array.
								var valueArr = ngModel.$viewValue.split(',');
								ngModel.$viewValue = [Number(valueArr[0]), Number(valueArr[1])];
							}
							// Check outer bounds for min and max values
							if (angular.isDefined(options.min) && options.min > ngModel.$viewValue[0]) {
								ngModel.$viewValue[0] = options.min;
							}
							if (angular.isDefined(options.max) && options.max < ngModel.$viewValue[1]) {
								ngModel.$viewValue[1] = options.max;
							}

							// Check min and max range values
							if (ngModel.$viewValue[0] > ngModel.$viewValue[1]) {
								// Min value should be less to equal to max value
								if (prevRangeValues.min >= ngModel.$viewValue[1]) {
									ngModel.$viewValue[1] = prevRangeValues.min;
								}
								// Max value should be less to equal to min value
								if (prevRangeValues.max <= ngModel.$viewValue[0]) {
									ngModel.$viewValue[0] = prevRangeValues.max;
								}
							}

							// Store values for later user
							prevRangeValues.min = ngModel.$viewValue[0];
							prevRangeValues.max = ngModel.$viewValue[1];

						}
						elm.slider(method, ngModel.$viewValue);
					};

					scope.$watch(attrs.ngModel, function () {
						if (options.range === true) {
							ngModel.$render();

							$(elm).find('.ui-slider-tip').each(function (i, tipElm) {
								$(tipElm).text(ngModel.$viewValue[i]);
							});
						} else {
							$(elm).find('.ui-slider-tip').text(ngModel.$viewValue);
						}
					}, true);

					function destroy() {
						if (elm.hasClass('ui-slider')) {
							elm.slider('destroy');
						}
					}

					scope.$on("$destroy", destroy);
					elm.one('$destroy', destroy);
				};

				var postLink = function (scope, element, attrs, ngModel) {
					// Add tick marks if 'tick' and 'step' attributes have been setted on element.
					// Support horizontal slider bar so far. 'tick' and 'step' attributes are required.
					var options = angular.extend({}, scope.$eval(attrs.uiSlider));
					var properties = ['min', 'max', 'step', 'tick', 'tip'];
					angular.forEach(properties, function (property) {
						if (angular.isDefined(attrs[property])) {
							options[property] = attrs[property];
						}
					});
					if (angular.isDefined(options['tick']) && angular.isDefined(options['step'])) {
						var total = parseInt((parseInt(options['max']) - parseInt(options['min'])) / parseInt(options['step']));
						for (var i = total; i >= 0; i--) {
							var left = ((i / total) * 100) + '%';
							$("<div/>").addClass("ui-slider-tick").appendTo(element).css({ left: left });
						};
					}
					if (angular.isDefined(options['tip'])) {
						$timeout(function () {
							var handles = element.find('.ui-slider-handle');
							if (handles && handles.length > 1 && ngModel.$viewValue && angular.isArray(ngModel.$viewValue)) {
								$(handles[0]).append('<div class="ui-slider-tip">' + ngModel.$viewValue[0] + '</div>');
								$(handles[1]).append('<div class="ui-slider-tip">' + ngModel.$viewValue[1] + '</div>');
							} else {
								element.find('.ui-slider-handle').append('<div class="ui-slider-tip">' + ngModel.$viewValue + '</div>');
							}
						}, 10);
					}
				}

				return {
					pre: preLink,
					post: postLink
				};
			}
		};
	}]);
})();
(function (angular,$) {
    /*
        :: directive attributes
                onResize    :   & // fires when element changes size
          onHeightChange    :   & // fires when element's height change
           onWidthChange    :   & // fires when element's width change
    */
    "use strict";
    angular.module("SMART2")
        .directive("smartResize", ["$timeout", "$parse", smartResizeDir]);

    function smartResizeDir($timeout, $parse) {
        return {
            link: function (scope, element, attrs) {
                var callbacks = {
                    onResize: attrs.onResize ? $parse(addArguments(attrs.onResize)) : null,
                    onHeightChange: attrs.onHeightChange ? $parse(addArguments(attrs.onHeightChange)) : null,
                    onWidthChange: attrs.onWidthChange ? $parse(addArguments(attrs.onWidthChange)) : null
                };
                function addArguments(fn) {
                    return fn.replace(/\(\)/, '(e)');
                }
                $timeout(function () {
                    resizeElement({
                        element: element.get(0),
                        onResize: function (a) {
                            callbacks.onResize(scope, { e: a });
                        },
                        onHeightChange: function (a) {
                            callbacks.onHeightChange(scope, { e: a });
                        },
                        onWidthChange: function (a) {
                            callbacks.onWidthChange(scope, { e: a });
                        }
                    });
                });

                function resizeElement(config) {
                    var config = $.extend({
                        element: null, // html element :: accepts Html Element not selector
                        onResize: null, // callback fires after changed size of element :: accepts function
                        onHeightChange: null, // callback fires after changed height of element :: accepts function
                        onWidthChange: null // callback fires after changed width of element :: accepts function
                    }, config),
                        resizeSensorCss = 'width:100%;height:100%;position:absolute;left:0;top:0;z-index:-1;',
                        sensorCss = 'position:absolute;left:0;top:0;overflow:hidden;height:100%;width:100%;',
                        sensorElementCss = 'position:relative;top:0;',
                        html = '<div class="resize-sensor" style="' + resizeSensorCss + '"><div class="sensor" style="' + sensorCss + '" data-el="shrink"><div class="sensor-element-shrink" style="' + sensorElementCss + '"></div></div><div class="sensor" style="' + sensorCss + '" data-el="expand"><div class="sensor-element-expand" style="' + sensorElementCss + '"></div></div></div>';

                    var el = $(config.element),
                        PD = { height: 0, width: 0 },
                        PDC = { height: 0, width: 0 };
                    if (el.length > 0) {
                        var mainSensor = $(html);
                        el.css("position", "relative").append(mainSensor);
                        mainSensor.find(".sensor").each(function () {
                            var sensor = $(this);
                            if (sensor.data("el") == "expand") {
                                sensor.find(".sensor-element-expand")
                                    .css({ width: el.outerWidth() * 2, height: el.outerHeight() * 2 });
                            } else if (sensor.data("el") == "shrink") {
                                sensor.find(".sensor-element-shrink")
                                    .css({ width: "200%", height: "200%" });
                            }
                            sensor.scrollLeft(el.outerWidth() * 2);
                            sensor.scrollTop(el.outerHeight() * 2);
                        }).each(function () {
                            var sensor = $(this);
                            sensor.scroll(function (e) {
                                var _this = $(this);
                                if ((el.outerWidth() != PD.width || el.outerHeight() != PD.height) && (PD.height != 0 && PD.width != 0)) {
                                    PD.height = el.outerHeight();
                                    PD.width = el.outerWidth()
                                    if (_this.data("el") == "shrink") {
                                        mainSensor
                                            .find(".sensor-element-expand")
                                            .css({ width: PD.width * 2, height: PD.height * 2 })
                                            .parent()
                                            .scrollLeft(PD.width * 2)
                                            .scrollTop(PD.height * 2);

                                    } else if (_this.data("el") == "expand") {
                                        mainSensor
                                            .find(".sensor-element-shrink")
                                            .parent()
                                            .scrollLeft(PD.width * 2)
                                            .scrollTop(PD.height * 2)
                                            .next()
                                            .find(".sensor-element-expand")
                                            .css({ width: PD.width * 2, height: PD.height * 2 })
                                            .parent()
                                            .scrollLeft(PD.width * 2)
                                            .scrollTop(PD.height * 2);
                                    }

                                    initHandlers(PD, PDC); // invoke callbacks
                                } else {
                                    PD.height = el.outerHeight();
                                    PD.width = el.outerWidth();

                                    PDC.height = PD.height;
                                    PDC.width = PD.width;
                                }
                            });
                        });
                    }

                    function initHandlers(size, previousSize) {
                        if (callbacks.onResize) {
                            config.onResize.call(config.element, size); // execute resize callback
                        }

                        if (size.height != previousSize.height && callbacks.onHeightChange) {
                            config.onHeightChange.call(config.element, size); // execute height resize callback
                        } else if (size.width != previousSize.width && callbacks.onWidthChange) {
                            config.onWidthChange.call(config.element, size); // execute width resize callback
                        }

                        // save new dimention
                        previousSize.height = size.height;
                        previousSize.width = size.width;
                    }
                };
            }
        }
    }

    $.fn.resizeSensor = function (setting) {

        var resizeSensorCss = 'width:100%;height:100%;position:absolute;left:0;top:0;z-index:-1;',
            sensorCss = 'position:absolute;left:0;top:0;overflow:hidden;height:100%;width:100%;',
            sensorElementCss = 'position:relative;top:0;',
            html = '<div class="resize-sensor" style="' + resizeSensorCss + '"><div class="sensor" style="' + sensorCss + '" data-el="shrink"><div class="sensor-element-shrink" style="' + sensorElementCss + '"></div></div><div class="sensor" style="' + sensorCss + '" data-el="expand"><div class="sensor-element-expand" style="' + sensorElementCss + '"></div></div></div>',
         defaultConfig = {
             onResize: null, // callback fires after changed size of element :: accepts function
             onHeightChange: null, // callback fires after changed height of element :: accepts function
             onWidthChange: null // callback fires after changed width of element :: accepts function
         };

        return this.each(function () {

            var config = $.extend(defaultConfig, setting),
                el = $(this),
                    PD = { height: 0, width: 0 },
                    PDC = { height: 0, width: 0 };
            if (el.length > 0) {
                var mainSensor = $(html);
                if (el.css('position') === 'static') {
                    el.css("position", "relative")
                }
                el.append(mainSensor);

                mainSensor.find(".sensor").each(function () {
                    var sensor = $(this);
                    if (sensor.data("el") == "expand") {
                        sensor.find(".sensor-element-expand")
                            .css({ width: el.outerWidth() * 2, height: el.outerHeight() * 2 });
                    } else if (sensor.data("el") == "shrink") {
                        sensor.find(".sensor-element-shrink")
                            .css({ width: "200%", height: "200%" });
                    }
                    sensor.scrollLeft(el.outerWidth() * 2);
                    sensor.scrollTop(el.outerHeight() * 2);
                }).each(function () {
                    var sensor = $(this);
                    sensor.scroll(function (e) {
                        var _this = $(this);
                        if ((el.outerWidth() != PD.width || el.outerHeight() != PD.height) && (PD.height != 0 && PD.width != 0)) {
                            PD.height = el.outerHeight();
                            PD.width = el.outerWidth()
                            if (_this.data("el") == "shrink") {
                                mainSensor
                                    .find(".sensor-element-expand")
                                    .css({ width: PD.width * 2, height: PD.height * 2 })
                                    .parent()
                                    .scrollLeft(PD.width * 2)
                                    .scrollTop(PD.height * 2);

                            } else if (_this.data("el") == "expand") {
                                mainSensor
                                    .find(".sensor-element-shrink")
                                    .parent()
                                    .scrollLeft(PD.width * 2)
                                    .scrollTop(PD.height * 2)
                                    .next()
                                    .find(".sensor-element-expand")
                                    .css({ width: PD.width * 2, height: PD.height * 2 })
                                    .parent()
                                    .scrollLeft(PD.width * 2)
                                    .scrollTop(PD.height * 2);
                            }

                            initHandlers(sensor, PD, PDC); // invoke callbacks
                        } else {
                            PD.height = el.outerHeight();
                            PD.width = el.outerWidth();

                            PDC.height = PD.height;
                            PDC.width = PD.width;
                        }
                    });
                });

                function initHandlers(sensor, size, previousSize) {
                    if (config.onResize) {
                        config.onResize.call(sensor, size); // execute resize callback
                    }

                    if (size.height != previousSize.height && config.onHeightChange) {
                        config.onHeightChange.call(sensor, size); // execute height resize callback
                    } else if (size.width != previousSize.width && config.onWidthChange) {
                        config.onWidthChange.call(sensor, size); // execute width resize callback
                    }

                    // save new dimention
                    previousSize.height = size.height;
                    previousSize.width = size.width;
                }
            }


        });
    };
})(angular, jQuery);

(function (angular) {
    "use strict";
    angular.module("SMART2")
        .directive("smartRevision", ["$timeout", "$sce", "$translate", smartRevisionDir]);

    function smartRevisionDir($timeout, $sce, $translate) {
        return {
            restrict: "E",
            replace: true,
            transclude: {
                oldData: "?span",
                newData:"?div"
            },
            scope: {
                align: "@",
                oldData: "=?",
                newData: "=?",
                label: "@",
                type: "@",
                imgDimention: "@",
                treeCallback: "&"
            },
            link: function (scope, element, attrs) {
                var value = {
                    image: "image",
                    normal: "normal",
                    defaultDimention: 150,
                    tree: "tree"
                };
                scope.type = scope.type || value.normal;
                scope.align = scope.align ? scope.align : "left";
                scope.treemode = attrs.treemode;
                //scope.oldData = scope.oldData ? scope.oldData : attrs.oldData;
                //scope.newData = scope.newData ? scope.newData : attrs.newData;

                scope.closeButton = { title: $translate.instant("closeBtn") };

                scope.multiRows = function (data) {
                    var ismultiRows = false;
                    if (data) {
                        var type = data.constructor.toString().match(/function ([A-Za-z]+)/)[1];
                        if (type == "Array") {
                            ismultiRows = true;
                        }
                    }
                    return ismultiRows;
                }(scope.oldData || scope.newData);
                if (!scope.oldData && !scope.newData) { // for transclude element
                    scope.transclude = true;
                    $timeout(function () {
                        element
                            .find("[old-data]")
                            .addClass("revision-old-val")
                            .wrap("<span>")
                            .parent()
                            .addClass("revision-old-data");
                        element
                            .find("[new-data]")
                            .wrap("<span>")
                            .parent()
                            .addClass("revision-new-data");
                    });
                } else if (scope.oldData && scope.newData) {
                    scope.isChanged = true;
                    if (scope.type !== "tree") {
                        scope.oldDataHtml = $sce.trustAsHtml(scope.oldData);
                        scope.newDataHtml = $sce.trustAsHtml(scope.newData);
                    }
                } else if (scope.oldData && !scope.newData) {
                    scope.isChanged = false;
                    if (scope.type !== "tree") {
                        scope.oldDataHtml = $sce.trustAsHtml(scope.oldData);
                    }
                } else if (!scope.oldData && scope.newData) {
                    scope.isChanged = true;
                    if (scope.type !== "tree") {
                        scope.newDataHtml = $sce.trustAsHtml(scope.newData);
                    }
                }
                if (scope.type == value.image) {
                    if (scope.imgDimention) {
                        scope.diagonal = {}
                    } else {
                        var diagonalWidth = calculateRectdiagonal(value.defaultDimention, value.defaultDimention);
                        scope.diagonal = {
                            width: diagonalWidth,
                            left: -(diagonalWidth / 2 - value.defaultDimention / 2)
                        }
                    }
                } else if (scope.type == value.tree) {
                    scope.popup = {
                        url: "shared/directives/smartRevision/treeviewChanges.html",
                        show: false,
                        callback: function (a) {
                            scope.popup.show = false;
                            if (attrs.treeCallback) {
                                scope.treeCallback({
                                    data: {
                                        'oldData': scope.oldData,
                                        'newData': scope.newData,
                                        'type': 'close',
                                        'label': scope.label
                                    }
                                });
                            }
                        }
                    }
                };

                scope.treeChange = function () {
                    if (attrs.treeCallback) {
                        scope.treeCallback({
                            data: {
                                'oldData': scope.oldData,
                                'newData': scope.newData,
                                'type': 'open',
                                'label': scope.label
                            }
                        });
                    }
                    scope.popup.show = true;
                }
            },
            templateUrl: "shared/directives/smartRevision/smartRevisionTemplate.html"
        }
    }
    function calculateRectdiagonal(w, h) {
        return Math.sqrt(w * w + h * h);
    }
    function checkJson(a) {
        if (a) {
            try{
                a = JSON.parse(a);
            }catch(e){}
        }

        return a;
    }
})(angular);
(function() {
    'use strict';
    angular.module('SMART2')
        .directive('smartSavedViewPopup', ['notification', 'cacheHelperService', 'smartSavedViewPopupCollection', '$translate', smartSavedViewPopupFunc])
        .service("smartSavedViewPopupCollection", function () {
            this.collection = [];
            this.set = function (x) {
                this.collection.push(x);
            }
            this.get = function (x) {
                return this.collection;
            }
        });

    function smartSavedViewPopupFunc(notification, cacheHelperService, smartSavedViewPopupCollection, $translate) {
        return {
            restrict: 'E',
            transclude: true,
            scope: {
                show: '=',
                hide: '&',
                loader: '=',
                model: '=ngModel',
                config: '=',
                isApplyFilters: "=",
                isSavedView: "=",
                isSavedViewModified: "=",
                openPopupSavedView: "=",
                api: "=",
                setTitle: '@',
                callbackFunc: "&"
            },
            controller: ["$scope", "$http", "$timeout", "smartSavedViewPopupCollection", function ($scope, $http, $timeout, smartSavedViewPopupCollection) {
                //  $scope.collection = smartSavedViewPopupCollection.get("all").length;
                smartSavedViewPopupCollection.set($scope);
                $scope.popupInc = smartSavedViewPopupCollection.get().length;
                
                $scope.disableDoneButton = true;
                $scope.doneButton = { title: $translate.instant("doneBtn") };
                $scope.cancelButton = { title: $translate.instant("cancelBtn") };
                $scope.uncheckMarkAsDefault;
                /*for Done button disabled*/
                var handleDoneButtonVisibility = function () {
                    var isDefaultSelected = _.find($scope.config, { "isDefault": true });
                    if (isDefaultSelected) {
                        $scope.disableDoneButton = false;
                    } else {
                        $scope.disableDoneButton = true;
                    }
                }
                handleDoneButtonVisibility();
                $scope.defaultCheckUncheck = true;
                var handleMarkAsDefault = function () {
                    $scope.isMarkAsDefault.check = false;
                    for (var i = 0; i < $scope.config.length; i++) {
                        if ($scope.config[i].isDefault && $scope.config[i].isDefaultTxt) {
                            $scope.isMarkAsDefault.check = true;
                        }
                    }
                }

                $scope.setDefaultFiler = function (isDefaultTrue) {
                    $scope.defaultCheckUncheck = true;
                    if (isDefaultTrue) {
                        $scope.uncheckMarkAsDefault = false;
                    } else {
                        $scope.uncheckMarkAsDefault = true;
                    }
                    for (var i = 0; i < $scope.config.length; i++) {
                        if ($scope.config[i].isDefault && $scope.config[i].isDefaultTxt) {
                            $scope.defaultCheckUncheck = isDefaultTrue;
                        }
                    }
                };

                $scope.showSavedViewPopup = true;
                $scope.showSaveView = true;
                $scope.radioChangeCallback = function (index, currentItem) {
                    var view = _.find($scope.config, { "index": $scope.model.name });
                    if (!view) {
                        view = _.find($scope.config, { "index": $scope.model.index });
                    }
                    $scope.selectedFilter = view;
                    for (var i = 0; i < $scope.config.length; i++) {
                        $scope.config[i].isDefault = false;
                    }
                    
                    for (var i = 0; i < $scope.config.length; i++) {
                        if (currentItem) {
                            if ($scope.config[i].index === currentItem.index) {
                                $scope.config[i].isDefault = true;
                            }
                        } else {
                            if ($scope.config[i].index === (view && view.index)) {
                                $scope.config[i].isDefault = true;
                            }
                        }
                    }
                    handleDoneButtonVisibility();
                    handleMarkAsDefault();
                }
                $scope.currentDefault;
                $scope.showSavedView = function () {
                    $scope.currentDefault = _.find($scope.config, { "isDefaultTxt": true });
                    var currentCheck = $scope.defaultCheckUncheck;
                    $scope.isSavedView = true;
                    $scope.isSavedFilter = true;
                    if ($scope.uncheckMarkAsDefault && $scope.uncheckMarkAsDefault != undefined) {
                        for (var i = 0; i < $scope.config.length; i++) {
                            $scope.config[i].isDefaultTxt = false;
                        }
                    }
                    $scope.uncheckMarkAsDefault = false;
                    for (var i = 0; i < $scope.config.length; i++) {
                        if ($scope.isMarkAsDefault.check == true) {
                            $scope.config[i].isDefaultTxt = false;
                            if ($scope.config[i].isDefault == true) {
                                $scope.config[i].isDefaultTxt = true;

                            }
                        }
                    }
                    if (!$scope.selectedFilter.name) {
                        $scope.selectedFilter.name = $scope.api.currentViewApplied.name;
                    }
                    if ($scope.api) {
                        $scope.api.currentViewApplied = _.find($scope.config, { index: $scope.selectedFilter.index });
                        if ($scope.api.currentViewApplied == null) {
                            cacheHelperService.setFilterDef('{"defaultFilterType":3,"filters":[]}');
                        }
                        if ($scope.api.currentViewApplied != undefined) {
                            cacheHelperService.setFilterDef($scope.api.currentViewApplied.Filters);
                        }
                        $scope.api.selectedSavedview = { "name": $scope.selectedFilter.name };
                        $scope.api.selectedFilterView = { "name": $scope.selectedFilter.name };
                        if ($scope.currentDefault != undefined) {
                            if ($scope.currentDefault.index != $scope.api.currentViewApplied.index) {
                                $scope.currentDefault.isDefault = currentCheck;
                                SaveResetOrMarkAsDefault($scope.currentDefault);
                            }
                        }
                        if ($scope.isMarkAsDefault.check == true) {
                            $scope.api.currentViewApplied.isDefault = true;
                            SaveResetOrMarkAsDefault($scope.api.currentViewApplied);
                            $scope.isMarkAsDefault.check = false;
                        } else {
                            $scope.api.currentViewApplied.isDefault = false;
                            SaveResetOrMarkAsDefault($scope.api.currentViewApplied);
                        }
                        if($scope.setTitle != "SAVED FILTERS")
                            $scope.api.applyViewOnGrid();
                    }
                    $scope.callbackFunc({
                        e: {
                            'model': $scope.selectedFilter,
                            'currOperation': 'applyFilter'
                        }
                    });

                };

                $scope.Reset = function() {
                    var sysDefault = _.find($scope.config, { IsSystemDefault: true });
                    sysDefault.isDefault = true;
                    $scope.api.currentViewApplied = sysDefault;
                    var req = {
                        method: 'POST',
                        url: $scope.api.UpdateSavedViewURL,
                        headers: {
                            "Content-Type": "application/json"
                        }
                    };
                    _.each($scope.config, function(n) {
                        if (!n.IsSystemDefault) {
                            if (n.isDefault) {
                                req.data = n;
                                $http(req).then(function(response) {}).catch(function (errorCallback) {
                                    console.log(errorCallback.statusText);
                                });
                            }
                            n.isDefault = false;
                        }
                    })
                    if($scope.setTitle != "SAVED FILTERS")
                        $scope.api.applyViewOnGrid();
                };

                $scope.isMarkAsDefault = { 'check': false };
                $scope.SystemAsDefault = { 'check': false };
                $scope.showSavedViewPopup = false;
                $scope.showSaveView = false;
                $scope.focusSearch = false;
                $scope.isActive = false;
                $scope.showMe = false;

                $scope.showSearch = function() {
                    $scope.isActive = true;
                    $scope.focusSearch = true;
                    $scope.showMe = true;
                    $scope.hideClose = true;
                }

                $scope.hideSearch = function() {
                    $scope.isActive = false;
                    $scope.focusSearch = false;
                    $scope.hideClose = false;
                }

                var msg = {
                    type: "inform",
                    buttons: [{
                        "title": $translate.instant('notificationButtonOk'),
                        "result": "true"
                    }]
                }

                $scope.deleteItem = function(index, currentItem, currOperation) {
                    if (currentItem.IsSystemDefault && $scope.setTitle != "SAVED FILTERS") {
                        msg.message = $translate.instant('deleteSystemDefaultMsg');
                        notification.notify(msg, function(result) {});
                    } else if (currentItem.isDefault == true && $scope.setTitle != "SAVED FILTERS") {
                        msg.message = "You can not delete a saved view when it is marked as default.";
                        notification.notify(msg, function(result) {});
                    } else {
                        var config = {
                            type: "warning",
                            message: $translate.instant('deleteMessage'),
                            buttons: [{
                                "title": $translate.instant('notificationButtonYes'),
                                "result": "true"
                            }, {
                                "title": $translate.instant('notificationButtonNo'),
                                "result": "false"
                            }]
                        };
                        var alterView = cacheHelperService.getDefaultSavedView($scope.config, false) || cacheHelperService.getDefaultSavedView($scope.config, true);
                        notification.notify(config, function(result) {
                            if (result.result == "true") {
                                var deletedView;
                                for (var i = 0; i < $scope.config.length; i++) {
                                    if ($scope.config[i].index === currentItem.index) {
                                        deletedView = $scope.config.splice(i, 1);
                                    }
                                }

                                handleDoneButtonVisibility();
                                handleMarkAsDefault();
                                $scope.callbackFunc({
                                    e: {
                                        'index': currentItem.index,
                                        'currentItem': currentItem,
                                        'currOperation': currOperation
                                    }
                                });
                                var req = {
                                    method: 'DELETE',
                                    url: $scope.api.deleteSavedViewURL,
                                    data: { "data": { "savedViewId": deletedView[0].ViewId } },
                                    headers: {
                                        "Content-Type": "application/json"
                                    }
                                };
                                $http(req).then(function(response) {
                                    if (response.data != null) {
                                        if(alterView){
                                            $scope.api.currentViewApplied = alterView;
                                            $scope.selectedFilter.name = alterView.name;
                                            $scope.api.applyViewOnGrid();
                                            console.log("Saved View Deleted");
                                        }
                                    }
                                }).catch(function(errorCallback) {
                                    console.log(errorCallback.statusText);
                                });
                            }

                        });
                    }

                };

                $scope.showEditor = false;

                $scope.editCurrentViewName = function (index, currentItem) {
                    var _this = $scope;
                    angular.forEach(_this.config, function (key, value) {
                        if (_this.config[value].showCurrentItemEditor == true) {
                            _this.config[value].showCurrentItemEditor = false;
                        }
                    });
                    if (!currentItem.IsSystemDefault) {
                        //$scope.config[index].showCurrentItemEditor = true;
                        //$scope.getEditedviewName.name = $scope.config[index].name;

                        for (var i = 0; i < _this.config.length; i++) {
                            if (_this.config[i].index === currentItem.index) {
                                _this.config[i].showCurrentItemEditor = true;
                            }
                        }
                        _this.getEditedviewName.name = currentItem.name;
                    } else {
                        msg.message = $translate.instant('renameSystemDefaultMsg');
                        notification.notify(msg, function(result) {});
                    }
                    $timeout(function() {
                        _this.getEditedviewName.isFocus = true;
                    }, 900);
                }

                $scope.getEditedviewName = { "name": "", isFocus: false };

                $scope.updateViewName = function (index, currentItem, currOperation) {
                    $scope.closeEditPanel(index, currentItem);
                    $scope.callbackFunc({
                        e: {
                            'index': currentItem.index,
                            'currentItem': currentItem,
                            'currOperation': currOperation,
                            'editedName': $scope.getEditedviewName.name
                        }
                    });
                    if ($scope.getEditedviewName.name.length == 0) {
                        keepPopupOpen();
                        return false;
                    }
                    var duplicateItem = $scope.config.filter(function(view) {
                        return (view.name === $scope.getEditedviewName.name && view.ViewId !== $scope.config[index].ViewId)
                    });
                    if (duplicateItem.length != 0) {
                        showAlertMessage($scope.api.duplicateErrorMessage);
                    } else if (greaterThanMaxCharacterLength($scope.getEditedviewName.name)) {
                        showAlertMessage($scope.api.maxCharacterLength);
                    } else {
                        $scope.config[currentItem.index].name = $scope.getEditedviewName.name;
                        $scope.config[currentItem.index].showCurrentItemEditor = false;
                        var obj = {
                            'ViewName': $scope.config[currentItem.index].name || $scope.config[currentItem.index].ViewName,
                            'IsDefaultView': $scope.config[currentItem.index].isDefault,
                            'IsSystemDefault': $scope.config[currentItem.index].IsSystemDefault,
                            'SortColumn': $scope.config[currentItem.index].SortColumn,
                            'SortOrder': $scope.config[currentItem.index].SortOrder,
                            'ViewId': $scope.config[currentItem.index].ViewId,
                            'GroupColumn': $scope.config[currentItem.index].GroupColumn,
                            'Filters': $scope.config[currentItem.index].Filters,
                            'DocumentTypeCode': $scope.config[currentItem.index].DocumentTypeCode,
                            'ContactCode': $scope.config[currentItem.index].ContactCode,
                            'ColumnList': $scope.config[currentItem.index].ColumnList
                        };
                        var req = {
                            method: 'POST',
                            url: $scope.api.UpdateSavedViewURL,
                            data: obj,
                            headers: {
                                "Content-Type": "application/json"
                            }
                        };
                        $http(req).then(function(response) {
                            if (response.data != null) {
                                console.log($scope.api.updateMessage);
                            }
                        }).catch(function(errorCallback) {
                            console.log(errorCallback.statusText);
                        });

                    }

                };

                $scope.closeEditPanel = function (index, currentItem) {
                    for (var i = 0; i < $scope.config.length; i++) {
                        if ($scope.config[i].index === currentItem.index) {
                            $scope.config[i].showCurrentItemEditor = false;
                        }
                    }
                    currentItem.validate = false;
                };

                $scope.viewObject = {};
                $scope.viewObject.SaveViewName = "";

                $scope.saveCurrentView = function(passData) {
                    if (passData != '') {
                        if (isNameDuplicate(passData)) {
                            showAlertMessage($scope.api.duplicateErrorMessage);
                        } else if (greaterThanMaxCharacterLength(passData)) {
                            showAlertMessage($scope.api.maxCharacterLength);
                        } else {
                            $scope.isApplyFilters = false;

                            $scope.model = { 'name': passData, 'isDefault': false, 'showCurrentItemEditor': false };

                            var req = {
                                method: 'POST',
                                url: $scope.api.insertSavedViewURL,
                                data: {
                                    "ViewId": 0,
                                    "ViewName": passData,
                                    "ContactCode": $scope.api.contactCode,
                                    "ColumnList": cacheHelperService.getColDef() || "",
                                    "Filters": cacheHelperService.getFilterDef() || "",
                                    "SortColumn": "NeedByDate",
                                    "SortOrder": "Ascending",
                                    "GroupColumn": cacheHelperService.getGroupDef() || "",
                                    "IsDefaultView": false,
                                    "IsSystemDefault": false,
                                    "DocumentTypeCode": $scope.api.documentTypeCode
                                },
                                headers: {
                                    "Content-Type": "application/json"
                                }
                            };
                            $http(req).then(function(response) {
                                if (response.data != null) {
                                    $scope.isSavedView = true;
                                    $scope.config.push({
                                        "ViewId": response.data,
                                        "ViewName": passData,
                                        "ContactCode": $scope.api.contactCode,
                                        "ColumnList": cacheHelperService.getColDef() || "",
                                        "Filters": cacheHelperService.getFilterDef() || "",
                                        "SortColumn": "NeedByDate",
                                        "SortOrder": "Ascending",
                                        "GroupColumn": cacheHelperService.getGroupDef() || "",
                                        "IsDefaultView": false,
                                        "IsSystemDefault": false,
                                        "DocumentTypeCode": $scope.api.documentTypeCode,
                                        "showCurrentItemEditor": false,
                                        "name": passData,
                                        "isDefault": false
                                    });
                                    $scope.api.currentViewApplied = _.find($scope.config, { name: $scope.selectedFilter.name });
                                    console.log("Saved View Created");
                                }
                            }).catch(function(errorCallback) {
                                console.log(errorCallback.statusText);
                            });
                            $scope.isSavedFilter = true;
                            $scope.viewObject.SaveViewName = '';


                        }
                    } else {
                        keepPopupOpen();
                    }
                }

                function keepPopupOpen(e) {
                    if (!e) {
                        var e = window.event;
                    }
                    e.cancelBubble = true;
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }
                }

                function isNameDuplicate(editedSavedName) {
                    var duplicateName = "";
                    duplicateName = _.find($scope.config, { name: editedSavedName });
                    if (typeof duplicateName === 'undefined') {
                        return false;
                    }
                    return true;
                }

                function greaterThanMaxCharacterLength(editedSavedName) {
                    if (editedSavedName.length > $scope.api.viewNameLength) {
                        return true;
                    }
                    return false;
                }

                function showAlertMessage(alertMessage) {
                    notification.notify(alertMessage, function(result) { });
                }
                $scope.$watch('show', function(n, o) {
                    angular.forEach($scope.config, function(key, value) {
                        if ($scope.config[value].showCurrentItemEditor == true) {
                            $scope.config[value].showCurrentItemEditor = false;
                        }
                    }); //clearing if anything in edit state
                    if ($scope.openPopupSavedView == true && n == true) {
                        $scope.showPopUp = true;
                        $scope.showSavedViewPopup = true;
                        $scope.showSaveView = false;
                        $scope.hideSearch();
                    } else if ($scope.openPopupSavedView != true && n == true) {
                        $scope.showSavedViewPopup = false;
                        $scope.showSaveView = true;
                    } else {
                        $scope.showSavedViewPopup = false;
                        $scope.showSaveView = false;
                        $scope.show = false;
                        $scope.showPopUp = false;
                    }
                    $timeout(function () {
                        angular.element('.searchWithHiddenTextField input').blur();
                        angular.element('.savedFiltersPopUpLists').find(angular.element('input[checked="checked"]')).prop('checked', true);
                    }, 1000);
                    $scope.radioChangeCallback();
                });


                $scope.loaderFlag = {
                    plain: true,
                    message: $translate.instant('loadingMsg'),
                    center: true
                };

                $scope.$watch('setTitle', function (value) {
                    if (value == 'SAVED FILTERS') {
                        $scope.title = $translate.instant('savedFilters');
                    }
                    if (value == 'SAVED VIEWS') {
                        $scope.title = $translate.instant('savedViews');
                    }
                    
                });

                function SaveResetOrMarkAsDefault(currentViewApplied) {
                    if ($scope.setTitle == "SAVED FILTERS") {
                        console.log(currentViewApplied);

                        var obj =
                        {
                            "rowKey": currentViewApplied.rowKey,
                            "moduleName": currentViewApplied.module,
                            "removeDefaultFilter": currentViewApplied.isDefault ? false : true

                        };
                        var req = {
                            method: 'POST',
                            url: $scope.api.MarkasDefault,
                            data: obj,
                            headers: {
                                "Content-Type": "application/json"
                            }
                        };

                        $http(req).then(function (response) {
                            if (response.data != null) {

                                /*if (currentViewApplied.isDefault) {
                                    for (var i = 0; i < $scope.config.length; i++) {
                                        if ($scope.config[i].rowKey != currentViewApplied.rowKey && $scope.config[i].isDefault) {
                                            $scope.config[i].isDefault = false; 
                                        }
                                    }
                                }*/

                                var view = _.find($scope.config, { "name": $scope.selectedFilter.name || $scope.api.currentViewApplied.name });
                                if (view) {
                                    if (view.isDefault) {
                                        $scope.isMarkAsDefault.check = true;
                                    } else {
                                        $scope.isMarkAsDefault.check = false;
                                    }
                                }

                                for (var i = 0; i < $scope.config.length; i++) {
                                    $scope.config[i].isDefault = false;
                                }

                                view.isDefault = true;
                            }
                        }).catch(function (errorCallback) {
                            console.log(errorCallback.statusText);
                        });

                    } else {
                        var obj = {
                            "ViewId": currentViewApplied.ViewId,
                            "ViewName": currentViewApplied.name,
                            "ContactCode": currentViewApplied.ContactCode,
                            "ColumnList": currentViewApplied.ColumnList,
                            "Filters": currentViewApplied.Filters,
                            "SortColumn": "NeedByDate",
                            "SortOrder": "Ascending",
                            "GroupColumn": currentViewApplied.GroupColumn,
                            "IsDefaultView": currentViewApplied.isDefault,
                            "IsSystemDefault": currentViewApplied.IsSystemDefault,
                            "DocumentTypeCode": currentViewApplied.DocumentTypeCode
                        };
                        var req = {
                            method: 'POST',
                            url: $scope.api.UpdateSavedViewURL,
                            data: obj,
                            headers: {
                                "Content-Type": "application/json"
                            }
                        };
                        $http(req).then(function(response) {
                            if (response.data != null) {
                                console.log($scope.api.updateMessage);
                                if (currentViewApplied.isDefault) {
                                    for (var i = 0; i < $scope.config.length; i++) {
                                        if ($scope.config[i].ViewId != currentViewApplied.ViewId && $scope.config[i].isDefault) {
                                            $scope.config[i].isDefault = false;
                                        }
                                    }
                                }
                            }
                        }).catch(function(errorCallback) {
                            console.log(errorCallback.statusText);
                        });
                    }
                }
                $scope.search_data = $scope.config;
                var b = [];
                $scope.search_savedpopup = function(e) {
                    $scope.config = [];

                    if (e.data[0].value != null && e.data[0].value != "") {

                        b = [];
                        for (var i = 0; i < $scope.search_data.length; i++) {
                            var lowerStr = ($scope.search_data[i].name + "").toLowerCase();
                            var s = lowerStr.indexOf(e.data[0].value.toLowerCase()) === 0;
                            if (s) {
                                if (b.indexOf($scope.search_data[i].name) == -1) {
                                    b.push({ 'name': $scope.search_data[i].name, 'isDefault': $scope.search_data[i].isDefault, 'showCurrentItemEditor': $scope.search_data[i].showCurrentItemEditor });
                                }
                            }
                        }
                        $scope.config = b;
                    } else {
                        b = [];
                        $scope.config = $scope.search_data;
                    }
                }

                $scope.onHide = function() {
                    $scope.viewObject.SaveViewName = '';
                    $scope.hide();
                };

            }],
            templateUrl: 'shared/directives/smartSavedViewPopup/smartSavedViewPopupTemplate.html'
        };
    }
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartSearch', ['httpService', '$timeout', 'APPCONSTANTS', '$translate', function (httpService, $timeout, APPCONSTANTS, $translate) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            scope: {
                type: '@'
            },
            link: function (scope, element, attrs) {
                var scopeValues = { "RFX": { "value": "0", "string": "RFX", "SubAppCodes": 103 }, "RFP": { "value": "1", "string": "RFP", "SubAppCodes": 103 }, "RFQ": { "value": "2", "string": "RFQ", "SubAppCodes": 103 }, "RFI": { "value": "3", "string": "RFI", "SubAppCodes": 103 }, "Auction": { "value": "4", "string": "Auction", "SubAppCodes": 103 }, "Contract": { "value": "5", "string": "Contract", "SubAppCodes": 104 }, "Catalog": { "value": "6", "string": "Catalog", "SubAppCodes": 108 }, "Requisition": { "value": "7", "string": "Requisition", "SubAppCodes": 107 }, "PO": { "value": "8", "string": "PO", "SubAppCodes": 107 }, "Order": { "value": "8", "string": "Order", "SubAppCodes": 107 }, "Invoice": { "value": "9", "string": "Invoice", "SubAppCodes": 107 }, "Receipts": { "value": "10", "string": "Receipt", "SubAppCodes": 107 }, "Forms": { "value": "11", "string": "Forms", "SubAppCodes": 105 }, "Scorecards": { "value": "12", "string": "Scorecards", "SubAppCodes": 105 }, "Workbench": { "value": "13", "string": "Workbench", "SubAppCodes": 110 }, "InvoiceReconciliation": { "value": "14", "string": "InvoiceReconciliation", "SubAppCodes": 107 }, "Items": { "value": "20", "string": "Items" }, "Templates": { "value": "15", "string": "Templates", "SubAppCodes": 111 }, "Partners": { "value": "19", "string": "Partners", "SubAppCodes": 105 }, "ContractRequest": { "value": "16", "string": "ContractRequest" }, "RFxRequest": { "value": "17", "string": "RFxRequest" }, "AuctionRequest": { "value": "18", "string": "AuctionRequest" }, "PaymentRequest": { "value": "27", "string": "PaymentRequest" }, "Project": { "value": "21", "string": "Project", "SubAppCodes": 113 }, "CreditMemo": { "value": "22", "string": "CreditMemo", "SubAppCodes": 107 }, "ReturnNote": { "value": "20", "string": "ReturnNote", "SubAppCodes": 107 }, "ActionPlan": { "value": "23", "string": "ActionPlan", "SubAppCodes": 105 }, "Blanket": { "value": "30", "string": "Blanket", "SubAppCodes": 104 }, "CategoryWorkbench": { "value": "28", "string": "CategoryWorkbench", "SubAppCodes": 116 }, "ProjectDashboard": { "value": "101", "string": "ProjectDashboard", "SubAppCodes": 113 } };

                /*
                 *  Get current module scope
                 */
                var getCurrentModuleScope = function () {
                    var selectedModules = scope.selectedModule.FilterKey.split(',');
                    var moduleScopeString = "";

                    for (var i = 0; i < selectedModules.length; i++) {
                        switch (selectedModules[i]) {
                            case (scopeValues.RFI.value):
                                moduleScopeString += scopeValues.RFI.string + ",";
                                break;
                            case (scopeValues.RFP.value):
                                moduleScopeString += scopeValues.RFP.string + ",";
                                break;
                            case (scopeValues.RFQ.value):
                                moduleScopeString += scopeValues.RFQ.string + ",";
                                break;
                            case (scopeValues.Auction.value):
                                moduleScopeString += scopeValues.Auction.string + ",";
                                break;
                            case scopeValues.Workbench.value:
                                moduleScopeString += scopeValues.Workbench.string + ",";
                                break;
                            case scopeValues.Contract.value:
                                moduleScopeString += scopeValues.Contract.string + ",";
                                break;
                            case scopeValues.Scorecards.value:
                                moduleScopeString += scopeValues.Scorecards.string + ",";
                                break;
                            case scopeValues.Forms.value:
                                moduleScopeString += scopeValues.Forms.string + ",";
                                break;
                            case scopeValues.Requisition.value:
                                moduleScopeString += scopeValues.Requisition.string + ",";
                                break;
                            case scopeValues.Order.value:
                                moduleScopeString += scopeValues.Order.string + ",";
                                break;
                            case scopeValues.Invoice.value:
                                moduleScopeString += scopeValues.Invoice.string + ",";
                                break;
                            case scopeValues.InvoiceReconciliation.value:
                                moduleScopeString += scopeValues.InvoiceReconciliation.string + ",";
                                break;
                            case scopeValues.Receipts.value:
                                moduleScopeString += scopeValues.Receipts.string + ",";
                                break;
                            case scopeValues.AuctionRequest.value:
                                moduleScopeString += scopeValues.AuctionRequest.string + ",";
                                break;
                            case scopeValues.RFxRequest.value:
                                moduleScopeString += scopeValues.RFxRequest.string + ",";
                                break;
                            case scopeValues.ContractRequest.value:
                                moduleScopeString += scopeValues.ContractRequest.string + ",";
                                break;
                            case scopeValues.PaymentRequest.value:
                                moduleScopeString += scopeValues.PaymentRequest.string + ",";
                                break;
                            case scopeValues.Partners.value:
                                moduleScopeString += scopeValues.Partners.string + ",";
                                break;
                            case scopeValues.Templates.value:
                                moduleScopeString += scopeValues.Templates.string + ",";
                                break;
                            case scopeValues.Catalog.value:
                                moduleScopeString += scopeValues.Catalog.string + ",";
                                break;
                                //PPST
                            case scopeValues.Project.value:
                                moduleScopeString += scopeValues.Project.string + ",";
                                break;
                            case scopeValues.CreditMemo.value:
                                moduleScopeString += scopeValues.CreditMemo.string + ",";
                                break;
                            case scopeValues.ReturnNote.value:
                                moduleScopeString += scopeValues.ReturnNote.string + ",";
                                break;
                            case scopeValues.ActionPlan.value:
                                moduleScopeString += scopeValues.ActionPlan.string + ",";
                                break;
                            case scopeValues.Blanket.value:
                                moduleScopeString += scopeValues.Blanket.string + ",";
                                break;
                            case scopeValues.CategoryWorkbench.value:
                                moduleScopeString += scopeValues.CategoryWorkbench.string + ",";
                                break;
                            case scopeValues.ProjectDashboard.value:
                                moduleScopeString += scopeValues.ProjectDashboard.string + ",";
                                break;
                        }
                    }

                    //if ModuleScope is 'RFI,RFQ & RFP' than it should be RFx
                    if ((moduleScopeString.indexOf(scopeValues.RFI.string) !== -1) ||
                        (moduleScopeString.indexOf(scopeValues.RFP.string) !== -1) ||
                        (moduleScopeString.indexOf(scopeValues.RFQ.string) !== -1)) {
                        moduleScopeString = moduleScopeString.replace(scopeValues.RFI.string + ",", '');
                        moduleScopeString = moduleScopeString.replace(scopeValues.RFP.string + ",", '');
                        moduleScopeString = moduleScopeString.replace(scopeValues.RFQ.string + ",", '');
                        moduleScopeString += scopeValues.RFX.string;
                    }

                    // Remove last comma from modulescopestring
                    var lastChar = moduleScopeString.slice(-1);
                    if (lastChar == ',') {
                        moduleScopeString = moduleScopeString.slice(0, -1);
                    }

                    return moduleScopeString;
                };


                /*
                 *  Get search navigation url
                 */
                scope.getSearchNavigateURL = function (moduleScope, fieldKey) {
                    var redirectURL = generateUrl(moduleScope);
                    if (fieldKey) {
                        redirectURL += "&fieldkey=" + fieldKey;
                    }
                    return redirectURL;
                };


                /*
                 *  Get scope from module type
                 */
                var getScopeFromModuleType = function (moduleType) {
                    var scope = '';
                    var array = $.makeArray("16,17,18,27".split(','), moduleType.split(',')[0]);

                    if (moduleType == "1,2,3") {
                        scope = scopeValues.RFX.string.toLowerCase();
                    }
                    else if (array == "16" || array == "17" || array == "18" || array == "27") {
                        scope = "request";
                    }
                    else {
                        for (var key in scopeValues) {
                            if (scopeValues[key].value == moduleType) {
                                scope = scopeValues[key].string.toLowerCase();
                                break;
                            }
                        }
                    }
                    return scope;
                };

                var getModuleTypeFromScope = function (moduleScope) {
                    var type = '';
                    for (var key in scopeValues) {
                        if (scopeValues[key].string.toLowerCase() == moduleScope) {
                            type = scopeValues[key].value;
                            break;
                        }
                    }
                    return type;
                };

                var IsAdvanceSearchEnabled = function (moduleScope) {
                    var productsArray = getAdvanceSearchEnabledProducts();
                    var type = getModuleTypeFromScope(moduleScope);
                    if (productsArray.length > 0) {
                        if (productsArray.indexOf(type) != -1)
                            return true;
                        else
                            return false;
                    }
                };

                var getAdvanceSearchEnabledProducts = function () {
                    var productsArray = scope.advancedSearchDocTypes != null ? scope.advancedSearchDocTypes.split(",") : [];
                    return productsArray;
                };

                /*
                 *  Create redirection url
                 */
                var generateUrl = function (moduleScope) {
                    var searchText = scope.searchText.trim();
                    var url = '';
                    if (IsAdvanceSearchEnabled(moduleScope)) {
                        url = searchConstants.portalURL + 'Portal/Dashboard/Documents?scope=' + moduleScope + '&q=' + searchText + '&oloc=' + searchConstants.documentTypeCodes;
                    }
                    else {
                        url = searchConstants.portalURL + 'Portal/search/searchresults?q=' + searchText + '&scope=' + moduleScope + '&oloc=' + searchConstants.documentTypeCodes;
                    }

                    switch (moduleScope.toLowerCase()) {
                        case scopeValues.Catalog.string.toLowerCase():
                            url = searchConstants.portalURL + '/Catalog/Manage/Navigation?bpc=' + searchConstants.encryptedBPC + '&navTo=1&q=' + searchText + '&scope=' + moduleScope + '&' + searchConstants.catalogQueryString + '&oloc=' + scopeValues.Catalog.SubAppCodes;
                            break;
                        case scopeValues.Order.string.toLowerCase():
                            url += '&' + searchConstants.orderQueryString;
                            break;
                        case scopeValues.Invoice.string.toLowerCase():
                            url += '&' + searchConstants.invoiceQueryString;
                            break;
                        case scopeValues.Receipts.string.toLowerCase():
                            url += '&' + searchConstants.receiptQueryString;
                            break;
                        case scopeValues.Requisition.string.toLowerCase():
                            url += '&' + searchConstants.requisitionQueryString;
                            break;
                        case scopeValues.InvoiceReconciliation.string.toLowerCase():
                            url += '&' + searchConstants.invoiceReconcillationQueryString;
                            break;
                        case scopeValues.CreditMemo.string.toLowerCase():
                            url += '&' + searchConstants.creditMemoQuerystring;
                            break;
                        case scopeValues.Blanket.string.toLowerCase():
                            url += '&' + searchConstants.blanketQueryString;
                            break;
                        case scopeValues.CategoryWorkbench.string.toLowerCase():
                            url += '&' + searchConstants.categoryWorkbenchQueryString;
                            break;
                        case scopeValues.Partners.string.toLowerCase():
                            url = searchConstants.portalURL + 'Portal/search/searchresults?q=' + searchText + '&scope=' + moduleScope + '&' + searchConstants.partnersQueryString + '&oloc=' + searchConstants.documentTypeCodes;
                            break;
                        case scopeValues.Forms.string.toLowerCase():
                            url += '&' + searchConstants.formQueryString;
                            break;
                        case scopeValues.Scorecards.string.toLowerCase():
                            url += '&' + searchConstants.assessmentQueryString;
                            break;
                        case scopeValues.Workbench.string.toLowerCase():
                            url += '&' + searchConstants.workBenchQueryString;
                            break;
                        case scopeValues.RFX.string.toLowerCase():
                        case scopeValues.RFP.string.toLowerCase():
                        case scopeValues.RFQ.string.toLowerCase():
                        case scopeValues.RFI.string.toLowerCase():
                            url += '&' + searchConstants.rfxQueryString;
                            break;
                        case scopeValues.Auction.string.toLowerCase():
                            url += '&' + searchConstants.auctionQueryString;
                            break;
                        case scopeValues.ActionPlan.string.toLowerCase():
                            url += '&' + searchConstants.actionPlanQueryString;
                            break;
                        case scopeValues.Contract.string.toLowerCase():
                            url += '&' + searchConstants.contractQueryString;
                            break;
                        case scopeValues.Templates.string.toLowerCase():
                            url += '&' + searchConstants.catalogQueryString;
                            break;
                        case "request":
                            moduleScope = scopeValues.RFxRequest.string.toLowerCase() + "," + scopeValues.AuctionRequest.string.toLowerCase() + "," + scopeValues.ContractRequest.string.toLowerCase() + "," + scopeValues.PaymentRequest.string.toLowerCase();
                            url = searchConstants.portalURL + 'Portal/search/searchresults?q=' + searchText + '&scope=' + moduleScope + '&oloc=' + searchConstants.documentTypeCodes;
                            break;
                        case "returnnote":
                            url += '&' + searchConstants.returnNoteQuerystring;
                            break;
                        case scopeValues.Project.string.toLowerCase():
                            url = searchConstants.portalURL + 'PPST/Project/ProjectHome?oloc=113&q=' + searchText + '&' + searchConstants.projectQueryString;
                            break;
                        default:
                            if ((moduleScope.toLowerCase().indexOf(scopeValues.AuctionRequest.string.toLowerCase()) !== -1) || (moduleScope.toLowerCase().indexOf(scopeValues.RFxRequest.string.toLowerCase()) !== -1) || (moduleScope.toLowerCase().indexOf(scopeValues.ContractRequest.string.toLowerCase()) !== -1) || (moduleScope.toLowerCase().indexOf(scopeValues.PaymentRequest.string.toLowerCase()) !== -1)) {
                                url += '&' + searchConstants.auctionQueryString;
                            }
                            break;
                    }

                    if (APPCONSTANTS.userPreferences.UserBasicDetails.IsSupplier) {
                        url = url + "&dd=" + searchConstants.encryptedBPC;
                    }

                    return url;
                };


                scope.searchText = '';

                var request, searchConstants, lastSearchedText;

                /*
                 *  Get search constants from .net controller
                 */
                if (APPCONSTANTS && APPCONSTANTS.userPreferences && APPCONSTANTS.userPreferences.constantURLAndQueryStringValue)
                    searchConstants = APPCONSTANTS.userPreferences.constantURLAndQueryStringValue;
                else {
                    request = {
                        method: 'GET',
                        url: '/' + APPCONSTANTS.userPreferences.AreaName + '/GetConstantURLAndQueryStringValues?oloc=216'
                    };

                    httpService.directhttp(request).then(function (result) {
                        searchConstants = result;
                    }, function (errorData) {
                        searchConstants = {};
                    });
                }

                request = {
                    method: 'GET',
                    url: '/' + APPCONSTANTS.userPreferences.AreaName + '/GetAllowedModulesList?oloc=216&BuyerPartnerCode=' + APPCONSTANTS.userPreferences.UserBasicDetails.BuyerPartnerCode
                };

                function setAllowedModuleListData(result) {
                    var modules = result.Output;
                    var orderIndex = -1;
                    for (var i = 0; i < modules.length; i++) {
                        if (modules[i].FilterKey == 8) {
                            orderIndex = i;
                            break;
                        }
                    }
                    if (orderIndex > -1) {
                        var quickSearchItem = modules.splice(orderIndex, 1);
                        modules.splice(1, 0, quickSearchItem[0]);
                    }
                    scope.modules = angular.copy(modules);
                    scope.selectedModule = scope.modules[0];
                    scope.advancedSearchDocTypes = result.AdvancedSearchDocTypes;
                };

                if (APPCONSTANTS.userPreferences.allowedModulesList){
                    setAllowedModuleListData(APPCONSTANTS.userPreferences.allowedModulesList);
                }else{
                    httpService.directhttp(request).then(function (result) {
                        setAllowedModuleListData(result);
                    }, function (errorData) { });
                }
                
                /*
                 *  On module item click handler
                 */
                scope.onModuleClick = function (module) {
                    scope.selectedModule = module;
                    scope.showFilterList = false;
                    scope.recentSearches = null;
                    scope.searchResult = null;
                };


                /*
                 *  Get recent searches
                 */
                var getRecentSearches = function () {
                    if (scope.recentSearches) {
                        scope.recentSearches = scope.recentSearches.splice(0, 5);
                        scope.showRecentSearches = true;
                        return;
                    }

                    scope.recentSearches = null;

                    scope.isRecentSearchesLoading = true;

                    request = {
                        method: 'GET',
                        url: '/Controls/HeaderBar/GetRecentSearches?oloc=101&moduleType=' + (scope.selectedModule.IsAllMenu ? 0 : scope.selectedModule.FilterKey.split(',')[0]) + '&fieldKey=' + (scope.selectedModule.FieldKey != undefined ? scope.selectedModule.FieldKey : 0)
                    };

                    httpService.directhttp(request).then(function (result) {
                        scope.showRecentSearches = true;
                        scope.isRecentSearchesLoading = false;
                        try {
                            scope.recentSearches = JSON.parse(result.RecentSearches).splice(0, 5);
                        }
                        catch (e) {
                            scope.recentSearches = [];
                        }
                    }, function (errorData) {
                        scope.isRecentSearchesLoading = false;
                    });
                };


                /*
                 *  Get search results
                 */
                scope.onSearchTextChange = function (event) {
                    if (event.keyCode === 13 && scope.searchText.trim().length > 2) {
                        if (!scope.selectedModule.IsAllMenu) {
                            window.location.href = scope.getSearchNavigateURL(getScopeFromModuleType(scope.selectedModule.FilterKey), scope.selectedModule.FieldKey);
                            return;
                        }

                        scope.showRecentSearches = false;
                        scope.showFilterList = false;
                        scope.showSearchResult = true;
                        scope.isSearchResultLoading = true;

                        //  If user has recently searched for the text entered, do not hit the service
                        if (lastSearchedText === scope.searchText.trim() && scope.searchResult) {
                            scope.isSearchResultLoading = false;
                            return;
                        }

                        if (!scope.recentSearches) {
                            getSearchResults();
                            return;
                        }

                        var recentSearches = [{ "Sequence": 0, "SearchText": scope.searchText.trim() }];

                        //  Remove duplicate entries from recent searches and generate recent search sequence
                        for (var i = 0; i < scope.recentSearches.length; i++) {
                            if (scope.recentSearches[i].SearchText != scope.searchText.trim()) {
                                recentSearches.push({
                                    "Sequence": recentSearches.length,
                                    "SearchText": scope.recentSearches[i].SearchText
                                });
                            }
                        }

                        scope.recentSearches = angular.copy(recentSearches);

                        request = {
                            method: 'POST',
                            url: '/Controls/HeaderBar/SaveRecentSearches?oloc=101',
                            data: {
                                "recentSearches": JSON.stringify(recentSearches),
                                "moduleType": scope.selectedModule.IsAllMenu ? 0 : scope.selectedModule.FilterKey.split(",")[0],
                                "fieldKey": scope.selectedModule.FieldKey != undefined ? scope.selectedModule.FieldKey : 0
                            }
                        };

                        httpService.directhttp(request).then(function (result) {
                            getSearchResults();
                        }, function (errorData) {
                            getSearchResults();
                        });
                    }
                    else {
                        if (scope.searchText.trim().length == 0) {
                            scope.showSearchResult = false;
                            getRecentSearches();
                        }
                    }
                };


                var getSearchResults = function () {
                    lastSearchedText = angular.copy(scope.searchText.trim());

                    scope.searchResult = null;

                    request = {
                        method: 'POST',
                        url: '/Controls/BaseSearch/GetSearchResultForWeb?oloc=101',
                        data: {
                            "searchKeyword": scope.searchText.trim(),
                            "Filters": ["searchScope:All", "pageNumber:1", "isGlobalSearch:true", "module:all", "moduleScope:" + getCurrentModuleScope(), "noOfRecords:0"]
                        }
                    };

                    if (scope.selectedModule.FieldKey) {
                        request.data.Filters.push("fieldkey:" + scope.selectedModule.FieldKey);
                    }

                    httpService.directhttp(request).then(function (result) {
                        scope.isSearchResultLoading = false;
                        if (result.DataSearchResult.GroupTotal.TotalCount > 0) {
                            scope.searchResult = result.DataSearchResult.GroupTotal;
                        }
                        else {
                            scope.searchResult = [];
                        }
                    }, function (errorData) {
                        scope.isSearchResultLoading = false;
                    });
                };


                /*
                 *  On search-text focus
                 */
                scope.onSearchTextFocus = function (e) {
                    if (scope.searchText.trim().length == 0) {
                        scope.showSearchResult = false;
                        getRecentSearches();
                    }
                };


                /*
                 *  On recent search item click handler
                 */
                scope.onRecentSearchItemClick = function (text) {
                    scope.searchText = text;
                    scope.onSearchTextChange({ keyCode: 13 });
                };


                /*
                 *  Get translated label
                 */
                scope.getTranslatedLabel = function (label) {
                    return $translate.instant(label);
                };


                /*
                 *  On document click handler
                 */
                var onDocumentClick = function () {
                    $timeout(function () {
                        scope.showRecentSearches = false;
                        scope.showFilterList = false;
                        scope.showSearchResult = false;
                        try {
                            httpService.abort(request);
                        }
                        catch (e) { }
                    });
                };

                $(document).on('click', onDocumentClick);

                scope.$on('$destroy', function () {
                    $(document).off('click', onDocumentClick);
                })
            },
            templateUrl: 'shared/directives/smartSearch/smartSearchTemplate.html'
        };
    }]);
})();
/*
    ::attributes {
        getCheckboxInfo : & (callback for getting selected items and total length of set)
                   data : @ (takes pipe "|" sepereted values like eg. "dataset|selector")
            checkerFlag : @
            disableFlag : @
    }
*/

(function (angular) {
    "use strict";
    angular
        .module("SMART2")
        .directive("smartSelectall", ["$parse", "$timeout", smartSelectallFun]);

    function smartSelectallFun($parse, $timeout) {
        return {
            restrict: "A",
            require: "ngModel",
            link: function (scope, element, attrs, ngModel) {
                var getCheckboxInfo = attrs.getCheckboxInfo ? $parse(attrs.getCheckboxInfo.replace(/\(\)/, '(selected, length)')) : false, // callback for to get checkbox selection status info
                    config = function () {
                        var a = attrs.data.split("|"),
                        scopeDeep = a[0] ? a[0].replace(/\s+/ig, '') : null,
                        checkboxSelector = a[1] ? a[1].replace(/\s+/ig, '') : null,
                        checkerFlag = attrs.checkerFlag ? attrs.checkerFlag : "checked",
                        disableFlag = attrs.disableFlag ? attrs.disableFlag : "disable",
                        //checkerStyle = attrs.checkerFlag.indexOf("{") == 0 ? "eval" : "flag",
                        disableStyle = disableFlag.indexOf("{") == 0 ? "eval" : "flag",
                        sc = getScope(scope, scopeDeep);

                        return {
                            checkerFlag: checkerFlag,
                            //checkerStyle: checkerStyle,
                            disableFlag: disableFlag,
                            disableStyle: disableStyle,
                            scopeDeep: scopeDeep,
                            scopeData: sc, // set of list items
                            selector: checkboxSelector,
                            selected: 0,
                            length: sc.length
                        };
                    }(),
                    mainCheckbox = element.find("input[type=checkbox]");

                if (scope.__selectallExoprt) {
                    !scope.__selectallExoprt && (scope.__selectallExoprt = {});
                    scope.__selectallExoprt.selectall = function (check) {
                        mainCheckbox.prop('checked', check).change();
                    };
                };

                mainCheckbox.change(function (e) {
                    var el = $(this),
                        _scope = scope,
                        isChecked = el.prop("checked");

                    config.scopeData.forEach(function (a) {
                        var isDisabled = function () {
                            var r;
                            if (config.disableStyle == "flag") {
                                r = a[config.disableFlag];
                            } else if (config.disableStyle == "eval") {
                                r = eval(config.disableFlag.replace(/(\{|\})/ig, '').replace(/this/ig, 'a'));
                            }
                            return r;
                        }();
                        if (!isDisabled) {
                            a[config.checkerFlag] = isChecked;
                        }
                    });
                    element.removeClass("filled-partial");
                    config.selected = isChecked ? config.scopeData.length : 0;
                    if (getCheckboxInfo)
                        scope.$apply(function () {
                            getCheckboxInfo(scope, getInfo());
                        });
                });


                scope.$watchCollection(config.scopeData, function () {
                    refresh();
                });

                scope.$watch(config.scopeDeep + ".length", function () {
                    refresh();
                });

                initCheckbox(); // applying events to checkbox


                function initCheckbox() {
                    $timeout(function () {
                        initCheckboxItem();
                    });
                }
                function initCheckboxItem() {
                    var allCheckbox = $(config.selector).find("input[type=checkbox]");
                    if (allCheckbox && allCheckbox.length > 0) {
                        allCheckbox.unbind("change").change(function (e) {
                            var el = $(this),
                                isChecked = el.prop("checked");

                            config.selected = isChecked ? config.selected += 1 : config.selected -= 1;
                            if (config.selected < config.length) {
                                config.selected == 0 ? element.removeClass("filled-partial") : element.addClass("filled-partial");
                                ngModel.$setViewValue(false);
                                ngModel.$render();
                            } else if (config.selected == config.length) {
                                element.removeClass("filled-partial");
                                ngModel.$setViewValue(true);
                                ngModel.$render();
                            }
                            if (getCheckboxInfo)
                                scope.$apply(function () {
                                    getCheckboxInfo(scope, getInfo());
                                });
                        });
                    }
                }
                function resetConfig() {
                    var selected = 0;
                    config.scopeData = getScope(scope, config.scopeDeep);
                    config.scopeData.forEach(function (a) {
                        if (a[config.checkerFlag]) selected++;
                    });

                    config.selected = selected;
                    config.length = config.scopeData.length;

                    if (config.selected < config.length) {
                        config.selected == 0 ? element.removeClass("filled-partial") : element.addClass("filled-partial");
                        ngModel.$setViewValue(false);
                        ngModel.$render();
                    } else if (config.selected == config.length) {
                        element.removeClass("filled-partial");
                        ngModel.$setViewValue(true);
                        ngModel.$render();
                    }

                    if (getCheckboxInfo)
                        scope.$applyAsync(function () {
                            getCheckboxInfo(scope, getInfo());
                        });
                }
                function getScope(scope, deep) {
                    var a, b = deep.split(".");
                    if (b.length > 1) {
                        a = scope;
                        for (var i = 0; i < b.length; i++) {
                            a = a[b[i]];
                        }
                    } else {
                        a = scope[deep];
                    }
                    return a;
                }
                function refresh() {
                    initCheckbox();
                    resetConfig();
                }
                function getInfo() {
                    return {
                        selected: config.selected,
                        length: config.length
                    }
                }
            }
        };
    };
})(angular);
angular.module('SMART2').directive('smartSort', function () {
    return {
        restrict: 'E',
       	transclude: true,
       	template:'<a href=\"javascript:void(0)\" class="waves-circle waves-effect waves-grey" ng-click=\"ascDescToggler()\">\n<i ng-if="currentCell != sortBy" class=\"icon iconSmall grey-text\" smart-tooltip position=\"bottom\" delay=\"50\" message=\"{{ \'Sort By \' | translate }}\">\n<svg>\n<use xlink:href=\"{{ \'#icon_Sort\' }}\"><\/use>\n<\/svg><\/i><i class=\"icon iconSmall grey-text\" ng-if="currentCell == sortBy" ng-class=\" { \'s-dd-icon-wth-color\':  currentCell == sortBy }\"  smart-tooltip position=\"bottom\" delay=\"50\" message=\"{{ iconWithTooltip.tooltip | translate }}\">\n<svg>\n<use xlink:href=\"{{ iconWithTooltip.sortbyIcon }}\"><\/use>\n<\/svg><\/i><\/a>',
       	scope:{
       		sortBy:"=",
       		sortReverse:"=",
			currentCell:"@"
       	},
       	link:function($scope, $element, $attrs){

       		$scope.iconWithTooltip = {
				sortbyIcon : "",
       			tooltip	:	""

       		}

       		
	       		$scope.ascDescToggler = function(){
              
       			$scope.sortBy = $scope.currentCell;
	       			$scope.sortReverse = !$scope.sortReverse;

	       			if($scope.sortBy == $scope.currentCell && $scope.sortReverse == false ){
							$scope.iconWithTooltip.sortbyIcon = "#icon_SortDescending";
	       					$scope.iconWithTooltip.tooltip	=	"Descending";
	       			}
	       			else if($scope.sortBy == $scope.currentCell && $scope.sortReverse == true ){
							$scope.iconWithTooltip.sortbyIcon = "#icon_SortAscending";
	       					$scope.iconWithTooltip.tooltip	=	"Ascending";
	       			}
	       			
       			};
       		
       	}
       
    }
});
var isRegionalSettingEnabled = typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable;
(function () {
    'use strict';

    var app = angular.module('SMART2');


    window.onmousedown = function (e) {
        if ($(e.target).closest('.smart-table-cell-template').length > 0) {
            window.isSmartTableCellClicked = true;
        }

        //	If autosuggest option is not clicked, allow scope to be cleared
        if (window.lastActiveCellScope && ($(e.target).closest('.daterangepicker').length > 0 || $(e.target).closest('.autocomplete-suggestion').length > 0 ||
        $(e.target).closest('.autocomplete-suggestions').length > 0 || $(e.target).closest('.modal').length > 0 || $(e.target).closest('.lean-overlay').length > 0)) {
            return;
        }

        //	Clear and update last rendered cell when selection or tree icon is clicked
        if ($(e.target).closest('.smart-table-row-cell').length == 0 || $(e.target).closest('.smart-table-icon-holder').length > 0) {
            if (window.lastActiveCellScope) {
                window.lastActiveCellScope.stopEdit();
                window.lastActiveCellScope = undefined;
            }
            return;
        }
    };


    window.focusHandler = function (element) {
        element.focus(function () {
            setTimeout((function (el) {
                var strLength = el.value.length;
                return function () {
                    if (el.setSelectionRange !== undefined) {
                        el.setSelectionRange(strLength, strLength);
                    }
                    else {
                        $(el).val(el.value);
                    }
                }
            }(this)), 0);
        });
    };


    //  To handle date picker control issue
    setTimeout(function () {
        window.onkeydown = function (e) {
            if ($(e.target).is('body') && window.lastActiveCellScope &&
                window.lastActiveCellScope.column.attributes && window.lastActiveCellScope.column.attributes.type == 'date') {
                window.lastActiveCellScope.onElementKeyDown(e);
                return false;
            }
        };
    }, 500);


    function getObjectValue(obj, keys) {
        try {
            var arr = keys.split('.');
            while (arr.length) {
                obj = obj[arr.shift()];
            }
        }
        catch (e) { }
        return obj;
    };

    function getObjectValueForAutoSuggest(obj, keys) {
        var arr = keys.split('.');
        if (arr.length > 1) {
            arr.splice(arr.length - 1, 1);
            return getObjectValue(obj, arr.join('.'));
        }
        return obj[arr[0]];
    };

    function setObjectValue(obj, keys, value) {
        try {
            var arr = keys.split('.');
            if (arr.length == 1) {
                obj[arr[0]] = value;
            }
            else {
                var obj = obj[arr[0]];
                arr.shift();
                var keys = arr.join('.');
                setObjectValue(obj, keys, value);
            }
        }
        catch (e) { }
    };

    function updateCell(obj, keys, value) {
        if (!angular.isObject(value)) {
            setObjectValue(obj, keys, value);
            return;
        }
        else if (!angular.isObject(obj[keys.split('.')[0]]) && angular.isObject(value)) {
            setObjectValue(obj, keys, value[keys.split('.')[0]]);
            return;
        }
        angular.extend(obj[keys.split('.')[0]], value);
    };

    function getFormattedData(data, displayFormat) {
        if (!data || data.length == 0) {
            return [];
        }
        for (var i = 0; i < data.length; i++) {
            var str = displayFormat;
            try {
                var parentSplit = str.split('{');
                for (var j = 0; j < parentSplit.length; j++) {
                    var childSplit = parentSplit[j].split('}');
                    for (var k = 0; k < childSplit.length; k++) {
                        if (childSplit[k].indexOf('.') > 0 || data[i].hasOwnProperty(childSplit[k])) {
                            str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), eval('data[i].' + childSplit[k]));
                        }
                    }
                }
            }
            catch (e) { }
            data[i].value = str.trim();
        }
        return data;
    };

    function getDisplayData(data, displayFormat) {
        if (data == undefined || data == null || data == '') {
            return '';
        }
        var str = displayFormat, evalResult, evaluatedKeysCounter = 0, nullKeysCounter = 0;
        try {
            var parentSplit = str.split('{');
            for (var j = 0; j < parentSplit.length; j++) {
                var childSplit = parentSplit[j].split('}');
                for (var k = 0; k < childSplit.length; k++) {
                    if (childSplit[k].indexOf('.') > 0 || data.hasOwnProperty(childSplit[k])) {
                        evalResult = eval('data.' + childSplit[k]);
                        evaluatedKeysCounter++;
                        if (evalResult == undefined || evalResult == null || (evalResult + '').trim().length == 0) {
                            evalResult = '';
                            nullKeysCounter++;
                        }
                        str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), evalResult);
                    }
                }
            }
            if (evaluatedKeysCounter == nullKeysCounter) {
                str = '';
            }
        }
        catch (e) { }
        return str === undefined || str === null || str === 'undefined' || str === 'null' ? '' : str;
    };

    function convertNumberToFixed(number, minPrecision, maxPrecision) {
        var arrTmpInputValue, tmpStrAfterPrecision;
        arrTmpInputValue = (number + '').split('.');

        if (arrTmpInputValue.length > 1) {
            tmpStrAfterPrecision = arrTmpInputValue[arrTmpInputValue.length - 1];
            if (maxPrecision > 0 && tmpStrAfterPrecision.length >= maxPrecision) {
                return number.toString().match(new RegExp('^-?\\d+(?:\.\\d{0,' + (maxPrecision || -1) + '})?'))[0];
            }
            else if (minPrecision > 0 && tmpStrAfterPrecision.length <= minPrecision) {
                return Number(Math.round(number + 'e' + minPrecision) + 'e-' + minPrecision);
            }
            else {
                return number;
            }
        }
        else {
            return Number(Math.round(number + 'e' + minPrecision) + 'e-' + minPrecision);
        }
    };

    function sortSmartTableData(data, column, isAscending, translate) {
        return data.sort(function (a, b) {
            var strOne = getObjectValue(a, column.field);
            var strTwo = getObjectValue(b, column.field);

            var intOne = parseFloat(strOne);
            var intTwo = parseFloat(strTwo);

            if (isNaN(intOne) && isNaN(intTwo)) {
                try {
                    if (column.enableTranslation) {
                        strOne = translate.instant(strOne);
                        strTwo = translate.instant(strTwo);
                    }
                    strOne = strOne.toLowerCase();
                    strTwo = strTwo.toLowerCase();
                }
                catch (e) { }
                return strOne > strTwo ? (isAscending ? -1 : 1) : (strOne < strTwo ? (isAscending ? 1 : -1) : 0);
            }
            else if (isNaN(intOne)) {
                return isAscending ? -1 : 1;
            }
            else if (isNaN(intTwo)) {
                return isAscending ? 1 : -1;
            }
            else {
                return intOne > intTwo ? (isAscending ? -1 : 1) : (intOne < intTwo ? (isAscending ? 1 : -1) : 0);
            }
        });
    };

    app.filter('smartTableFilter', ['$filter', '$translate', 'smartTableUtils', function ($filter, $translate, smartTableUtils) {
        var isParentRowToBeDisplayed = function (data, index, filters) {
            var result = false;

            for (var i = index + 1; i < data.length; i++) {
                if (data[i].$$treeLevel == 0) {
                    break;
                }
                else {
                    for (var j = 0; j < filters.length; j++) {
                        if (((getObjectValue(data[i], filters[j].filterKey) + "").toLowerCase()).indexOf((filters[j].filterText + "").toLowerCase()) > -1) {
                            result = true;
                            break;
                        }
                    }
                }
            }

            return result;
        };

        var getChildrenNodes = function (data, nodeIndex) {
            var tmpRows = $filter('filter')(data, function (row, i) {
                return row.$$treeLevel > 0 && row.$$nodeIndex == nodeIndex;
            });
            tmpRows = $filter('orderBy')(tmpRows, '$$treeLevel', false);
            return tmpRows;
        };

        return function (data, filters, sortState, enableTreeView, showTreeView, offset, limit, useExternalPagination, smartTableId) {
            var outputData;
            if (filters.length == 0) {
                if (data) {
                    if (enableTreeView) {
                        var nodeIndex = -1;
                        var parentIndex = -1;

                        outputData = $filter('filter')(data, function (row, index) {
                            if (row.$$treeLevel == 0) {
                                nodeIndex++;
                                parentIndex = index;
                                row.$$enableTreeView = false;
                            }
                            else {
                                try {
                                    data[parentIndex].$$enableTreeView = true;
                                }
                                catch (e) { }
                            }

                            row.$$nodeIndex = nodeIndex;
                            row.$$index = (useExternalPagination ? offset : 0) + index;
                            row.$$parentIndex = parentIndex;
                            row.$$isExpanded = data[parentIndex].$$isExpanded || !showTreeView;
                            row.$$isSelectable = angular.isUndefined(row.$$isSelectable) ? true : row.$$isSelectable;

                            return row.$$treeLevel == 0 || row.$$isExpanded;
                        });
                    }
                    else {
                        outputData = $filter('filter')(data, function (row, index) {
                            row.$$index = (useExternalPagination ? offset : 0) + index;
                            row.$$isSelectable = angular.isUndefined(row.$$isSelectable) ? true : row.$$isSelectable;
                            return true;
                        });
                    }
                }
                else {
                    outputData = [];
                }
            }
            else {
                var keysMatchCounter = 0;
                var nodeIndex = -1;
                var parentIndex = -1;
                var cellValue;

                if (enableTreeView) {
                    outputData = $filter('filter')(data, function (row, index) {
                        if (row.$$treeLevel == 0) {
                            nodeIndex++;
                            parentIndex = index;
                            row.$$enableTreeView = false;
                        }
                        else {
                            try {
                                data[parentIndex].$$enableTreeView = true;
                            }
                            catch (e) { }
                        }

                        row.$$nodeIndex = nodeIndex;
                        row.$$index = index;
                        row.$$parentIndex = parentIndex;
                        row.$$isExpanded = data[parentIndex].$$isExpanded || !showTreeView;
                        row.$$isSelectable = angular.isUndefined(row.$$isSelectable) ? true : row.$$isSelectable;
                        keysMatchCounter = 0;

                        for (var j = 0; j < filters.length; j++) {
                            cellValue = (filters[j].colDef.enableTranslation && $translate.instant(getObjectValue(row, filters[j].filterKey) + '')) || getObjectValue(row, filters[j].filterKey) + '';

                            if ((cellValue.toLowerCase()).indexOf((filters[j].filterText + '').toLowerCase()) > -1 ||
                            (angular.isFunction(filters[j].condition) && filters[j].condition(filters[j].filterText, row, filters[j].colDef))) {
                                keysMatchCounter++;
                            }
                        }

                        return (row.$$treeLevel == 0 && keysMatchCounter == filters.length) ||
                            (row.$$treeLevel != 0 && row.$$isExpanded && keysMatchCounter == filters.length) ||
                            (row.$$treeLevel == 0 && isParentRowToBeDisplayed(data, index, filters));
                    });
                }
                else {
                    outputData = $filter('filter')(data, function (row, index) {
                        row.$$index = index;
                        row.$$isSelectable = angular.isUndefined(row.$$isSelectable) ? true : row.$$isSelectable;
                        keysMatchCounter = 0;

                        for (var j = 0; j < filters.length; j++) {
                            cellValue = (filters[j].colDef.enableTranslation && $translate.instant(getObjectValue(row, filters[j].filterKey) + '')) || getObjectValue(row, filters[j].filterKey) + '';

                            if ((cellValue.toLowerCase()).indexOf((filters[j].filterText + '').toLowerCase()) > -1 ||
                            (angular.isFunction(filters[j].condition) && filters[j].condition(filters[j].filterText, row, filters[j].colDef))) {
                                keysMatchCounter++;
                            }
                        }

                        return keysMatchCounter == filters.length;
                    });
                }
            }

            if (sortState) {
                if (enableTreeView) {
                    //	reorder tree data
                    var arrParentNodes = $filter('filter')(outputData, function (row) {
                        return row.$$treeLevel == 0;
                    });
                    if (sortState.order > -1) {
                        if (angular.isFunction(sortState.condition)) {
                            arrParentNodes = sortState.condition(arrParentNodes, sortState.column, sortState.order == 0 ? false : true);
                        }
                        else {
                            arrParentNodes = sortSmartTableData(arrParentNodes, sortState.column, sortState.order == 0 ? false : true, $translate);
                        }
                    }
                    var arrOrderedData = [];
                    angular.forEach(arrParentNodes, function (row) {
                        arrOrderedData = arrOrderedData.concat([row]).concat(getChildrenNodes(outputData, row.$$nodeIndex));
                    });
                    outputData = arrOrderedData;
                }
                else {
                    if (sortState.order > -1) {
                        if (angular.isFunction(sortState.condition)) {
                            outputData = sortState.condition(outputData, sortState.column, sortState.order == 0 ? false : true);
                        }
                        else {
                            outputData = sortSmartTableData(outputData, sortState.column, sortState.order == 0 ? false : true, $translate);
                        }
                    }
                }
            }

            if (!useExternalPagination) {
                //	Update total number of pages
                smartTableUtils.broadcast('dataChange', { totalRecords: outputData.length, smartTableId: smartTableId });

                outputData = outputData.slice(offset, limit);

                //	Update currently displayed records count
                smartTableUtils.broadcast('pageIndexChanged', { currentPageDataLength: outputData.length, smartTableId: smartTableId });
            }

            return outputData;
        }
    }]);


    app.directive('smartTable', ['$filter', '$timeout', '$templateCache', 'smartTableUtils', function ($filter, $timeout, $templateCache, smartTableUtils) {
        return {
            restrict: 'EA',
            replace: true,
            transclude: true,
            scope: {
                smartTable: '=?'
            },
            link: function (scope, element, attrs) {
                var areEventListenersAdded = false, arrSelectedRowsIndexes = [], smartTableState;
                var pageIndex = 0;
                var recordsFetchedCount = 0;
                var totalPages;
                var apis;

                var sortOrder = 1;  //  1 = descending, 0 = ascending, -1 = reset
                scope.filters = [];
                scope.enableRowSelection = false;
                scope.enableTreeView = false;
                scope.showTreeView = false;
                scope.arrRowsPerPageOptions = [10, 20, 30, 40, 50];
                scope.rowsPerPage = "10";
                scope.useExternalPagination = false;
                scope.smartTableId = 'smart-table-' + (new Date().getTime());

                scope.listeners = {};

                var limit = parseInt(scope.rowsPerPage);

                var addEventListeners = function (smartTable) {
                    apis = {
                        core: {
                            getActiveColumns: function () {
                                return scope.smartTableConfig.columnDefs;
                            },
                            getColDefs: function () {
                                return scope.smartTableConfig.columnDefs;
                            },
                            notifyColumnChange: function () {
                                init('columnChange');
                            },
                            notifyRowDataChange: function (rowIndex) {
                                smartTableUtils.broadcast('rowDataChange', { rowIndex: rowIndex, smartTableId: scope.smartTableId });
                            },
                            notifyDataChange: function (isToBeRefreshed) {
                                if (isToBeRefreshed) {
                                    init('refresh');
                                }
                                else {
                                    smartTableUtils.broadcast('dataChange', { smartTableId: scope.smartTableId, updateCell: true });
                                }
                            },
                            refresh: function () {
                                scope.enableRowSelection = scope.smartTableConfig.enableRowSelection ? true : false;
                                scope.enableTreeView = scope.smartTableConfig.enableTreeView ? true : false;
                                scope.showTreeView = scope.smartTableConfig.showTreeView ? true : false;
                                scope.useExternalPagination = scope.smartTableConfig.useExternalPagination ? true : false;
                                init('refresh');
                                angular.isFunction(smartTable.onRefresh) && smartTable.onRefresh(apis);
                            },
                            update: function () {
                                init('dataChange');
                            },
                            stopEdit: function () {
                                if (window.lastActiveCellScope) {
                                    window.lastActiveCellScope.stopEdit();
                                    window.lastActiveCellScope = undefined;
                                }
                            },
                            pagination: {
                                on: {
                                    nextButtonClick: function (scopeRef, onNextButtonClick) {
                                        scope.listeners['nextButtonClick'] = onNextButtonClick;
                                    },
                                    previousButtonClick: function (scopeRef, onPreviousButtonClick) {
                                        scope.listeners['previousButtonClick'] = onPreviousButtonClick;
                                    },
                                    sort: function (scopeRef, onSort) {
                                        scope.listeners['sort'] = onSort;
                                    },
                                    filter: function (scopeRef, onFilter) {
                                        scope.listeners['filter'] = onFilter;
                                    }
                                },
                                setDataLength: function (totalItemsCount) {
                                    scope.displayedRecords = totalItemsCount;
                                },
                                setData: function (items) {
                                    scope.smartTableConfig.data = items;
                                    scope.currentPageDataLength = items.length;
                                },
                                setOffset: function (offset) {
                                    scope.offset = offset;
                                },
                                setLimit: function (limit) {
                                    scope.limit = limit;
                                },
                                getOffset: function () {
                                    return scope.offset;
                                },
                                getRowsPerPage: function () {
                                    return scope.rowsPerPage;
                                }
                            },
                            on: {
                                columnRefresh: function (scopeRef, onColumnRefresh) {
                                    scope.listeners['columnRefresh'] = onColumnRefresh;
                                }
                            }
                        },
                        cell: {
                            on: {
                                click: function (scopeRef, onCellClick) {
                                    scope.listeners['cellClick'] = onCellClick;
                                },
                                change: function (scopeRef, onCellChange) {
                                    scope.listeners['cellChange'] = onCellChange;
                                },
                                optionsChange: function (scopeRef, onOptionsChange) {
                                    scope.listeners['optionsChange'] = onOptionsChange;
                                },
                                optionSelect: function (scopeRef, onOptionSelect) {
                                    scope.listeners['optionSelect'] = onOptionSelect;
                                }
                            }
                        },
                        cellNav: {
                            scrollToFocus: function (rowIndex, colField) {
                                var columnIndex, toBeFocused = true;

                                for (var i = 0; i < scope.colDefs.length; i++) {
                                    if (scope.colDefs[i].field == colField) {
                                        columnIndex = i;
                                        break;
                                    }
                                }

                                if (scope.enableTreeView && scope.showTreeView && !scope.smartTableConfig.data[scope.smartTableConfig.data[rowIndex].$$parentIndex].$$isExpanded) {
                                    scope.pendingFocus = {
                                        rowIndex: rowIndex,
                                        columnIndex: columnIndex
                                    };
                                    scope.smartTableConfig.data[scope.smartTableConfig.data[rowIndex].$$parentIndex].$$isExpanded = true;
                                    toBeFocused = false;
                                }

                                //  Load next page
                                if (rowIndex > (scope.limit > scope.displayedRecords ? scope.displayedRecords : scope.limit) - 1) {
                                    scope.pendingFocus = {
                                        rowIndex: rowIndex,
                                        columnIndex: columnIndex
                                    };
                                    scope.updatePagination(true, false);
                                }
                                    //  Load previous page
                                else if (rowIndex < scope.offset) {
                                    scope.pendingFocus = {
                                        rowIndex: rowIndex,
                                        columnIndex: columnIndex
                                    };
                                    scope.updatePagination(false, false);
                                }
                                else if (toBeFocused) {
                                    scope.pendingFocus = undefined;
                                    $('#' + scope.smartTableId + '-smart-table-cell-' + ((scope.pinnedColumns.length + scope.unpinnedColumns.length) * (rowIndex - scope.offset) + columnIndex)).focus();
                                    //smartTableUtils.broadcast('focusCell', { rowIndex: rowIndex - scope.offset, colField: colField, smartTableId: scope.smartTableId });
                                }

                                document.getSelection().removeAllRanges();
                            }
                        },
                        edit: {
                            on: {
                                beginCellEdit: function (scopeRef, onBeginCellEdit) {
                                    scope.listeners['beginCellEdit'] = onBeginCellEdit;
                                },
                                endCellEdit: function (scopeRef, onEndCellEdit) {
                                    scope.listeners['endCellEdit'] = onEndCellEdit;
                                },
                                afterCellEdit: function (scopeRef, onAfterCellEdit) {
                                    scope.listeners['afterCellEdit'] = onAfterCellEdit;
                                }
                            }
                        },
                        saveState: {
                            save: function () {
                                var columnsState = [];
                                var tmpColDefs = getReOrderedColumnDefsForState(scope.smartTableConfig.columnDefs);

                                for (var i = 0; i < tmpColDefs.length; i++) {
                                    columnsState.push({
                                        displayKey: tmpColDefs[i].displayKey,
                                        displayName: tmpColDefs[i].displayName,
                                        field: tmpColDefs[i].field,
                                        width: tmpColDefs[i].width,
                                        visible: tmpColDefs[i].visible
                                    });
                                }

                                return {
                                    columns: JSON.stringify(columnsState),
                                    filters: scope.filters,
                                    sort: scope.sortState,
                                    enableRowSelection: scope.enableRowSelection,
                                    enableTreeView: scope.enableTreeView,
                                    showTreeView: scope.showTreeView,
                                    pagination: {
                                        pageIndex: pageIndex,
                                        limit: limit,
                                        paginationCurrentPage: 1,
                                        paginationPageSize: 10
                                    },
                                    timestamp: new Date(),
                                    documentURL: window.location.href,
                                    isSmartTable: true
                                };
                            },
                            restore: function (scopeRef, state) {
                                //	restore table state
                                if (state.isSmartTable) {
                                    scope.enableRowSelection = state.enableRowSelection ? true : false;
                                    scope.enableTreeView = state.enableTreeView ? true : false;
                                    scope.showTreeView = state.showTreeView ? true : false;

                                    if (state.filters && !scope.useExternalPagination) {
                                        scope.filters = state.filters;
                                    }
                                    if (angular.isDefined(state.columns)) {
                                        scope.smartTableConfig.columnDefs = getReOrderedColumnDefs(state.columns);
                                    }
                                    if (!scope.useExternalPagination) {
                                        if (state.pagination) {
                                            pageIndex = state.pagination.limit > 10 ? 0 : state.pagination.pageIndex;
                                            limit = 10; // state.pagination.limit;
                                            scope.offset = pageIndex * limit;
                                            scope.limit = (pageIndex * limit) + limit;
                                            scope.rowsPerPage = "10";
                                        }
                                        if (state.sort) {
                                            scope.sortState = state.sort;
                                            sortOrder = state.sort.order;
                                        }
                                    }
                                    refreshColumns();
                                    angular.isFunction(smartTable.onRefresh) && smartTable.onRefresh(apis);
                                }
                                else {
                                    scope.enableRowSelection = scope.smartTableConfig.enableRowSelection ? true : false;
                                    scope.enableTreeView = scope.smartTableConfig.enableTreeView ? true : false;
                                    scope.showTreeView = scope.smartTableConfig.showTreeView ? true : false;
                                    init('refresh');
                                }
                            }
                        },
                        selection: {
                            clearSelectedRows: function () {
                                for (var i = 0; i < scope.smartTableConfig.data.length; i++) {
                                    scope.smartTableConfig.data[i].$$isSelected = false;
                                }
                                arrSelectedRowsIndexes = [];
                                scope.isAllRowSelected = false;
                            },
                            getSelectedRows: function () {
                                var tmpSelectedRows = [], tmpRow, arrDeletedIndexes = [];
                                for (var i = 0; i < arrSelectedRowsIndexes.length; i++) {
                                    tmpRow = angular.copy(scope.smartTableConfig.data[arrSelectedRowsIndexes[i]]);
                                    if (tmpRow) {
                                        tmpRow.$$isSelected = false;
                                        tmpSelectedRows.push({ entity: tmpRow, index: arrSelectedRowsIndexes[i] });
                                    }
                                    else {
                                        arrDeletedIndexes.push(i);
                                    }
                                }
                                for (var i = arrDeletedIndexes.length - 1; i >= 0; i--) {
                                    arrSelectedRowsIndexes.splice(arrDeletedIndexes[i], 1);
                                }
                                return tmpSelectedRows;
                            },
                            on: {
                                rowSelectionChanged: function (scopeRef, onRowSelectedChanged) {
                                    scope.listeners['rowSelectionChanged'] = onRowSelectedChanged;
                                }
                            }
                        },
                        options: scope.smartTableConfig
                    };
                    angular.isFunction(smartTable.onRegister) && smartTable.onRegister(apis);
                };


                var onSmartTableConfigChange = scope.$watch('smartTable', function (newConfig) {
                    if (!newConfig) {
                        return;
                    }

                    scope.smartTableConfig = newConfig;
                    scope.enableRowSelection = scope.smartTableConfig.enableRowSelection ? true : false;
                    scope.enableTreeView = scope.smartTableConfig.enableTreeView ? true : false;
                    scope.showTreeView = scope.smartTableConfig.showTreeView ? true : false;
                    scope.useExternalPagination = scope.smartTableConfig.useExternalPagination ? true : false;

                    scope.smartTableConfig.columnDefs = newConfig.columnDefs ? newConfig.columnDefs : [];
                    scope.smartTableConfig.data = newConfig.data ? newConfig.data : [];

                    init('refresh');

                    if (!areEventListenersAdded) {
                        addEventListeners(scope.smartTable);
                        areEventListenersAdded = true;
                    }
                });


                var getColumnDef = function (srcConfig, colField) {
                    for (var i = 0; i < srcConfig.length; i++) {
                        if (srcConfig[i].field == colField) {
                            return srcConfig[i];
                        }
                    }
                    return undefined;
                };


                var getColumFilterText = function (colField) {
                    for (var i = 0; i < scope.filters.length; i++) {
                        if (scope.filters[i].filterKey == colField) {
                            return scope.filters[i].filterText;
                        }
                    }
                    return undefined;
                };


                var getReOrderedColumnDefs = function (colDefs) {
                    colDefs = typeof colDefs == 'string' ? JSON.parse(colDefs) : colDefs;
                    for (var i = 0; i < scope.smartTableConfig.columnDefs.length; i++) {
                        if (angular.isUndefined(getColumnDef(colDefs, scope.smartTableConfig.columnDefs[i].field))) {
                            return scope.smartTableConfig.columnDefs;
                        }
                    }
                    var reOrderedColumns = [];
                    var colDef;
                    for (var i = 0; i < colDefs.length; i++) {
                        colDef = getColumnDef(scope.smartTableConfig.columnDefs, colDefs[i].field);
                        if (angular.isUndefined(colDef)) {
                            return scope.smartTableConfig.columnDefs;
                        }
                        reOrderedColumns.push(angular.extend(colDef, {
                            width: colDefs[i].width,
                            visible: angular.isUndefined(colDefs[i].visible) ? colDef.visible : colDefs[i].visible,
                            filterText: getColumFilterText(colDefs[i].field)
                        }));
                    }
                    return reOrderedColumns;
                };


                var getReOrderedColumnDefsForState = function (colDefs) {
                    var pinnedColumns = [];
                    var unpinnedColumns = [];

                    for (var i = 0; i < colDefs.length; i++) {
                        if (colDefs[i].pinnedLeft) {
                            pinnedColumns.push(colDefs[i]);
                        }
                        else {
                            unpinnedColumns.push(colDefs[i]);
                        }
                    }

                    return pinnedColumns.concat(unpinnedColumns);
                };


                var refreshColumns = function () {
                    var pinnedColumns = [];
                    var unpinnedColumns = [];
                    var pinnedContainerWidth = 0;

                    var colDefs = angular.copy(scope.smartTableConfig.columnDefs);
                    var tmpColDefs = [];
                    var leftPos = (scope.enableRowSelection ? 40 : 0) + (scope.enableTreeView && scope.showTreeView ? 40 : 0);

                    for (var i = 0; i < colDefs.length; i++) {
                        if (colDefs[i].visible == false) {
                            continue;
                        }

                        if (colDefs[i].pinnedLeft) {
                            pinnedColumns.push(colDefs[i]);
                        }
                        else {
                            colDefs[i].pinnedLeft = false;
                            unpinnedColumns.push(colDefs[i]);
                        }
                    }

                    colDefs = pinnedColumns.concat(unpinnedColumns);
                    pinnedColumns = [];
                    unpinnedColumns = [];

                    for (var i = 0; i < colDefs.length; i++) {
                        if (colDefs[i].visible == false) {
                            continue;
                        }

                        colDefs[i].left = leftPos;

                        leftPos = leftPos + colDefs[i].width;

                        if (colDefs[i].pinnedLeft) {
                            pinnedContainerWidth = pinnedContainerWidth + (colDefs[i].visible ? (colDefs[i].width ? colDefs[i].width : '100') : 0);
                            pinnedColumns.push(colDefs[i]);
                        }
                        else {
                            unpinnedColumns.push(colDefs[i]);
                        }
                    }

                    tmpColDefs = pinnedColumns.concat(unpinnedColumns);

                    scope.colDefs = angular.copy(tmpColDefs);

                    $(element.find('.smart-table-unpinned-container')).css('margin-left', pinnedContainerWidth + (scope.enableRowSelection ? 40 : 0) + (scope.enableTreeView && scope.showTreeView ? 40 : 0));

                    scope.pinnedColumns = pinnedColumns;
                    scope.unpinnedColumns = unpinnedColumns;

                    scope.updateSmartTableColumnResizer = true;
                    scope.updateSmartTableColumnSorter = true;
                };


                var init = function (eventType) {
                    switch (eventType) {
                        case 'refresh':
                            pageIndex = 0;
                            scope.rowsPerPage = "10";
                            limit = parseInt(scope.rowsPerPage); // 10;
                            recordsFetchedCount = 0;

                            sortOrder = 1;

                            for (var i = 0; i < scope.smartTableConfig.columnDefs.length; i++) {
                                scope.smartTableConfig.columnDefs[i].filterText = "";
                            }

                            scope.filters = [];
                            scope.sortState = undefined;

                            scope.isRowSelectionEnabled = true;
                            scope.isAllRowSelected = false;

                            refreshColumns();

                            scope.updatePagination(false, true);
                            break;

                        case 'columnChange':
                        case 'dataChange':
                            refreshColumns();
                            break;
                    }
                };


                scope.updatePagination = function (isNextButtonClicked, isRefresh) {
                    if (scope.useExternalPagination) {
                        if (isNextButtonClicked) {
                            angular.isFunction(scope.listeners.nextButtonClick) && scope.listeners.nextButtonClick();
                        }
                        else {
                            angular.isFunction(scope.listeners.previousButtonClick) && scope.listeners.previousButtonClick();
                        }
                        return;
                    }

                    if (isRefresh) {
                        scope.offset = 0;
                        scope.limit = parseInt(scope.rowsPerPage); // 10
                        pageIndex = 0;
                    }
                    else {
                        if (isNextButtonClicked && pageIndex < totalPages) {
                            pageIndex++;
                        }
                        else if (!isNextButtonClicked && pageIndex > 0) {
                            pageIndex--;
                        }
                        scope.offset = pageIndex * limit;
                        scope.limit = (pageIndex * limit) + limit;
                    }
                };


                scope.onRowsPerPageOptionChange = function (rowsPerPage) {
                    limit = parseInt(rowsPerPage);
                    scope.updatePagination(false, true);
                };


                scope.filterData = function (column) {
                    for (var i = 0; i < scope.filters.length; i++) {
                        if (scope.filters[i].filterKey == column.field) {
                            if (column.filterText.trim() == '') {
                                scope.filters.splice(i, 1);
                            }
                            else {
                                scope.filters[i].filterText = column.filterText;
                            }
                            scope.updatePagination(false, true);
                            return;
                        }
                    }
                    scope.filters.push({
                        filterKey: column.field,
                        filterText: column.filterText,
                        colDef: column,
                        condition: column.hasOwnProperty('filter') && column.filter.condition
                    });
                    scope.updatePagination(false, true);
                };


                scope.sortData = function (column) {
                    smartTableUtils.debounce.add(function () {
                        //	If new column needs to be sorted, then reset sort flag
                        if (scope.sortState && scope.sortState.column.field != column.field || sortOrder < -1) {
                            sortOrder = 1;
                        }
                        refreshColumns();
                        scope.updatePagination(false, true);
                        scope.sortState = {
                            column: column,
                            order: sortOrder,
                            condition: column.sortCondition
                        };
                        sortOrder--;
                    }, 250);
                };


                scope.selectRow = function (row, rowIndex, shouldSelectedAllRows) {
                    if (shouldSelectedAllRows) {
                        scope.isAllRowSelected = !scope.isAllRowSelected;
                        if (scope.isAllRowSelected) {
                            arrSelectedRowsIndexes = [];
                        }
                        for (var i = 0; i < scope.smartTableConfig.data.length; i++) {
                            scope.smartTableConfig.data[i].$$isSelected = scope.smartTableConfig.data[i].$$isSelectable && scope.isAllRowSelected;
                            if (scope.isAllRowSelected && scope.smartTableConfig.data[i].$$isSelected) {
                                arrSelectedRowsIndexes.push(i);
                            }
                        }
                        if (!scope.isAllRowSelected) {
                            arrSelectedRowsIndexes = [];
                        }
                    }
                    else {
                        row.$$isSelected = row.$$isSelectable && !row.$$isSelected;
                        if (row.$$isSelected) {
                            arrSelectedRowsIndexes.push(rowIndex);
                        }
                        else {
                            if (arrSelectedRowsIndexes.indexOf(rowIndex) > -1) {
                                arrSelectedRowsIndexes.splice(arrSelectedRowsIndexes.indexOf(rowIndex), 1);
                            }
                        }
                        scope.isAllRowSelected = arrSelectedRowsIndexes.length == scope.smartTableConfig.data.length;
                    }

                    if (/*rowIndex > -1 &&*/ angular.isFunction(scope.listeners.rowSelectionChanged)) {
                        scope.listeners.rowSelectionChanged({
                            row: {
                                entity: row,
                                index: rowIndex,
                                isSelected: scope.isAllRowSelected || (row && row.$$isSelected)
                            }
                        });
                    }
                };


                scope.expandRow = function (row, rowIndex, shouldExpandAllRows) {
                    if (shouldExpandAllRows) {
                        for (var i = 0; i < scope.smartTableConfig.data.length; i++) {
                            if (scope.smartTableConfig.data[i].$$treeLevel == 0) {
                                scope.smartTableConfig.data[i].$$isExpanded = !scope.isAllRowExpanded
                            }
                        }
                        scope.isAllRowExpanded = !scope.isAllRowExpanded;
                        scope.updatePagination(false, true);
                    }
                    else {
                        if (row.$$treeLevel > 0) {
                            return;
                        }
                        row.$$isExpanded = !row.$$isExpanded;
                        scope.isAllRowExpanded = false;
                    }
                };


                scope.onColumnSort = function (e) {
                    var activeColDefs = angular.copy(scope.colDefs);
                    var startIndex, endIndex, toBeSorted;

                    var startCol = activeColDefs[e.startIndex];
                    var endCol = activeColDefs[e.endIndex];

                    if (startCol.pinnedLeft != endCol.pinnedLeft || startCol.field == endCol.field) {
                        return;
                    }

                    scope.$apply(function () {
                        for (var i = 0; i < scope.smartTableConfig.columnDefs.length; i++) {
                            if (scope.smartTableConfig.columnDefs[i].field == startCol.field) {
                                startIndex = i;
                                if (angular.isDefined(endIndex)) {
                                    break;
                                }
                            }

                            if (scope.smartTableConfig.columnDefs[i].field == endCol.field) {
                                endIndex = i;
                                if (angular.isDefined(startIndex)) {
                                    break;
                                }
                            }
                        }

                        var tmpColDefs = angular.copy(scope.smartTableConfig.columnDefs);
                        var item = tmpColDefs.splice(startIndex, 1);
                        tmpColDefs.splice(endIndex, 0, item[0]);
                        scope.smartTableConfig.columnDefs = angular.copy(tmpColDefs);
                        tmpColDefs = null;

                        init('columnChange');
                        angular.isFunction(scope.listeners.columnRefresh) && scope.listeners.columnRefresh(scope.colDefs);
                    });
                };


                scope.onColumnResize = function (e) {
                    var activeColDefs = angular.copy(scope.colDefs);
                    var colToBeResized;

                    for (var i = 0; i < activeColDefs.length; i++) {
                        if (e.columnIndex == i) {
                            colToBeResized = activeColDefs[i];
                            break;
                        }
                    }

                    for (var i = 0; i < scope.smartTableConfig.columnDefs.length; i++) {
                        if (scope.smartTableConfig.columnDefs[i].field == colToBeResized.field) {
                            scope.smartTableConfig.columnDefs[i].width = e.width;
                            break;
                        }
                    }

                    init('columnChange');
                    angular.isFunction(scope.listeners.columnRefresh) && scope.listeners.columnRefresh(scope.colDefs);
                };


                var watchers;

                scope.onSmartTableRenderingStart = function () {
                    watchers = scope.$$watchers;
                    scope.$$watchers = [];
                    // window.startTime = performance.now();
                    // console.log('rendering start');
                };

                scope.onSmartTableRenderingDone = function () {
                    if (watchers) {
                        scope.$$watchers = watchers;
                    }
                    // discard our copy of the watchers
                    watchers = void 0;
                    // console.log('rendering done in => ' + ((performance.now() - window.startTime) / 1000) + ' seconds');
                };

                var onDataChange = smartTableUtils.on('dataChange', function (e) {
                    if (angular.isDefined(e.totalRecords) && e.smartTableId == scope.smartTableId) {
                        totalPages = Math.ceil(e.totalRecords / limit) - 1;
                        scope.displayedRecords = e.totalRecords;
                    }
                });

                var onPageIndexChanged = smartTableUtils.on('pageIndexChanged', function (e) {
                    if (e.smartTableId == scope.smartTableId) {
                        scope.currentPageDataLength = e.currentPageDataLength;
                    }
                });

                var onSmartTableCurrentPageDataLength = scope.$watch('currentPageDataLength', function (newLength) {
                    if (newLength == 0 && pageIndex > 0) {
                        scope.updatePagination(false, false);
                    }
                });

                scope.$on('$destroy', function () {
                    onSmartTableConfigChange();
                    onPageIndexChanged();
                    onSmartTableCurrentPageDataLength();
                });
            },
            templateUrl: 'shared/directives/smartTable/smartTableTemplate.html'
        };
    }]);

    app.service('smartTableUtils', ['$timeout', function ($timeout) {
        var _this = this;

        /*
         *  Alternative of broadcast event
         */
        var arrEvents = [];
        var eventCounter = 0;


        /*
         *  Deregister an event or events
         */
        this.removeEventListener = function (event) {
            for (var i = 0; i < arrEvents.length; i++) {
                if (arrEvents[i].eventName == event.eventName && arrEvents[i].eventId == event.eventId) {
                    arrEvents[i].callback = null;
                    arrEvents.splice(i, 1);
                    break;
                }
            }
        };


        /*
         *  Register a listener
         */
        this.on = function (eventName, callback) {
            eventCounter++;
            arrEvents.push({
                eventName: eventName,
                callback: callback,
                eventId: 'smart-broadcast-event-' + eventCounter
            });
            var objEvent = {
                eventName: eventName,
                eventId: 'smart-broadcast-event-' + eventCounter
            };
            return function () {
                _this.removeEventListener(objEvent);
            };
        };


        /*
         *  Fire an event
         */
        this.broadcast = function (eventName, data) {
            for (var i = 0; i < arrEvents.length; i++) {
                if (eventName == arrEvents[i].eventName) {
                    angular.isFunction(arrEvents[i].callback) && arrEvents[i].callback(data);
                }
            }
        };


        /*
	     *	Debouncer logic
		 */
        var functionTimeout, isAngularTimeout;

        this.debounce = {
            add: function (callback, duration, isDigestCycleToBeTriggered) {
                if (functionTimeout) {
                    if (angular.isDefined(isDigestCycleToBeTriggered) && isDigestCycleToBeTriggered == false) {
                        clearTimeout(functionTimeout);
                    }
                    else {
                        $timeout.cancel(functionTimeout);
                    }
                }
                functionTimeout = angular.isDefined(isDigestCycleToBeTriggered) && isDigestCycleToBeTriggered == false ? setTimeout(function () {
                    angular.isFunction(callback) && callback();
                }, duration ? duration : 1000) : $timeout(function () {
                    angular.isFunction(callback) && callback();
                }, duration ? duration : 1000);
                isAngularTimeout = !angular.isDefined(isDigestCycleToBeTriggered) && isDigestCycleToBeTriggered == false;
            },
            cancel: function () {
                if (isAngularTimeout) {
                    $timeout.cancel(functionTimeout);
                }
                else {
                    clearTimeout(functionTimeout);
                }
                functionTimeout = null;
            }
        };
    }]);

    app.directive('smartTableCellStyle', ['$compile', '$timeout',
	function () {
	    return {
	        restrict: 'A',
	        link: function (scope, element, attrs) {
	            //	to watch the rendering changes e.g. sort or filter
	            var onColumnConfigChange = scope.$watch('column', function (n) {
	                init();
	            });

	            var init = function () {
	                element.removeClass('smart-table-pinned-column smart-table-unpinned-column');
	                if (scope.column.pinnedLeft) {
	                    element.addClass('smart-table-pinned-column');
	                    element.css('left', scope.column.left);
	                    element.css('width', scope.column.width);
	                }
	                else {
	                    element.addClass('smart-table-unpinned-column');
	                }
	            };

	            scope.$on('$destroy', function () {
	                onColumnConfigChange();
	            });
	        }
	    };
	}]);

    app.directive('smartTableHeaderCellTextContainer', ['$compile', '$timeout',
	function () {
	    return {
	        restrict: 'C',
	        link: function (scope, element, attrs) {
	            //	to watch the rendering changes e.g. sort or filter
	            var onColumnConfigChange = scope.$watch('column', function (n) {
	                init();
	            });

	            var init = function () {
	                element.css('width', scope.column.width - (scope.column.pinnedLeft ? 12 : 0));
	            };

	            scope.$on('$destroy', function () {
	                onColumnConfigChange();
	            });
	        }
	    };
	}]);

    app.directive('smartTableColumnResizer', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var isMouseDown, canBeResized, resizer, leftPosLimit = 0, columnIndex, maxWidth, width, newWidth;

                var onMouseMove = function (e) {
                    if (isMouseDown) {
                        if (e.clientX > leftPosLimit && (angular.isUndefined(maxWidth) || (angular.isDefined(maxWidth) && e.clientX - leftPosLimit < maxWidth))) {
                            resizer.css({
                                left: e.clientX
                            });
                        }
                        document.getSelection().removeAllRanges();
                    }
                    else {
                        if (e.offsetX > (($(this).outerWidth(true) - 2) - 5) && e.offsetX < (($(this).outerWidth(true) - 2))) {
                            $(this).css('cursor', 'col-resize');
                        }
                        else {
                            $(this).css('cursor', 'default');
                        }
                    }
                };

                var onMouseUp = function (e) {
                    if (isMouseDown) {
                        resizer.off('mousemove', onMouseMove);
                        resizer.off('mouseup', onMouseUp);
                        resizer.remove();
                        canBeResized = false;
                        isMouseDown = false;
                        newWidth = (angular.isDefined(maxWidth) && e.clientX - leftPosLimit > maxWidth) ? maxWidth : e.clientX - leftPosLimit;

                        if (Math.abs(newWidth - width) > 5) {
                            scope.$apply(function () {
                                scope.onColumnResize({
                                    columnIndex: columnIndex,
                                    width: newWidth < 20 ? 20 : newWidth
                                });
                            });
                        }
                    }
                };

                var onMouseDown = function (e) {
                    if (e.offsetX >= (($(this).outerWidth(true) - 2) - 5) && e.offsetX < (($(this).outerWidth(true) - 2))) {
                        $(this).css('cursor', 'col-resize');
                        leftPosLimit = $(this).offset().left;
                        resizer = $(document.createElement('div'));
                        columnIndex = parseInt($(this).attr('column-index'));
                        maxWidth = scope.colDefs[columnIndex].maxWidth;
                        width = scope.colDefs[columnIndex].width;

                        resizer.css({
                            position: 'absolute',
                            left: $(this).offset().left + $(this).outerWidth(true),
                            top: $(this).offset().top,
                            width: '1px',
                            height: $(this).closest('table').outerHeight(true),
                            'z-index': 1000,
                            border: 'dotted'
                        });

                        resizer.on('mousemove', onMouseMove);
                        resizer.on('mouseup', onMouseUp);

                        $(document.body).append(resizer);

                        isMouseDown = true;
                    }
                    else {
                        $(this).css('cursor', 'default');
                    }
                };

                var bindEvents = function () {
                    setTimeout(function () {
                        element.find('th').not('.smart-table-icon-holder').off('mousedown', onMouseDown);
                        element.find('th').not('.smart-table-icon-holder').off('mouseup', onMouseUp);
                        element.find('th').not('.smart-table-icon-holder').off('mousemove', onMouseMove);

                        element.find('th').not('.smart-table-icon-holder').on('mousedown', onMouseDown);
                        element.find('th').not('.smart-table-icon-holder').on('mouseup', onMouseUp);
                        element.find('th').not('.smart-table-icon-holder').on('mousemove', onMouseMove);
                    }, 250);
                };

                scope.$watch('updateSmartTableColumnResizer', function (newValue) {
                    if (newValue) {
                        bindEvents();
                        scope.updateSmartTableColumnResizer = false;
                    }
                });
            }
        };
    }]);

    app.directive('smartTableColumnSorter', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var isMouseDown, startX, offsetX, isPinnedColumn, clone, mouseDownTimeout;

                var onMouseMove = function (e) {
                    if (isMouseDown) {
                        $(clone).css({
                            left: e.clientX - offsetX
                        });
                        document.getSelection().removeAllRanges();
                    }
                };

                var onMouseUp = function (e) {
                    $(clone).off('mousemove', onMouseMove);
                    $(clone).off('mouseup', onMouseUp);
                    $(clone).off('mouseleave', onMouseUp);
                    $(clone).remove();

                    if (isMouseDown && e.type == 'mouseup') {
                        var startIndex, endIndex;

                        element.find('th').not('.smart-table-icon-holder').each(function (index, th) {
                            if (angular.isUndefined(startIndex) && startX > $(th).offset().left && startX < $(th).offset().left + $(th).outerWidth(true)) {
                                startIndex = index;
                            }
                            else if (angular.isUndefined(endIndex) && e.clientX > $(th).offset().left && e.clientX < $(th).offset().left + $(th).outerWidth(true)) {
                                endIndex = index;
                            }
                        });

                        if (angular.isDefined(startIndex) && angular.isDefined(endIndex)) {
                            scope.onColumnSort({
                                startIndex: startIndex,
                                endIndex: endIndex,
                                isPinnedColumn: isPinnedColumn
                            });
                        }
                    }

                    isMouseDown = false;

                    if (mouseDownTimeout) {
                        clearTimeout(mouseDownTimeout);
                        mouseDownTimeout = undefined;
                    }
                };

                var onMouseDown = function (e) {
                    if ($(e.target).closest('.smart-table-search-container').length > 0 || e.offsetX >= $(this).outerWidth(true) - 20) {
                        return;
                    }

                    var $this = this;

                    mouseDownTimeout = setTimeout(function () {
                        startX = e.clientX;
                        offsetX = e.offsetX;
                        isMouseDown = true;

                        isPinnedColumn = $(e.target).closest('.smart-table-pinned-column').length > 0;
                        clone = $($this).clone();

                        $(clone).on('mousemove', onMouseMove);
                        $(clone).on('mouseup', onMouseUp);
                        $(clone).on('mouseleave', onMouseUp);

                        $(clone).css({
                            position: 'absolute',
                            left: $($this).offset().left,
                            top: $($this).offset().top,
                            width: $($this).outerWidth(true),
                            height: $($this).outerHeight(true),
                            'z-index': 1000,
                            border: 'dotted'
                        });

                        $(document.body).append(clone);

                        mouseDownTimeout = undefined;
                    }, 500);
                };

                var bindEvents = function () {
                    setTimeout(function () {
                        element.find('th').not('.smart-table-icon-holder').off('mousedown', onMouseDown);
                        element.find('th').not('.smart-table-icon-holder').off('mouseup', onMouseUp);
                        element.find('th').not('.smart-table-icon-holder').off('mousemove', onMouseMove);

                        element.find('th').not('.smart-table-icon-holder').on('mousedown', onMouseDown);
                        element.find('th').not('.smart-table-icon-holder').on('mousemove', onMouseMove);
                        element.find('th').not('.smart-table-icon-holder').on('mouseup', onMouseUp);
                    }, 250);
                };

                scope.$watch('updateSmartTableColumnSorter', function (newValue) {
                    if (newValue) {
                        bindEvents();
                        scope.updateSmartTableColumnSorter = false;
                    }
                });
            }
        };
    }]);

    app.directive('smartTableCell', ['$rootScope', '$compile', '$timeout', 'smartTableUtils', '$filter', '$translate', 'APPCONSTANTS', 'httpService',
	function ($rootScope, $compile, $timeout, smartTableUtils, $filter, $translate, APPCONSTANTS, httpService) {
	    return {
	        restrict: 'EA',
	        replace: true,
	        link: function (scope, element, attrs) {
	            var tabIndex, oldCellValue, oldCellClass, tmpCellValue, tmpInputValue, tmpValueForAutoSuggest;
	            var isInEditMode = false, selectedOption, selectedDate;

	            var templateContainer, cellClassElement = $(element.closest('.smart-table-row-cell'));
	            var hasStopEditCalled = false, isLineNumberAssigned = false, isInputFieldFocused = false, isRenderingToBeSkipped = false, isFocusToBeSkipped = false;

	            var appScope = scope.$parent.$parent.$parent;
	            var smartTableScope = scope.$parent.$parent;

	            //	to watch the rendering changes e.g. sort or filter, col def change
	            var onCellDataAndColDefChange = scope.$watchGroup(['value', 'column'], function (n) {
	                tabIndex = (scope.pinnedColumns.length + scope.unpinnedColumns.length) * scope.$parent.$index + scope.$index;
	                element.attr('id', smartTableScope.smartTableId + '-smart-table-cell-' + tabIndex);
	                element.attr('tabindex', tabIndex);
	                oldCellClass = undefined;
	                init(false, true);
	                if (angular.isDefined(smartTableScope.pendingFocus) && (smartTableScope.pendingFocus.rowIndex - smartTableScope.offset) == scope.rowIndex && smartTableScope.pendingFocus.columnIndex == scope.columnIndex) {
	                    element.trigger('focus');
	                    scope.pendingFocus = undefined;
	                }
	            });

	            var init = function (isRowDataUpdated, toBeTranslated) {
	                scope.row = {
	                    entity: scope.value
	                };

	                if (angular.isDefined(scope.column) && scope.column.uiType == 'editable' && scope.column.attributes.type == 'date' && isRegionalSettingEnabled) {
	                    scope.column.attributes.format = moment.localeData().longDateFormat('L').toLowerCase().replace(/m/g, 'M');
	                }

	                scope.enableCellEdit = angular.copy(scope.column.enableCellEdit);

	                cellClassElement.removeClass('smart-table-row-cell-invalid smart-table-row-cell-disabled smart-table-row-cell-canceled');

	                $(element.closest('.smart-table-row-cell-text')).css({
	                    border: '',
	                    width: scope.column.width + (scope.column.pinnedLeft ? -2 : 10)
	                });

	                if (!isRowDataUpdated) {
	                    //	rendering start callback
	                    if (!smartTableScope.hasSmartTableRenderingStarted) {
	                        scope.onSmartTableRenderingStart();
	                        smartTableScope.hasSmartTableRenderingStarted = true;
	                    }

	                    scope.pinned = attrs.pinned == 'true';

	                    scope.rowIndex = scope.$parent.$index;
	                    scope.columnIndex = scope.$index;

	                    if (scope.column.autoIncrement && !smartTableScope.useExternalPagination) {
	                        if (angular.isDefined(scope.row.entity.$$nodeIndex)) {
	                            updateCell(scope.row.entity, scope.column.field, scope.row.entity.$$nodeIndex + 1);
	                        }
	                        else {
	                            updateCell(scope.row.entity, scope.column.field, scope.row.entity.$$index + 1);
	                        }
	                    }
	                }

	                if (angular.isDefined(scope.column.attributes) && scope.column.attributes.type == "autocomplete" &&
                    angular.isDefined(scope.column.attributes.displayformat) && angular.isDefined(scope.column.field)) {
	                    tmpValueForAutoSuggest = getObjectValueForAutoSuggest(scope.row.entity, scope.column.field);
	                    if (angular.isObject(tmpValueForAutoSuggest)) {
	                        //scope.COL_FIELD = getDisplayData(getObjectValue(scope.row.entity, scope.column.field.split('.')[0]), scope.column.attributes.displayformat);
	                        scope.COL_FIELD = getDisplayData(tmpValueForAutoSuggest, scope.column.attributes.displayformat);
	                    }
	                    else {
	                        scope.COL_FIELD = getObjectValue(scope.row.entity, scope.column.field);
	                    }
	                }
	                else {
	                    scope.COL_FIELD = getObjectValue(scope.row.entity, scope.column.field);
	                }

	                if (angular.isFunction(scope.column.cellClass) /*&& oldCellValue != scope.COL_FIELD*/) {
	                    var tmpClass = scope.column.cellClass({}, { entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex, value: getObjectValue(scope.row.entity, scope.column.field) });
	                    if (angular.isObject(tmpClass)) {
	                        if (cellClassElement.find('.smart-table-row-cell-info-icon').length == 0) {
	                            var iconTemplate = '';
	                            switch (tmpClass.type) {
	                                case 'smart-table-row-cell-info':
	                                    iconTemplate += '<svg><use xlink:href="#icon_Info"></use></svg>';
	                                    break;
	                                default:
	                                    iconTemplate += '<svg><use xlink:href="#icon_Info"></use></svg>';
	                                    break;
	                            }
	                            cellClassElement.find('.smart-table-cell-text').append('<i class="icon small blue-text smart-table-row-cell-info-icon" style="float: right; line-height: 23px !important;" title="' + tmpClass.message + '">' + iconTemplate + '</i>');
	                        }
	                        cellClassElement.addClass(tmpClass.class);
	                    }
	                    else {
	                        cellClassElement.addClass(tmpClass);
	                    }
	                    oldCellClass = tmpClass;
	                }

	                if (angular.isFunction(scope.column.cellEditableCondition)) {
	                    scope.enableCellEdit = scope.column.cellEditableCondition({ row: scope.row, index: scope.rowIndex, col: { colDef: scope.column, index: scope.columnIndex }, grid: { rows: smartTableScope.smartTableConfig.data } });
	                }

	                updateCellTemplate(true, toBeTranslated);

	                if (!isRowDataUpdated) {
	                    //	rendering done callback
	                    if (scope.$parent.$last && scope.$last) {
	                        scope.onSmartTableRenderingDone();
	                        smartTableScope.hasSmartTableRenderingStarted = false;
	                    }
	                }
	            };

	            // init();


	            //  Update date
	            var updateDate = function (tmpDate) {
	                if (selectedDate == '/Date(' + ((tmpDate.unix() * 1000) + 43200000) + '+0000)/') {
	                    return;
	                }
	                selectedDate = '/Date(' + ((tmpDate.unix() * 1000) + 43200000) + '+0000)/';
	                element.find('input').val($filter('smartDateFormat')(selectedDate, scope.column.attributes.format));
	                if (scope.column.isRegUpdateCol) {
	                    //	cell change listener
	                    angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: selectedDate });
	                }
	            };


	            //  Pop-up listeners
	            var onPopupOpened, onPopupClosed;

	            var addPopupListeners = function () {
	                var oldCellModel, newCellModel;

	                onPopupOpened = $rootScope.$on("popupOpened", function () {
	                    oldCellModel = getObjectValue(scope.row.entity, scope.column.field);
	                });

	                onPopupClosed = $rootScope.$on("popupClosed", function () {
	                    if (angular.isDefined(scope.column.debounce) && scope.column.debounce > 0) {
	                        setTimeout(function () {
	                            newCellModel = getObjectValue(scope.row.entity, scope.column.field);
	                            updateCellValueForPopup(oldCellModel, newCellModel);
	                        }, scope.column.debounce);
	                    }
	                    else {
	                        newCellModel = getObjectValue(scope.row.entity, scope.column.field);
	                        updateCellValueForPopup(oldCellModel, newCellModel);
	                    }

	                    element.trigger('focus');
	                });
	            };


	            var updateCellValueForPopup = function (oldCellModel, newCellModel) {
	                if (!angular.equals(oldCellModel, newCellModel)) {
	                    scope.COL_FIELD = newCellModel;
	                    updateCellTemplate(true, true);
	                    angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                }
	            };


	            var removePopupListeners = function () {
	                angular.isFunction(onPopupOpened) && onPopupOpened();
	                angular.isFunction(onPopupClosed) && onPopupClosed();
	            };

	            function triggerTaxesPopup() {
	                element.trigger("blur");
	                smartTableUtils.debounce.add(function () {
	                    window.isPopupOpenedByUIGridCompatibleElement = true;
	                    angular.isFunction(smartTableScope.listeners.cellClick) && smartTableScope.listeners.cellClick({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                }, 100);
	            }
	            function triggerAdhocPopup() {

	                smartTableUtils.debounce.add(function () {
	                    window.isPopupOpenedByUIGridCompatibleElement = true;
	                    angular.isFunction(smartTableScope.listeners.cellClick) && smartTableScope.listeners.cellClick({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                }, 100);
	                event.stopPropagation();
	                event.preventDefault();
	            }
	            function triggerSupplierCardPopup() {

	                smartTableUtils.debounce.add(function () {
	                    window.isPopupOpenedByUIGridCompatibleElement = true;
	                    angular.isFunction(smartTableScope.listeners.cellClick) && smartTableScope.listeners.cellClick({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                }, 100);
	                event.stopPropagation();
	                event.preventDefault();
	            }
	            var updateCellTemplate = function (toBeFiltered, toBeTranslated) {
	                if (angular.isFunction(scope.column.cellTemplate)) {
	                    tmpCellValue = scope.column.cellTemplate({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                    if (scope.column.uiType == 'popup' && angular.isNumber(tmpCellValue)) {
	                        if (angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                            tmpCellValue = $filter('minPrecisionHandler')(tmpCellValue, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                        }
	                        else {
	                            tmpCellValue = $filter('minPrecisionHandler')(tmpCellValue);
	                        }
	                    }
	                    element.find('.smart-table-cell-template').html((scope.column.uiType == 'popup' ? '<a' + (scope.column.enableCellEdit && scope.enableCellEdit ? '' : ' class="disabled" ') + '>' : '<span>') + tmpCellValue + (scope.column.uiType == 'popup' ? '</a>' : '</span>'));
	                    element.parent().attr('title', tmpCellValue);
	                    return;
	                }

	                if (scope.column.uiType == 'editable') {
	                    switch (scope.column.attributes.type) {
	                        case 'number':
	                            if (toBeFiltered && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                scope.COL_FIELD = $filter('minPrecisionHandler')(scope.COL_FIELD, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                            }
	                            break;

	                        case 'date':
	                            if (toBeFiltered) {
	                                scope.COL_FIELD = scope.COL_FIELD == '' || scope.COL_FIELD == undefined || scope.COL_FIELD == null ? '' : $filter('smartDateFormat')(scope.COL_FIELD, scope.column.attributes.format);
	                            }
	                            break;

	                        default:
	                            if (toBeTranslated && scope.column.enableTranslation) {
	                                scope.COL_FIELD = $translate.instant(scope.COL_FIELD);
	                            }
	                            if (toBeFiltered && angular.isDefined(scope.column.attributes.maxlength) && angular.isDefined(scope.COL_FIELD)) {
	                                scope.COL_FIELD = scope.COL_FIELD.substr(0, scope.column.attributes.maxlength);
	                            }
	                            break;
	                    }
	                    tmpCellValue = (scope.COL_FIELD == undefined || scope.COL_FIELD == null ? '' : scope.COL_FIELD);
	                    element.find('.smart-table-cell-template').html('<span>' + tmpCellValue + '</span>');
	                    if (scope.column.uiType == "editable" && scope.column.adhocpopup && scope.column.adhocpopup === "adhocpopup") {
	                        var icon = $('<i style="float: right" class="icon small blue-text smart-table-row-cell-info-icon" style="float: right; line-height: 23px !important;" title="' + $translate.instant("P2P_Common_AddAdhocLocation") + '"><svg><use xlink:href="#icon_Location"></use></svg></i>')
	                        icon.mousedown(function () {
	                            triggerAdhocPopup();
	                        })
	                        element.find('.smart-table-cell-template').append(icon);
	                    }
	                    else if (scope.column.uiType == "editable" && scope.column.supplierCardPopup && scope.column.supplierCardPopup === "supplierCardPopup") {
	                        var icon = $('<i style="float: right" class="icon small blue-text smart-table-row-cell-info-icon" style="float: right; line-height: 23px !important;" title="' + $translate.instant("P2P_Req_SupplierName") + '"><svg><use xlink:href="#icon_ContactCard"></use></svg></i>')
	                        icon.mousedown(function () {
	                            triggerSupplierCardPopup();
	                        })
	                        element.find('.smart-table-cell-template').append(icon);
	                    }
	                    if (scope.row.entity.RequisitionSource != undefined && scope.row.entity.RequisitionSource == 3 && scope.column.uiType == "editable" && scope.column.Changereq && scope.column.Changereq === "Changereq") {
	                        if (scope.row.entity.IsAddedFromRequistion != undefined) {
	                            if (scope.row.entity.IsAddedFromRequistion == true) {
	                            }
	                            else {
	                                var icon = $('<i  style="float: right" class="icon small red-text smart-table-row-cell-info-icon" style="float: right; line-height: 23px !important;" title=""><svg><use xlink:href="#icon_AddToDefault "></use></svg></i>')
	                                element.find('.smart-table-cell-template').append(icon);
	                            }
	                        }
	                    }
	                }
	                else if (scope.column.uiType == 'popup') {
	                    tmpCellValue = (scope.COL_FIELD === '' || scope.COL_FIELD == undefined || scope.COL_FIELD == null) ? (scope.column.placeHolder ? scope.column.placeHolder : $translate.instant('P2P_Common_Add')) : scope.COL_FIELD;
	                    if (angular.isNumber(tmpCellValue)) {
	                        if (angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                            tmpCellValue = $filter('minPrecisionHandler')(tmpCellValue, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                        }
	                        else {
	                            tmpCellValue = $filter('minPrecisionHandler')(tmpCellValue);
	                        }
	                    }
	                    element.find('.smart-table-cell-template').html('<a' + (scope.column.enableCellEdit && scope.enableCellEdit ? '' : ' class="disabled" ') + '>' + tmpCellValue + '</a>');
	                }
	                else if (scope.column.uiType == 'dropdown') {
	                    tmpCellValue = toBeTranslated && scope.column.enableTranslation ? $translate.instant(scope.COL_FIELD) : scope.COL_FIELD;
	                    element.find('.smart-table-cell-template').html('<span>' + tmpCellValue + '</span>');
	                }
	                else if (scope.column.uiType == 'taxesPopup') {
	                    tmpCellValue = scope.row.entity[scope.column.field];

	                    if (angular.isNumber(tmpCellValue)) {
	                        if (angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                            tmpCellValue = $filter('minPrecisionHandler')(tmpCellValue, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                        }
	                        else {
	                            tmpCellValue = $filter('minPrecisionHandler')(tmpCellValue);
	                        }
	                    }

	                    element.find('.smart-table-cell-template').html('<a' + (scope.column.enableCellEdit && scope.enableCellEdit ? '' : ' class="disabled" ') + '>' + tmpCellValue + '</a>');
	                    if (scope.row.entity.isTaxExempt) {
	                        var taxExempt = $('<a>' + $translate.instant("P2P_Common_Exempt") + '</a>');
	                        taxExempt.mousedown(function () {
	                            triggerTaxesPopup();
	                        })
	                        element.find('.smart-table-cell-template').html(taxExempt);
	                    }
	                    var icon = $('<i style="float: right" class="icon iconSmall tooltipped" smart-tooltip position="bottom" delay="50" message="ADD"><svg><use xlink:href="#icon_CirclePlus"></use></svg></i>')
	                    icon.mousedown(function () {
	                        triggerTaxesPopup();
	                    })
	                    element.find('.smart-table-cell-template').append(icon);
	                    element.parent().attr('title', tmpCellValue);
	                }
	                else {
	                    if (toBeFiltered && scope.column.attributes && scope.column.attributes.type == 'number' && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                        scope.COL_FIELD = $filter('minPrecisionHandler')(scope.COL_FIELD, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                    }
	                    tmpCellValue = toBeTranslated && scope.column.enableTranslation ? $translate.instant(scope.COL_FIELD) : (scope.COL_FIELD == undefined || scope.COL_FIELD == null ? '' : scope.COL_FIELD);
	                    element.find('.smart-table-cell-template').html('<span>' + tmpCellValue + '</span>');
	                }
	                element.parent().attr('title', tmpCellValue);
	            };


	            var getEditableTemplate = function () {
	                var template = '<div>';
	                switch (scope.column.uiType) {
	                    case 'editable':
	                        switch (scope.column.attributes.type) {
	                            case 'number':
	                                tmpInputValue = parseFloat(getObjectValue(scope.row.entity, scope.column.field));

	                                if (!isRegionalSettingEnabled && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                    tmpInputValue = convertNumberToFixed(tmpInputValue, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1])
	                                }

	                                template += '<input type="number" autocomplete="off" value="' + (tmpInputValue == 0 ? '' : tmpInputValue) + '">';
	                                break;

	                            case 'date':
	                                template += '<input type="text" autocomplete="off" value="' + (scope.COL_FIELD == undefined || scope.COL_FIELD == null ? '' : scope.COL_FIELD) + '" placeholder="' + (scope.column.attributes.format ? (scope.column.attributes.format).toUpperCase() : 'MM/DD/YYYY') + '">';
	                                break;

	                            default:
	                                template += '<input type="text" autocomplete="off" value="' + (scope.COL_FIELD == undefined || scope.COL_FIELD == null ? '' : scope.COL_FIELD) + '"' + (angular.isDefined(scope.column.attributes.maxlength) ? 'maxlength="' + scope.column.attributes.maxlength : '"') + '>';
	                                break;
	                        }
	                        break;

	                    case 'dropdown':
	                    case 'select':
	                        template += '<select style="display: block !important;">';
	                        for (var i = 0; i < scope.column.attributes.options.length; i++) {
	                            template += '<option ' + ($translate.instant(scope.column.attributes.options[i][scope.column.attributes.dataKey] + '') == $translate.instant(scope.COL_FIELD + '') ? 'selected' : '') + ' value="' + $translate.instant(scope.column.attributes.options[i][scope.column.attributes.idKey] + '') + '">' + $translate.instant(scope.column.attributes.options[i][scope.column.attributes.dataKey] + '') + '</option>';
	                        }
	                        template += '</select>';
	                        break;

	                        //case 'popup':
	                        //    template += '<div><a>' + ((scope.COL_FIELD === '' || scope.COL_FIELD == undefined || scope.COL_FIELD == null) ? (scope.column.placeHolder ? scope.column.placeHolder : 'ADD') : scope.COL_FIELD) + '</a></div>';
	                        //    break;
	                }
	                return template + '</div>'
	            };


	            var onElementKeyDown = function (e) {
	                window.lastKeyPressed = e.keyCode;
	                switch (e.keyCode) {
	                    //	space key
	                    case 32:
	                        if (scope.column.uiType == 'editable' && element.find('input').length > 0) {
	                            if (element.find('input:focus').length > 0) {
	                                isInputFieldFocused = true;
	                            }
	                            if (scope.column.attributes.type == 'date') {
	                                element.find('input').focus();
	                                e.stopPropagation();
	                                return false;
	                            }
	                            else {
	                                if (!isInputFieldFocused) {
	                                    isInputFieldFocused = true;

	                                    //if (element.find('input:focus').length == 0) {
	                                    tmpInputValue = element.find('input').val();
	                                    element.find('input').focus().val('').val(tmpInputValue);
	                                    //if (element.find('input').val().trim().length == 0) {
	                                    e.stopPropagation();
	                                    return false;
	                                    //}
	                                    //}
	                                }
	                            }
	                        }
	                        else if (scope.column.uiType == 'dropdown' && element.find('select').length > 0) {
	                            element.find('select').focus();
	                        }
	                        else if (scope.column.uiType == 'popup' && scope.column.enableCellEdit && angular.isFunction(scope.column.cellEditableCondition) && scope.column.cellEditableCondition({ row: scope.row, col: { colDef: scope.column }, grid: { rows: smartTableScope.smartTableConfig.data } }) && scope.column.isRegClickCol) {
	                            smartTableUtils.debounce.add(function () {
	                                window.isPopupOpenedByUIGridCompatibleElement = true;
	                                //	cell click listener
	                                angular.isFunction(smartTableScope.listeners.cellClick) && smartTableScope.listeners.cellClick({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                            }, 100);
	                            e.stopPropagation();
	                            return false;
	                        }
	                        else {
	                            e.stopPropagation();
	                            return false;
	                        }
	                        break;
	                        //	arrow keys
	                    case 37:
	                        if (!isInputFieldFocused) {
	                            if (element.find('input:focus').length > 0) {
	                                isInputFieldFocused = true;
	                                return;
	                            }

	                            if (scope.rowIndex == 0 && scope.columnIndex == 0) { }
	                            else {
	                                $('#' + smartTableScope.smartTableId + '-smart-table-cell-' + (parseInt(tabIndex) - 1)).focus();
	                                scope.stopEdit();
	                            }
	                            e.stopPropagation();
	                            return false;
	                        }
	                        break;
	                    case 39:
	                    case 9:
	                        if (e.keyCode == 39) {
	                            if (!isInputFieldFocused) {
	                                if (element.find('input:focus').length > 0) {
	                                    isInputFieldFocused = true;
	                                    return;
	                                }

	                                if (scope.$parent.$last && scope.$last) {
	                                    $('#' + smartTableScope.smartTableId + '-smart-table-cell-0').focus();
	                                }
	                                else {
	                                    $('#' + smartTableScope.smartTableId + '-smart-table-cell-' + (parseInt(tabIndex) + 1)).focus();
	                                }
	                                scope.stopEdit();
	                                e.stopPropagation();
	                                return false;
	                            }
	                        }
	                        else {
	                            if (e.shiftKey) {
	                                if (scope.rowIndex == 0 && scope.columnIndex == 0) {
	                                }
	                                else {
	                                    $('#' + smartTableScope.smartTableId + '-smart-table-cell-' + (parseInt(tabIndex) - 1)).focus();
	                                    scope.stopEdit();
	                                }
	                            }
	                            else {
	                                $('#' + smartTableScope.smartTableId + '-smart-table-cell-' + (parseInt(tabIndex) + 1)).focus();
	                                scope.stopEdit();
	                            }
	                            e.stopPropagation();
	                            return false;
	                        }
	                        break;
	                    case 38:
	                        // if(!$(e.target).is('select')) {
	                        if (scope.rowIndex > 0) {
	                            var cellIndexFocus = parseInt(tabIndex) - (smartTableScope.pinnedColumns.length + smartTableScope.unpinnedColumns.length);
	                            $('#' + smartTableScope.smartTableId + '-smart-table-cell-' + cellIndexFocus).focus();
	                            scope.stopEdit();
	                        }
	                        e.stopPropagation();
	                        return false;
	                        // }
	                        break;
	                    case 40:
	                    case 13:
	                        // if(!$(e.target).is('select')) {
	                        if (scope.rowIndex < smartTableScope.currentPageDataLength - 1) {
	                            var cellIndexFocus = parseInt(tabIndex) + (smartTableScope.pinnedColumns.length + smartTableScope.unpinnedColumns.length);
	                            $('#' + smartTableScope.smartTableId + '-smart-table-cell-' + cellIndexFocus).focus();
	                            scope.stopEdit();
	                        }
	                        e.stopPropagation();
	                        return false;
	                        // }
	                        break;
	                        //  escape key
	                    case 27:
	                        if ((scope.column.uiType == 'editable' || scope.column.uiType == 'dropdown') && (scope.column.attributes.type != 'autocomplete' || (scope.column.attributes.type == 'autocomplete' &&
                            scope.column.isFreeText && !selectedOption))) {
	                            isInputFieldFocused = false;

	                            if (scope.column.attributes.type == 'number') {
	                                tmpInputValue = parseFloat(oldCellValue);
	                                if (!isRegionalSettingEnabled && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                    tmpInputValue = convertNumberToFixed(tmpInputValue, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1]);
	                                }
	                                element.find('input').val(tmpInputValue == 0 ? '' : tmpInputValue).blur();
	                                if (isRegionalSettingEnabled) {
	                                    try {
	                                        element.find('input').autoNumeric('get');
	                                    }
	                                    catch (e) { }
	                                }
	                                updateCell(scope.row.entity, scope.column.field, oldCellValue);
	                            }
	                            else if (scope.column.attributes.type == 'date') {
	                                element.find('input').val($filter('smartDateFormat')(oldCellValue, scope.column.attributes.format)).blur();
	                                updateCell(scope.row.entity, scope.column.field, oldCellValue);
	                                selectedDate = undefined;
	                            }
	                            else {
	                                if (scope.column.uiType == 'dropdown') {
	                                    var tmpPreviousSelectedDropdownObj;
	                                    for (var i = 0; i < scope.column.attributes.options.length; i++) {
	                                        if (oldCellValue == scope.column.attributes.options[i][scope.column.attributes.dataKey]) {
	                                            tmpPreviousSelectedDropdownObj = scope.column.attributes.options[i];
	                                            updateCell(scope.row.entity, scope.column.field, scope.column.attributes.options[i]);
	                                            break;
	                                        }
	                                    }
	                                    element.find('select').val(tmpPreviousSelectedDropdownObj[scope.column.attributes.idKey]).blur();
	                                }
	                                else {
	                                    element.find('input').val(oldCellValue).blur();
	                                    updateCell(scope.row.entity, scope.column.field, oldCellValue);
	                                }
	                            }

	                            isRenderingToBeSkipped = true;
	                            isFocusToBeSkipped = true;
	                            element.focus();

	                            if (scope.column.attributes.type == 'number' && scope.column.isRegUpdateCol) {
	                                smartTableUtils.debounce.add(function () {
	                                    //	cell change listener
	                                    angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                                    smartTableUtils.broadcast('rowDataChange', { rowIndex: scope.rowIndex, smartTableId: smartTableScope.smartTableId });
	                                }, 250, false);
	                            }
	                            else if (scope.column.attributes.type == 'date') {
	                                if (scope.column.isRegUpdateCol) {
	                                    //	cell change listener
	                                    angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: selectedDate });
	                                }
	                            }
	                            else if (scope.column.uiType == 'dropdown') {
	                                // Options change listener
	                                angular.isFunction(smartTableScope.listeners.optionSelect) && smartTableScope.listeners.optionSelect({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: tmpPreviousSelectedDropdownObj });
	                            }
	                        }
	                        break;
	                    default:
	                        //  disable focus on function and filter keys
	                        if ((e.keyCode >= 112 && e.keyCode <= 123) || [16, 20, 255, 17, 91, 18, 33, 34, 144, 45, 19, 145, 93, 173, 174, 175].indexOf(e.keyCode) > -1) {
	                            e.preventDefault();
	                            return false;
	                        }
	                        if ((scope.column.uiType == 'editable' || scope.column.uiType == 'taxesPopup') && element.find('input').length > 0) {
	                            //  HOME and END keys
	                            if (!isInputFieldFocused && [35, 36].indexOf(e.keyCode) > -1) {
	                                e.preventDefault();
	                                return false;
	                            }
	                            if (!isInputFieldFocused) {
	                                isInputFieldFocused = true;

	                                if (element.find('input:focus').length == 0) {
	                                    //tmpInputValue = element.find('input').val();
	                                    //element.find('input').focus().val('').val(tmpInputValue);
	                                    element.find('input').focus().val('');

	                                    if (scope.column.attributes.type == 'number' && !isRegionalSettingEnabled && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                        var arrDecimalSplits = element.find('input').val().split('.');

	                                        if (arrDecimalSplits.length > 1) {
	                                            if (arrDecimalSplits[arrDecimalSplits.length - 1].length >= scope.column.attributes.minmaxprecisionfilter.split(':')[1] && ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105))) {
	                                                e.preventDefault();
	                                                return false;
	                                            }
	                                        }
	                                        else if (scope.column.attributes.minmaxprecisionfilter.split(':')[0] == 0 && e.keyCode == 190) {
	                                            e.preventDefault();
	                                            return false;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                        else if (scope.column.uiType == 'dropdown' && element.find('select').length > 0) {
	                            element.find('select').focus();
	                        }
	                        if (e.keyCode == 8 && element.find('input').length == 0) {
	                            e.preventDefault();
	                            return false;
	                        }
	                        break;
	                }
	            };

	            scope.onElementKeyDown = onElementKeyDown;

	            element.on('keydown', onElementKeyDown);


	            scope.stopEdit = function (isWindowClickFired) {
	                isRenderingToBeSkipped = false;
	                isFocusToBeSkipped = false;

	                //  prevent stop edit 
	                if (isWindowClickFired && scope.column.uiType == 'popup') {
	                    return;
	                }

	                //	scroll container to left
	                if (scope.$last && window.lastKeyPressed != 37 && !window.isSmartTableCellClicked && (window.shiftKey && window.lastKeyPressed == 9)) {
	                    $(element.closest('.smart-table-unpinned-container')).scrollLeft(0);
	                }

	                if ((scope.column.uiType == 'popup' || scope.column.uiType == 'taxesPopup' || (scope.column.adhocpopup && scope.column.adhocpopup === "adhocpopup") || (scope.column.supplierCardPopup && scope.column.supplierCardPopup === "supplierCardPopup")) && scope.column.isRegClickCol) {
	                    removePopupListeners();
	                }

	                if (hasStopEditCalled) {
	                    return;
	                }

	                isInEditMode = false;
	                isInputFieldFocused = false;

	                //	If cell is editable
	                if (scope.column.enableCellEdit && (angular.isFunction(scope.column.cellEditableCondition) && scope.column.cellEditableCondition({ row: scope.row, col: { colDef: scope.column }, grid: { rows: smartTableScope.smartTableConfig.data } }))) {
	                    switch (scope.column.uiType) {
	                        case 'editable':
	                            switch (scope.column.attributes.type) {
	                                case 'number':
	                                    if (isRegionalSettingEnabled) {
	                                        try {
	                                            scope.COL_FIELD = element.find('input').autoNumeric('get') * 1;
	                                        }
	                                        catch (error) {
	                                            console.log(error);
	                                            console.log("Error in number get. " + scope.column.field);
	                                        }
	                                    }
	                                    else {
	                                        scope.COL_FIELD = parseFloat($(element.find('input')).val());
	                                    }
	                                    scope.COL_FIELD = isNaN(scope.COL_FIELD) ? 0 : scope.COL_FIELD;
	                                    updateCell(scope.row.entity, scope.column.field, angular.copy(scope.COL_FIELD));
	                                    if (angular.isDefined(scope.column.attributes) && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                        scope.COL_FIELD = $filter('minPrecisionHandler')(scope.COL_FIELD, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                                    }
	                                    break;

	                                case 'autocomplete':
	                                    if (element.find('input').devbridgeAutocomplete()) {
	                                        element.find('input').devbridgeAutocomplete().dispose();
	                                    }
	                                    if (selectedOption) {
	                                        scope.COL_FIELD = angular.isDefined(scope.column.attributes.displayformat) ? getDisplayData(selectedOption, scope.column.attributes.displayformat) : $(element.find('input')).val();
	                                        updateCell(scope.row.entity, scope.column.field, selectedOption);
	                                        selectedOption = undefined;
	                                    }
	                                    else if (scope.column.isFreeText) {
	                                        scope.COL_FIELD = $(element.find('input')).val();
	                                        updateCell(scope.row.entity, scope.column.field, scope.COL_FIELD);
	                                    }
	                                    else {
	                                        scope.COL_FIELD = getObjectValue(scope.row.entity, scope.column.field);
	                                    }
	                                    break;

	                                case 'date':
	                                    if (element.find('input').daterangepicker()) {
	                                        element.find('input').daterangepicker().daterangepicker();
	                                    }
	                                    if (selectedDate == '') {
	                                        scope.COL_FIELD = '';
	                                        updateCell(scope.row.entity, scope.column.field, null);
	                                    }
	                                    else if (angular.isDefined(selectedDate) && selectedDate.indexOf('Date') > -1) {
	                                        scope.COL_FIELD = $filter('smartDateFormat')(selectedDate, scope.column.attributes.format);
	                                        updateCell(scope.row.entity, scope.column.field, selectedDate);
	                                    }
	                                    else {
	                                        scope.COL_FIELD = $filter('smartDateFormat')(getObjectValue(scope.row.entity, scope.column.field), scope.column.attributes.format);
	                                    }
	                                    selectedDate = undefined;
	                                    break;

	                                default:
	                                    scope.COL_FIELD = $(element.find('input')).val();
	                                    updateCell(scope.row.entity, scope.column.field, scope.COL_FIELD);
	                                    break;
	                            }
	                            break;

	                        case 'dropdown':
	                        case 'select':
	                            for (var i = 0; i < scope.column.attributes.options.length; i++) {
	                                if ($(element.find('select')).val() == scope.column.attributes.options[i][scope.column.attributes.idKey]) {
	                                    scope.COL_FIELD = scope.column.attributes.options[i][scope.column.attributes.dataKey];
	                                    updateCell(scope.row.entity, scope.column.field, scope.column.attributes.options[i]);
	                                    break;
	                                }
	                            }
	                            scope.COL_FIELD = scope.column.enableTranslation ? $translate.instant(scope.COL_FIELD) : scope.COL_FIELD;
	                            break;
	                        case 'taxesPopup':
	                            if (isRegionalSettingEnabled) {
	                                try {
	                                    if (element.find('input').length > 0) {
	                                        scope.COL_FIELD = element.find('input').autoNumeric('get') * 1;
	                                    }
	                                }
	                                catch (error) {
	                                    console.log(error);
	                                    console.log("Error in number get. " + scope.column.field);
	                                }
	                            }
	                            else {
	                                scope.COL_FIELD = parseFloat($(element.find('input')).val());
	                            }
	                            scope.COL_FIELD = isNaN(scope.COL_FIELD) ? 0 : scope.COL_FIELD;
	                            updateCell(scope.row.entity, scope.column.field, angular.copy(scope.COL_FIELD));
	                            if (angular.isDefined(scope.column.attributes) && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                scope.COL_FIELD = $filter('minPrecisionHandler')(scope.COL_FIELD, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1], false);
	                            }
	                            break;
	                    }
	                    updateCellTemplate();
	                }

	                $(element.closest('.smart-table-row-cell-text')).css('border', '');
	                templateContainer && templateContainer.empty();

	                if (scope.column.enableCellEdit && oldCellValue != scope.COL_FIELD) {
	                    if (oldCellValue != scope.COL_FIELD) {
	                        angular.isFunction(smartTableScope.listeners.afterCellEdit) && smartTableScope.listeners.afterCellEdit({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });

	                        smartTableUtils.broadcast('rowDataChange', { rowIndex: scope.rowIndex, smartTableId: smartTableScope.smartTableId });
	                    }

	                    //	end cell edit listener
	                    angular.isFunction(smartTableScope.listeners.endCellEdit) && smartTableScope.listeners.endCellEdit({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                }

	                if (scope.column.enableCellEdit && (scope.column.uiType == 'popup' || scope.column.uiType == 'taxesPopup')) {
	                    smartTableUtils.broadcast('rowDataChange', { rowIndex: scope.rowIndex, smartTableId: smartTableScope.smartTableId });
	                }

	                hasStopEditCalled = true;
	            };


	            var onFocus = function (e) {
	                if (isRenderingToBeSkipped) {
	                    if (element.find('input').length > 0 && !isFocusToBeSkipped) {
	                        element.find('input').focus();
	                    }
	                    return;
	                }

	                oldCellValue = scope.column.enableTranslation ? $translate.instant(scope.COL_FIELD) : (scope.column.uiType == 'editable' && (scope.column.attributes.type == 'date' || scope.column.attributes.type == 'number') ? getObjectValue(scope.row.entity, scope.column.field) : scope.COL_FIELD);

	                //  Prevent from scrolling to left
	                if (scope.$last) {
	                    window.lastKeyPressed = 37;
	                }

	                if (window.lastActiveCellScope) {
	                    window.lastActiveCellScope.stopEdit();
	                    window.lastActiveCellScope = undefined;
	                }

	                window.lastActiveCellScope = scope;

	                hasStopEditCalled = false;

	                //	scroll container to left
	                if (smartTableScope.pinnedColumns.length == scope.$index) {
	                    setTimeout(function () {
	                        $(element.closest('.smart-table-unpinned-container')).scrollLeft(0);
	                    }, 250);
	                }

	                if ((scope.column.uiType == 'popup' || scope.column.uiType == 'taxesPopup' || (scope.column.adhocpopup && scope.column.adhocpopup === "adhocpopup") || (scope.column.supplierCardPopup && scope.column.supplierCardPopup === "supplierCardPopup")) && scope.column.enableCellEdit && angular.isFunction(scope.column.cellEditableCondition) && scope.column.cellEditableCondition({ row: scope.row, col: { colDef: scope.column }, grid: { rows: smartTableScope.smartTableConfig.data } }) && scope.column.isRegClickCol) {
	                    addPopupListeners();
	                }

	                window.isSmartTableCellClicked = false;

	                $(element.closest('.smart-table-row-cell-text')).css('border', '1px solid ' + (cellClassElement.hasClass('smart-table-row-cell-invalid') ? 'red' : '#159dfc'));
	                if (isInEditMode || !scope.column.enableCellEdit || (angular.isFunction(scope.column.cellEditableCondition) && !scope.column.cellEditableCondition({ row: scope.row, col: { colDef: scope.column }, grid: { rows: smartTableScope.smartTableConfig.data } }))) {
	                    return;
	                }

	                //	Begin cell edit listener
	                angular.isFunction(smartTableScope.listeners.beginCellEdit) && smartTableScope.listeners.beginCellEdit({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });

	                if (scope.column.uiType != 'popup') {
	                    $(element.find('.smart-table-cell-template')).html(getEditableTemplate());
	                    if (scope.column.uiType == "editable" && scope.column.adhocpopup && scope.column.adhocpopup === "adhocpopup") {
	                        var icon = $('<i style="float: right" class="icon small blue-text smart-table-row-cell-info-icon" style="float: right; line-height: 23px !important;" title="' + $translate.instant("P2P_Common_AddAdhocLocation") + '"><svg><use xlink:href="#icon_Location"></use></svg></i>');
	                        icon.mousedown(function () {
	                            triggerAdhocPopup();
	                        });
	                        var inputvalue = $(element.find('.smart-table-cell-template')).html(getEditableTemplate()).css("width", $(element.find('.smart-table-cell-template')).parent().width() - 40 + "px");
	                        $(element.find('.smart-table-cell-template')).append(inputvalue).append(icon);
	                    }
	                    else if (scope.column.uiType == "editable" && scope.column.supplierCardPopup && scope.column.supplierCardPopup === "supplierCardPopup") {
	                        var icon = $('<i style="float: right" class="icon small blue-text smart-table-row-cell-info-icon" style="float: right; line-height: 23px !important;" title="' + $translate.instant("P2P_Req_SupplierName") + '"><svg><use xlink:href="#icon_ContactCard"></use></svg></i>')
	                        icon.mousedown(function () {
	                            triggerSupplierCardPopup();
	                        })
	                        element.find('.smart-table-cell-template').append(icon);
	                    }
	                }

	                if (scope.column.uiType == 'taxesPopup') {
	                    var tmpInputValue = parseFloat(getObjectValue(scope.row.entity, scope.column.field));
	                    if (!isRegionalSettingEnabled && angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                        tmpInputValue = convertNumberToFixed(tmpInputValue, scope.column.attributes.minmaxprecisionfilter.split(':')[0], scope.column.attributes.minmaxprecisionfilter.split(':')[1]);
	                    }
	                    var input = $('<input  type="number" autocomplete="off" value="' + (tmpInputValue == 0 ? '' : tmpInputValue) + '">');
	                    if (scope.row.entity.isTaxExempt) {
	                        input = $('<a>' + $translate.instant("P2P_Common_Exempt") + '</a>')
	                        input.mousedown(function () {
	                            triggerTaxesPopup();

	                        });
	                    }
	                    var icon = $('<i style="float: right" class="icon iconSmall tooltipped"><svg><use xlink:href="#icon_CirclePlus"></use></svg></i>');
	                    icon.mousedown(function () {
	                        triggerTaxesPopup();
	                    });
	                    input.css("width", $(element.find('.smart-table-cell-template')).parent().width() - 40 + "px");
	                    $(element.find('.smart-table-cell-template')).html('').append(input).append(icon);
	                }

	                switch (scope.column.uiType) {
	                    case 'editable':
	                        switch (scope.column.attributes.type) {
	                            case 'number':
	                                setTimeout(function () {
	                                    var tmpVal;
	                                    if (isRegionalSettingEnabled) {
	                                        try {
	                                            element.find('input').attr('type', 'text');
	                                            var mDec = scope.column.attributes.minmaxprecisionfilter != undefined && scope.column.attributes.minmaxprecisionfilter.split(':')[1] != '' ? scope.column.attributes.minmaxprecisionfilter.split(':')[1] : MaxPrecessionValue;
	                                            element.find('input').autoNumeric('init', { mDec: mDec });
	                                        }
	                                        catch (error) {
	                                            console.log("Error in number init. " + scope.column.field);
	                                        }
	                                    }
	                                    else if (angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                        var arrDecimalSplits;

	                                        element.find('input').on('keydown', function (e) {
	                                            arrDecimalSplits = $(this).val().split('.');

	                                            if (arrDecimalSplits.length > 1) {
	                                                if (arrDecimalSplits[arrDecimalSplits.length - 1].length >= scope.column.attributes.minmaxprecisionfilter.split(':')[1] && ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105))) {
	                                                    e.preventDefault();
	                                                    return false;
	                                                }
	                                            }
	                                            else if (scope.column.attributes.minmaxprecisionfilter.split(':')[0] == 0 && e.keyCode == 190) {
	                                                e.preventDefault();
	                                                return false;
	                                            }
	                                        });
	                                    }

	                                    element.find('input').on('keyup', function (e) {
	                                        if (isRegionalSettingEnabled) {
	                                            try {
	                                                tmpVal = $(this).autoNumeric('get') * 1;
	                                            }
	                                            catch (error) {
	                                                console.log("Error in number format. " + scope.column.field);
	                                            }
	                                        }
	                                        else {
	                                            if (tmpVal == $(this).val()) {
	                                                return;
	                                            }
	                                            tmpVal = $(this).val();
	                                        }

	                                        if (scope.column.isRegUpdateCol) {
	                                            smartTableUtils.debounce.add(function () {
	                                                updateCell(scope.row.entity, scope.column.field, parseFloat(tmpVal));
	                                                //	cell change listener
	                                                angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                                                smartTableUtils.broadcast('rowDataChange', { rowIndex: scope.rowIndex, smartTableId: smartTableScope.smartTableId });
	                                            }, 250, false);
	                                        }
	                                    });
	                                });
	                                break;

	                            case 'autocomplete':
	                                var filterKeys = scope.column.attributes.filterkeys ? scope.column.attributes.filterkeys : ['title'];
	                                var optionFormat = scope.column.attributes.optionformat ? scope.column.attributes.optionformat : '{title}';
	                                var displayFormat = scope.column.attributes.displayformat ? scope.column.attributes.displayformat + '' : '{title}';

	                                setTimeout(function () {
	                                    var serviceObj = scope.column.attributes.serviceObj;
	                                    var tmpVal = oldCellValue;

	                                    element.find('input').on('keyup', function (e) {
	                                        if (angular.isDefined(tmpVal) && $(this).val().trim().length > 0 && tmpVal.trim() == $(this).val().trim()) {
	                                            return;
	                                        }

	                                        tmpVal = $(this).val();

	                                        if ([37, 38, 39, 40].indexOf(e.keyCode) > -1) {
	                                            return;
	                                        }

	                                        //	cell change listener
	                                        angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: tmpVal });

	                                        if (angular.isDefined(tmpVal) && tmpVal.trim().length == 0 && !scope.column.attributes.populateListOnFocus) {
	                                            return;
	                                        }

	                                        smartTableUtils.debounce.add(function () {
	                                            if (serviceObj != undefined) {
	                                                var req = {
	                                                    method: serviceObj.method === "POST" ? "POST" : "GET",
	                                                    url: serviceObj.url,
	                                                    params: JSON.parse(JSON.stringify(serviceObj.param).replace("@term", tmpVal)),
	                                                    timeout: 120000,
	                                                    headers: {
	                                                        "Content-Type": "application/json",
	                                                        "UserExecutionContext": JSON.stringify(APPCONSTANTS.userPreferences.UserBasicDetails)
	                                                    }
	                                                };
	                                                if (req.method == "POST") {
	                                                    req.data = JSON.parse(JSON.stringify(serviceObj.param).replace("@term", tmpVal));
	                                                    delete req.params;
	                                                }
	                                                httpService.directhttp(req).then(function (response) {
	                                                    if (serviceObj.CallbackObj) {
	                                                        response = serviceObj.CallbackObj(response, scope.column.field)
	                                                    }

	                                                    var resp = [];

	                                                    if (typeof response === "string") {
	                                                        response = JSON.parse(response);
	                                                    }

	                                                    if (serviceObj.isFlatArray) {
	                                                        _.each(response, function (x, index) {
	                                                            var obj = {};
	                                                            obj["name"] = x;
	                                                            obj["code"] = x;
	                                                            resp.push(obj);
	                                                        });
	                                                    }
	                                                    else {
	                                                        _.each(response, function (obj) {
	                                                            var mapperObj = (serviceObj.isObjectArray) ? obj : {};
	                                                            _.each(serviceObj.mapper, function (mapper) {
	                                                                var mapperstri = '';
	                                                                if (angular.isArray(mapper['toBeMapped'])) {
	                                                                    var mapperkey = mapper.key;
	                                                                    _.each(mapper['toBeMapped'], function (res) {
	                                                                        if (mapperkey != undefined && mapperkey == 'email' && res == 'EmailAddress') {
	                                                                            mapperstri += "</br>" + obj[res] + " ";
	                                                                        }
	                                                                        else {
	                                                                            mapperstri += obj[res] + " ";
	                                                                        }
	                                                                    });
	                                                                    mapperstri.trim();
	                                                                }
	                                                                else {
	                                                                    mapperstri = obj[mapper['toBeMapped']];
	                                                                }
	                                                                mapperObj[mapper['key']] = mapperstri;
	                                                            });
	                                                            _.each(serviceObj.staticValues, function (item) {
	                                                                mapperObj[item['key']] = item['value'];
	                                                            });
	                                                            resp.push(mapperObj);
	                                                        });
	                                                    }

	                                                    if (element.find('input').devbridgeAutocomplete()) {
	                                                        element.find('input').devbridgeAutocomplete().setLookup(getFormattedData(resp, displayFormat));
	                                                    }
	                                                    else {
	                                                        element.find('input').devbridgeAutocomplete({
	                                                            filterKeys: filterKeys,
	                                                            optionFormat: optionFormat,
	                                                            displayFormat: displayFormat,
	                                                            lookup: getFormattedData(resp, displayFormat),
	                                                            width: scope.column.width,
	                                                            minChars: scope.column.attributes.populateListOnFocus ? 0 : 1,
	                                                            onSelect: function (suggestion) {
	                                                                selectedOption = suggestion;
	                                                                isRenderingToBeSkipped = true;
	                                                                element.find('input').devbridgeAutocomplete().setLookup([]);
	                                                                //	Option select listener
	                                                                angular.isFunction(smartTableScope.listeners.optionSelect) && smartTableScope.listeners.optionSelect({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: tmpVal, option: selectedOption });
	                                                                element.trigger('focus');
	                                                            }
	                                                        });
	                                                    }

	                                                    if (resp.length == 1 && scope.column.attributes.populateListOnFocus) {
	                                                        try {
	                                                            element.find('input').devbridgeAutocomplete().onSelect(0);
	                                                        }
	                                                        catch (e) { }
	                                                    }
	                                                    else {
	                                                        //	Options change listener
	                                                        angular.isFunction(smartTableScope.listeners.optionsChange) && smartTableScope.listeners.optionsChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: tmpVal, options: response });
	                                                    }

	                                                }, function () {
	                                                });
	                                            }
	                                        }, 250, false);
	                                    });

	                                    if (scope.column.attributes.populateListOnFocus) {
	                                        var triggerKeyUpOnfocus = function () {
	                                            if (!isInputFieldFocused) {
	                                                var tmpEvent = $.Event("keyup", {
	                                                    keyCode: 32
	                                                });
	                                                element.find('input').trigger(tmpEvent);
	                                                isInputFieldFocused = true;
	                                            }
	                                        };

	                                        element.find('input').on('click', function (e) {
	                                            triggerKeyUpOnfocus();
	                                        });

	                                        if (element.find('input:focus').length > 0) {
	                                            triggerKeyUpOnfocus();
	                                        }
	                                    }
	                                });
	                                break;

	                            case 'date':
	                                setTimeout(function () {
	                                    element.find('input').on('keyup', function (e) {
	                                        selectedDate = $(this).val();
	                                    });

	                                    element.find('input').daterangepicker({
	                                        singleDatePicker: true,
	                                        showDropdowns: true,
	                                        locale: {
	                                            format: scope.column.attributes.format ? (scope.column.attributes.format).toUpperCase() : 'MM/DD/YYYY'
	                                        },
	                                        minDate: scope.column.attributes.min ? scope.column.attributes.min : null,
	                                        maxDate: scope.column.attributes.max ? scope.column.attributes.max : null,
	                                        autoUpdateInput: false
	                                    }, function (startDate, endDate) {
	                                        updateDate(startDate);
	                                    }).on('apply.daterangepicker', function (e, picker) {
	                                        updateDate(picker.startDate);
	                                    });
	                                });
	                                break;
	                        }
	                        break;

	                    case 'dropdown':
	                        if (angular.isFunction(smartTableScope.listeners.optionSelect)) {
	                            setTimeout(function () {
	                                element.find('select').on('change', function () {
	                                    for (var i = 0; i < scope.column.attributes.options.length; i++) {
	                                        if ($(this).val() == scope.column.attributes.options[i][scope.column.attributes.idKey] + '') {
	                                            // Options change listener
	                                            smartTableScope.listeners.optionSelect({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex }, { value: scope.column.attributes.options[i] });
	                                            break;
	                                        }
	                                    }
	                                });
	                            });
	                        }
	                        break;

	                    case 'taxesPopup':
	                        setTimeout(function () {
	                            var tmpVal;
	                            if (isRegionalSettingEnabled) {
	                                try {
	                                    element.find('input').attr('type', 'text');
	                                    element.find('input').autoNumeric('init');
	                                }
	                                catch (error) {
	                                    console.log("Error in number init. " + scope.column.field);
	                                }
	                            }
	                            else if (angular.isDefined(scope.column.attributes.minmaxprecisionfilter)) {
	                                var arrDecimalSplits;

	                                element.find('input').on('keydown', function (e) {
	                                    arrDecimalSplits = $(this).val().split('.');

	                                    if (arrDecimalSplits.length > 1) {
	                                        if (arrDecimalSplits[arrDecimalSplits.length - 1].length >= scope.column.attributes.minmaxprecisionfilter.split(':')[1] && ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 96 && e.keyCode <= 105))) {
	                                            e.preventDefault();
	                                            return false;
	                                        }
	                                    }
	                                    else if (scope.column.attributes.minmaxprecisionfilter.split(':')[0] == 0 && e.keyCode == 190) {
	                                        e.preventDefault();
	                                        return false;
	                                    }
	                                });
	                            }

	                            element.find('input').on('keyup', function (e) {
	                                if (isRegionalSettingEnabled) {
	                                    try {
	                                        tmpVal = $(this).autoNumeric('get') * 1;
	                                    }
	                                    catch (error) {
	                                        console.log("Error in number format. " + scope.column.field);
	                                    }
	                                }
	                                else {
	                                    if (tmpVal == $(this).val()) {
	                                        return;
	                                    }
	                                    tmpVal = $(this).val();
	                                }

	                                if (scope.column.isRegUpdateCol) {
	                                    smartTableUtils.debounce.add(function () {
	                                        updateCell(scope.row.entity, scope.column.field, parseFloat(tmpVal));
	                                        //	cell change listener
	                                        angular.isFunction(smartTableScope.listeners.cellChange) && smartTableScope.listeners.cellChange({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                                        smartTableUtils.broadcast('rowDataChange', { rowIndex: scope.rowIndex, smartTableId: smartTableScope.smartTableId });
	                                    }, 250, false);
	                                }
	                            });
	                        });
	                        break;
	                }

	                smartTableScope.lastActiveCell = {
	                    rowIndex: scope.rowIndex,
	                    columnIndex: scope.columnIndex
	                };

	                isInEditMode = true;
	            };


	            element.on('focus', onFocus);

	            element.on('click', function (e) {
	                if (scope.column.uiType == 'popup' && scope.column.enableCellEdit && angular.isFunction(scope.column.cellEditableCondition) && scope.column.cellEditableCondition({ row: scope.row, col: { colDef: scope.column }, grid: { rows: smartTableScope.smartTableConfig.data } }) && scope.column.isRegClickCol) {
	                    smartTableUtils.debounce.add(function () {
	                        window.isPopupOpenedByUIGridCompatibleElement = true;
	                        //	cell click listener
	                        angular.isFunction(smartTableScope.listeners.cellClick) && smartTableScope.listeners.cellClick({ entity: scope.row.entity, index: scope.rowIndex }, { colDef: scope.column, index: scope.columnIndex });
	                    }, 100);
	                }
	            });

	            var onFocusCell = smartTableUtils.on('focusCell', function (e) {
	                if (e.rowIndex == scope.rowIndex && e.columnIndex == scope.columnIndex && e.smartTableId == smartTableScope.smartTableId) {
	                    element.trigger('focus');
	                }
	            });

	            var onRowDataChange = smartTableUtils.on('rowDataChange', function (e) {
	                if (e.rowIndex == scope.rowIndex && e.smartTableId == smartTableScope.smartTableId) {
	                    //	skip updating the field since being already in edit mode
	                    if (!isInEditMode) {
	                        init(true, true);
	                    }
	                }
	            });

	            var onDataChange = smartTableUtils.on('dataChange', function (e) {
	                if (e.smartTableId == smartTableScope.smartTableId && e.updateCell) {
	                    init(true, true);
	                }
	            });

	            scope.$on('$destroy', function () {
	                // console.log('smart-cell scope destroyed');
	                onCellDataAndColDefChange();
	                onFocusCell();
	                onRowDataChange();
	                onDataChange();
	                element.off('keydown', onElementKeyDown);
	            });
	        },
	        template: '<span class="smart-table-cell-text"><span class="smart-table-cell-template"></span></span>'
	    };
	}]);
})();
(function (angular) {
	'use strict';
	angular.module('SMART2').directive('smartTreePopup', ['$timeout',
	function($timeout) {
		return {
			restrict : 'E',
			scope : {
				header : "@",
				isRadio : "@",
				toggle : "@",
				preselection : "@",
				onHide : "&",
				onSelect : "&",
                disableLevelSelection : "@"
			},
			link : function(scope, element, attrs) {
			    //watch treePopupToggle boolean to toggle popup
			    var isInitServiceCall = true;
				scope.$watch('toggle', function(value) {
				    scope.showPopupBool = scope.$eval(value);
				    if (scope.showPopupBool) {
				        scope.treeConfig.hideSearch = false;
				        if (isInitServiceCall) {
				            $timeout(function () {
				                scope.treeConfig.initServiceCall();
				            });
				            isInitServiceCall = false;
				        }
				    }
				});
				
				//watch preselection
				scope.$watch('preselection', function(value) {
					scope.treeConfig.SelectedNodes = value;
				});

				//on-hide callback
				var hideCallback = scope.$eval(scope.onHide);
				
				//on-select callback
				var selectCalback = scope.$eval(scope.onSelect);

				//creating Tree Component Config
				scope.treeConfig = {
					IsRadio : scope.$eval(scope.isRadio),
					type : "Category",
					SelectedNodes : "",
					title: scope.header,
					disableLevelSelection: scope.disableLevelSelection,
                    hideSearch : false
				};
				scope.onDoneCallback = function(e) {
					if (angular.isFunction(selectCalback)) {
						selectCalback(e);
					};
				};

				// view bindings
				scope.showPopupBool = false;
				scope.onPopupHideCallback = function() {
				    scope.showPopupBool = false;
				    scope.treeConfig.hideSearch = true;
					if (angular.isFunction(hideCallback)) {
						hideCallback();
					};
				};
			},
			templateUrl : 'shared/directives/smartTree/smartTreePopup.html'
		};
	}]);

	/*******----smartTreeComponent Module----*******/

	angular.module('smartTreeComponent', []).directive('smartTreeComponent', ['$timeout', '$translate', 'RESTApiSt', '$q', 'APPCONSTANTS', 'Common',
	function ($timeout, $translate, RESTApiSt, $q, APPCONSTANTS, Common) {
		return {
			restrict : 'E',
			replace : true,
			scope : {
				config : '=',
				onDone : '&'
			},
			link: function (scope, element, attrs) {

			    // ID's generation
			    scope.parentId = 'Parent_' + Common.uniqueIDGenerator();
			    scope.templateId = 'Template_' + Common.uniqueIDGenerator() + '.html';


				/*config for the directive*/
			    scope.config.initServiceCall = function () {
			        RESTApiSt.getData(scope.treeConfig.type, RESTApiStCallback, req);
			    }
				scope.treeConfig = scope.config;
				var doneCallback = scope.$eval(scope.onDone);
				scope.$watch('config.SelectedNodes', function(n, o) {
					if (n) {
						preselection = n.split(',');
						if (preselectionRecievedPromise)
							preselectionRecievedPromise.resolve();
					}
				});

				scope.$watch('config.hideSearch', function (n, o) {
				    if (n && scope.searchFieldVal.length > 0) {
				        $timeout(function () {
				            angular.element('#closeButton').trigger('click');
				        });
				    }
				});

				/*promise*/
				var dataRecievedCallPromise;
				var preselectionRecievedPromise;
				var promises = [];
				initializePromise(true, true);

				/*Local variables*/
				var dataSet;
				var searchBucket = 50;
				var lazyLoadingBucket = 50;
				var maxLevel;
				var lazyLoadOffset;
				var lazyLoadMarker = [];
				var levelKey = 'level';
				var levelWiseData = {};
				var parentStringConstant = "parentString";
				var parentCodeStringConstant = "parentCodeString";
				var preselection;
				var searchCategories = [];
				var req;

				switch(scope.treeConfig.type) {
				case 'Category':
					scope.codeProperty = 'PASCode';
					scope.titleProperty = 'PASName';
					scope.levelProperty = 'PASLevel';
					scope.parentProperty = 'ParentPASCode';
					/*req = {
					    method: 'POST',
					    url: 'https://gepqcsmart-rest.servicebus.windows.net/PortalRestService/GetPASForDeviceMob',
					    headers: {
					        'Content-Type': 'application/json',
					        'UserExecutionContext': '{"ClientName":"BuyerSqlConn","ClientID":2,"BuyerPartnerCode":6315,"Product":2,"UserId":"28082","EntityType":"supplier registration","EntityId":8888,"LoggerCode":"EC101","Culture":"en-US","UserName":"RiteAid.Admin@gep.com","CompanyName":"BuyerSqlConn","ContactCode":63150040000001}'
					    },
					    data: {
					        "ContactCode": 63150040000001,
					        "entityDetailCode": 7,
					        "entityId": 1
					    }
					};*/
					req = {
					    method: 'POST',
					    url: APPCONSTANTS.userPreferences.URLs.AppURL + 'PortalRestService/GetPASForDeviceMob?oloc=218',
					    headers: {
					        'Content-Type': 'application/json',
					        'UserExecutionContext': JSON.stringify(APPCONSTANTS.userPreferences.UserBasicDetails),
					    },
					    data: {
					        "ContactCode": APPCONSTANTS.userPreferences.UserBasicDetails.ContactCode,
					        "entityDetailCode": APPCONSTANTS.userPreferences.ACEntityId,
					        "entityId": APPCONSTANTS.userPreferences.UserBasicDetails.EntityId
					    }
					};
					break;
				case 'Region':
					scope.codeProperty = 'RegionId';
					scope.titleProperty = 'RegionName';
					scope.levelProperty = 'RegionLevel';
					scope.parentProperty = 'RegionParentId';
					break;
				};
				
				scope.isLoading = true;
				scope.selectedData = [];
				scope.isSingleSelect = scope.treeConfig.IsRadio;
				scope.msg = $translate.instant('loadingMsg');

				/*Local member fuctions*/

				function initializePromise(dataRievedPromiseBool, preselectionRecievedPromiseBool) {
					dataRecievedCallPromise = null;
					preselectionRecievedPromise = null;
					promises.length = 0;
					if (dataRievedPromiseBool) {
						dataRecievedCallPromise = $q.defer();
						promises.push(dataRecievedCallPromise.promise);
					}
					if (preselectionRecievedPromiseBool) {
						preselectionRecievedPromise = $q.defer();
						promises.push(preselectionRecievedPromise.promise);
					}
					$q.all(promises).then(promiseResolved);
				}

				function promiseResolved() {
					initatePreSelection();
					initializePromise(false, true);
				}

				function createLevelWiseDataSet() {
					var level = 1;
					var parentNodes = dataSet[level];
					insertParentHierarchyForFlatStrucure(parentNodes);
					while (parentNodes) {
						levelWiseData[levelKey + level] = parentNodes;
						insertParentHierarchyForFlatStrucure(parentNodes, level);
						maxLevel = level;
						level = level + 1;
						parentNodes = dataSet[level];
					}
				};

				function insertParentHierarchyForFlatStrucure(parentNodes, level) {
					var fetchedData = (level) ? _.groupBy(dataSet[level + 1], scope.parentProperty) : null;
					_.each(parentNodes, function(parent) {
						var childForParent = (fetchedData) ? fetchedData[parent[scope.codeProperty]] : parentNodes;
						if (childForParent) {
							_.each(childForParent, function(node, index) {
								node[parentStringConstant] = parent[parentStringConstant] ? parent[parentStringConstant] + ' > ' + node[scope.titleProperty] : (node[scope.levelProperty] > 1) ? parent[scope.titleProperty] + ' > ' + node[scope.titleProperty] : "";
								node[parentCodeStringConstant] = parent[parentCodeStringConstant] ? parent[parentCodeStringConstant] + '>' + node[scope.codeProperty] : (node[scope.levelProperty] > 1) ? parent[scope.codeProperty] + '>' + node[scope.codeProperty] : "";
								node['isExpanded'] = false;
								node['selection'] = "0";
								node['index'] = index;
							});
						}
					});
				};

				function RESTApiStCallback(response) {
				    try{
				        dataSet = _.groupBy(JSON.parse(response.data.GetPASForDeviceMobResult), scope.levelProperty);
				        createLevelWiseDataSet();
				        scope.categories = levelWiseData[levelKey + '1'].slice(0, lazyLoadingBucket);
				        lazyLoadMarker.push(levelWiseData[levelKey+'1'][levelWiseData[levelKey + '1'].length - 1]);
				        scope.isLoading = false;
				    }catch(e){
				        scope.msg = $translate.instant('loadingDataErr');
				    }
				    dataRecievedCallPromise.resolve();
				};

				function resetSelectionState() {
					_.each(scope.selectedData, function(_node) {
						scope.selectNode(_node, '0');
					});
				};

				function initatePreSelection() {
					resetSelectionState();
					_.each(preselection, function(preselectionNode) {
						var searchLevel = 1;
						while (searchLevel <= maxLevel) {
							var foundNode = _.groupBy(levelWiseData[levelKey + searchLevel],scope.codeProperty)[preselectionNode];
							if (foundNode) {
								scope.selectNode(foundNode[0], '1');
								break;
							}
							searchLevel = searchLevel + 1;
						}
					});
				};

				function openSelectionTree() {
					var partialSeletedNodes = _.filter(levelWiseData[levelKey + 0], function(node) {
						return node.selection = '2';
					});
					_.each(partialSeletedNodes, function(nodes) {
						var level = nodes[scope.levelProperty];
						//var childs = _.
					});
				}

				function getChildsForParentAsPerBucket(parent, bucket, startIndex) {
					var childSearchLevel = parent[scope.levelProperty] + 1;
					var parentCodeStringIterator;
					var result = _.groupBy(levelWiseData[levelKey+childSearchLevel],scope.parentProperty)[parent[scope.codeProperty]];
					//var bucketData = (bucket) ? result.slice(startIndex, startIndex + bucket) : result;
					var bucketData = result;
					return bucketData;
				};

				function lazyLoadLevelWiseData(markerNode) {
					var parentSearchLevel = markerNode[scope.levelProperty] - 1;
					var markerNodeParent = markerNode[scope.parentProperty];
					var parent = _.find(levelWiseData[levelKey + parentSearchLevel], function(node) {
						return node[scope.codeProperty] == markerNodeParent;
					});
					if (parent) {
						var bucketChilds = getChildsForParentAsPerBucket(parent, lazyLoadingBucket, markerNode.index + 1);
						console.log('childs appended = ' + bucketChilds.length);
						if (bucketChilds.length > 0) {
							parent.children = parent.children.concat(bucketChilds);
							lazyLoadMarker.push(bucketChilds[bucketChilds.length - 1]);
							scope.$apply();
						}
					}
				};

				var searchString = "";
				var searchLevel;
				var searchDataYetToBeDisplayed = [];
				var searchWithContainsHitResult = [];
				scope.searchResults = [];
				function searchAsPerBucketSize(searchStr, bucket) {
					if (searchString != searchStr) {
						searchString = searchStr;
						searchLevel = maxLevel;
						searchDataYetToBeDisplayed.length = 0;
						searchWithContainsHitResult.length = 0;
						scope.searchResults.length = 0;
					};
					var searchData = getDataAsPerBucketSize(searchStr, bucket);
					scope.searchResults = scope.searchResults.concat(searchData);
				};

				function getOffsetSearchData(bucket) {
					var partitionedData = _.partition(searchDataYetToBeDisplayed, function(data, index) {
						return index > (bucket - 1);
					});
					searchDataYetToBeDisplayed = partitionedData[0];
					return partitionedData[1];
				};

				function getOffsetSearchDataForContainsSearch(bucket) {
					var partitionedData = _.partition(searchWithContainsHitResult, function(data, index) {
						return index > (bucket - 1);
					});
					searchWithContainsHitResult = partitionedData[0];
					return partitionedData[1];
				};

				function getDataAsPerBucketSize(searchStr, bucket) {
					var bucketData = [];
					while (bucketData.length < bucket && searchLevel > 0) {
						var offsetSearchData = getOffsetSearchData(bucket);
						if (offsetSearchData.length == bucket) {
							bucketData = offsetSearchData;
							break;
						}
						var searchData = _.filter(levelWiseData[levelKey + searchLevel], function(node) {
							return -1 != node[scope.titleProperty].toLowerCase().indexOf(searchString.toLowerCase());
						});

						var containsSarchResult = _.filter(levelWiseData[levelKey + searchLevel], function(node) {
							return new RegExp("(" + _.compact(searchString.split(' ')).join('|') + ")", "gi").test(node[scope.titleProperty]) && -1 == node[scope.titleProperty].toLowerCase().indexOf(searchString.toLowerCase());
						});
						searchWithContainsHitResult = searchWithContainsHitResult.concat(containsSarchResult);
						var qumulativeData = offsetSearchData.concat(searchData);
						var partitionedData = _.partition(qumulativeData, function(data, index) {
							return index > (bucket - 1);
						});
						searchDataYetToBeDisplayed = searchDataYetToBeDisplayed.concat(partitionedData[0]);
						bucketData = bucketData.concat(partitionedData[1]);
						searchLevel = searchLevel - 1;
					}
					if (searchLevel == 0) {
						while (bucketData.length < bucket) {
							var containsSearchDataToBeAppended = getOffsetSearchDataForContainsSearch(bucket);
							if (containsSearchDataToBeAppended.length > 0) {
								bucketData = bucketData.concat(containsSearchDataToBeAppended);
							} else {
								break;
							}
						}
					}
					return bucketData;
				};

				function closeChildsForParent(parent) {
					var childs = _.filter(getChildsForParentAsPerBucket(parent), function(childNode) {
						return childNode.isExpanded;
					});
					_.each(childs, function(child) {
						child.isExpanded = false;
						child.children = [];
						closeChildsForParent(child);
					});
				}


				scope.searchText = '';
				scope.searchFieldVal = '';

				scope.expandNode = function(node, index) {
					node.isExpanded = !node.isExpanded;
					if (node.isExpanded) {
						node.children = getChildsForParentAsPerBucket(node, lazyLoadingBucket, 0);
						lazyLoadMarker.push(node.children[node.children.length - 1]);
					} else {
						node.children = [];
						removeMarkerForParent(node);
					}
				};

				function removeMarkerForParent(parent) {
					var childMarkers = _.filter(lazyLoadMarker, function(node, index) {
						return -1 != node[parentCodeStringConstant].indexOf(parent[scope.codeProperty]);
					});
					lazyLoadMarker = _.difference(lazyLoadMarker, childMarkers);
					closeChildsForParent(parent);
				};

				var filterTextTimeout;
				scope.searchAndSelectNode = function(node) {
					if (filterTextTimeout)
						$timeout.cancel(filterTextTimeout);
					filterTextTimeout = $timeout(function() {
						if (scope.searchFieldVal.length > 2)
							searchAsPerBucketSize(scope.searchFieldVal, searchBucket);
						else {
							searchDataYetToBeDisplayed.length = 0;
							searchWithContainsHitResult.length = 0;
						}
					}, 300);
				};

				scope.selectNode = function(node, selectionState) {
					node.selection = selectionState;
					if (scope.isSingleSelect) {
					    if (scope.selectedData && scope.selectedData[0] && scope.selectedData[0][scope.codeProperty] != node[scope.codeProperty]) {
					        scope.selectedData[0].selection = '0';
					    };
					    scope.selectedData = (selectionState == '0') ? [] : [node];
					} else {
						updateSelectionObject(node, selectionState);
						updateChildsForNode(node, selectionState);
					}
					updateParentForNode(node, selectionState);
				};

				function updateSelectionObject(node, selectionState) {
					switch(selectionState) {
					case '0':
						scope.selectedData = _.without(scope.selectedData, node);
						break;
					case '1':
						scope.selectedData.push(node);
						break;
					}
				};

				function updateParentForNode(node, selectionState) {
					var depthLevel = node[scope.levelProperty] - 1;
					var immediateParentCode = node[scope.parentProperty].toString();
					while (depthLevel > 0) {
						var parent = _.find(levelWiseData[levelKey + depthLevel], function(node) {
							return node[scope.codeProperty] == immediateParentCode;
						});
						immediateParentCode = parent[scope.parentProperty].toString();
						if (!parent['isExpanded']) {
							scope.expandNode(parent);
						}
						if (!scope.isSingleSelect) {
							parent.selection = getStateForNode(parent);
						}
						depthLevel = depthLevel - 1;
					}
				};

				function getStateForNode(node) {
					var childCount = node.ChildCount;
					var depthLevel = node[scope.levelProperty] + 1;
					var parentCode = node[scope.codeProperty];
					var groupByData = _.groupBy(levelWiseData[levelKey + depthLevel], scope.parentProperty);
					var selectedChild = _.filter(groupByData[parentCode], function(node) {
						return node.selection == '1';
					});
					var partiallySelectedChild = _.filter(groupByData[parentCode], function(node) {
						return node.selection == '2';
					});
					if (childCount == selectedChild.length) {
						scope.selectedData = _.difference(scope.selectedData, selectedChild);
						scope.selectedData.push(node);
						return "1";
					} else if ((selectedChild.length + partiallySelectedChild.length) > 0) {
						scope.selectedData = _.union(scope.selectedData, selectedChild);
						scope.selectedData = _.without(scope.selectedData, node);
						return "2";
					} else {
						scope.selectedData = _.union(scope.selectedData, selectedChild);
						scope.selectedData = _.without(scope.selectedData, node);
						return "0";
					}
				};

				function updateChildsForNode(node, selectionState) {
					var depthLevel = node[scope.levelProperty] + 1;
					var parentCode = node[scope.codeProperty].toString();
					while (depthLevel <= maxLevel) {
						var childs = _.filter(levelWiseData[levelKey + depthLevel], function(node) {
							return -1 != node[parentCodeStringConstant].indexOf(parentCode);
						});
						_.each(childs, function(child) {
							child.selection = selectionState;
							if (selectionState == "1") {
								scope.selectedData = _.without(scope.selectedData, child);
							};
						});
						depthLevel = depthLevel + 1;
					}
				}

				var uniqueIDGenerator = function() {
					var d = new Date().getTime();
					var uniqueID = 'xxx2xxxpxxxoxxx'.replace(/[xy]/g, function(c) {
						var r = (d + Math.random() * 16) % 16 | 0;
						d = Math.floor(d / 16);
						return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
					});
					return uniqueID;
				};
				if (scope.isSingleSelect) {
					scope.uniqueRadioGroupName = uniqueIDGenerator();
				}

				/*$timeout(function() {
					lazyLoadOffset = angular.element("#treeComponentContainer")[0].getBoundingClientRect().bottom;
					angular.element('.scrollbar-outer').scrollbar({
						onScroll : function(y, x) {
							if (lazyLoadMarker.length > 0 && scope.searchFieldVal.length == 0) {
								var markerNode = lazyLoadMarker[lazyLoadMarker.length - 1];
								if (angular.element("#"+markerNode[scope.codeProperty])[0].getBoundingClientRect().top <= lazyLoadOffset) {
									console.log(markerNode);
									lazyLoadMarker.length = (lazyLoadMarker.length > 0) ? lazyLoadMarker.length - 1 : 0;
									lazyLoadLevelWiseData(markerNode);
									console.log(lazyLoadMarker.length);
								}
							}
							if (y.maxScroll > 0 && y.scroll == y.maxScroll && scope.searchFieldVal.length > 0) {
								$timeout(function() {
									searchAsPerBucketSize(scope.searchFieldVal, searchBucket);
								});
							}
						}
					});
				});*/
				
				scope.scrollEnd = function(e){
					searchAsPerBucketSize(scope.searchFieldVal, searchBucket);
				};

				scope.doneButton = { title: $translate.instant("doneBtn") };

				scope.doneClickHandler = function() {
					if (angular.isFunction(doneCallback)) {
						doneCallback(scope.selectedData);
					}
				};
				
				scope.focusSearch = false;
				scope.isActive = false;
				scope.showMe = false;
				scope.showSearch = function () {
				    scope.isActive = true;
				    scope.focusSearch = true;
				    scope.showMe = true;
				    scope.hideClose = true;
				}

				scope.hideSearch = function () {
				    scope.isActive = false;
				    scope.focusSearch = false;
				    scope.hideClose = false;


				}


			},
			templateUrl : 'shared/directives/smartTree/smartTreeTemplate.html'
		};
	}]).directive('ngIndeterminate', function($compile) {
		return {
			restrict : 'A',
			link : function(scope, element, attributes) {
				scope.$watch(attributes['ngIndeterminate'], function(value) {
					element.prop('indeterminate', value);
				});
			}
		};
	}).directive('ngHighlightSt',['$compile', 'hilitor', function($compile, hilitor) {
		return {
			restrict : 'A',
			link : function(scope, element, attributes) {
				scope.$watch(attributes['ngHighlight'], function(value) {
					hilitor.getHilitor().apply(value);
				});
			}
		};
	}]).service('RESTApiSt', ['$http',
	function($http) {
		var Callback;

		this.getData = function(mode, callback, requestObject) {
			switch(mode) {
			case 'Category':
				Callback = callback;
				serviceCall(requestObject);
				break;
			}
		};

		function serviceCall(req) {
			$http(req).then(function(response) {
				Callback(response);
			}, function(error) {
				Callback(error);
			});
		};
	}]).service('hilitor', [
	function() {
		var hilitor = new Hilitor("treeComponentContainer");
		this.getHilitor = function() {
			return hilitor;
		};
	}]);

})(angular);

// Original JavaScript code by Chirp Internet: www.chirp.com.au
// Please acknowledge use of this code by including this header.
// 2/2013 jon: modified regex to display any match, not restricted to word boundaries.

// License at http://www.the-art-of-web.com/copyright.html

(function ( window, factory ) {

  if ( typeof module === "object" && typeof module.exports === "object" ) {
    // Expose a factory as module.exports in loaders that implement the Node
    // module pattern (including browserify).
    // This accentuates the need for a real window in the environment
    // e.g. var jQuery = require("jquery")(window);
    module.exports = function( w ) {
      w = w || window;
      if ( !w.document ) {
        throw new Error("Hilitor requires a window with a document");
      }
      return factory( w.document );
    };
  } else {
    if ( typeof define === "function" && define.amd ) {
      // AMD. Register as a named module.
      define( [], function() {
        return factory(document);
      });
    } else {
        // Browser globals
        window.Hilitor = factory(document);
    }
  }

// Pass this, window may not be defined yet
}(this, function ( document, undefined ) {


function Hilitor(id, tag, options)
{
  var targetNode = document.getElementById(id) || document.body;
  var hiliteTag = tag || "EM";
  var skipTags = new RegExp("^(?:SCRIPT|FORM|INPUT|TEXTAREA|IFRAME|VIDEO|AUDIO)$");
  var colors = ["#ff6"];
  var wordColor = [];
  var colorIdx = 0;
  var matchRegex = "";
  var openLeft = true;
  var openRight = true;
  options = options || {};
  if (typeof options.onStart !== 'function') {
    options.onStart = function () { /* return FALSE when you want to abort */ };
  }
  if (typeof options.onFinish !== 'function') {
    options.onFinish = function () { /* What you return here is returned by Hilitor.apply() */ return true; };
  }
  if (typeof options.onDoOne !== 'function') {
    options.onDoOne = function (node) { /* return FALSE when you want to skip the highlighting change for this node */ };
  }

  this.setMatchType = function(type)
  {
    switch(type)
    {
    case "left":
      openLeft = false;
      openRight = true;
      break;
    case "right":
      openLeft = true;
      openRight = false;
      break;
    default:
    case "open":
      openLeft = openRight = true;
      break;
    case "complete":
      openLeft = openRight = false;
      break;
    }
  };

  this.setRegex = function (input)
  {
    input = input.replace(/^[^\w]+|[^\w]+$/g, "").replace(/[^\w'\-]+/g, "|");
    var re = "(" + input + ")";
    if(!openLeft) re = "\\b" + re;
    if(!openRight) re = re + "\\b";
    matchRegex = new RegExp(re, "i");
  };

  this.getRegex = function ()
  {
    var retval = matchRegex.toString();
    retval = retval.replace(/^\/(\\b)?|(\\b)?\/i$/g, "");
    retval = retval.replace(/\|/g, " ");
    return retval;
  };

  // recursively apply word highlighting
  this.hiliteWords = function (node)
  {
    var i;

    if(!node)
      return;
    if(!matchRegex)
      return;
    if(skipTags.test(node.nodeName))
       return;
    if(node.nodeName === hiliteTag && node.className === "hilitor")
      return;

    if(node.hasChildNodes()) {
      for(i = 0; i < node.childNodes.length; i++) {
        this.hiliteWords(node.childNodes[i]);
      }
    }
    if(node.nodeType === 3) { // NODE_TEXT
      if((nv = node.nodeValue) && (regs = matchRegex.exec(nv))) {
        if (false !== options.onDoOne.call(this, node)) {
          if(!wordColor[regs[0].toLowerCase()]) {
            wordColor[regs[0].toLowerCase()] = colors[colorIdx++ % colors.length];
          }

          var match = document.createElement(hiliteTag);
          match.appendChild(document.createTextNode(regs[0]));
          match.className = "hilitor";
          match.style.backgroundColor = wordColor[regs[0].toLowerCase()];
          match.style.fontStyle = "inherit";
          match.style.color = "#000";

          var after = node.splitText(regs.index);
          after.nodeValue = after.nodeValue.substring(regs[0].length);
          node.parentNode.insertBefore(match, after);
        }
      }
    }
  };

  // remove highlighting
  this.remove = function ()
  {
    var arr, i;
    do {
      arr = document.querySelectorAll(hiliteTag + ".hilitor");
      i = 0;
      while (i < arr.length && (el = arr[i])) {
        // store the reference to the parent of the hilite tag as that node itself, 
        // and all its links, is invalidated in the next .replaceChild() call:
        var parentNode = el.parentNode;
        if (!parentNode) {
          i++;      
          // this entry would otherwise crash in the code below; we can however improve 
          // on the total run-time costs by cutting back on the number of times we trigger
          // the outer loop (which serves as a recovery mechanism anyway) by continuing
          // with this querySelectorAll()'s results, but at it's higher indexes, which
          // are very probably still valid/okay. This saves a number of outer loops and 
          // thus a number of querySelectorAll calls.
          continue;
        }
        // Note that this stuff can crash (due to the parentNode being nuked) when multiple
        // snippets in the same text node sibling series are merged. That's what the
        // parentNode check is for. Ugly. Even while the .querySelectorAll() 'array' is updated
        // automatically, which would imply that this never occurs, yet: it does. :-(
        parentNode.replaceChild(el.firstChild, el);
        // and merge the text snippets back together again.
        parentNode.normalize();
      }
    } while (arr.length > 0);
  };

  // start highlighting at target node
  this.apply = function (input)
  {
    // always remove all highlight markers which have been done previously
    this.remove();
    if(!input) {
      return false;
    }
    this.setRegex(input);
    var rv = options.onStart.call(this);
    if (rv === false) {
      return rv;
    }
    // ensure all text node series are merged, etc. so that we don't have to bother with fragmented texts in the search/scan.
    targetNode.normalize();
    this.hiliteWords(targetNode);
    return options.onFinish.call(this);
  };
}


  return Hilitor;
}));

angular.module('SMART2').directive('stickOnScroll', function ($window, $compile) {
    return {
        restrict: 'A',
        scope: {
            setTop: '@',
            setZindex: '@',
            onScroll:'&',
            setLeft:"@",
            setRight:"@",
        },
        link: function (scope, elem, attrs) {


            if (scope.setTop == '' || scope.setTop == undefined) {
                scope.setTop = '0'
            }
            if (scope.setLeft == '' || scope.setLeft == undefined) {
                scope.setLeft = '0'
            }
            if (scope.setRight == '' || scope.setRight == undefined) {
                scope.setRight = '0'
            }

            if (scope.setZindex == '' || scope.setZindex == undefined) {
                scope.setZindex = '1'
            }
            

            var template = '<div id="fixedtoHeaderheight_' + scope.$id + '" style="display:none"></div>';
            attrs.$observe('stickOnScroll', function (value) {
                if (value == "true") {
                    var newElement = $compile(template)(scope);
                    elem.after(newElement);
                    var scrollTop = elem.offset().top;
                    angular.element($window).bind('scroll', function () {
                        var elemHeight = elem.outerHeight(),
                            winScrollTop = angular.element($window).scrollTop();

                        if (winScrollTop >= scrollTop) {
                            if (attrs.stickLimit != undefined) {
                                var el = $(attrs.stickLimit),
                                    config = {
                                        top: el.offset().top,
                                        height: el.outerHeight()
                                    };
                                if ((winScrollTop + elem.outerHeight()) > (config.top + config.height)) {
                                    elem.removeClass('is-fixed-on-top').css({ 'top': "", "left": "", "right": "", 'z-index': "" });
                                    angular.element('#fixedtoHeaderheight_' + scope.$id).css({ 'height': 0, 'display': 'none' });
                                } else {
                                    elem.addClass('is-fixed-on-top ' + attrs.applyClassOnFixed).css({ 'top': scope.setTop, 'left': scope.setLeft, 'right': scope.setRight, 'z-index': scope.setZindex });
                                    angular.element('#fixedtoHeaderheight_' + scope.$id).css({ 'height': elemHeight, 'display': 'block' });
                                }
                            } else {
                                elem.addClass('is-fixed-on-top ' + attrs.applyClassOnFixed).css({ 'top': scope.setTop, 'left': scope.setLeft, 'right': scope.setRight, 'z-index': scope.setZindex });
                                angular.element('#fixedtoHeaderheight_' + scope.$id).css({ 'height': elemHeight, 'display': 'block' });
                            }
                        } else {
                            elem.removeClass('is-fixed-on-top').css({ 'top': "", "left": "", "right":"", 'z-index': "" });
                            angular.element('#fixedtoHeaderheight_' + scope.$id).css({ 'height': 0, 'display': 'none' });
                        }

                        scope.onScroll();
                    });
                }
                else {
                    angular.element('#fixedtoHeaderheight_' + scope.$id).css({ 'height': 0, 'display': 'none' });
                    elem.next('#fixedtoHeaderheight_' + scope.$id).remove();
                    elem.removeClass('is-fixed-on-top').css({ 'top': "",   "left": "", "right":"",'z-index': "" });
                    
                }
            });

        }

    }
});


(function () {
    'use strict';
angular.module('SMART2')
.directive('customTab', [function () {
    return {
        restrict: 'A',
        link: function (scope, elem, attrs) {
            var tabbingOnKeyDown = function (e) {
                var $this = $(this),
                    tabType = angular.isDefined(attrs.tabType);
                if (e.keyCode == 38 && !tabType && ($this.prev().length > 0) || e.keyCode == 37 && tabType && ($this.prev().length > 0)) {
                    $this.prev().focus();
                    e.preventDefault();
                }
                else if (e.keyCode == 40 && !tabType && ($this.next().length > 0) || e.keyCode == 39 && tabType && ($this.next().length > 0)) {
                    $this.next().focus();
                    e.preventDefault();
                }
               else if (e.keyCode == 13) {
                   $this.trigger("click");
                   e.preventDefault();
               }
                
            };
            elem.bind("keydown", tabbingOnKeyDown);
            scope.$on('$destroy', function () {
                elem.unbind("keydown", tabbingOnKeyDown);
            });
        }
    }
}]);
})();
(function () {
    'use strict';
angular.module('SMART2')
  .directive('focusonkeypress', ['$focusOnField', function ($focusOnField) {
    return {
        restrict: 'A',
        link: function (scope, elem, attr) {
            var prevFocus;
            var bindKeyEventFunction = function (e) {
                var focusInfunc = function () {
                    if (!elem.hasClass("focused")) {
                        prevFocus = document.activeElement;
                        elem.addClass("focused");
                        var firstFieldFocus = elem.find("a, input, textarea, [tabindex]").first();
                        $focusOnField(firstFieldFocus);
                    }
                },
                focusOutfunc = function () {
                    if (elem.hasClass("focused")) {
                        $focusOnField(prevFocus);
                        prevFocus = ''
                        elem.removeClass("focused");

                    }
                };

                if (attr.altkey && attr.altkey != 'false') {
                    if (attr.focusin && e.key == attr.focusin && e.altKey == true) {
                        focusInfunc();
                    } else if (attr.focusout && e.key == attr.focusout && e.altKey == true) {
                        focusOutfunc();
                    };
                }
                else {
                    if (attr.focusin && e.key == attr.focusin) {
                        focusInfunc();
                    } else if (attr.focusout && e.key == attr.focusout) {
                        focusOutfunc();
                    };
                };

            };
            $(document).bind("keydown", bindKeyEventFunction);
          scope.$on('$destroy', function () {
                $(document).unbind("keydown", bindKeyEventFunction);
            });
        }
    }
  }]);
})();
(function () {
    'use strict';
angular.module('SMART2')
  .directive('a', function () {
      return {
          restrict : 'E',
          link: function (scope, elem, attr) {
              var checkAttr = attr.href,
                  svgIcon = elem.find('svg');
                  
              if(svgIcon){
                  svgIcon.attr("focusable","false");// ie 11 not supported for this
              }  
              if(checkAttr == undefined){
                  attr.$set("href","");
              }
          }
      }
  })
.directive('menuItemList', ['menuListItemServ', function (menuListItemServ) {
    return {
        restrict: 'A',
        link: function (scope, elem, attr) {
            menuListItemServ(elem);
        }
    }
}])
.directive('extraNavTitle', [function () {
    return {
        restrict: 'C',
        link: function (scope, element, attrs) {
            var firstField = element.find("a, input, button, textarea, [tabindex]").not(":disabled, :hidden, [tabindex = -1]").first();
            firstField.focus();
        }
    }

}]);
})();
(function () {
    'use strict';
angular.module('SMART2')
.directive('tabbingGroup', ['$focusOnField', function ($focusOnField) {
    return {
        restrict: 'A',
        link: function (scope, elem, attrs) {
            elem.bind("keydown", function (e) {
                if (e.which == 9) {
                    var focusableEle = "a, input[type=text],input[type=radio]:checked,input[type=checkbox], button, textarea, [tabindex='0']",
                        avoidFocusableEle = ":disabled, :hidden, [tabindex=-1]",
                        $firstField = elem.find(focusableEle).not(avoidFocusableEle).first(),
                        $lastField = elem.find(focusableEle).not(avoidFocusableEle).last();
                    if (e.target == $firstField.get(0) && e.shiftKey) {
                        e.preventDefault();
                        $focusOnField($lastField);
                    } else if (e.target == $lastField.get(0) && !e.shiftKey) {
                        e.preventDefault();
                        $focusOnField($firstField);
                    }
                }
            });
        }

    }
}]);
})();
(function () {
angular.module("SMART2").directive("searchableCube", [function () {
        "use strict";
        return {
            restrict: 'E',
            transclude: true,
            scope: {
                cubeletList: '=?',
                enableProceed: '&',
                selectedCube: '=?',
                formatKey: '@'
            },
            link: function (scope, $element, attrs) {
                scope.proceed = false;

                var enableProceed = scope.$eval(scope.enableProceed);
                scope.options = JSON.parse(JSON.stringify(scope.cubeletList));

                scope.selectedCube = scope.selectedCube || {};

                var container,
                    camera, scene, renderer,
                    canvasMouseMove = false,
                    mouse = new THREE.Vector2(),
                    INTERSECTED, previousInt,
                    group = new THREE.Group(),

                    // mouseRotation vars
                    mouseDown = false,
                    mousemoved = false,
                    startPosition = { x: 0, y: 0, z: 0 },
                    rotateStartPoint = new THREE.Vector3(0, 0, 1),
                    rotateEndPoint = new THREE.Vector3(0, 0, 1),
                    curQuaternion,
                    animationComplete = true,
                    windowHalfX = window.innerWidth / 2,
                    windowHalfY = window.innerHeight / 2,
                    rotationSpeed = 2,
                    lastMoveTimestamp,
                    moveReleaseTimeDelta = 50,
                    selectedCublet,
                    startPoint = {
                        x: 0,
                        y: 0
                    },
                    deltaX = 0,
                    deltaY = 0;
                // mouseRotation vars End



                init();
                animate();

                function init() {
                    container = $element[0];

                    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
                    camera.position.set(-360, 440, 700);

                    scene = new THREE.Scene();
                    //scene.background = new THREE.Color(0x0067b0);

                    camera.lookAt(scene.position);

                    scene.add(new THREE.AmbientLight(0x505050));

                    var light = new THREE.SpotLight(0xffffff, 1.25);
                    light.position.set(-650, 650, 650);
                    // light.rotation.set(  37.32 * Math.PI/180,    -16.45* Math.PI/180,    204.184* Math.PI/180);
                    light.castShadow = true;

                    light.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(70, 1, 100, 10000));
                    light.shadow.bias = 0.00001;

                    light.shadow.mapSize.width = 4096;
                    light.shadow.mapSize.height = 4096;

                    scene.add(light);

                    var cubletWidth = 90,
                        cubeSeparation = 20,
                        geometry,
                        generateThreeByThree,
                        generateTwoByTwo;

                    var positionsArrayThreeByThree = [
                            [-1, 1, 1],
                            [-1, 0, 1],
                            [-1, -1, 1],
                            [0, 1, 1],
                            [0, 0, 1],
                            [0, -1, 1],
                            [1, 1, 1],
                            [1, 0, 1],
                            [1, -1, 1],
                            [1, 1, 0],
                            [1, 0, 0],
                            [1, -1, 0],
                            [1, 1, -1],
                            [1, 0, -1],
                            [1, -1, -1],
                            [0, 1, -1],
                            [0, 0, -1],
                            [0, -1, -1],
                            [-1, 1, -1],
                            [-1, 0, -1],
                            [-1, -1, -1],
                            [-1, 1, 0],
                            [-1, 0, 0],
                            [-1, -1, 0],
                            [0, 1, 0],
                            [0, -1, 0],
                            [0, 0, 0]
                        ],
                        positionsArrayTwoByTwo = [
                            [-1, 1, 1],
                            [-1, -1, 1],
                            [1, 1, 1],
                            [1, -1, 1],
                            [1, 1, -1],
                            [1, -1, -1],
                            [-1, 1, -1],
                            [-1, -1, -1]
                        ];


                    generateThreeByThree = function () {
                        geometry = new THREE.BoxGeometry(cubletWidth, cubletWidth, cubletWidth);
                        var object;
                        for (var i = 0; i < 27; i++) {
                            if (i < scope.options.length) {
                                object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: "#6fc2fb" }));
                            } else {
                                object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
                                    color: 0xffffff,
                                    transparent: true,
                                    opacity: 0.7
                                }));
                            }
                            object.position.x = positionsArrayThreeByThree[i][0] * (cubletWidth + cubeSeparation);
                            object.position.y = positionsArrayThreeByThree[i][1] * (cubletWidth + cubeSeparation);
                            object.position.z = positionsArrayThreeByThree[i][2] * (cubletWidth + cubeSeparation);

                            object.scale.x = 1;
                            object.scale.y = 1;
                            object.scale.z = 1;

                            
                            object.dataID = i + 1;
                            if (i < scope.options.length) {
                                object.castShadow = true;
                                object.receiveShadow = true;
                                object.name = scope.options[i][scope.formatKey];
                                object.disable = false;
                            } else {
                                object.disable = true;
                            }

                            group.add(object);
                        }
                    };

                    generateTwoByTwo = function () {
                        geometry = new THREE.BoxGeometry(cubletWidth + 45, cubletWidth + 45, cubletWidth + 45);
                        var object;
                        for (var i = 0; i < 8; i++) {
                            if (i < scope.options.length) {
                                object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ color: "#6fc2fb" }));
                            } else {
                                object = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
                                    color: 0xffffff,
                                    transparent: true,
                                    opacity: 0.7
                                }));
                            }

                            object.position.x = positionsArrayTwoByTwo[i][0] * (cubletWidth + cubeSeparation + 45) / 2;
                            object.position.y = positionsArrayTwoByTwo[i][1] * (cubletWidth + cubeSeparation + 45) / 2;
                            object.position.z = positionsArrayTwoByTwo[i][2] * (cubletWidth + cubeSeparation + 45) / 2;

                            object.scale.x = 1;
                            object.scale.y = 1;
                            object.scale.z = 1;
                            object.dataID = i + 1;
                            
                            if (i < scope.options.length) {
                                object.name = scope.options[i][scope.formatKey];
                                object.castShadow = true;
                                object.receiveShadow = true;
                                object.disable = false;
                            } else {
                                object.disable = true;
                            }

                            group.add(object);
                        }
                    };
                    

                    if (scope.options.length > 8) {
                        generateThreeByThree();
                    } else {
                        generateTwoByTwo();
                    }

                    scene.add(group);

                    renderer = new THREE.WebGLRenderer({
                            alpha: true,
                            antialias: true
                    });
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setSize(window.innerWidth, window.innerHeight);

                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFShadowMap;
                    renderer.shadowMap.soft = true;

                    container.appendChild(renderer.domElement);
                    container.addEventListener('mousemove', onMouseMove);

                    // window.addEventListener('resize', onWindowResize, false);
                    container.addEventListener('mousedown', onDocumentMouseDown, true);
                    window.addEventListener('resize', onWindowResize, false);
                }

                // keyhandler
                container.addEventListener('keydown', keyPressed);

                function keyPressed(e) {
                    switch (e.keyCode) {
                        case 38:
                            scope.handleRotation("top");
                            break;
                        case 40:
                            scope.handleRotation("bottom");
                            break;
                        case 37:
                            scope.handleRotation("left");
                            break;
                        case 39:
                            scope.handleRotation("right");
                            break;
                    }
                };
                

                //$element.find(".searchElement").on('click', function (event) {
                //    event.stopPropagation();
                //});
                   
                
                //$element.find(".navBtn").on('click', function(event) {
                //    scope.handleRotation(this.id);
                //});

                scope.handleRotation = function(btnType) {
                    if (!animationComplete) {
                        return;
                    }
                    switch (btnType) {
                        case "top":
                            animateRotation(1, 0, 0);
                            break;
                        case "bottom":
                            animateRotation(-1, 0, 0);
                            break;
                        case "left":
                            animateRotation(0, 1, 0);
                            break;
                        case "right":
                            animateRotation(0, -1, 0);
                            break;
                    }
                };

                scope.routeToReport = function () {
                    location.href = "index_reports.html#/analytics/new";
                }

                scope.searchElementByValue = function () {
                    var value = $element.find(".searchElement input").val().toLowerCase();
                    var index = _.findIndex(this.cubeletList, { name: value.charAt(0).toUpperCase() + value.slice(1) });
                    if (index !== -1) {
                        scope.selectedCube.select = this.cubeletList[index];
                        scope.searchElement(scope.selectedCube.select.id);
                    }
                }
                

                function animateRotation(xDirection, yDirection, zDirection) {
                    var position = { x: 0, y: 0 },
                        target = { x: 0, y: Math.PI / 2 },
                        tween = new TWEEN.Tween(position).to(target, 1000),
                        prePositon = { x: 0, y: 0 },
                        X = 0,
                        Y = 0,
                        Z = 0;

                    tween.easing(TWEEN.Easing.Quadratic.InOut);

                    tween.onUpdate(function() {
                        if (xDirection) {
                            X = position.y - prePositon.y;
                            if (xDirection == 1) {
                                X = -1 * X;
                            }
                        } else {
                            Y = position.y - prePositon.y;
                            if (yDirection == 1) {
                                Y = -1 * Y;
                            }
                        }

                        animationComplete = false;
                        var deltaRotationQuaternion = new THREE.Quaternion()
                            .setFromEuler(new THREE.Euler(X,
                                Y,
                                Z,
                                'XYZ'
                            ));
                        group.quaternion.multiplyQuaternions(deltaRotationQuaternion, group.quaternion);
                        prePositon.y = position.y;
                    });
                    tween.start();
                    tween.onComplete(function() {
                        animationComplete = true;
                    });
                };

                // keyhandler end


                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };

                function animate() {
                    requestAnimationFrame(animate);
                    render();
                    update();
                    TWEEN.update();
                };

                // animationLogic
                function onDocumentMouseDown(event) {
                    if (!animationComplete || event.target != $element.find('.mainScreen')[0]) {
                        return;
                    }
                    //event.preventDefault();
                    container.addEventListener('mousemove', onDocumentMouseMove, false);
                    container.addEventListener('mouseup', onDocumentMouseUp, false);

                    mouseDown = true;

                    startPoint = {
                        x: event.clientX,
                        y: event.clientY
                    };

                    rotateStartPoint = rotateEndPoint = projectOnTrackball(0, 0);
                };

                function onMouseMove(e) {
                    canvasMouseMove = true;
                    event.preventDefault();
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                    mouse.clientX = event.clientX;
                    mouse.clientY = event.clientY;
                };

                function onDocumentMouseMove(event) {
                    mousemoved = true;

                    deltaX = event.x - startPoint.x;
                    deltaY = event.y - startPoint.y;

                    handleRotationMouse();

                    startPoint.x = event.x;
                    startPoint.y = event.y;

                    lastMoveTimestamp = new Date();
                };

                function onDocumentMouseUp(event) {
                    highlightCublet(previousInt);
                    if (new Date().getTime() - (lastMoveTimestamp ? lastMoveTimestamp.getTime() : 0) > moveReleaseTimeDelta) {
                        deltaX = event.x - startPoint.x;
                        deltaY = event.y - startPoint.y;
                    }

                    mouseDown = false;

                    container.removeEventListener('mousemove', onDocumentMouseMove, false);
                    container.removeEventListener('mouseup', onDocumentMouseUp, false);
                    if (mousemoved && animationComplete) {
                        // resetCube();
                    }
                    mousemoved = false;


                    var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                    vector.unproject(camera);
                    var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                    // create an array containing all objects in the scene with which the ray intersects
                    var intersects = ray.intersectObjects(scene.children[2].children);

                    // if there is one (or more) intersections
                    if (intersects.length > 0 && (selectedCublet == void 0 || intersects[0].object.name != selectedCublet.name)) {
                        popInCube(INTERSECTED);
                        popOutCube(INTERSECTED);
                        //console.log("route to: " + intersects[0].object.name);
                        
                    }
                };


                function projectOnTrackball(touchX, touchY) {
                    var mouseOnBall = new THREE.Vector3();

                    mouseOnBall.set(
                        clamp(touchX / windowHalfX, -1, 1), clamp(-touchY / windowHalfY, -1, 1),
                        0.0
                    );

                    var length = mouseOnBall.length();

                    if (length > 1.0) {
                        mouseOnBall.normalize();
                    } else {
                        mouseOnBall.z = Math.sqrt(1.0 - length * length);
                    }

                    return mouseOnBall;
                };

                function rotateMatrix(rotateStart, rotateEnd) {
                    var axis = new THREE.Vector3(),
                        quaternion = new THREE.Quaternion(),
                        angle;

                    angle = Math.acos(rotateStart.dot(rotateEnd) / rotateStart.length() / rotateEnd.length());

                    if (angle) {
                        axis.crossVectors(rotateStart, rotateEnd).normalize();
                        angle *= rotationSpeed;
                        quaternion.setFromAxisAngle(axis, angle);
                    }
                    return quaternion;
                };

                function clamp(value, min, max) {
                    return Math.min(Math.max(value, min), max);
                };
                // animationLogicEnds


                function render() {
                    TWEEN.update();
                    if (!mouseDown) {
                        var drag = 0.95,
                            minDelta = 0.05;

                        if (deltaX < -minDelta || deltaX > minDelta) {
                            deltaX *= drag;
                        } else {
                            deltaX = 0;
                        }

                        if (deltaY < -minDelta || deltaY > minDelta) {
                            deltaY *= drag;
                        } else {
                            deltaY = 0;
                        }

                        // handleRotationMouse();
                    }
                    renderer.render(scene, camera);
                };


                var handleRotationMouse = function() {
                    rotateEndPoint = projectOnTrackball(deltaX, deltaY, -1 * deltaX);
                    var rotateQuaternion = rotateMatrix(rotateStartPoint, rotateEndPoint);
                    curQuaternion = group.quaternion;
                    curQuaternion.multiplyQuaternions(rotateQuaternion, curQuaternion);
                    curQuaternion.normalize();
                    group.setRotationFromQuaternion(curQuaternion);
                    rotateEndPoint = rotateStartPoint;
                };

                function resetCube() {
                    var position = group.rotation;
                    animateResetRotation(Math.sign(position.x), Math.sign(position.y), Math.sign(position.z), group.rotation.x, group.rotation.y, group.rotation.z);
                    group.updateMatrix();
                };

                function animateResetRotation(xDirection, yDirection, zDirection, anglex, angley, anglez) {
                    var PI = Math.PI,
                        position = { x: anglex, y: angley, z: anglez },
                        nearesrXGap = Math.abs(anglex % (PI / 2)) > PI / 4 ? anglex + xDirection * (PI / 2 - Math.abs(anglex % (PI / 2))) : anglex - anglex % (PI / 2),
                        nearesrYGap = Math.abs(angley % (PI / 2)) > PI / 4 ? angley + yDirection * (PI / 2 - Math.abs(angley % (PI / 2))) : angley - angley % (PI / 2),
                        nearesrZGap = Math.abs(anglez % (PI / 2)) > PI / 4 ? anglez + zDirection * (PI / 2 - Math.abs(anglez % (PI / 2))) : anglez - anglez % (PI / 2),
                        target = { x: nearesrXGap, y: nearesrYGap, z: nearesrZGap },
                        tween = new TWEEN.Tween(position).to(target, 200),
                        prePositon = { x: anglex, y: anglex, z: anglez },
                        X, Y, Z;

                    // tween.easing(TWEEN.Easing.Linear.InOut);

                    tween.onUpdate(function() {
                        if (xDirection) {
                            X = position.x - prePositon.x;
                            if (xDirection == 1) {
                                X = -1 * X;
                            }
                        }
                        if (yDirection) {
                            Y = position.y - prePositon.y;
                            if (yDirection == 1) {
                                Y = -1 * Y;
                            }
                        }
                        if (zDirection) {
                            Z = position.z - prePositon.z;
                            if (yDirection == 1) {
                                Y = -1 * Y;
                            }
                        }

                        animationComplete = false;
                        group.rotation.x = position.x;
                        group.rotation.y = position.y;
                        group.rotation.z = position.z;
                        prePositon.x = position.x;
                        prePositon.y = position.y;
                        prePositon.z = position.z;
                    });
                    tween.start();
                    tween.onComplete(function() {
                        animationComplete = true;
                    });
                };

                //$element.find("#search-cublet").on("click", function (e) {
                //     searchElement();
                //});

                scope.searchElement = function (requestedID) {
                    if (scope.options.length > 8) {
                        switch (requestedID) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                                animateFindElementRotation(0, 0, 0, 0, 0, 0, requestedID);
                                break;
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                                animateFindElementRotation(1, 0, 1, Math.PI, 0, Math.PI, requestedID);
                                break;
                            case 22:
                            case 23:
                            case 24:
                                animateFindElementRotation(0, 1, 0, 0, Math.PI / 2, 0, requestedID);
                                break;
                            case 10:
                            case 11:
                            case 12:
                            case 13:
                            case 14:
                            case 15:
                                animateFindElementRotation(0, -1, 0, 0, -Math.PI / 2, 0, requestedID);
                                break;
                            case 25:
                                animateFindElementRotation(1, 0, 0, Math.PI / 2, 0, 0, requestedID);
                                break;
                            case 26:
                                animateFindElementRotation(-1, 0, 0, -Math.PI / 2, 0, 0, requestedID);
                                break;
                        }
                    } else {
                        switch (requestedID) {
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                animateFindElementRotation(0, 0, 0, 0, 0, 0, requestedID);
                                break;
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                                animateFindElementRotation(1, 0, 1, Math.PI, 0, Math.PI, requestedID);
                                break;
                        }
                    }
                    
                };

                function animateFindElementRotation(xDirection, yDirection, zDirection, anglex, angley, anglez, requestedID) {
                    var INTERSECTED = scene.children[2].children[parseInt(requestedID) - 1],
                        currentAngles = group.rotation,
                        PI = Math.PI,
                        position = { x: currentAngles.x, y: currentAngles.y, z: currentAngles.z },
                        target = { x: anglex, y: angley, z: anglez },
                        tween = new TWEEN.Tween(position).to(target, 200),
                        prePositon = { x: anglex, y: anglex, z: anglez },
                        X, Y, Z;

                    highlightCublet(previousInt);
                    //if (previousInt == void 0 || previousInt.dataID !== requestedID) {
                        animateCubePopup(INTERSECTED, true);
                        popInCube(INTERSECTED);
                        popOutCube(INTERSECTED);
                    //}

                    previousInt = INTERSECTED;

                    // tween.easing(TWEEN.Easing.Linear.InOut);

                    tween.onUpdate(function() {
                        if (xDirection) {
                            X = position.x - prePositon.x;
                            if (xDirection == 1) {
                                X = -1 * X;
                            }
                        }
                        if (yDirection) {
                            Y = position.y - prePositon.y;
                            if (yDirection == 1) {
                                Y = -1 * Y;
                            }
                        }
                        if (zDirection) {
                            Z = position.z - prePositon.z;
                            if (yDirection == 1) {
                                Y = -1 * Y;
                            }
                        }

                        animationComplete = false;
                        group.rotation.x = position.x;
                        group.rotation.y = position.y;
                        group.rotation.z = position.z;
                        prePositon.x = position.x;
                        prePositon.y = position.y;
                        prePositon.z = position.z;
                    });
                    tween.start();
                    tween.onComplete(function() {
                        animationComplete = true;
                    });
                };

                // highlight logic
                function update() {
                    if (!animationComplete || mouseDown || !canvasMouseMove) {
                        return;
                    }
                    // find intersections

                    // create a Ray with origin at the mouse position
                    //   and direction into the scene (camera direction)
                    var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                    vector.unproject(camera);
                    var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                    // create an array containing all objects in the scene with which the ray intersects
                    var intersects = ray.intersectObjects(scene.children[2].children);

                    // INTERSECTED = the object in the scene currently closest to the camera 
                    //      and intersected by the Ray projected from the mouse position    

                    // if there is one (or more) intersections
                    if (intersects.length > 0) {
                        // if the closest object intersected is not the currently stored intersection object
                        if (intersects[0].object != INTERSECTED) {

                            // restore previous intersection object (if it exists) to its original color
                            if (INTERSECTED && (selectedCublet == void 0 || INTERSECTED.id != selectedCublet.id) && !INTERSECTED.disable) {
                                INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                            }


                            // store reference to closest object as current intersection object
                            INTERSECTED = intersects[0].object;
                            if (INTERSECTED.disable) {
                                return;
                            }

                            if (previousInt !== void 0 && INTERSECTED.name !== previousInt.name && previousInt.hovered) {
                                highlightCublet(previousInt);
                            }

                            if (previousInt == void 0 || INTERSECTED.name !== previousInt.name) {
                                // store color of closest object (for later restoration)
                                canvasMouseMove = false;

                                animateCubePopup(INTERSECTED);
                            }
                        }
                    } else // there are no intersections
                    {
                        INTERSECTED = null;
                    }
                };

                var getIntersect = function (INTERSECTED, camera, jqdiv) {


                    var pos = INTERSECTED.position.clone(),
                    projScreenMat = new THREE.Matrix4();
                    projScreenMat.multiply(camera.projectionMatrix, camera.matrixWorldInverse);
                    projScreenMat.multiplyVector3(pos);

                    return {
                        "x": (pos.x + 1) * jqdiv.width() / 2 + jqdiv.offset().left,
                        "y": (-pos.y + 1) * jqdiv.height() / 2 + jqdiv.offset().top
                    };
                };


                function animateCubePopup(INTERSECTED, fromSerach) {
                    var position = { x: 0, y: 0 },
                        target = { x: 0, y: 20 },
                        tween = new TWEEN.Tween(position).to(target, 100),
                        prePositon = { x: 0, y: 0 },
                        $mainScreen = $element.find(".mainScreen"),
                        intersect = {
                            x: mouse.clientX + 10,
                            y: mouse.clientY
                        };

                        if (fromSerach) {
                            intersect = getIntersect(INTERSECTED, camera, $element);
                        }

                    $mainScreen.attr("interesect", JSON.stringify(intersect))
                    .attr("tooltipActive", true)
                    .attr("message", "Cublet <b>" + INTERSECTED.name + "</b>")
                    .trigger("interesected");

                    INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                    INTERSECTED.hovered = true;
                    // set a new color for closest object
                    if (!INTERSECTED.selected) {
                        INTERSECTED.material.color.setHex(0xa49cfb);
                    } else {
                        INTERSECTED.material.color.setHex(0xffa600);
                    }
                    previousInt = INTERSECTED;
                };

                function highlightCublet(cublet) {
                    $element.find(".mainScreen").attr("tooltipActive", false);
                    if (cublet !== void 0 && cublet.hovered) {
                        if (selectedCublet == void 0 || previousInt.id != selectedCublet.id) {
                            previousInt.material.color.setHex(previousInt.currentHex);
                            previousInt.hovered = false;
                        }
                    }
                }

                function popOutCube(cublet) {
                    if (cublet.disable) {
                        return;
                    }
                    animationComplete = false;
                    previousInt.material.color.setHex(0xffa600);
                    cublet.selected = true;
                    scope.selectedCube.select = _.where(scope.cubeletList, { id: cublet.dataID })[0];


                    var position = { x: 0, y: 0 },
                        target = { x: 0, y: 20 },
                        tween = new TWEEN.Tween(position).to(target, 100),
                        prePositon = { x: 0, y: 0 };
                    
                    tween.easing(TWEEN.Easing.Quadratic.InOut);

                    tween.onUpdate(function() {
                        cublet.position.x += Math.sign(cublet.position.x) * (position.y - prePositon.y);
                        cublet.position.y += Math.sign(cublet.position.y) * (position.y - prePositon.y);
                        cublet.position.z += Math.sign(cublet.position.z) * (position.y - prePositon.y);
                        selectedCublet = cublet;
                        prePositon.y = position.y;
                    });
                    tween.start();
                    tween.onComplete(function() {
                        animationComplete = true;
                        if(!scope.proceed) {
                            scope.proceed = true;
                            enableProceed();
                            scope.$apply();
                        }
                    });
                }

                function popInCube(currentSelection) {
                    if (selectedCublet == void 0 || currentSelection.disable) {
                        return;
                    }
                    selectedCublet.selected = false;
                    selectedCublet.material.color.setHex(7324411);
                    selectedCublet.position.x -= Math.sign(selectedCublet.position.x) * 20;
                    selectedCublet.position.y -= Math.sign(selectedCublet.position.y) * 20;
                    selectedCublet.position.z -= Math.sign(selectedCublet.position.z) * 20;
                }

                if (scope.selectedCube.select)
                    scope.searchElement(scope.selectedCube.select.id);
            },
            templateUrl: 'shared/directives/uiElements/searchableCube/searchableCubeTemplate.html'
        };

}]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartBack', ['$timeout','persistenceService', '$rootScope', function ($timeout, persistenceService, $rootScope) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                callback: "&"
            },
            link: function (scope, element, attrs) {
               
                //click callback
                var callback = scope.$eval(scope.callback);
                
                if(!persistenceService.nPlusOne.historyIsEmpty()){
                    scope.show=true;
                }
                
                //Local click binding
                scope.goBackClick = function (e) {
                    if (!scope.disable) {
                        if (angular.isFunction(callback)) {
                            callback(e)
                        };
                        persistenceService.redirectToPreviousNode();
                    }
                };

            },
            templateUrl: 'shared/directives/uiElements/smartBack/smartBackTemplate.html'
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').factory('browserSniffing', [function () {
        var ua = navigator.userAgent, tem,
                   old_ie = ua.indexOf('MSIE '), //IE browser version less than 11
                    new_ie = ua.indexOf('Trident/'), //IE browser version greater or equal to 11
              // M = ua.match(/(opera|chrome|safari|firefox|msie|android|ipad|iphone|trident(?=\/))\/?\s*(\d+)/i) || [];
        M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

        //For checking if browser is from Internet Explorer family
        if (/trident/i.test(M[1]) || /MSIE/i.test(M[1])) {
            tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
            if (tem.length == 0) {
                return 'IE ' + (M[2] || '');
            } else {
                return 'IE ' + (tem[1] || '');
            }
        }
        if (M[1] === 'Chrome') {
            tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
            if (tem != null)
                return tem.slice(1).join(' ').replace('OPR', 'Opera');
        }
        M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
        if ((tem = ua.match(/version\/(\d+)/i)) != null)
            M.splice(1, 1, tem[1]);
        return M; // returning browser name and browser version
    }]);

    angular.module('SMART2').directive('smartBrowserSniffing', ['$window', '$timeout', '$translate', 'browserSniffing', 'notification', 'APPCONSTANTS', 'favoriteOps', function ($window, $timeout, $translate, browserSniffing, notification, APPCONSTANTS, favoriteOps) {
        return {
            restrict: 'A',
            scope: {
                showSniffing: '@',
            },
            templateUrl: 'shared/directives/uiElements/smartBrowserSniffing/browerSniffingTemplate.html',
            link: function (scope, element) {
                var showSniffing = (scope.showSniffing == 'true') ? true : false;
                scope.image960 = APPCONSTANTS.userPreferences.URLs.ContentURL + "smartcontent/workspace/shared/resources/images/browser-sniff/960-error-trans.png";
                scope.image1920 = APPCONSTANTS.userPreferences.URLs.ContentURL + "smartcontent/workspace/shared/resources/images/browser-sniff/1920-error-trans.png";
                var iconIE = APPCONSTANTS.userPreferences.URLs.ContentURL + "smartcontent/workspace/shared/resources/images/browser-sniff/IE.png",
                    iconChrome = APPCONSTANTS.userPreferences.URLs.ContentURL + "smartcontent/workspace/shared/resources/images/browser-sniff/Chrome.png";
                if (showSniffing == true) {
                    $timeout(function () {
                        scope.execBrowserSniffing();
                    });

                    angular.element($window).bind('resize', function () {
                        scope.execBrowserSniffing();
                    });

                    scope.Screen960 = false;
                    scope.Screen1920 = false;

                    scope.execBrowserSniffing = function () {
                        scope.isShowSniffer = favoriteOps.getSnifferFlag && favoriteOps.getSnifferFlag();
                        if (!scope.isShowSniffer) {
                            scope.sniffTemplateUrl = "";
                            angular.element('html').css('overflow', 'hidden');

                            if (angular.element($window).innerWidth() < 960 || angular.element($window).innerWidth() > 1920) {
                                if (angular.element($window).innerWidth() < 960) {
                                    scope.Screen960 = true;
                                    scope.sniffTemplateUrl = "shared/directives/uiElements/smartBrowserSniffing/Browse960.html";
                                    element.addClass('active');
                                    scope.$apply();
                                }
                                if (angular.element($window).innerWidth() > 1920) {
                                    scope.Screen1920 = true;
                                    scope.sniffTemplateUrl = "shared/directives/uiElements/smartBrowserSniffing/Browse1920.html";
                                    element.addClass('active');
                                    scope.$apply();
                                }
                            }
                            else {
                                element.removeClass('active');
                                angular.element('html').removeAttr('style');
                            }
                            angular.element('.sniffingContainer').animate({ scrollTop: 1000 }, 'slow');
                        }
                    }

                    scope.onChange = function (isTrue) {
                        scope.isShowSniffer = isTrue;
                    }

                    scope.hideSniffingOverlay = function () {
                        scope.Screen1920 = false;
                        scope.Screen960 = false;
                        element.removeClass('active');
                        angular.element('html').removeAttr('style');
                        favoriteOps.setSnifferFlag(scope.isShowSniffer);
                    }
                    if (!(typeof browserSniffing === 'object')) {
                        browserSniffing = browserSniffing.split(' ');
                    }
                    var browserDetail = browserSniffing;

                    scope.remindOptions = [{
                        "title": "30 Days"
                    }, {
                        "title": "15 Days"
                    }];
                    scope.selectedDate = { "title": "30 Days" };

                    var unsupportedBrowserVersion = {
                        type: "unsupportedBrowserVersion",
                        isMultipleCheck: true,
                        titleTextColor: "browser-version-header-text",
                        buttons: [
                            {
                                title: $translate.instant('updateNowBtn'),
                                result: "Update Now"
                            },
                        {
                            title: $translate.instant('dismissLink'),
                            result: "dismiss"
                        }
                        ],
                        multipleCheckList: [{
                            type: "select",
                            checkContext: scope.selectedDate,
                            options: scope.remindOptions,
                            model: scope.selectedDate,
                            preSelected: scope.selectedDate,
                            header: $translate.instant('yourCurrentBrowser')
                        }]
                    };

                    var unsupportedBrowser = {
                        type: "unsupportedBrowser",
                        isMultipleCheck: true,
                        //message: "<em>" + browserDetail[0] + "</em> " + $translate.instant("browserIncompatibleMsg") + "<ul class=\"browser-list\"><li><a href=\"https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&gclid=EAIaIQobChMIuPufvL320gIVwpe9Ch3VhQUtEAAYASAAEgJ8ifD_BwE\" target=\"_blank\"><img src=" + iconChrome + " /><p>" + $translate.instant('broswerChrome') + "</p></a></li><li><a href=\"https://www.microsoft.com/en-in/download/Internet-Explorer-11-for-Windows-7-details.aspx\" target=\"_blank\"><img src=" + iconIE + " /><p>" + $translate.instant('browserInterExplorer') + "</p></a></li></ul>",
                        titleTextColor: "browser-unsupported-header-text",
                        buttons: [
                            {
                                title: $translate.instant('dismissLink'),
                                result: "dismiss"
                            }
                        ],
                        multipleCheckList: [{
                            type: "select",
                            checkContext: scope.selectedDate,
                            options: scope.remindOptions,
                            model: scope.selectedDate,
                            preSelected: scope.selectedDate,
                            header: "<em>" + browserDetail[0] + "</em> " + $translate.instant("browserIncompatibleMsg") + "<ul class=\"browser-list\"><li><a href=\"https://www.google.com/chrome/browser/desktop/index.html?brand=CHBD&gclid=EAIaIQobChMIuPufvL320gIVwpe9Ch3VhQUtEAAYASAAEgJ8ifD_BwE\" target=\"_blank\"><img src=" + iconChrome + " /><p>" + $translate.instant('broswerChrome') + "</p></a></li><li><a href=\"https://www.microsoft.com/en-in/download/Internet-Explorer-11-for-Windows-7-details.aspx\" target=\"_blank\"><img src=" + iconIE + " /><p>" + $translate.instant('browserInterExplorer') + "</p></a></li></ul>",
                        }]
                    };

                    var standalone = window.navigator.standalone,
                    userAgent = window.navigator.userAgent.toLowerCase(),
                    mobile = /iphone|ipod|ipad|android/.test(userAgent);
                    if (mobile) {
                        return false;
                    }
                    else {
                        if ((browserSniffing[0] == "Chrome" && browserSniffing[1] < 45) ||
                            (browserSniffing[0] == "IE" && browserSniffing[1] < 11)) {
                            notification.notify(unsupportedBrowserVersion, function (result) {
                            });
                        }

                        if ((browserSniffing[0] != "Chrome" && browserSniffing[0] != "IE")) {
                            notification.notify(unsupportedBrowser, function (result) { });
                        }
                    }
                }
            }
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartButton', ['$timeout', 'persistenceService', function ($timeout, persistenceService) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                callback: "&",
                onClick: "&",
                config: "=",
                backgroundColor: "=",
                fabConfig: "=",
                flat: "=",
                disable: "=",
                callbackParams: "=",
                buttonType: "="
            },
            link: function (scope, element, attrs) {
                //check is floating
                scope.isFloating = (attrs.floating) ? scope.$eval(attrs.floating) : false;

                //check is large
                scope.isLarge = (attrs.large) ? scope.$eval(attrs.large) : false;

                //click callback
                var callback = scope.$eval(scope.callback);
           
                //Local click binding
                scope.clickCallback = function (e) {
                    e.goBack= persistenceService.redirectToPreviousNode;
                    if (!scope.buttonType  || (scope.buttonType && scope.buttonType != "Cancel")) {
                        if (!scope.disable) {
                            if (angular.isFunction(callback)) {
                                callback(e, scope.callbackParams)
                            };
                            scope.onClick({ $event: e });
                        }
                    }
                    else {
                        persistenceService.redirectToPreviousNode();
                    }
                };

                attrs.$observe('ngClass', function (value) {
                    scope.styleClass = value;
                });
            },
            templateUrl: 'shared/directives/uiElements/smartButton/smartButtonTemplate.html'
        };
    }]);
})();
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Checkbox
   * @description This directive is useful for creating a checkbox.
   *
   * @attr {String} label
   *    Label to be displayed for identification of this ui element
   * @attr {Boolean} ng-model
   *    Checkbox's default state (selected or unselected)
   * @attr {Object} ng-model-options
   *    https://docs.angularjs.org/api/ng/directive/ngModelOptions. 
   *    <a href="SMART2.Textfield.html">Click here</a> and scoll down to 'Textfield with ng-model-options' to see example reference.
   * @attr {Boolean} disable
   *    If value of this attribute is set to true, checkbox will not be clickable
   * @attr {Boolean} focus 
   *    If set to true, this ui element will be focused
   * @attr {Boolean} validate
   *    If set to true, this ui element will be validated on the basis of rules passed to it
   * @attr {Array} rules 
   *    Rules to be evaluated when this element's blur event is fired. A rule must have 'rule' and 'errorMessage' properties (keys).
   *    'rule' must be a condition or group of conditions. 'errorMessage' will be the message to be displayed when corresponding rule fails. See example for more.
   * @attr {String} error-message 
   *    Error message to be displayed. This attribute can be set at any point to display an error message.
   * @attr {Boolean} is-mandatory 
   *    If set to true, default error message will be displayed when blur event is fired and this ui element is left blank
   * @attr {Boolean} is-visible 
   *    If set to true, this ui element will be displayed on form regardless of 'is-mandatory' property's value. 
   *    This ui element can be removed from form by clicking 'x' button on top right corner of this ui element.
   * @attr {Number} colspan
   *    Number of columns to be occupied by this ui element. 1 column is equal to 1 ui element.
   *    Default value is 1.
   *    For e.g. If colspan is set to 2, this ui element will occupy width of 2 ui elements (fields).
   * @attr {Function} on-change
   *    Callback function when checkbox state is changed 
   * 
   * @example
   Dynamic:
   Controller:
       $scope.config = {
            "modelData": {
                "isUrgent": true
            }, 
            "formConfig": {
                "sections": [
                    {
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "Urgent",
                                        "type": "checkbox",
                                        "isMandatory": true,
                                        "data": "isUrgent",
                                        "colspan": 1,
                                        "onChange": "onChange"  //  controller function ,
                                        "attributes": {
                                            "fill": true
                                        },
                                        "rules": [
                                            { 
                                                "rule": "this == true", 
                                                "error": "Checkbox should not be selected" 
                                            }
                                        ]
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
   
   * @example
   Static:
   Controller:
       $scope.isUrgent = true;
       $scope.onChange = function(isUrgent) {
           console.log(isUrgent);
       };
   Usage:
       <smart-checkbox label="Urgent" ng-model="isUrgent" on-change="onChange(isUrgent)"></smart-checkbox>
       
   * @example
   Disabled checkbox:
   <smart-checkbox disable="true"></smart-checkbox>     
   */
  

(function() {
    'use strict';
    var checkboxCounter = 0;
    
    angular.module('SMART2').directive('smartCheckbox', ['$timeout', 'ScrollTo', 'RuleEngine', function ($timeout, ScrollTo, RuleEngine) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                //ngModel: '=?',
                ngModelResolve: '&',
                disable: '@',
                isMandatory: '@',
                isVisible: '=?',
                label: '@',
                minHeight: '@',
                fill: '@',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                errorMessage: '@',
                onChange: '&',
                removable: '@',
                showTooltip: '@',
                tooltipPosition: '@',
                showinfo: '@'
            },
            link: function (scope, element, attrs, ngModelCtrl) {
                checkboxCounter++;
                scope.checkBoxId = "checkbox-" + checkboxCounter;
                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);
                scope.showTooltip = (scope.showTooltip == undefined || scope.showTooltip == null) ? false : scope.showTooltip;
                scope.fill = scope.$eval(scope.fill) == undefined ? true : scope.$eval(scope.fill);
                var checkboxEle = element.find(":checkbox");
                /*
                 *  Following code has been added to make ng-model-options work
                 *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                 */
                try {
                    ngModelCtrl.$render = function () {
                        scope.ngModel = ngModelCtrl.$modelValue;
                    };
                }
                catch (e) { }

                var updateView = function () {
                    try {
                        ngModelCtrl.$setViewValue(scope.ngModel);
                    }
                    catch (e) { }
                };


                /*
                 * Focus field when focus is set to true
                 */
                var onFocus = scope.$watch('focus', function (newVal) {
                    if (newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        scope.focus = false;
                    }
                });

                /*
                 * Validate field whene validate is set to true
                 */
                var onValidate = scope.$watch('validate', function (newValue) {
                    if (newValue != undefined && newValue) {
                        scope.validateRules();
                    }
                });

                /*
                 * Validate rules
                 */
                scope.validateRules = function () {
                    scope.validate = false;
                    scope.errorMessage = null;

                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false;

                        for (var i = 0; i < rules.length; i++) {
                            if (typeof rules[i] == 'object') {
                                if (eval((rules[i].rule).replace(/this/g, 'scope.ngModel'))) {
                                    scope.validate = true;
                                    scope.errorMessage = rules[i].error;
                                    break;
                                }
                                else {
                                    if (!isFoundInvalid) {
                                        RuleEngine.isValid(rules[i], function (e) {
                                            scope.validate = true;
                                            scope.errorMessage = e.errorData.error;
                                            isFoundInvalid = true;
                                        });
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                };


                scope.ngChange = function () {
                    if (attrs.ngModelResolve) {
                        var isChecked = checkboxEle.prop('checked');
                        checkboxEle.prop('checked', !isChecked);
                        ngModelCtrl.$setViewValue(!isChecked);
                        scope.ngModel = !isChecked;

                        scope.ngModelResolve({
                            $event: {
                                isChecked: !checkboxEle.prop('checked'),
                                resolveFun: function (checked) {
                                    checkboxEle.prop('checked', checked);
                                    ngModelCtrl.$setViewValue(checked);
                                    scope.ngModel = checked;
                                    updateView();
                                    scope.validateRules();
                                    var timeout = $timeout(function () {
                                        scope.onChange();
                                        $timeout.cancel(timeout);
                                    });
                                }
                            }
                        });
                    } else {
                        updateView();
                        scope.validateRules();
                        var timeout = $timeout(function () {
                            scope.onChange();
                            $timeout.cancel(timeout);
                        });
                    };
                };


                scope.$on('$destroy', function () {
                    onFocus();
                    onValidate();
                    element.remove();
                    scope = null;
                });
            },
            templateUrl: 'shared/directives/uiElements/smartCheckBox/smartCheckBoxTemplate.html'
        };
    }]);
})();

angular.module('SMART2').directive('smartCultureDate', ['APPCONSTANTS', function (APPCONSTANTS) {
    "use strict";
    var monthAbr = {
        january: 'Jan',
        february: 'Feb',
        march: 'Mar',
        april: 'Apr',
        may: 'May',
        june: 'Jun',
        july: 'Jul',
        august: 'Aug',
        september: 'Sep',
        october: 'Oct',
        november: 'Nov',
        december: 'Dec'
    };
    return {
        restrict: 'AE',
        scope: {
            ngModel: '=ngModel',
            enableShortMonth: '@'
        },
        replace: true,
        link: function ($scope, elem, attr) {
            var matchExpression = /^[0-9]+$/;
            var cultureCode = APPCONSTANTS.userPreferences.UserBasicDetails.Culture;
            //var currencyCode = APPCONSTANTS.userPreferences.UserBasicDetails.DefaultCurrencyCode;

            var formatNumber = function () {
                if (attr.type == 'number' && $scope.ngModel != undefined && $scope.ngModel != '') {
                    if (typeof $scope.ngModel == "string") {
                        var tempNumb = $scope.ngModel.replace(/,/g, "");
                        if (tempNumb.indexOf('.') !== -1) {
                            tempNumb = $scope.ngModel.replace(/\./g, '');
                        }
                        if (tempNumb.indexOf('') !== -1) {
                            tempNumb = $scope.ngModel.replace(/\s/g, '');
                        }
                        $scope.ngModel = parseInt(tempNumb);
                    }
                    if (cultureCode == 'pt-PT') {
                        $scope.ngModel = $scope.ngModel.toLocaleString(cultureCode).replace(/\s+/g, '.');
                    } else {
                        $scope.ngModel = $scope.ngModel.toLocaleString(cultureCode);
                    }
                }
            };

            if (attr.type == 'date' && $scope.ngModel != undefined && $scope.ngModel != '') {
                if (matchExpression.test($scope.ngModel)) {
                    if (attr.showTime == 'true') {
                        $scope.ngModel = moment.unix(new Date(JSON.parse($scope.ngModel)).getTime() / 1000).format(moment.localeData()._longDateFormat.L + " " + 'HH:mm');
                    } else {
                        $scope.ngModel = moment.unix(new Date(JSON.parse($scope.ngModel)).getTime() / 1000).format(moment.localeData()._longDateFormat.L);
                    }
                } else {
                    if (attr.showTime == 'true') {
                        $scope.ngModel = moment.unix(new Date($scope.ngModel).getTime() / 1000).format(moment.localeData()._longDateFormat.LL + " " + 'HH:mm');
                    } else {
                        $scope.ngModel = moment.unix(new Date($scope.ngModel).getTime() / 1000).format(moment.localeData()._longDateFormat.LL);
                    }
                }

                if ($scope.enableShortMonth == true && $scope.ngModel) {
                    for (var i = 0, abr = Object.keys(monthAbr) ; i < abr.length; i++) {
                        if ($scope.ngModel.search(new RegExp(abr[i], 'gi')) > -1) {
                            $scope.ngModel = $scope.ngModel.replace(new RegExp(abr[i], 'gi'), monthAbr[abr[i]]);
                            break;
                        }
                    }
                }
            }

            formatNumber();

            $scope.$watch('ngModel', function (newValue) {
                if (newValue) formatNumber();
            });

        },
        templateUrl: 'shared/directives/uiElements/smartCultureDate/smartCultureDate.html',
    };
}]);
(function () {
    'use strict';

    var startIndex;

    angular.module('SMART2').directive('smartSortable', [function () {
        return {
            restrict: 'A',
            scope: {
                onSort: '&',
                onDrag: '&'
            },
            link: function (scope, element, attrs) {
                element.sortable({
                    placeholder: attrs.placeholder ? attrs.placeholder : "drop-hover",
                    helper: attrs.helper ? attrs.helper : "original",
                    handle: ".collapsible-header-drag-icon",
                    items: ">*:not(.disable-sort-item)",
                    cancel: ".disable-sort-item",
                    connectWith: attrs.connectWith ? attrs.connectWith : "",
                    appendTo: attrs.appendTo ? attrs.appendTo : "parent",
                    containment: attrs.containment ? attrs.containment : "parent",
                    tolerance: attrs.tolerance ? attrs.tolerance : "intersect",
                    start: function (event, ui) {
                        if (attrs.isOverflowHidden == 'true') {
                            $('body').css('overflow', 'hidden');
                        }
                        startIndex = ui.item.index();
                        if (ui.placeholder) {
                            ui.placeholder.height(ui.item.height()).css("width", ui.item.outerWidth());
                        }
                        scope.$apply(function () {
                            scope.onDrag({
                                $event: {
                                    dragging: true
                                }
                            });
                        });
                    },
                    stop: function (event, ui) {
                        if (attrs.isOverflowHidden == 'true') {
                            $('body').css('overflow', '');
                        }
                        scope.$apply(function () {
                            scope.onDrag({
                                $event: {
                                    dragging: false
                                }
                            });
                        });
                    },
                    update: function (event, ui) {
                        if (attrs.isOverflowHidden == 'true') {
                            $('body').css('overflow', '');
                        }
                        scope.$apply(function () {
                            scope.onSort({
                                $event: {
                                    startIndex: startIndex,
                                    endIndex: ui.item.index()
                                }
                            });
                            scope.onDrag({
                                $event: {
                                    dragging: false
                                }
                            });
                        });
                        if (attrs.swipItem == "true") {
                            // swiping element position with each other
                            if (ui.sender) {
                                var el = ui.item.next().length == 1 ? ui.item.next() : ui.item.prev();
                                ui.sender.append(el);
                            }
                        }
                    },
                    sort: function (event, ui) {
                        //console.log({ event, ui })
                        if (attrs.whileSorting == "true") {
                            var ele = $(".slick-list"),
                                scrollpos = ele.scrollLeft(),
                                main_width = ele.outerWidth(),
                                ew = ui.helper.outerWidth(),
                                elft = ui.helper.offset().left - ele.offset().left,
                                rpos = (main_width - (elft + ew));
                            if (elft < 0) { // left
                                $('.slick-prev').click();
                            } else if (rpos < 0) { // right    
                                $('.slick-next').click();
                            }
                        }
                    }
                });
            }
        };
    }]);

    angular.module('SMART2').directive('isDraggable', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                attrs.$observe('isDraggable', function (isDraggable) {
                    if (isDraggable != undefined && isDraggable != "") {
                        if (isDraggable == 'true' || isDraggable == true) {
                            element.removeClass('disable-sort-item');
                        }
                        if (isDraggable == 'false' || isDraggable == false) {
                            element.addClass('disable-sort-item');
                        }
                    }
                });
            }
        };
    }]);



    //var droppableParent;

    ///*
    // * Highlight droppables on mouse down
    // */
    //var highlightDroppableElements = function (currentDraggableElement) {
    //    currentDraggableElement.removeAttr('style').addClass('being-dragged z-index-plus');
    //    angular.element('.ui-droppable').addClass('being-dropped-on');
    //};

    ///*
    // * Unhighlight droppables on mouse up
    // */
    //var unhighlightDroppableElements = function (currentDraggableElement) {
    //    currentDraggableElement.removeClass('being-dragged z-index-plus');
    //    angular.element('.ui-droppable').removeClass('being-dropped-on');
    //};

    ///*
    // *  This directive will handle dragging of portlet
    // */
    //angular.module('SMART2').directive('smartDraggable', [function () {
    //    return {
    //        restrict: 'A',
    //        link: function (scope, element, attrs) {
    //            if (attrs.smartDraggable == 'false' || attrs.smartDraggable == false) {
    //                return;
    //            }

    //            attrs.$observe('enabled', function (isEnabled) {
    //                if (isEnabled != undefined) {
    //                    if (isEnabled == 'true' || isEnabled == true) {
    //                        element.draggable('enable');
    //                    }
    //                    if (isEnabled == 'false' || isEnabled == false) {
    //                        element.draggable('disable');
    //                    }
    //                }
    //            });

    //            /*
    //             *  Make portlet dragging enabled
    //             */
    //            element.draggable({
    //                revert: 'invalid',
    //                handle: '.collapsible-header-drag-icon',
    //                revertDuration: 200,
    //                delay: 200,
    //                appendTo: 'body',
    //                containment: 'body',
    //                start: function () {
    //                    droppableParent = $(this).parent();
    //                    $(droppableParent).addClass('being-dragged z-index-plus');
    //                },
    //                drag: function (e) {
    //                    if (e.clientX > window.innerWidth - 10 || e.clientX < 10 || e.clientY > window.innerHeight - 10 || e.clientY < 10) {
    //                        $(document).trigger('mouseup');
    //                    }
    //                },
    //                stop: function () {
    //                    setTimeout(function () {
    //                        $(droppableParent).removeClass('being-dragged z-index-plus');
    //                        // clearTimeout(dragTimeout);
    //                    }, 250);
    //                }
    //            });
    //        }
    //    };
    //}]);


    ///*
    // *  This directive will handle dropping of portlet
    // */
    //angular.module('SMART2').directive('smartDroppable', ['$compile', '$timeout', function ($compile, $timeout) {
    //    return {
    //        restrict: 'A',
    //        link: function (scope, element, attrs) {
    //            if (attrs.smartDroppable == 'false' || attrs.smartDroppable == false) {
    //                return;
    //            }

    //            /*
    //             *  Make portlet dropping enabled
    //             */
    //            element.droppable({
    //                hoverClass: 'drop-hover',
    //                drop: function (event, ui) {
    //                    var draggable = $(ui.draggable[0]),
    //                        draggableOffset = draggable.offset(),
    //                        container = $(event.target),
    //                        containerOffset = container.offset();

    //                    $('.draggable', event.target).appendTo(droppableParent).css({ opacity: 0 }).animate({ opacity: 1 }, 200);
    //                    draggable.appendTo(container).css({ left: draggableOffset.left - containerOffset.left, top: draggableOffset.top - containerOffset.top }).animate({ left: 0, top: 0 }, 200);
    //                }
    //            });
    //        }
    //    };
    //}]);
})();

(function () {
    'use strict';
    angular.module('SMART2').directive('smartDropdown', ['$window', '$timeout', 'menuListItemServ', '$focusOnField', function ($window, $timeout, menuListItemServ, $focusOnField) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            scope: {
                config: "@",
                show: "@",
                onHide: "&",
                stopProg: "@",
                autoClose: "@"
            },
            link: function (scope, element, attrs) {
                var islistDropdown;
                var dropDownMenuListItem = function (dropdownContent) {
                    /*dropdown checker*/
                    var liList = dropdownContent.children('li'),
                        liLength = liList.length;
                    if (!liList.attr("isItemList")) {
                       
                        for (var i = 0; i < liLength; i++) {
                            var $this = liList.eq(i),
                                children = $this.children().eq(0);
                            if ($this.children().length == 1 && !$this.hasClass("dropdown-content-footer") && (children.attr("ng-click") != null || children.attr("ui-sref") != null || $this.attr("ng-click") != null)) {
                                islistDropdown = true;
                                break;
                            }
                        };
                        if (islistDropdown == true) {
                            if (liList.last().hasClass("dropdown-content-footer")) {
                                liList.splice(liLength - 1, 1);
                            }
                            menuListItemServ(liList);
                            islistDropdown = false;
                        };
                    }
                    /*dropdown checker end*/

                },
                keycodeis,
			     hideOnTabOut = function (e) {
			         if (e.keyCode == 9) {
			             keycodeis = e.keyCode;
			             window.lastOpenedDropdownConfig.activates.hide().removeClass('active');
			             window.lastOpenedDropdownConfig.origin.removeClass("active");
			             window.lastOpenedDropdownConfig.activates.unbind("keydown", hideOnTabOut);
			         };
			     };


                //initialization
                var clrTout = setTimeout(function () {
                    var _element = element.find(".dropdown-button"),
			            closeDDButtons = element.find(".close-dd");
                    $(_element).dropdown(angular.extend(typeof scope.$eval(attrs.config) == "object" ? scope.$eval(attrs.config) : {}, {
                        onHide: function () {
                            if (keycodeis != 9 && (attrs.singleElementDropdown != undefined)) {
                                window.lastOpenedDropdownConfig.origin.focus();
                                keycodeis = null;
                            }
                            if (scope.autoClose == "false") {
                                return false;
                            }
                        }
                    }));
                    var ddCloseOff = angular.element(".dd-close-off");
                    if (ddCloseOff.length > 0) {
                        ddCloseOff.click(function (e) {
                            var _elem = angular.element(e.target);							
							if(!_elem.hasClass("btn-flat") && !_elem.hasClass("btn") && !_elem.hasClass("btn-large")){
								e.stopPropagation();
							}
                        });
                    }

                    if (closeDDButtons.length > 0) {
                        closeDDButtons.click(function () {
                            var dd = element.find(".dropdown-content");
                            if (dd.length > 0) {
                                scope.hideDropDown(dd);
                            };
                        });
                    }

                    clearTimeout(clrTout);
                    clrTout = null;
                });

                if (scope.$eval(attrs.fixed)) {
                    $(element).find('.dropdown-content').addClass('fixeddd');
                    $(element).find('.dropdown-button').bind('click', function (e) {
                        (function ($t) {
                            var clrTout1 = setTimeout(function () {
                                var ddCnt = $t.next('.dropdown-content'),
                                    $tOffsetTop = $t.offset().top - $(window).scrollTop(),
                                    $tOffsetLeft = $t.offset().left - $(window).scrollLeft();
                                ddCnt.css({ 'left': $tOffsetLeft - 2 + 'px', 'top': $tOffsetTop - 2 + 'px' });
                                //ddCnt.attr('style', function (i, s) { return s + 'display: block !important;' });
                                var lastScrollPosition = $tOffsetTop - 2,
									newScrollPosition = $tOffsetTop - 2;

                                var ddHgt = ddCnt.css('height'),
                                    winHgt = angular.element(window).height();
                                if ((parseInt(ddHgt) + $tOffsetTop) > winHgt) {
                                    var diffHgt = (parseInt(ddHgt) + $tOffsetTop) - winHgt,
                                        clientOffsetHgt = ($tOffsetTop - diffHgt - 15);
                                    ddCnt.css('top', clientOffsetHgt + 'px');
                                    lastScrollPosition = clientOffsetHgt,
									newScrollPosition = clientOffsetHgt;
                                }

                                angular.element($window).on("scroll.smartFixedSmartDrop", function () {
                                    newScrollPosition = this.pageYOffset;
                                    if (newScrollPosition !== lastScrollPosition) {
                                        if (ddCnt.hasClass('active')) {
                                            scope.hideDropDown(ddCnt);
                                        }
                                    }
                                    lastScrollPosition = newScrollPosition;
                                });
                                dropDownMenuListItem(ddCnt) // function for apply the tabbing
                                if (attrs.singleElementDropdown != undefined ) {
                                    ddCnt.bind("keydown", hideOnTabOut);
                                }
                                var firstFieldFocus = ddCnt.find("a, input, textarea, [tabindex]").first();
                                $focusOnField(firstFieldFocus);

                                clearTimeout(clrTout1);
                                clrTout1 = null;

                            });
                        })($(this));
                    });

                } else {

                    // Animation from bottom to top
                    $(element).find('.dropdown-button').bind('click', function (e) {
                        var dropdownContent = $(this).next('.dropdown-content');
                        dropDownMenuListItem(dropdownContent) // function for apply the tabbing
                        if (attrs.singleElementDropdown != undefined) {
                            dropdownContent.bind("keydown", hideOnTabOut);
                        }

                        $(this).next('.dropdown-content').addClass('ddautoHeight');
                        (function ($t) {
                            var tOut2 = setTimeout(function () {
                                var ddCnt = $t.next('.dropdown-content');
                                var ddCntTop = (parseInt(ddCnt.css('top')) + 5) + 'px';
                                var ddCntLeft = (parseInt(ddCnt.css('left')) + 5) + 'px';
                                if (parseInt(ddCntTop, 10) < 0) {
                                    ddCnt.css('top', 0);
                                    ddCnt.animate({
                                        top: ddCntTop, left: ddCntLeft
                                    });
                                }
                                var firstFieldFocus = ddCnt.find("a, input, textarea, [tabindex]").first();
                                $focusOnField(firstFieldFocus);
                                clearTimeout(tOut2);
                                tOut2 = null;
                            });
                        })($(this));
                    });
                }


                var onShow = attrs.$observe('show', function (value) {
                    if (angular.isDefined(value)) {
                        if (!scope.$eval(value)) {
                            var dropdown = element.find('.dropdown-content');
                            scope.hideDropDown(dropdown);
                        }
                    }
                });


                scope.hideDropDown = function (dropdown) {
                    if (dropdown.length > 0) {
                        dropdown.fadeOut(250);
                        dropdown.removeClass('active');
                        dropdown.css('max-height', '');
                        angular.element("[data-activates='" + dropdown.attr('id') + "']").removeClass('active');
                        angular.isFunction(scope.onHide) && scope.onHide();
                    }
                }

                /*Stop Propogation: Start*/
                if (scope.stopProg === "true") {
                    var cancelTout = $timeout(function () {
                        element.find(".dropdown-button").click(function (e) {
                            e.stopPropagation();
                        }).end().find(".dropdown-content").click(function (e) {
                            //Close dropdown after option get selected, this is default fuctionality of materialize framework
                            var a = window.lastOpenedDropdownConfig;
                            a.activates.fadeOut(a.options.outDuration);
                            a.activates.removeClass('active');
                            a.activates.css('max-height', '');
                            a.origin.removeClass('active');
                            e.stopPropagation();
                        });
                        $timeout.cancel(cancelTout);
                        cancelTout = null;
                    });
                }
                /*Stop Propogation: End*/

                scope.$on('$destroy', function () {
                    onShow();
                    angular.element($window).off("scroll.smartFixedSmartDrop");
                    $(element).find('.dropdown-button').unbind('click');
                    $(element).find('.dropdown-button').off('click');
                });
            },
            templateUrl: 'shared/directives/uiElements/smartDropdown/smartDropdownTemplate.html'
        };
    }]);


    angular.module('SMART2').directive('actionCloseDropdown', [function () {
        return {
            restrict: 'C',
            scope: true,
            link: function (scope, element, attrs) {
                //[commenting the traverseAndFireHideDropDown function as it takes time to close/hide dropdown container as soon as closing event is fired]
                //var traverseAndFireHideDropDown = function (scopeRef, dropdown) {
                //    for (var key in scopeRef) {
                //        if (key == 'hideDropDown') {
                //            scopeRef.hideDropDown(dropdown);
                //            return;
                //        }
                //    }
                //    traverseAndFireHideDropDown(scopeRef.$parent, dropdown);
                //    dropdown = null; //[OPTIMIZATION]
                //};

                element.bind('click', function () {
                    angular.element(document).trigger('click');
                });

                scope.$on('$destroy', function () {
                    element.unbind('click', function () {
                        angular.element(document).trigger('click');
                    });
                });
            }
        };
    }]);
})();
'use strict';
angular.module('SMART2').directive('smartErrorFieldHighlighter', ['$timeout', function ($timeout) {
    return {
        restrict: 'AE',
        scope: {
            errorConfig: "="
        },
        link: function (scope, element, attrs) {
            scope.otherMandetoryFields = false;
            scope.$watch("errorConfig.check", function (value) {
                if (value == true) {
                    $timeout(function () {
                        $(element.find("[is-mandatory='true'] input")).each(function () {
                            if ($(this).hasClass('invalid')) {
                                $(this).focus();
                                scope.otherMandetoryFields = true;
                                return false;
                            } else {
                                scope.otherMandetoryFields = false;
                            }
                        });

                        if (!scope.otherMandetoryFields) {
                            $(element.find("[is-mandatory='true'].smartMandetoryField")).each(function () {
                                if ($(this).find('.smartErrorText').length > 0 || $(this).find('.select-invalid-wrapper').length > 0) {
                                    $(this).find('a.focusErrorField').focus();
                                    $(this).find('input').focus();
                                    return false;
                                }
                            });
                        }
                        scope.errorConfig.check = false;
                    });
                }
            });
        }
    }
}]);
/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Form-widget
 * @description Form widget directive accepts form-config and model-data. 
 *    ui elements (fields) that are optional are added in right-panel (widget-panel). Optional fields can be added on form by simply clicking that item in right-panel. 
 *    Optional field can also be removed by clicking 'x' icon on the upper right corner of ui element or 'x' icon against that item in right-panel. 
 * 
 * @attr {Array} form-config
 *    Form config is expected to be an array of ui elements (fields)
 * @attr {Object} model-data
 *    Data to be bound on ui elements (fields)
 * @attr {Boolean} is-sequencial
 *    If the value of this attribute is set to true, newly added ui element (field) will be added at the end of the section.
 *    If the value of this attribute is set to false, newly added ui element (field) will be added by the orders it appears in form-config.  
 * @attr {Boolean} show-widget
 *    When form-config is passed to form-widget, right-panel will always be created if this attribute is not set to false.
 * @attr {String} search-holder
 *    Id of DOM element where search bar should appear. This attribute enables form-widget search feature, where user can search for optional sections and fields on the form.
 *    And navigate to optional section or field by clicking on search result item.
 * @attr {Number} widget-panel-top
 *    Top position for widget-panel (right-panel)
 * @attr {Number} widget-panel-right
 *    Right position for widget-panel (right-panel)
 * @attr {Function} on-section-sort
 *    Callback function when sections are sorted or rearranged
 * @attr {Function} on-save
 *    Callback function when sections are need to be save on outside section click
 *
 * @example
 Dynamic:
 Controller:
      $scope.config = {
          modelData: {
              "firstName": "Sushant",
              "lastName": "Ahirrao"
          },    
          formConfig: {
              "sections": [
                  {
                      "isMandatory": true
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "First name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "firstName"
                                  }, {
                                      "label": "Last name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "lastName"
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          },
          "rules": [
              {
                  "rule": "this.firstName == \"Sushant\" && this.lastName != \"Ahirrao\"",
                  "error": "First name and last name combination is not matching"
              }
          ]
      };

  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

 * @example
 Dynamic attribute value. One can set a scope variable or function as attribute value. 
 One can also pass parameters in calling function as is done on callback functions.
 In following example, value of 'isMandatory' field for 'Last Name' can be 'isLastNameMandatory(config.modelData)'.
 'options' attribute does not support function as value.
 Controller:
      $scope.isFirstNameMandatory = true;

      $scope.isLastNameMandatory = function() {
            return true;
      };

      $scope.config = {
          modelData: {
              "firstName": "Sushant",
              "lastName": "Ahirrao"
          },    
          formConfig: {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "First name",
                                      "type": "textfield",
                                      "isMandatory": "isMandatory",
                                      "data": "firstName"
                                  }, {
                                      "label": "Last name",
                                      "type": "textfield",
                                      "isMandatory": "isLastNameMandatory",
                                      "data": "lastName"
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          },
          "rules": [
              {
                  "rule": "this.firstName == \"Sushant\" && this.lastName != \"Ahirrao\"",
                  "error": "First name and last name combination is not matching"
              }
          ]
      };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
      
 * @example
 Form widget without widget panel (right panel):
 <smart-form-widget show-widget="false"></smart-form-widget>   
     
 * @example
 If newly added ui elements (fields) to be added at the end of the section:
 <smart-form-widget is-sequencial="true"></smart-form-widget>
 
 * @example
 Widget-panel with top and right position:
 <smart-form-widget widget-panel-top="100" widget-panel-right="70"></smart-form-widget>    
 
 * @example
 Form widget with 'Rule Engine' service:
 Controller:
      $scope.config = {
          modelData: {
              "firstName": "Sushant",
              "lastName": "Ahirrao"
          },    
          formConfig: {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "First name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "firstName"
                                  }, {
                                      "label": "Last name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "lastName"
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          },
          "rules": [
              {
                  "rule": "this.firstName == \"Sushant\" && this.lastName != \"Ahirrao\"",
                  "error": "First name and last name combination is not matching"
              }
          ]
      };

      $scope.validateForm = function() {
          RuleEngine.setRules($scope.config.formConfig.sections, $scope.config.modelData, $scope.config.rules);
          RuleEngine.execute(function (e) {
              console.log(e);   //  Check e for more details
          }, $scope);  
      };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
      <button ng-click="validateForm()">Validate Form</button>

* @example
Saving sections on outside section click.

mandatoryFieldStatus property used to initiate sec Nav validation and section indicator

 Dynamic:
 Controller:
      $scope.config = {
          modelData: {
              "firstName": "Sushant",
              "lastName": "Ahirrao"
          },    
          formConfig: {
              "sections": [
                  {
                      "isMandatory": true,
                        "save":true,
                        "mandatoryFieldStatus": {
                            "status": "complete",
                            "isvalidate":  false,
                            "description": "There are some mandatory fields that are not filled in this section",
                            "title": "Section 3 - Completed" 
                        },
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "First name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "firstName"
                                  }, {
                                      "label": "Last name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "lastName"
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          },
          "rules": [
              {
                  "rule": "this.firstName == \"Sushant\" && this.lastName != \"Ahirrao\"",
                  "error": "First name and last name combination is not matching"
              }
          ]
      };
	  $scope.onSave = function (data, prevObj) {
	      console.log(data, "In Controller ", prevObj)
          $scope.$digest();
		  // Note: data will give scope.modelData Obj and prevObj will give scope.formConfig.sections[..]
		  // use class="savable" in actionable container within the section for avoiding the onSave callback function. 
	  };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData" on-save="onSave(data, prevObj)"></smart-form-widget>


 */

(function () {
    'use strict';
    var formWidgetCounter = 0;
    angular.module('SMART2').directive('smartFormWidget', ['APPCONSTANTS', 'ScrollTo', 'formWidgetUtils', '$translate', '$timeout', '$compile', 'persistenceService', 'scrollPosition', '$window', function (APPCONSTANTS, ScrollTo, formWidgetUtils, $translate, $timeout, $compile, persistenceService, scrollPosition, $window) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            scope: {
                formConfig: '=?',
                modelData: '=?',
                isSequential: '@',
                showWidget: '@',
                searchHolder: '@',
                widgetPanelTop: '@',
                widgetPanelRight: '@',
                onSectionSort: '&',
                onSave: '&',
                revisionMode: "@",
                secNav: '=?',
                filterWith: '=?'
            },
            link: function (scope, element, attrs) {
                $window.onload = function () {
                    ///TODO 
                    //Call persistenceService to get All MasterData for all root fields
                    persistenceService.masterPersistenceService.getMasterDataForRootField();
                };
                if (scope.secNav == undefined) {
                    scope.secNav = true
                }
                scope.widgetPanelRightPos = scope.widgetPanelRight ? parseFloat(scope.widgetPanelRight) : 70;
                formWidgetCounter = formWidgetCounter + 1;
                scope.formWidgetId = 'form-widget-' + formWidgetCounter;
                scope.addRemoveSection = $translate.instant('AddRemoveSectionTxt');
                scope.visibleSectionTrackerItemsCount = 0;

                var currentSelectedSection = 0,
                    thumbnailsWrapHeightTemp = 0,
                    secnavIndex = 0,
                    thumbnailsWrapHeight = 0,
                    sectionItemClicked = false,
                    staticTopmargin = 64; // header height

                scope.enableFieldPreview = false;

                /*
                 *  Update visible section tracker items
                 */
                var updateVisibleSectionTrackerItemsCount = function () {
                    var count = 0,
                        len = scope.sectionTrackerItems.length;
                    for (var i = 0; i < len; i++) {
                        var tItem = scope.sectionTrackerItems[i];
                        if (tItem.visible && !tItem.hidden) {
                            count++;
                        }
                    }
                    scope.visibleSectionTrackerItemsCount = count;
                };

                var onSubHeaderHeight = attrs.$observe('subHeaderHeight', function (value) {
                    if (!isNaN(value)) {
                        ScrollTo.setScrollingTopMargin(parseInt(value));
                    }
                });


                scope.isFormWidgetToBeLoaded = false;

                var toutPromise = $timeout(function () {
                    scope.isFormWidgetToBeLoaded = true;
                    $timeout.cancel(toutPromise);
                    toutPromise = null;
                }, 500);



                scope.checkPresistence = false;
                scope.getPresistence = function (formConfig) {
                    if (formConfig && typeof formConfig.documentType != 'undefined') {
                        persistenceService.getUserData(formConfig.documentType);
                        persistenceService.sectionPersistence.getSectionsPersistence(formConfig, persistenceService.userData);
                    }
                }

                scope.modelDataWatcherEnabledOrNot = false;
                scope.initModelDataWatcher = function (newConfig) {
                    scope.modelDataWatcherEnabledOrNot = true;
                    scope.unbindModelDataWatcher = scope.$watch('modelData', function (newVal, oldVal) {

                        persistenceService.getModelData(newConfig, newVal, scope.unbindModelDataWatcher, scope.initChipsWatcher);
                    }, true);
                }
                var persistenceTimeout;
                scope.initChipsWatcher = function (arr) {

                    scope.$watchGroup(arr, function (newVal, oldVal) {
                        persistenceService.nPlusOne.getSelectedSection();
                        if (persistenceTimeout) {
                            $timeout.cancel(persistenceTimeout);
                            persistenceTimeout = undefined;
                        }
                        persistenceTimeout = $timeout(function () {
                            persistenceService.saveRecentDocument(newVal, scope.modelData);
                        }, 1000);

                    });
                }

                var unbindSectionsLoadedWathcer;
                function initSectionsLoadedWatcher() {
                    scope.SectionLoaderInitiated = true;
                    var arr = [];
                    for (var i = 0; i < scope.formConfig.sections.length; i++) {
                        arr.push('formConfig.sections[' + i + '].isContentLoaded');
                    }


                    unbindSectionsLoadedWathcer = scope.$watchGroup(arr, function (newVal, oldVal) {
                        if (newVal) {
                            var loadedCompletely = false;
                            for (var i = 0; i < newVal.length; i++) {
                                if (newVal[i] == false && !scope.formConfig.sections[i].isLazyLoadEnabled) {
                                    break;
                                }
                                if (i == newVal.length - 1 && (newVal[i] == true || typeof newVal[i] == 'undefined')) {
                                    scope.initSectionFocus();
                                    var seclectedSectionId = persistenceService.nPlusOne.getSelectedSection();
                                    if (seclectedSectionId != '') {
                                        var seclectedSectionIndex = -1;
                                        var sections = scope.formConfig.sections;
                                        for (var j = 0; j < sections.length; j++) {
                                            if (typeof sections[j].id != 'undefined' && sections[j].id == seclectedSectionId) {
                                                seclectedSectionIndex = j;
                                                sections[j].isActive = true;
                                                break;
                                            }
                                        }

                                        loadedCompletely = true;
                                        if (seclectedSectionIndex > -1) {
                                            sectionItemClicked = true;
                                            var mySection = scope.sectionTrackerItems[seclectedSectionIndex];
                                            if (mySection.visible) {
                                                scope.sectionTrackerItems[currentSelectedSection].isActive = false;
                                                mySection.isActive = true;
                                                currentSelectedSection = seclectedSectionIndex;


                                            }

                                            scope.isSectionsLoaded = false;
                                            ScrollTo.perform(element.find('#' + scope.formWidgetId + '-section-' + seclectedSectionIndex), angular.element('#' + scope.formWidgetId), function (e) {
                                                setTimeout(function () {
                                                    sectionItemClicked = false;
                                                    scope.isSectionsLoaded = true;
                                                }, 250);

                                                // scope.sectionsLoadedCompletely = true;
                                                unbindSectionsLoadedWathcer();
                                            });
                                        }
                                        else {
                                            scope.isSectionsLoaded = true;
                                        }
                                    }
                                    else {
                                        scope.isSectionsLoaded = true;
                                    }
                                }
                            }
                        }
                    });
                }
                var formWidgetTimeout,
                    fixedElemHeight = 0,
                    windowScrollTop = 0;
                scope.sectionTrackerItems = [];
                var onFormConfig = scope.$watch('formConfig', function (newConfig, oldConfig) {
                    if (newConfig) {
                        if (formWidgetTimeout) {
                            $timeout.cancel(formWidgetTimeout);
                            formWidgetTimeout = undefined;
                        }
                        if (scope.checkPresistence != true) {
                            scope.getPresistence(newConfig);
                            scope.formConfig.sections = newConfig.sections;
                            scope.checkPresistence = true;
                        }

                        if (scope.modelDataWatcherEnabledOrNot == false && newConfig != undefined) {
                            scope.initModelDataWatcher(newConfig);

                        }

                        formWidgetTimeout = $timeout(function () {
                            var sectionItems = [];
                            var optionalSections = [];
                            var optionalFieldsAndSections = [],
                                sectionLen = scope.formConfig.sections.length;

                            scope.enableFieldPreview = newConfig.enableFieldPreview;

                            for (var i = 0; i < sectionLen; i++) {
                                var tSection = scope.formConfig.sections[i];
                                //  if (firstTime || !angular.equals(newConfig.sections[i], (typeof oldConfig === 'undefined') ? null : oldConfig.sections[i])) {
                                tSection.isMandatory = formWidgetUtils.convertAndGetValue(tSection.isMandatory, scope, tSection);
                                if (angular.isDefined(tSection.isVisible)) {
                                    tSection.isVisible = formWidgetUtils.convertAndGetValue(tSection.isVisible, scope, tSection);
                                } else {
                                    tSection.isVisible = tSection.isMandatory;
                                }
                                if (!angular.isDefined(tSection.isHidden)) {
                                    //tSection.isHidden = scope.formConfig.sections[i].isHidden; //[TODO] not needed code
                                    tSection.isHidden = false;
                                } //else {
                                //tSection.isHidden = false;
                                //}
                                tSection.key = scope.formWidgetId + '-section-' + i;

                                if (scope.$eval(scope.showWidget) != false) {
                                    sectionItems.push({
                                        sectionKey: tSection.key,
                                        sectionId: tSection.sectionId,
                                        isOptionalSection: !tSection.isMandatory,
                                        label: tSection.label,
                                        sectionIndex: i,
                                        visible: tSection.isVisible,
                                        hidden: tSection.isHidden,
                                        isActive: i == currentSelectedSection,
                                        save: tSection.save,
                                        id: tSection.id || '',
                                        mandatoryFieldStatus: tSection.mandatoryFieldStatus,
                                        isReadOnly: tSection.isReadOnly
                                    });

                                    var sectionTLength = scope.sectionTrackerItems.length;
                                    if (sectionTLength) {

                                        //  For loop is needed in this case, because it is difficult to maintain the index of dragged/dropped item with ng-repeat.

                                        for (var ij = 0; ij < sectionTLength; ij++) {
                                            if (scope.sectionTrackerItems[ij].sectionIndex == tSection.key.split('section-')[1]) {
                                                scope.sectionTrackerItems[ij] = {
                                                    sectionKey: tSection.key,
                                                    sectionId: tSection.sectionId,
                                                    isOptionalSection: !tSection.isMandatory,
                                                    label: tSection.label,
                                                    sectionIndex: i,
                                                    visible: tSection.isVisible,
                                                    hidden: tSection.isHidden,
                                                    isActive: i == currentSelectedSection,
                                                    save: tSection.save,
                                                    mandatoryFieldStatus: tSection.mandatoryFieldStatus,
                                                    isReadOnly: tSection.isReadOnly
                                                };
                                            };
                                        }
                                    }
                                }

                                if (!tSection.isMandatory && scope.$eval(scope.showWidget) != false && !tSection.isHidden) {
                                    optionalSections.push({
                                        sectionKey: tSection.key,
                                        sectionId: tSection.sectionId,
                                        isOptionalSection: !tSection.isMandatory,
                                        label: tSection.label,
                                        searchLabel: $translate.instant(tSection.label),
                                        sectionIndex: i,
                                        visible: tSection.isVisible,
                                        hidden: scope.formConfig.sections[i].isHidden,
                                        isActive: false,
                                        isSection: true,
                                        save: tSection.save,
                                        mandatoryFieldStatus: tSection.mandatoryFieldStatus,
                                        isReadOnly: tSection.isReadOnly
                                    });
                                }

                                var sectionOptionalFields = [],
                                    rowsLength = tSection.rows.length;

                                for (var j = 0; j < rowsLength; j++) {
                                    var trowsData = tSection.rows[j],
                                        propertyLen = trowsData.properties.length;
                                    for (var k = 0; k < propertyLen; k++) {
                                        var tProperty = trowsData.properties[k];
                                        tProperty.isMandatory = formWidgetUtils.convertAndGetValue(tProperty.isMandatory, scope, tProperty);
                                        if (angular.isDefined(tProperty.isVisible)) {
                                            tProperty.isVisible = formWidgetUtils.convertAndGetValue(tProperty.isVisible, scope, tProperty);
                                        } else {
                                            tProperty.isVisible = tProperty.isMandatory;
                                        }
                                        if (angular.isDefined(tProperty.isHidden)) {
                                            tProperty.isHidden = formWidgetUtils.convertAndGetValue(tProperty.isHidden, scope, tProperty);
                                        }
                                        if (!tProperty.isMandatory && scope.$eval(scope.showWidget) != false && !tProperty.isHidden) {
                                            sectionOptionalFields.push({
                                                sectionKey: tSection.key,
                                                label: tProperty.label,
                                                sectionLabel: tSection.label,
                                                searchLabel: $translate.instant(tSection.label) + ' ' + $translate.instant(tProperty.label),
                                                sectionIndex: i,
                                                rowIndex: j,
                                                propertyIndex: k,
                                                visible: tProperty.isVisible,
                                                isSection: false
                                            });
                                        }
                                    }
                                }

                                tSection.optionalFields = sectionOptionalFields;
                                optionalFieldsAndSections = optionalFieldsAndSections.concat(tSection.optionalFields);
                                //}
                            }
                            //  firstTime = false;

                            if (scope.sectionTrackerItems.length != sectionItems.length) {
                                scope.sectionTrackerItems = sectionItems;
                            }

                            scope.optionalSections = optionalSections;

                            optionalFieldsAndSections = scope.optionalSections.concat(optionalFieldsAndSections);

                            scope.optionalFieldsAndSections = optionalFieldsAndSections;

                            updateVisibleSectionTrackerItemsCount();

                            scope.showWidget = scope.sectionTrackerItems.length > 1 || scope.optionalSections.length > 0;
                            if (!scope.SectionLoaderInitiated) {
                                initSectionsLoadedWatcher();
                            }
                        }, 250);
                    }
                }, true);
                /*
                *  If search is enabled 
                */
                //caching the selector.
                var searchHolder = angular.element('#' + scope.searchHolder);
                if (searchHolder.length > 0) {
                    searchHolder.html('<div ng-include="\'shared/directives/uiElements/smartFormWidget/searchTemplate.html\'"></div>');
                    $compile(searchHolder.contents())(scope);
                }

                function getOpenWidgetSection(a_id) {
                    var returnItem = false,
                        len = scope.formConfig.sections.length;
                    for (var indx = 0; indx < len; indx++) {
                        var tmpObj = scope.formConfig.sections[indx];
                        if (tmpObj.id === a_id) {
                            returnItem = tmpObj;
                            break;
                        }

                    }
                    return returnItem;
                }

                if (scope.$eval(scope.showWidget) != false) {
                    var draggableWidth = $(window).width() / 2,
                        restrictWidth = 0,
                        secnavcontainerExpandWidth = 350;
                    // To expand the sec nav
                    element.on('click.secnavchevroicon', '#secnavchevroicon', function () {
                        var $panelExp = $('#panelexpandor');
                        if (!$panelExp.data('ui-draggable')) {
                            $panelExp.draggable({
                                axis: 'x',
                                drag: function (e, ui) {
                                    restrictWidth = secnavcontainerExpandWidth - draggableWidth;
                                    ui.position.left = Math.min(secnavcontainerExpandWidth - 300, ui.position.left);
                                    ui.position.left = Math.max(restrictWidth, ui.position.left);
                                },
                                stop: function (e, ui) {
                                    secnavcontainerExpandWidth -= ui.position.left;
                                    $('.secnavcontainer-expand').width(secnavcontainerExpandWidth);
                                    $panelExp.css('left', 0);
                                }
                            });
                        }

                        var $this = $(this),
                            $secNavCont = $this.closest('.secnavcontainer');

                        if ($secNavCont.hasClass('secnavcontainer-animate')) {

                            $secNavCont.removeClass('secnavcontainer-animate secnavcontainer-expand').width(69);
                            $this.find('use').attr('xlink:href', '#icon_LeftChevron');
                            $('#sevnav-overlay').remove();
                            $('body').css('overflow', 'auto');
                            secnavHeightCal(element, secnavIndex, thumbnailsWrapHeight)
                        } else {

                            $('body').css('overflow', 'hidden').append('<div id="sevnav-overlay" class="sevnav-overlay"></div>');
                            $secNavCont.addClass('secnavcontainer-animate').width(secnavcontainerExpandWidth);
                            setTimeout(function () {
                                $secNavCont.addClass('secnavcontainer-expand');
                            }, 450);
                            $this.find('use').attr('xlink:href', '#icon_RightChevro');
                            var $secNavContList = $secNavCont.find('.thumbnails-wrap').children('li')
                            $secNavContList.each(function (k, v) {
                                v.style.height = "46px";
                            });
                            var $thumbnailswrap = $('#thumbnails-wrap');
                            $thumbnailswrap.animate({ scrollTop: (($($secNavContList[secnavIndex]).offset().top - $thumbnailswrap.offset().top) - 20) }, "slow");
                            $('#sevnav-overlay').off('click').on('click', function () {
                                $('#secnavchevroicon').trigger('click');
                            });
                        }

                    });

                    // Sec nav dot mouse enter functionality 
                    element.on('mouseenter.secnav', '.thumbnails-wrap li', function (e) {
                        var $this = $(this);
                        if ($this.closest('.secnavcontainer').hasClass('secnavcontainer-animate')) return;

                        $('.nearby').removeClass("nearby");
                        $this.prev("li").addClass("nearby");
                        $this.next("li").addClass("nearby");
                        secnavHeightCal(element, e, thumbnailsWrapHeight, 'mouse');
                    });

                    // SubHeader 
                    $('.extra-nav-wrap').resizeSensor({
                        onHeightChange: function (a) {
                            $('#subheaderwrapper').height(a.height);
                            onDocumentScroll();
                        }
                    });

                    // Sec nav dot mouse leave functionality 
                    element.on('mouseleave.secnav', '.thumbnails-wrap', function () {
                        if ($(this).closest('.secnavcontainer').hasClass('secnavcontainer-animate')) return;
                        element.find('li').removeClass("nearby");
                        secnavHeightCal(element, secnavIndex, thumbnailsWrapHeight, 'mouse');
                    });

                    // Sec nav dot mouse leave functionality 
                    element.on('mouseenter.secnavform', '.accountDetails', function () {
                        if ($(this).closest('.secnavcontainer').hasClass('secnavcontainer-animate')) return;
                        element.find('li').removeClass("nearby");
                        secnavHeightCal(element, secnavIndex, thumbnailsWrapHeight, 'mouse');
                    });

                    // For calculating the dot height of sec nav 
                    var secnavHeightCal = function (element, e, thumbnailsWrapHeight, type) {
                        var $secNavSelector = $('#thumbnails-wrap').children('li'),
                            selectedLiIndex = typeof e === 'number' ? e : $secNavSelector.index($(e.currentTarget).closest('li')),
                            prevSec = selectedLiIndex - 1,
                            afterSec = selectedLiIndex + 1,
                            prevSecDiff = prevSec,
                            afterSecDiff = 2,
                            secNavUlHeight;

                        secNavUlHeight = Math.floor((thumbnailsWrapHeight) / ($secNavSelector.length));

                        if (type != 'mouse') {
                            secnavIndex = selectedLiIndex;
                        }
                        if (element.find('.secnavcontainer').hasClass('secnavcontainer-animate')) {
                            return
                        };

                        $secNavSelector.each(function (k, v) {
                            v.style.height = secNavUlHeight + "px";

                            //if (k === selectedLiIndex) {
                            //    v.style.height = (secNavUlHeight + 16) + "px";

                            //} else if (k <= prevSec) {

                            //    v.style.height = prevSecDiff === 1 ? (5 + secNavUlHeight) + "px" : prevSecDiff === 0 ? (10 + secNavUlHeight) + "px" : v.style.height = secNavUlHeight + "px";

                            //    prevSecDiff--;
                            //} else {
                            //    if (afterSecDiff === 2) {
                            //        v.style.height = (5 + secNavUlHeight) + "px";
                            //    } else {
                            //        v.style.height = secNavUlHeight + "px";
                            //    }
                            //    afterSecDiff--;
                            //}
                        });
                    };

                    var filterTextTimeout,
                        onDocumentScroll = function () {

                            /**
                             ** Adding and Removing fixed class on subheader
                             ** Setting height of sec nav
                             ** Highlighting sec nav dots 
                            **/
                            if (filterTextTimeout) {
                                $timeout.cancel(filterTextTimeout);
                            }

                            try {
                                var $fixedElem = $('.extra-nav-wrap'),
                                    $subHeaderFixedContainer = $('#subheaderwrapper'),
                                    $formWidgetElem = $('.secondary-navigation'),
                                    formWidgetElemHeight = $formWidgetElem && $formWidgetElem.height(),
                                    $thumbnailsWrap = $('#thumbnails-wrap'),
                                    $secnavchevroicon = $('#secnavchevroicon'),
                                    formWidgetTop,
                                    formWidgetFixedTop = 1;
                                windowScrollTop = $(window).scrollTop();
                                fixedElemHeight = $fixedElem.outerHeight();
                                if (windowScrollTop > 63) {

                                    $formWidgetElem.css("top", fixedElemHeight);

                                    thumbnailsWrapHeight = $(window).height() - ((scope.optionalSections && scope.optionalSections.length ? 193 : 150) + (fixedElemHeight - 63));

                                    if (!$fixedElem.hasClass('extra-nav-wrap-fixed')) {
                                        $fixedElem.addClass('extra-nav-wrap-fixed');
                                        $subHeaderFixedContainer.addClass('extra-nav-wrap-fixed');
                                    }

                                } else {

                                    $formWidgetElem.css("top", "auto");
                                    if ($fixedElem.hasClass('extra-nav-wrap-fixed')) {
                                        $fixedElem.removeClass('extra-nav-wrap-fixed');
                                        $subHeaderFixedContainer.removeClass('extra-nav-wrap-fixed');
                                    }

                                    thumbnailsWrapHeight = $(window).height() - (((scope.optionalSections && scope.optionalSections.length ? 193 : 150) + (fixedElemHeight)) - windowScrollTop);
                                }
                                $formWidgetElem.height(thumbnailsWrapHeight + 24);
                                $secnavchevroicon.css("top", (thumbnailsWrapHeight / 2));

                                formWidgetTop = $formWidgetElem.length && $formWidgetElem.offset().top;
                                var trackerItemsLen = scope.sectionTrackerItems && scope.sectionTrackerItems.length;


                                if (!sectionItemClicked && trackerItemsLen) {

                                    var $cardParent = element.find('#' + scope.formWidgetId + '-sortable').find('.cardParent');
                                    for (var i = 0; i < trackerItemsLen; i++) {
                                        var $this = element.find('#' + scope.formWidgetId + '-section-' + i);

                                        // Position of section relative to window
                                        if ($this.children().length > 0) {
                                            var offsetLi = $this.offset().top - 10,
                                                offsetLiHeight = offsetLi + $this.height();
                                            //activeoffset = offsetLi - formWidgetTop;
                                            //get index of div in the parent document  
                                            if (formWidgetTop >= offsetLi && formWidgetTop <= offsetLiHeight || thumbnailsWrapHeightTemp != thumbnailsWrapHeight) {
                                                thumbnailsWrapHeightTemp = thumbnailsWrapHeight;
                                                newSelected = scope.sectionTrackerItems[i].sectionIndex;

                                                if (scope.sectionTrackerItems[newSelected].visible) {
                                                    filterTextTimeout = $timeout(function () {
                                                        scope.sectionTrackerItems[currentSelectedSection].isActive = false;
                                                        scope.sectionTrackerItems[newSelected].isActive = true;
                                                        currentSelectedSection = newSelected;
                                                        if (typeof scope.sectionTrackerItems[newSelected].id != 'undefined') {
                                                            persistenceService.nPlusOne.saveSelectedSection(scope.sectionTrackerItems[newSelected].id);
                                                        }
                                                        secnavHeightCal(element, $cardParent.index($this), thumbnailsWrapHeight);
                                                    });
                                                }
                                                $cardParent.children('.collapsible-container').removeClass('collapsible-focus');

                                                $this.children('.collapsible-container').addClass('collapsible-focus');



                                                if (formWidgetTop >= offsetLi && formWidgetTop <= offsetLiHeight) {
                                                    break;
                                                };
                                            }
                                        }
                                        $this = null;
                                    }
                                }


                            } catch (e) { console.log("onDocumentScroll") }
                        },
                        checkSubheaderHeight,
                        subheaderHeight,
                        newSelected = 0,
                        filterTextTimeout = null;

                    setTimeout(function () {
                        isCheckSecnav();
                    }, 100);

                    function isCheckSecnav() {
                        if ($('.secondary-navigation').length) {
                            onDocumentScroll();
                            $(document).on('scroll.secnav', onDocumentScroll);
                        } else {
                            setTimeout(function () {
                                isCheckSecnav();
                            }, 500);
                        }
                    }

                    setTimeout(function () {
                        isCheckWidget();
                    }, 1000);

                    function isCheckWidget() {
                        if ($('#' + scope.formWidgetId).length) {
                            scrollPosition.scrollWitgetsection(scope.sectionTrackerItems);
                        } else {
                            setTimeout(function () {
                                isCheckWidget();
                            }, 1000);
                        }
                    };
                    /*
                     * Section item click handler
                     */
                    var activeItem;
                    scope.onSectionItemClick = function (item, sectionNumber, e) {

                        var sectionTrackerLength = scope.sectionTrackerItems.length;
                        //  For loop is needed in this case, because it is difficult to maintain the index of dragged/dropped item.
                        for (var i = 0; i < sectionTrackerLength; i++) {
                            scope.sectionTrackerItems[i].isActive = false;
                        }
                        scope.sectionTrackerItems[sectionNumber].isActive = true;
                        currentSelectedSection = sectionNumber;
                        var Selectedsection = scope.formConfig.sections[item.sectionIndex];
                        Selectedsection.isActive = true;
                        if (typeof Selectedsection.id != 'undefined') {
                            persistenceService.nPlusOne.saveSelectedSection(Selectedsection.id);
                        }
                        scope.formConfig.sections[item.sectionIndex].isActive = true;
                        sectionItemClicked = true;
                        activeItem = e;
                        ScrollTo.setScrollingTopMargin(staticTopmargin);
                        ScrollTo.perform(element.find('#' + scope.formWidgetId + '-section-' + item.sectionIndex), angular.element('#' + scope.formWidgetId + '-sortable'), function (e) {

                            setTimeout(function () {
                                secnavHeightCal(element, activeItem, thumbnailsWrapHeight);
                                sectionItemClicked = false;
                            }, 300);
                        });
                    };


                    /*
                     * On optional section item click handler
                     */
                    scope.onOptionalSectionItemClick = function (isLabelClicked, item) {
                        if (isLabelClicked && item.isVisible) {
                            return;
                        }

                        scope.formConfig.sections[item.sectionIndex].isVisible = !scope.formConfig.sections[item.sectionIndex].isVisible;
                        //  Toggle section tracker item visibility
                        var trackerTLen = scope.sectionTrackerItems.length;
                        for (var i = 0; i < trackerTLen; i++) {
                            if (scope.sectionTrackerItems[i].label === item.label) {
                                scope.sectionTrackerItems[i].visible = !item.visible;
                                break;
                            }
                        }

                        /*
                         *  scope.isSequential is set to 'true', form-widget-section would be added 
                         *  where it is positioned in the JSON structure else 
                         *  form-widget-section would be added at the end of row
                         */
                        if (!scope.$eval(scope.isSequential) && scope.formConfig.sections[item.sectionIndex].isVisible) {
                            //  Re-arrange sections order
                            var tmpSection = scope.formConfig.sections[item.sectionIndex];
                            scope.formConfig.sections.splice(item.sectionIndex, 1);
                            scope.formConfig.sections.push(tmpSection);

                            //  Re-arrange sections tracker items order
                            for (var i = 0; i < scope.sectionTrackerItems.length; i++) {
                                if (scope.sectionTrackerItems[i].label === item.label) {
                                    var tmpSection = scope.sectionTrackerItems[i];
                                    scope.sectionTrackerItems.splice(i, 1);
                                    scope.sectionTrackerItems.push(tmpSection);
                                    break;
                                }
                            }

                            //  Re-arrange sections tracker items section index
                            for (var i = 0; i < scope.formConfig.sections.length; i++) {
                                for (var j = 0; j < scope.sectionTrackerItems.length; j++) {
                                    if (scope.formConfig.sections[i].label == scope.sectionTrackerItems[j].label) {
                                        scope.sectionTrackerItems[j].sectionIndex = i;
                                    }
                                }
                            }

                            //  Re-arrange sections optional fields section index
                            for (var i = 0; i < scope.formConfig.sections.length; i++) {
                                for (var j = 0; j < scope.optionalSections.length; j++) {
                                    if (scope.formConfig.sections[i].label == scope.optionalSections[j].label) {
                                        scope.optionalSections[j].sectionIndex = i;
                                    }
                                }
                            }
                        }
                        var itemVisible = !item.visible;
                        var tempTOut = setTimeout(function () {
                            if (itemVisible) {

                                ScrollTo.setScrollingTopMargin(staticTopmargin);
                                ScrollTo.perform(element.find('#' + scope.formWidgetId + '-section-' + item.sectionIndex), angular.element('#' + scope.formWidgetId + '-sortable'), function () {
                                    if ($('.secnavcontainer').hasClass('secnavcontainer-animate')) {
                                        $('.secnavcontainer').find('.thumbnails-wrap').children('li').each(function (k, v) {
                                            v.style.height = "46px";
                                        });
                                    } else {
                                        secnavHeightCal(element, secnavIndex, thumbnailsWrapHeight);
                                    }
                                });
                            }
                            clearTimeout(tempTOut);
                        }, 200);

                        updateVisibleSectionTrackerItemsCount();
                    };


                    scope.onOptionalFieldClick = function (isLabelClicked, item) {
                        if (!item.visible) {
                            ScrollTo.setScrollingTopMargin(staticTopmargin);
                            ScrollTo.perform(element.find('#' + scope.formWidgetId + '-section-' + item.sectionIndex), angular.element('#' + scope.formWidgetId));
                        }
                        scope.$broadcast('optionalFieldClick', {
                            isLabelClicked: isLabelClicked, item: item
                        });
                    };


                    /*
                     * Widget panel
                     */
                    scope.showWidgetPanel = false;

                    scope.toggleWidgetPanel = function () {
                        scope.showWidgetPanel = !scope.showWidgetPanel;
                    };


                    /*
                     *  Callback function when section order gets changed
                     */

                    scope.onSort = function (e) {
                        scope.sectionTrackerItems[currentSelectedSection].isActive = false;

                        var sectionTrackerItems = angular.copy(scope.sectionTrackerItems),
                            item = sectionTrackerItems.splice(e.startIndex, 1);
                        sectionTrackerItems.splice(e.endIndex, 0, item[0]);

                        var formConfigAfterSort = [],
                            trackerSortLen = scope.sectionTrackerItems.length;
                        var sectionsList = [];
                        for (var i = 0; i < trackerSortLen; i++) {
                            var section = scope.formConfig.sections[scope.sectionTrackerItems[i].sectionIndex];
                            formConfigAfterSort.push(section);
                            if (typeof section.id != 'undefined') {
                                sectionsList.push(section.id);
                            }
                        }
                        if (sectionsList.length > 0 && typeof scope.formConfig.documentType != 'undefined') {
                            persistenceService.updateUserData('sections', sectionsList);
                            persistenceService.saveUserData(scope.formConfig.documentType);
                        }
                        scope.onSectionSort({
                            $event: {
                                formConfig: formConfigAfterSort
                            }
                        });

                        if (element.find('.secnavcontainer').hasClass('secnavcontainer-animate')) {
                            var $sectionCont = $('#form-widget-1-sortable'),
                                sectionList = $sectionCont.children('li'),
                                sectionListitem = sectionList.splice(e.startIndex, 1);
                            sectionList.splice(e.endIndex, 0, sectionListitem[0]);
                            $sectionCont.append(sectionList);
                        } else {
                            var $thumbnailsCont = $('#thumbnails-wrap'),
                                thumbnailsList = $thumbnailsCont.children('li'),
                                thumbnailsListitem = thumbnailsList.splice(e.startIndex, 1),
                                thumbNodes = [],
                                count = 0;
                            thumbnailsList.splice(e.endIndex, 0, thumbnailsListitem[0]);

                            $.each($thumbnailsCont.get(0).childNodes, function (k, v) {
                                if ($(v).is('li')) {
                                    thumbNodes[k] = thumbnailsList[count];
                                    count++;
                                } else {
                                    thumbNodes[k] = v;
                                }
                            });
                            $thumbnailsCont.append(thumbNodes);
                        }
                        setTimeout(function () {
                            onDocumentScroll();
                        }, 10);
                    };


                    /*
                     *  Make section active in section tracker
                     */
                    var previousClickedSection = [];
                    scope.initSectionFocus = function () {
                        scope.$on('sectionFocus', function (event, data) {
                            var openedSec = getOpenWidgetSection(data.id);
                            var sectionNumber = openedSec.sectionIndex;
                            if (openedSec) {
                                scope.onSectionItemClick(openedSec, sectionNumber);
                            }
                        });
                    }


                    scope.onSectionClick = function (section) {

                        //scrollPosition.set(0, location.hash, { key: section.key.split('section-')[1], active: true });

                        if (attrs.onSave) {
                            if (section.hasOwnProperty('save') && section != previousClickedSection[(previousClickedSection.length - 1)]) {
                                previousClickedSection.push(section);
                            }

                            if (previousClickedSection.length > 2) {
                                previousClickedSection.shift();
                            }
                        }
                        if (scope.sectionTrackerItems[currentSelectedSection].label === section.label) {
                            return;
                        }
                        var tlenTracker = scope.sectionTrackerItems.length;
                        for (var i = 0; i < tlenTracker; i++) {
                            if (scope.sectionTrackerItems[i].label === section.label) {
                                scope.sectionTrackerItems[currentSelectedSection].isActive = false;
                                scope.sectionTrackerItems[i].isActive = true;
                                currentSelectedSection = i;
                                if (typeof scope.sectionTrackerItems[i].id != 'undefined') {
                                    persistenceService.nPlusOne.saveSelectedSection(scope.sectionTrackerItems[i].id);
                                }
                                break;
                            }
                        }
                    };


                    /*
                     *  Callback function when user expands or collapses the section
                     */
                    scope.onSectionHeaderClick = function (section) {
                        if (angular.isDefined(section.onHeaderClick)) {
                            eval('scope.' + formWidgetUtils.generateFunctionWithParams(section.onHeaderClick, '$parent', true));
                        }
                        if (!section.isContentLoaded) {
                            section.isContentLoaded = true;
                        }

                        var $itemSelected = element.find('#' + section.key);

                        if (!$itemSelected.find('.collapsible-body').hasClass('displayBlock')) {

                            var displacementItem = $itemSelected.offset().top - angular.element('#' + scope.formWidgetId + '-sortable').offset().top;

                            displacementItem = displacementItem + staticTopmargin;
                            setTimeout(function () {
                                angular.element('body,html').animate({
                                    scrollTop: displacementItem
                                }, "medium");
                            }, 200)
                        }
                    };


                    // Auto Save Callback
                    if (attrs.onSave) {
                        var onDocumentClick = function (e) {
                            if (!previousClickedSection.length) {
                                return;
                            }
                            var prevKeyLen = $(e.target).closest('#' + previousClickedSection[0].key).length;
                            if ((!prevKeyLen) || (prevKeyLen && $(e.target).closest('.savable').length)) {
                                if (!$(e.target).closest('.modal').length && !$(e.target).closest('.noSaveItem').length && !$(e.target).closest('.lean-overlay').length) {
                                    scope.onSave({
                                        data: scope.modelData, prevObj: previousClickedSection[0]
                                    });
                                    previousClickedSection.shift();
                                }
                                //scope.$digest();
                            }
                        }

                        $(document).off('click.saveSection').on('click.saveSection', onDocumentClick);

                        // Needed due to selectbox plugin using stopPropagation
                        $(document).off('change.saveSelect').on('change.saveSelect', '.select-wrapper select', function (e) {
                            //var ind = $('#' + scope.formWidgetId + '-sortable').children('li').index($(this).closest('li')),
                            //    sectionDatastore = scope.formConfig.sections[ind];


                            var ind = $(this).closest('.card.cardParent').attr('id').split('section-'),
                                sectionDatastore = scope.formConfig.sections[ind[1]];
                            if (sectionDatastore.hasOwnProperty('save') && sectionDatastore != previousClickedSection[(previousClickedSection.length - 1)]) {
                                previousClickedSection.push(sectionDatastore);
                            }

                            if (previousClickedSection.length > 2) {
                                previousClickedSection.shift();
                            }

                            onDocumentClick(e);
                        });
                    };

                    /*
                     *  Remove all listeners on scope destroy
                     */
                    scope.$on('$destroy', function () {
                        $(document).off('scroll.secnav click.saveSection change.saveSelect');
                        $('#sevnav-overlay') && $('#sevnav-overlay').remove();

                        element.off('mouseenter.secnav mouseleave.secnav click.secnavchevroicon mouseenter.secnavform');
                        onSubHeaderHeight();
                        onFormConfig();

                    });


                    scope.iconClasses = APPCONSTANTS.formWidgetItemClasses;
                };
            },
            templateUrl: 'shared/directives/uiElements/smartFormWidget/smartFormWidgetTemplate.html'
        };
    }]);


    angular.module('SMART2').directive('smartSvgIcon', [function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.html('<svg><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#' + attrs.smartSvgIcon + '"></use></svg>');
            }
        };
    }]);


    /*
     *  Text highlighting filter
     */
    angular.module('SMART2').filter('highlight', ['$sce', function ($sce) {
        return function (text, phrase) {
            if (phrase) {
                text = text.replace(new RegExp('(' + phrase + ')', 'gi'), '<span style="background: yellow">$1</span>');
            }
            return $sce.trustAsHtml(text);
        }
    }]);
})();

(function () {
    'use strict';
    angular.module('SMART2').directive('smartGrid', ['$filter', function ($filter) {
        return {
            restrict: 'AE',
            scope: {
                gridConfig: '=config'
            },
            controller: function ($scope) {
                /*
                 * Current formatter
                 */
                $scope.currencyFormatter = function (amountarg, symbol, zeroprecision, defaultCurrency) {
                    var amount = amountarg;
                    if (zeroprecision)
                        amount = Number(amountarg).toFixed(0);

                    var formattedAmount;
                    if (amount >= 1000000 || amount <= -1000000) {
                        shortamount = amount / 1000000;
                        formattedAmount = $scope.currencyFormatter(shortamount, symbol, false, defaultCurrency);
                        //if (zeroprecision)
                        //formattedAmount = formattedAmount.substring(0, formattedAmount.length - 3);
                        formattedAmount = formattedAmount + " MM";
                    }
                    else {
                        formattedAmount = $filter('currency')(amount);
                        if (defaultCurrency != undefined) symbol = defaultCurrency;
                        if (amount < 0) {
                            if (symbol !== undefined)
                                formattedAmount = $filter('currency')(amount, symbol).replace("(", "-").replace(")", "");
                            else
                                formattedAmount = $filter('currency')(amount).replace("(", "-").replace(")", "");
                        }
                        else if (symbol !== undefined) {
                            formattedAmount = $filter('currency')(amount, symbol);
                        }
                        if (zeroprecision) {
                            if (parseInt(formattedAmount.substring(formattedAmount.length - 2, formattedAmount.length)) == 0) {
                                formattedAmount = formattedAmount.substring(0, formattedAmount.length - 3);
                            }
                        }
                    }
                    return formattedAmount.toString();
                };

                /*
                 * Number formatter
                 */
                $scope.numberFormatter = function (amountarg, zeroprecision) {
                    var formattedAmount = amountarg;
                    if (zeroprecision)
                        formattedAmount = Number(amountarg).toFixed(0);
                    if (formattedAmount >= 1000000 || formattedAmount <= -1000000) {
                        var shortamount = formattedAmount / 1000000;
                        if (zeroprecision) {
                            formattedAmount = Number(shortamount).toFixed(0);
                        } else {
                            formattedAmount = shortamount;
                        }
                        return $filter('number')(formattedAmount) + " MM";
                    }
                    else {
                        return $filter('number')(formattedAmount);
                    }
                };
            },
            link: function (scope, element, attr) {
                var headerTemplate, rowTemplate, headerData, rowData, cellTemplate, cellRenderer, headerCellRenderer, onClick, rowHeight, cellStyle;

                scope.$watch('gridConfig', function (n, o) {
                    if (n) {
                        scope.config = scope.gridConfig;

                        if (scope.config && scope.config.headerTemplate) {
                            headerTemplate = scope.config.headerTemplate;
                        }

                        if (scope.config && scope.config.rowTemplate) {
                            rowTemplate = scope.config.rowTemplate;
                        }

                        if (scope.config && scope.config.headerData) {
                            headerData = scope.config.headerData;
                        }

                        if (scope.config && scope.config.rowData) {
                            rowData = scope.config.rowData;
                        }

                        if (scope.config && scope.config.dimension && scope.config.dimension.height) {
                            scope.gridHeight = scope.config.dimension.height;
                        }
                        else {
                            scope.gridHeight = element.parent().outerHeight(true);
                        }

                        scope.gridHeight = scope.gridHeight - 1; // 1 is the border

                        if (scope.config && scope.config.cellRenderer) {
                            cellRenderer = scope.config.cellRenderer;
                        }

                        if (scope.config && scope.config.headerCellRenderer) {
                            headerCellRenderer = scope.config.headerCellRenderer;
                        }

                        if (scope.config && scope.config.onClick) {
                            onClick = scope.config.onClick;
                        }

                        if (scope.config && scope.config.cellTemplate) {
                            cellTemplate = scope.config.cellTemplate;
                        }

                        if (scope.config && scope.config.rowHeight) {
                            rowHeight = scope.config.rowHeight;
                        }
                        else {
                            rowHeight = 40;
                        }

                        if (scope.config && scope.config.cellStyle) {
                            cellStyle = scope.config.cellStyle;
                        }

                        var columnDefs = [];
                        var cellWidth = element.parent().outerWidth() / headerData.length;

                        for (var i = 0; i < headerData.length; i++) {
                            columnDefs.push({
                                displayName: headerData[i].title,
                                field: headerData[i].datamappingkey,
                                suppressSorting: headerData[i].sortable ? false : true,
                                formatterType: headerData[i].formatterType,
                                clickable: headerData[i].clickable ? true : false,
                                align: headerData[i].align,
                                width: headerData[i].width != undefined ? headerData[i].width : cellWidth,
                                cellStyle: headerData[i].cellStyle != undefined ? headerData[i].cellStyle : undefined
                            });

                            //  Set default currency if the formatter type is currency
                            if (headerData[i].formatterType == 'currency') {
                                columnDefs[columnDefs.length - 1].defaultCurrency = headerData[i].defaultCurrency;
                            }

                            if (cellTemplate != undefined) {
                                columnDefs[columnDefs.length - 1].template = cellTemplate;
                            }
                            else {
                                columnDefs[columnDefs.length - 1].cellRenderer = cellRenderer ? cellRenderer : function (e) {
                                    var columnValue, titleValue;
                                    switch (e.colDef.formatterType) {
                                        case 'link':
                                            columnValue = titleValue = '<a>' + e.value + '</a>';
                                            break;

                                        case 'number':
                                            if (e.colDef.clickable) {
                                                columnValue = titleValue = '<a>' + e.value + '</a>';
                                            }
                                            break;

                                        case 'currency':
                                            columnValue = titleValue = scope.currencyFormatter(e.value, undefined, true, e.colDef.defaultCurrency);
                                            if (e.colDef.clickable) {
                                                columnValue = '<a>' + columnValue + '</a>';
                                            }
                                            break;

                                        default:
                                            columnValue = e.value === 0 || e.value === '0' ? '0' : (e.value == 'null' || e.value == null || e.value == '' ? '<span style="color: transparent;">-</span>' : e.value);
                                            titleValue = e.value;
                                            if (e.colDef.clickable) {
                                                columnValue = '<a>' + columnValue + '</a>';
                                            }
                                            break;
                                    }
                                    if (e.value == 'null' || e.value == null || e.value == '') {
                                        return '<span style="width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; float: ' + e.colDef.align + '; text-align: ' + e.colDef.align + ';">' + columnValue + '</span>';
                                    }
                                    else {
                                        return '<span style="width: 100%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; float: ' + e.colDef.align + '; text-align: ' + e.colDef.align + ';" title="' + titleValue + '">' + columnValue + '</span>';
                                    }
                                    //'<a style="white-space: normal;">' + columnValue + '</a>' - To avoid text ellipsis
                                };
                            }
                        }

                        var tmpRowData = [];
                        for (var i = 0; i < rowData.length; i++) {
                            tmpRowData[i] = {};
                            for (var j = 0; j < columnDefs.length; j++) {
                                tmpRowData[i][columnDefs[j].field] = rowData[i][columnDefs[j].field]; // rowData[i][columnDefs[j].field] == 'null' || rowData[i][columnDefs[j].field] == null  || rowData[i][columnDefs[j].field] == '' ? '<span style="color: transparent;">-</span>' : rowData[i][columnDefs[j].field];
                            }
                        }

                        if (scope.angularGridConfig) {
                            scope.angularGridConfig.columnDefs = columnDefs;
                            scope.angularGridConfig.rowData = tmpRowData;
                            scope.angularGridConfig.api.onNewRows();
                        }
                        else {
                            scope.angularGridConfig = {
                                columnDefs: columnDefs,
                                rowData: tmpRowData,
                                enableSorting: true,
                                angularCompileRows: true,
                                virtualPaging: true,
                                enableColResize: true,
                                angularCompileHeaders: scope.config && scope.config.angularCompileHeaders,
                                headerCellRenderer: headerCellRenderer ? headerCellRenderer : function (e) {
                                    return '<span style="width: 80%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; float: ' + e.colDef.align + '; text-align: ' + e.colDef.align + ';">' + e.colDef.displayName + '</span>';
                                },
                                cellClicked: onClick ? function (e) {
                                    onClick({ dataMappingKey: e.colDef.field, value: e.value, rowIndex: e.rowIndex, rowData: rowData[e.rowIndex], clickable: e.colDef.clickable });
                                } : undefined,
                                rowHeight: rowHeight == undefined ? undefined : rowHeight
                            };
                        }
                    }
                });
            },
            templateUrl: 'shared/directives/uiElements/smartGrid/smartGrid.html'
        };
    }]);
})();
/*
 * Inject required CSS
 */
//var angularGridCSS = document.createElement("link");
//angularGridCSS.setAttribute("rel", "stylesheet");
//angularGridCSS.setAttribute("type", "text/css");
//angularGridCSS.setAttribute("href", $('#blobURL').val()+'shared/libraries/angularGrid/angularGrid.css');
//document.getElementsByTagName("head")[0].appendChild(angularGridCSS);

//var angularGridThemeCSS = document.createElement("link");
//angularGridThemeCSS.setAttribute("rel", "stylesheet");
//angularGridThemeCSS.setAttribute("type", "text/css");
//angularGridThemeCSS.setAttribute("href", $('#blobURL').val()+'shared/libraries/angularGrid/theme-fresh.css');
//document.getElementsByTagName("head")[0].appendChild(angularGridThemeCSS);

angular.module('SMART2').directive('smartInfotip', ['$window', function ($window) {
    "use strict";
    var _lastOpenInfotip = {},
    hideLastInfotip = function (hObj) {
        if (_lastOpenInfotip.target && _lastOpenInfotip.target.hasClass('isInfotipVisible')) {
            _lastOpenInfotip.target.removeClass('isInfotipVisible');
            _lastOpenInfotip.infotip.find(".infotip-popover").addClass('hide-popover-element');
            _lastOpenInfotip.infotip.find(".infotip-popover-triangle").addClass('hide-popover-element');
            _lastOpenInfotip._ev.value = true;
        }
    };
    $(document).click(function (evt) {
        hideLastInfotip();
     });
    return {
        restrict: 'A',
        transclude: true,
        scope:true,
        link: function (scope, element, attrs) {
            //the root div of the popup template
            var popover_container = element.find('.infotip-popover-container'),
                popover_container_parent = popover_container.parent(),
                popover = element.find('.infotip-popover'), //the popover element
                triangle = element.find('.infotip-popover-triangle'), //the small triangle attached with the popover
                triangle_height, //vertical height of the triangle
                triangle_diagonal, //base of the triangle
                triangle_div_side = 15, //side of the triangle
                triangle_rect_div_side = 30, //the div which has been rotated to make a triangle using the after pseudo class
                infotipElement = element,
                getPosition = popover_container_parent.css('position') === "" || popover_container_parent.css('position') === "static" ? "relative" : popover_container_parent.css('position'),
                $win = angular.element($window),
                bindOn = !attrs.bindOn ? 'click mouseover interesected' : attrs.bindOn;

            popover_container_parent.css({ 'position': getPosition, 'z-index': '1', 'display': 'inline-block' });
            //popover_container_parent.css('position', getPosition);
            //popover_container_parent.css('display', 'inline-block');
            triangle_height = Math.sqrt(triangle_div_side * triangle_div_side / 2);
            triangle_diagonal = Math.sqrt(triangle_div_side * triangle_div_side * 2);
            var mode = attrs.mode === '' || attrs.mode === undefined ? 'mouseover' : attrs.mode;
            var closeOnClick = attrs.closeOnClick === undefined ?
                                    (mode == 'click' ? true : false) :
                                    (attrs.closeOnClick === 'true');

            var closeOnMouseleave = attrs.closeOnMouseleave === undefined ?
                                        (mode == 'mouseover' ? true : false) :
                                        (attrs.closeOnMouseleave === 'true');

            var hideOnDocHover = { value: attrs.hideOnDocHover == 'true' };
            //return the path of the popover template
            scope.getContentPopover = attrs.templateUrl;

            scope.isTemplateUrl = attrs.templateUrl ? true : false;

            //depending upon the position specified, attached the appropriate class to the popover 
            var getTriangleClass = function () {
                return 'infotip-popover-triangle-' + attrs.position;
            }

            var hideTooltip = function () {
                setTimeout(function () {
                    if (!onHoverablearea() && hideOnDocHover.value) {
                        popover.addClass('hide-popover-element');
                        triangle.addClass('hide-popover-element');
                    }
                }, 0);
            };
            var onHoverablearea = function () {
                return (popover.is(':hover') || infotipElement.is(':hover') || triangle.is(':hover'));
            };

            scope.triangleClass = getTriangleClass();
            if (closeOnMouseleave) {
                if (hideOnDocHover.value) {
                    infotipElement.bind('mouseleave blur', function () {
                         hideTooltip();
                    });
                    popover.bind('mouseleave blur', function () {
                        hideTooltip();
                    });
                    triangle.bind('mouseleave blur', function () {
                        hideTooltip();
                    });
                }
                else {
                    infotipElement.bind('mouseleave blur ', function () {
                        popover.addClass('hide-popover-element');
                        triangle.addClass('hide-popover-element');
                    });
                }
            }

            if (mode != 'click' && closeOnClick) {
                infotipElement.bind('click', function () {
                    popover.addClass('hide-popover-element');
                    triangle.addClass('hide-popover-element');
                });
            }

            popover.on('click', function (evt) {
                evt.stopPropagation();
            });

            //Hide infotip on scroll
            $win.bind('scroll', function (e) {
                popover.addClass('hide-popover-element');
                triangle.addClass('hide-popover-element');
            });

            //listen for click on the directive element
            infotipElement.bind(bindOn, function (evt) {
                evt.stopImmediatePropagation();
               var _this = $(this),
                parent_height = _this.outerHeight(),
                parent_width, popover_height, popover_width,
                elementOffsetTop = element.offset().top + 23,
                elementOffsetLeft = element.offset().left,
                leftPos;

                if (evt.type == "click") {
                    hideLastInfotip();
                    hideOnDocHover.value = false;
                    _this.addClass('isInfotipVisible');
                    _lastOpenInfotip.target = _this;
                    _lastOpenInfotip.infotip = popover_container;
                    _lastOpenInfotip._ev = hideOnDocHover;
                };

                if (mode == "canvas") {
                    elementOffsetTop = 100;
                    elementOffsetLeft = 100;
                    parent_height = 100;
                }

                //move the popover container to the bottom of the directive element
                popover_container.css("top", parent_height)//.style.top = parent_height + 'px';
                parent_width = _this.outerWidth();

                //'mouseover' mode
                if (popover.hasClass('hide-popover-element') && attrs.message != '') {
                    popover.removeClass('hide-popover-element');
                    triangle.removeClass('hide-popover-element');
                }

                //if the template is supplied instead of templateUrl, set the popover innerHTML to the string passed in the 'template' attribute
                if (attrs.message) {
                    var templateElement = _this.find('.infotip-popover-template');
                    templateElement.html(attrs.message);
                }

                var setDynamicInfotipPosition = function (position) {
                    _this.find('.' + scope.triangleClass).removeClass(scope.triangleClass);
                    triangle.removeClass(scope.triangleClass);
                    attrs.position = position;
                    scope.triangleClass = getTriangleClass();
                    triangle.addClass(scope.triangleClass);
                }

                attrs.position = attrs.position === '' || attrs.position === undefined ? 'top' : attrs.position;

                //function to set dynamic position for popover and triangle
                var getDyanamicPositions = function () {
                    var popoverOffset = popover.offset(),
                                        bodyScrolled = $("body").scrollTop() || $("html").scrollTop();

                    if (popoverOffset.left + popover.width() > $(window).width()) {
                        leftPos = true;
                        setDynamicInfotipPosition('left');
                    } else if (popoverOffset.left < (0 || 10)) {
                        setDynamicInfotipPosition('right');
                    } else if (popover[0].getBoundingClientRect().top < 0) {
                        setDynamicInfotipPosition('bottom');
                    } else if ((popover[0].getBoundingClientRect().top + popover.height()) >= $(window).height()) {
                        setDynamicInfotipPosition('top');
                    } 
                };

                //check position and calculate position for appending popover and triangle
                var setInfotipPosition = function () {
                    popover_height = popover.outerHeight();
                    popover_width = popover.outerWidth();

                    if (mode == "canvas") {
                        popover_height = 100;
                        popover_width = 100;
                        if (infotipElement.attr("interesect")) {
                            var intersect = JSON.parse(infotipElement.attr("interesect")),
                                templateElement;

                            popover.css({
                                top: (intersect.y - triangle_height - 100),
                                left: (intersect.x)
                            });
                            triangle.css({
                                top: (intersect.y - triangle_height - 100),
                                left: (intersect.x - triangle_rect_div_side)
                            });

                        }
                        templateElement = _this.find('.infotip-popover-template');
                        templateElement.html(infotipElement.attr("message"));
                        return;
                    }

                    switch (attrs.position) {
                        case 'top':
                            popover.css({
                                top: (-parent_height - popover_height - triangle_height),
                                left: ((parent_width - popover_width) / 2)
                            });
                            triangle.css({
                                top: (-parent_height - triangle_height),
                                left: ((parent_width - triangle_rect_div_side) / 2)
                            });
                            break;

                        case 'bottom':
                            popover.css({
                                top: triangle_height,
                                left: ((parent_width - popover_width) / 2)
                            });
                            triangle.css({
                                top: -(triangle_rect_div_side - triangle_height),
                                left: ((parent_width - triangle_rect_div_side) / 2)
                            });
                            break;

                        case 'right':
                            popover.css({
                                top: ((parent_height - popover_height) / 2 - parent_height),
                                left: parent_width + triangle_height
                            });
                            triangle.css({
                                top: ((parent_height - triangle_rect_div_side) / 2 - parent_height),
                                left: (parent_width - (triangle_rect_div_side - triangle_height))
                            });
                            break;

                        case 'left':
                            if (leftPos) {
                                popover.css({ left: -(popover_width + triangle_div_side) })
                            }
                            popover.css({
                                top: ((parent_height - popover_height) / 2 - parent_height),
                                right: triangle_height
                            });
                            triangle.css({
                                top: ((parent_height - triangle_rect_div_side) / 2 - parent_height),
                                left: -triangle_height
                            });
                            if (attrs.customStyle == 'true') {
                                popover.css({ left: -(popover_width + triangle_div_side - 5) });
                                triangle.css({
                                    top: ((parent_height - triangle_rect_div_side) / 2 - parent_height + 5),
                                });
                            }
                            break;
                    }
                }

                //Append infotip to body only when isFixed = 'true'
                var appendInfotipToBody = function () {
                    if (attrs.isFixed == 'true') {
                        if (!popover_container.data('appended')) {
                            angular.element('body').append(popover_container.data('appended', true));
                        }
                        if (attrs.customStyle == 'true') {
                            popover_container.addClass('fullWidthInfo');
                        }
                        if (attrs.showFullTip == 'true') {
                            popover_container.addClass('showFullTip');
                        }
                        var templateElementBody = popover_container.find('.infotip-popover-template');
                        templateElementBody.html(attrs.message);
                        popover_container.css({ 'top': elementOffsetTop + 'px', 'left': elementOffsetLeft + 'px' });
                    }
                }

                setInfotipPosition();
                appendInfotipToBody();
                getDyanamicPositions();
                setInfotipPosition();
                appendInfotipToBody();
            });
        },
        templateUrl: 'shared/directives/uiElements/smartInfotip/smartInfotipTemplate.html'
    }
}]);
(function () {
    'use strict';
    angular.module('SMART2').directive('smartList', ['$parse', '$window', 'commonUtilities', function ($parse, $window, commonUtilities) {
        return {
            restrict: 'AE',
            replace: false,
            scope: true,
            link: function (scope, element, attrs) {
                scope.styleClass = 'collection';
                scope.itemClass = 'collection-item';
                // evaluating callback for list
                var clickCallback = $parse(attrs.clickCallback);

                attrs.$observe('selectiveDisplayConfig', function (displayConfig) {
                    if (displayConfig) {
                        scope.listDisplayConfig = scope.$eval(displayConfig);
                    } else {
                        scope.listDisplayConfig = { "showIcon": true, "showAction": false, "importantAttribLimit": 5 };
                    }

                });

                //Loacal list Click handler
                scope.listClickHandler = function (item) {
                    if (angular.isFunction(clickCallback)) {
                        clickCallback(scope, { e: item });
                    }
                };

                attrs.$observe("height", function (value) {
                    if (value) {
                        scope.listHeight = value;
                    }
                });

                attrs.$observe('model', function (value) {
                    if (value) {
                        scope.dataModel = scope.$eval(value);
                    }
                });


                attrs.$observe('styleClass', function (value) {
                    scope.styleClass = value;
                });

                attrs.$observe('itemClass', function (value) {
                    scope.itemClass = value;
                });

                attrs.$observe('template', function (value) {
                    scope.template = value;
                });
                var lazyLoadingCallback = $parse(attrs.lazyLoadCallback);
                var backToTopCallback = $parse(attrs.backToTopCallback);
                var scrolledCallback = $parse(attrs.scrollInProgress);

                scope.scrollEndCallback = function () {
                    if (angular.isFunction(lazyLoadingCallback)) {
                        lazyLoadingCallback(scope, { e: '' });
                    };
                };

                scope.scrollToTopCallback = function () {
                    if (angular.isFunction(backToTopCallback)) {
                        backToTopCallback(scope, { e: '' });
                    };
                };

                scope.scrollInProgress = function () {
                    if (angular.isFunction(scrolledCallback)) {
                        scrolledCallback(scope, { e: '' });
                    };
                };

                scope.actionElementID = commonUtilities.uniqueIDGenerator;

            },
            templateUrl: 'shared/directives/uiElements/smartList/smartListTemplate.html'
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartListLookup', ['$rootScope', '$timeout', 'ScrollTo', 'lookup', 'debouncer', function ($rootScope, $timeout, ScrollTo, lookup, debouncer) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                label: '@',
                ngModel: '=?',
                options: '=?',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                callAddNew: '&',
                lookupOpen: '&',
                lookupHide: '&',
                searchtextKeyUp: '&',
                readonly: '@',
                displayformat: '@',
                multiselect: '@',
                addnew: '@',
                titleofmodel: '@',
                selecttypeoption: '='
            },
            link: function (scope, element, attrs) {
                scope.ngModel = (scope.ngModel == undefined || scope.ngModel == null) ? '' : scope.ngModel;
                var multiselect = (scope.multiselect == undefined || scope.multiselect == null) ? false : scope.multiselect == "true" ? true : false;
                var addnew = (scope.addnew == undefined || scope.addnew == null) ? false : scope.addnew == "true" ? true : false;
                //var readonly = (scope.readonly == undefined || scope.readonly == null) ? false : scope.readonly == "true" ? true : false;
                var formatedArray = eval(scope.displayformat);
                scope.valuetoshow = [""];
                scope.titleofmodel = (scope.titleofmodel == undefined || scope.titleofmodel == null) ? 'Title Of Model' : scope.titleofmodel;
                scope.toolTip = "";
                var isInfoTipEnable = attrs.showInfoTip == 'true' ? true : false,
                    checkInfoToolTip = function () {
                        var infotipData = scope.ngModel;
                        

                        if (isInfoTipEnable) {
                            scope.toolTip = _.pluck(scope.ngModel, "name").join('</br>');
                        } 
                    };

                function generateName(obj) {
                    var label = "",
                        formattedLen = formatedArray.length;
                    for (var j = 0; j < formattedLen; j++) {
                        if (obj.hasOwnProperty(formatedArray[j])) {
                            label = label + " " + obj[formatedArray[j]];
                        }
                    }
                    return label;
                }

               var deregisterWatchModel = scope.$watch("ngModel", function (newVal) {
                    scope.valuetoshow = [""];
                    if (multiselect) {
                        if (angular.isDefined(newVal)) {
                            if (newVal.length > 0) {
                                scope.valuetoshow = [generateName(newVal[0])];
                                var totalEl = newVal.length;
                                if (totalEl > 1) {
                                    scope.valuetoshow.push("+" + (totalEl - 1) + " More");
                                }
                            }
                        }
                    } else {
                        scope.valuetoshow = [generateName(newVal)];
                    }
                    if (scope.valuetoshow[0] == "") {
                        scope.isActive = false;
                    } else {
                        scope.isActive = true;
                    }
                    checkInfoToolTip();
                });

                scope.openLookup = function () {
                    debouncer.add(function () {
                        if (scope.readonly === 'true' && !scope.valuetoshow[1]) return false;
                        if ($.isFunction(scope.lookupOpen)) {
                            scope.lookupOpen();
                        }
                        var lookupConfig = {
                            modelData: scope.ngModel,
                            config: {
                                mutliselect: multiselect,
                                displayProperties: formatedArray,
                                options: scope.options,
                                addnew: addnew,
                                isMandatory: scope.isMandatory,
                                onKeyUp: attrs.searchtextKeyUp ? scope.searchtextKeyUp : '',
                                titleOfModel: scope.titleofmodel,
                                selectTypeOption: scope.selecttypeoption,
                                readonly: (scope.readonly == undefined || scope.readonly == null) ? false : scope.readonly == "true" ? true : false
                            }
                        }
                        var cancelTimer = $timeout(function () {
                            lookup.open(lookupConfig, function (response) {

                                if (response.addnew) {
                                    if ($.isFunction(scope.callAddNew)) {
                                        scope.callAddNew();
                                    }
                                }
                                scope.ngModel = response.result;
                                scope.defaultselectiontext = response.defaultSelectionText;
                                scope.selecttypeoption = response.selectTypeOption;
                                if ($.isFunction(scope.lookupHide)) {
                                    scope.lookupHide({ data: response });
                                }
                            });
                            $timeout.cancel(cancelTimer);
                            cancelTimer = null;
                        });
                    }, 300);
                }

                scope.ngModel = (scope.ngModel == undefined || scope.ngModel == null) ? '' : scope.ngModel;
                scope.$on('$destroy', function () {
                    deregisterWatchModel();
                });
            },
            templateUrl: 'shared/directives/uiElements/smartListLookup/smartListLookupTemplate.html'
        };
    }]);
})();
//(function () {
//    'use strict';
//    angular.module('SMART2').factory('httpLoaderInterceptor', ['$rootScope', function ($rootScope) {
//        // Active request count
//        var requestCount = 0;

//        function startRequest(config) {
//            // If no request ongoing, then broadcast start event
//            if (!requestCount) {
//                $rootScope.$broadcast('httpLoaderStart');
//            }

//            requestCount++;
//            return config;
//        }

//        function endRequest(arg) {
//            // No request ongoing, so make sure we dont go to negative count
//            if (!requestCount)
//                return;

//            requestCount--;
//            // If it was last ongoing request, broadcast event
//            if (!requestCount) {
//                $rootScope.$broadcast('httpLoaderEnd');
//            }

//            return arg;
//        }

//        /* ROOTSCOPE EXPOSED BROADCAST TRIGGERS FOR LOADER */
//        $rootScope.showCentralLoader = function () {
//            $rootScope.$broadcast('httpLoaderStart');
//        };

//        $rootScope.hideCentralLoader = function () {
//            $rootScope.$broadcast('httpLoaderEnd');
//        };
//        /* END FOR -- ROOTSCOPE EXPOSED BROADCAST TRIGGERS FOR LOADER */

//        // Return interceptor configuration object
//        return {
//            'request': startRequest,
//            'requestError': endRequest,
//            'response': endRequest,
//            'responseError': endRequest
//        };
//    }]);

//    angular.module('SMART2').config(['$httpProvider', function ($httpProvider) {
//        $httpProvider.interceptors.push('httpLoaderInterceptor');
//    }]);

//    angular.module('SMART2').directive('httpLoader', function () {
//        return {
//            restrict: 'EA',
//            templateUrl: 'shared/directives/uiElements/smartLoader/smartLoaderTemplate.html',
//            link: function (scope, element) {
//                // Store original display mode of element
//                var shownType = element.css('display');
//                function hideElement() {
//                    element.css('display', 'none');
//                }

//                scope.$on('httpLoaderStart', function () {
//                    element.css('display', shownType);
//                });

//                scope.$on('httpLoaderEnd', hideElement);

//                // Initially hidden
//                hideElement();
//            }
//        };
//    });

//    angular.module('SMART2').directive('routeLoader', function () {
//        return {
//            restrict: 'EA',
//            templateUrl: 'shared/directives/uiElements/smartLoader/smartLoaderTemplate.html',
//            link: function (scope, element) {
//                // Store original display mode of element
//                var shownType = element.css('display');
//                function hideElement() {
//                    element.css('display', 'none');
//                }

//                scope.$on('$routeChangeStart', function () {
//                    element.css('display', shownType);
//                });
//                scope.$on('$routeChangeSuccess', hideElement);
//                scope.$on('$routeChangeError', hideElement);
//                // Initially element is hidden
//                hideElement();
//            }
//        }
//    });
//})();
(function () {
    'use strict';
    angular.module('SMART2').factory('lookup', ['$rootScope', function ($rootScope) {
        var Obj = {};
        Obj.onCallback = undefined;
        Obj.on = function (callback) {
            Obj.onCallback = callback;
        };

        Obj.open = function (config, callback) {
            this.config = config;
            this.broadcastItem();
            this.resultCallBack = function (result) {
                callback(result);
            };
        };
        Obj.optionUpdate = function (option) {
            if (typeof this.config != 'undefined') {
                this.config.config.options = option;
            }
        };
        Obj.getConfig = function () {
            return this.config;
        };
        Obj.setTempModel = function (arg) {
            this.tempModel = arg;
        };
        Obj.getTempModel = function () {
            return this.tempModel;
        };
        Obj.onScrollEnd = function (callback) {
            this.onScrollEndCall = function () {
                callback();
            };
        };
        Obj.onScrollTop = function (callback) {
            this.onScrollTopCall = function () {
                callback();
            };
        };
        Obj.onScrollInProgress = function (callback) {
            this.onScrollInProgressCall = function () {
                callback();
            };
        };
        Obj.broadcastItem = function () {
            angular.isFunction(Obj.onCallback) && Obj.onCallback();
        };
        return Obj;
    }]);

    var countForTheProprty = 0;
    angular.module('SMART2').directive('smartLookup', ['$rootScope', '$timeout', '$translate', 'ScrollTo', 'lookup', function ($rootScope, $timeout, $translate, ScrollTo, lookup) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                label: '@'
            },
            link: function (scope, element, attrs) {
                scope.searchText = { title: "" };
                scope.cancelTitle = scope.searchText.title == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                function isObjectEquals(obj1, obj2) {
                    var checkObj2 = function () {
                        for (var i in obj2) { }
                        return i == undefined ? false : true;
                    }
                    if (obj2 == '' || obj2 == null || checkObj2() === false) {
                        return false;
                    }
                    for (var i in obj2) {
                        if (obj2.hasOwnProperty(i)) {
                            if (!obj1.hasOwnProperty(i)) return false;
                            if (obj2[i] != obj1[i]) return false;
                        }
                    }
                    return true;
                }
                function containsObject(obj, list, catalogObj) {
                    for (var i = 0; i < list.length; i++) {
                        if (catalogObj) {
                            if (obj.UserId == list[i]) {
                                return true;
                            };
                        } else {
                            if (isObjectEquals(obj, list[i])) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                scope.smartScrollEnd = function () {
                    if (angular.isFunction(lookup.onScrollEndCall)) {
                        lookup.onScrollEndCall();
                    };
                    $timeout(function () {
                        if (scope.isLazyLoadingEnabled && scope.limitToCount <= scope.options.length)
                            scope.limitToCount = scope.limitToCount + 35;
                    });
                };
                scope.smartScrollTop = function () {
                    if (angular.isFunction(lookup.onScrollTopCall)) {
                        lookup.onScrollTopCall();
                    };
                };
                scope.smartScrollInProgress = function () {
                    if (angular.isFunction(lookup.onScrollInProgressCall)) {
                        lookup.onScrollInProgressCall();
                    };
                };
                scope.searchText = { title: "" };
                scope.selectdCount = 0;
                scope.model = [];
                scope.options = [];
                scope.displayProperties = ["name"];
                scope.selectTypeOptionWith = '';
                scope.propKey = "";
                countForTheProprty++;
                function generateName(obj) {
                    var label = "";
                    if (scope.displayProperties.length == 1) {
                        label = obj[scope.displayProperties[0]];
                    }
                    else {
                        for (var j = 0; j < scope.displayProperties.length; j++) {
                            if (scope.propSeparation !== undefined && j !== scope.displayProperties.length - 1) {
                               label = label + " " + obj[scope.displayProperties[j]] + " " + scope.propSeparation;
                            }
                            else { 
                                label = label + " " + obj[scope.displayProperties[j]];
                            }
                        }
                    }
                    return label;
              
                }
                var stopInit = false;
                function initialize() {
                    //migrate two array with flag
                    scope.propKey = "counterProp" + countForTheProprty;
                    if (scope.options == undefined || scope.config.options == undefined) {
                        scope.options = [];
                    } else {                      
                            scope.options = scope.config.options;                        
                    }
                    if (scope.multiple) {
                        for (var i = 0; i < scope.options.length; i++) {
                            if (!scope.options[i].hasOwnProperty("ischecked") && !stopInit) {
                                if (containsObject(scope.options[i], scope.model, scope.isObjectCompareCatalog)) {
                                    scope.options[i].ischecked = true;
                                    scope.options[i][scope.propKey] = generateName(scope.options[i]);
                                } else {
                                    scope.options[i].ischecked = false;
                                    scope.options[i][scope.propKey] = generateName(scope.options[i]);
                                }
                                if (scope.descriptionKey) {
                                    scope.options[i].description = scope.options[i][scope.descriptionKey];
                                }
                            }                           
                        }
                        if (scope.minMultiselect) {
                            checkSelectedItems();
                        }
                    } else {
                        for (var i = 0; i < scope.options.length; i++) {
                            if (!stopInit) {
                                if (isObjectEquals(scope.options[i], scope.model)) {
                                    scope.options[i].ischecked = true;
                                    scope.options[i][scope.propKey] = generateName(scope.options[i]);
                                } else {
                                    scope.options[i].ischecked = false;
                                    scope.options[i][scope.propKey] = generateName(scope.options[i]);
                                }
                                if (scope.descriptionKey) {
                                    scope.options[i].description = scope.options[i][scope.descriptionKey];
                                }
                            }
                        }
                    }
                    scope.limitToCount = scope.isLazyLoadingEnabled ? 35 : scope.options.length;
                };
                scope.searchTextKeyUpFn = function (e) {
                    if (scope.config.onKeyUp) {
                        scope.config.onKeyUp({ $data: { text: e.target.value, type: "textfield", "e": e } });
                    }

                    if (e.keyCode == 13) {
                        element.find("#lookup-content-wrpper .scroll-content").scrollTop(0);
                        if (scope.clearModelOnEnter) {
                            scope.model = [];
                        }
                    }
                    scope.cancelTitle = e.target.value == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                }

                var regEx = new RegExp("", "ig");
                //scope.filterKeyFn = function (searchtxt, filterKey, stopFilterOnKey) {
                //    return function (item) {
                //        var r;
                //        if (filterKey && !stopFilterOnKey && searchtxt != "") {
                //            regEx.compile(searchtxt, "ig");
                //            for (var f = 0; f < filterKey.length; f++) {
                //                if (!searchtxt || item[filterKey[f]].toString().search(regEx) > -1) {
                //                    r = true;
                //                    break;
                //                } else {
                //                    r = false
                //                }
                //            }
                //        } else {
                //            r = true;
                //        }
                //        return r;
                //    }
                //}
                function scrollbarReload() {
                    if (scope.scrollAlwaysTopOnload == true && scope.scrollReload == false) {
                        scope.scrollReload = true
                    } else if (scope.scrollAlwaysTopOnload == true && scope.scrollReload == true) {
                        scope.scrollReload = false
                    }
                };
                scope.triggerFlag = false;
                var returnObj = {};
                lookup.on(function () {
                    scope.config = lookup.config.config;
                    scope.minMultiselect = scope.config.minMultiselect;
                    scope.label = scope.config.label;
                    scope.isSearchOpen = false;
                    scope.multiple = false;
                    scope.addnew = false;
                    scope.readonly = false;
                    scope.multiple = typeof (scope.config.mutliselect) == "undefined" ? false : scope.config.mutliselect;
                    scope.addnew = typeof (scope.config.addnew) == "undefined" ? false : scope.config.addnew;
                    scope.readonly = typeof (scope.config.readonly) == "undefined" ? false : scope.config.readonly;
                    scope.titleOfModel = typeof (scope.config.titleOfModel) === "undefined" ? $translate.instant('titleOfModel') : scope.config.titleOfModel;
                	/*  Default Selection scope variable */
                    scope.config.defaultSelectOption = typeof (scope.config.defaultSelectOption) === "undefined" ? false : scope.config.defaultSelectOption;
                    scope.config.defaultSelectionText = typeof (scope.config.defaultSelectionText) === "undefined" ? "" : scope.config.defaultSelectionText;
                    scope.config.selectTypeOption = typeof (scope.config.selectTypeOption) === "undefined" ? null : scope.config.selectTypeOption;
                    scope.selectiontext = angular.copy(scope.config.selectTypeOption);    
                    scope.model = lookup.config.modelData;
                    scope.isLazyLoadingEnabled = scope.config.isLazyLoadingEnabled;
                    
                    if (angular.isDefined(scope.model) && (scope.model != "" || angular.equals(scope.model, {}) )) {
                        if (scope.multiple) {
                            scope.selectdCount = scope.model.length || 0;
                        }
                        else if (scope.model.hasOwnProperty('name') || scope.model.hasOwnProperty('value') || scope.model.hasOwnProperty('id')) {
                            scope.selectdCount = 1;
                        }
                    } else {
                        scope.selectdCount = 0;
                    }
                    scope.options = scope.config.options;
                    scope.limitToCount = scope.isLazyLoadingEnabled ? 35 : scope.options.length;
                    scope.displayProperties = scope.config.displayProperties.length > 0 ? scope.config.displayProperties : scope.displayProperties;
                    scope.descriptionKey = scope.config.descriptionKey;
                    scope.propSeparation = scope.config.propSeparation;
                    scope.scrollAlwaysTopOnload = (scope.config.scrollAlwaysTopOnload === undefined) ? false : scope.config.scrollAlwaysTopOnload;
                    scope.scrollReload = scope.scrollAlwaysTopOnload ? false : true;
                    scope.selectTypeOptionWith = scope.config.selectTypeOptionWith ? scope.config.selectTypeOptionWith : scope.selectTypeOptionWith;
                    scope.searchFilterKey = scope.config.searchFilterKey; // added for filter on key basis
                    scope.stopFilterOnKey = scope.config.stopFilterOnKey; // added for stop filtering on keydown
                    scope.hideSelectedCount = scope.config.hideSelectedCount;
                    scope.isObjectCompareCatalog = scope.config.isObjectCompareCatalog;
                    scope.clearModelOnEnter = scope.config.clearModelOnEnter;
                    initialize();
                    scope.triggerFlag = true;
                    scrollbarReload();
                    $timeout(function () {
                    element.find('.lookupPopupContent input[checked="checked"]').prop('checked', true);            
                });
                    scope.$watch(function () {
                        return lookup.config.config.options;
                    },
                    function (newVal, oldVal) {
                        initialize();
                    }, true);
                    returnObj.addnew = false;
                    returnObj.result = scope.model;
                    returnObj.btnType = '';
                    returnObj.defaultSelectionText = scope.config.defaultSelectionText.trim(),
                    returnObj.selectTypeOption = scope.config.selectTypeOption;
                    returnObj.errorModel = scope.config.errorModel;
                    scope.defaultError = false;

                    if (scope.selectdCount == 0 && scope.$eval(scope.config.isMandatory))
                    	scope.itemSelected = false;
                    else
                        scope.itemSelected = true;

                    scope.isLimitmultiselect = scope.minMultiselect ? scope.minMultiselect.event : false; scope.minMultiselect

                });

                scope.searchToggle = function () {
                    if (scope.isSearchOpen == false) {
                        scope.isSearchOpen = true;
                        $timeout(function () {
                            if ($("#searchTextbox").find("input").length) {
                                $("#searchTextbox").find("input").focus();
                            } else {
                                $("#searchTextbox").focus();
                            }
                        });
                    }
                    if (scope.config.onKeyUp) {
                        scope.config.onKeyUp({ $data: { text: scope.searchText.title, type: "search" } });
                    }
                    scope.cancelTitle = scope.searchText.title == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                };
                scope.closeSearch = function () {
                    if (scope.searchText.title != "") {
                        scope.searchText.title = "";
                    } else {
                        scope.isSearchOpen = false;
                        $("#btnShowSearch").focus();
                    }
                    if (scope.config.onKeyUp) {
                        scope.config.onKeyUp({ $data: {text: scope.searchText.title, type : "close" } });
                    }
                    scope.cancelTitle = scope.searchText.title == "" ? $translate.instant('closeSearch') : $translate.instant('clearSearch'); 
                };

            	/*  triggers which default radio btn click */
                scope.ondefaultSelectItem = function (obj) {
                	obj.ischecked = true;
                	scope.onChangeItem(obj);
                	scope.defaultError = false;
                	scope.config.errorModel = '';
                };
                var checkSelectedItems = function () {
                    if (scope.selectdCount >= parseInt(scope.minMultiselect.value)) {
                        for (var i = 0; i < scope.options.length; i++) {
                            if (!scope.options[i].ischecked) {
                                scope.options[i].isdisable = true;
                            } else {
                                scope.options[i].isdisable = false;
                            }
                        }
                    } else {
                        for (var i = 0; i < scope.options.length; i++) {
                            scope.options[i].isdisable = false;
                        }
                    }
                }
                scope.optionUnSelected = [];
                scope.onChangeItem = function (obj) {
                    if (scope.multiple) {
                		if (obj.ischecked) {
                			scope.selectdCount++;
                		} else {
                		    scope.selectdCount--;
                		    scope.optionUnSelected.push(obj);

                		    if (scope.$eval(scope.config.isDefaultMandatory) && obj[scope.propKey] === scope.config.defaultSelectionText) {
                		        scope.config.defaultSelectionText = ''
                		    }
                		}
                		if (scope.selectdCount == 0 && scope.$eval(scope.config.isMandatory)) {
                			scope.itemSelected = false;
                			scope.config.errorModel = $translate.instant("selectValueErrMsg");
                		}
                		else {
                			scope.itemSelected = true;
                			scope.config.errorModel = '';
                		}
                		if (scope.minMultiselect && scope.minMultiselect.event) {
                		    checkSelectedItems();
                		}
                	} else {
                		scope.model = obj;
                		scope.itemSelected = true;
                		scope.config.errorModel = '';
                		initialize();
                	}
                };
                
                function cleanData() {
                	stopInit = true;
                	for (var i = 0; i < scope.options.length; i++) {
                		delete scope.options[i].ischecked;
                		delete scope.options[i][scope.propKey];
                	}
                	$timeout(function () {
                		stopInit = false;
                	}, 500);
                };
                scope.defaultError = false;

                scope.cancelButton = { title: $translate.instant("cancelBtn") };
                scope.doneButton = { title: $translate.instant("doneBtn") };

                scope.selectionCancel = function () {
                    returnObj.btnType = 'cancel';
                }
                scope.selectionDone = function () {
                    returnObj.UnSelectedResult = [];
                	if (!scope.itemSelected && scope.$eval(scope.config.isMandatory)) {
                		return;
                	}
                	if (scope.$eval(scope.config.isDefaultMandatory) && scope.config.defaultSelectionText == '') {
                		scope.defaultError = true;
                		scope.config.errorModel = $translate.instant("markPaymentErrMsg");
                		return;
                	}
                    if (scope.multiple) {
                        var result = [];
                        stopInit = true;
                        for (var i = 0; i < scope.options.length; i++) {
                            delete scope.options[i][scope.propKey];
                            if (scope.options[i].ischecked) {
                            	delete scope.options[i].ischecked;

                            	/*  Default Selection check point */
                                if (scope.config.defaultSelectionText.trim() === scope.options[i].name) {
                                	result.unshift(scope.options[i]);
                                } else {
                                	result.push(scope.options[i]);
                                }
                            }
                        }
                        cleanData();
                        $timeout(function () {
                            stopInit = false;
                        }, 500);
                    }
                    else {
                        stopInit = true;
                        delete scope.model.ischecked;
                        delete scope.model[scope.propKey];
                        result = scope.model;
                        if (scope.config.selectTypeOption != null) {
                            scope.config.selectTypeOption.selectiontext = scope.selectiontext.selectiontext;
                        }
                        cleanData();
                        $timeout(function () {
                            stopInit = false;
                        }, 500)
                    }

                    returnObj.result = result;
                    returnObj.UnSelectedResult = scope.optionUnSelected;
                    scope.optionUnSelected = [];

                    returnObj.btnType = 'save';
                    returnObj.defaultSelectionText = scope.config.defaultSelectionText.trim();
                    returnObj.selectTypeOption = scope.config.selectTypeOption;
                    returnObj.errorModel = scope.config.errorModel;
                    scope.callbackOnHide();
                }
                scope.addNew = function () {
                    cleanData();
                    returnObj.addnew = true;
                    scope.triggerFlag = false;
                    scrollbarReload();
                }

                //Popup hide/show flag
                scope.callbackOnHide = function (e) {
                    scope.triggerFlag = false;
                    scrollbarReload();
                    scope.searchText.title = "";
                    if (scope.isLazyLoadingEnabled)
                    scope.limitToCount = 35;
                    scope.isSearchOpen = false;
                    //cleanData() comment this and add in manually due to avoid timeout checkbox issue;
                    stopInit = true;
                    for (var i = 0; i < scope.options.length; i++) {
                        delete scope.options[i].ischecked;
                        delete scope.options[i][scope.propKey];
                    }
                    $timeout(function () {
                        stopInit = false;
                    });

                    /*  Return Default Selection Object */
                    lookup.resultCallBack(returnObj);
                }
            },
            templateUrl: 'shared/directives/uiElements/smartLookup/smartLookupTemplate.html'
        };
    }]);
})();
(function () {
    'use strict';
    var multiSelectId = 0;
    angular.module('SMART2').directive('smartMultiselect', ['$timeout', '$translate', 'RuleEngine', function ($timeout, $translate, RuleEngine) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                label: '@',
                options: '=?',
                ngModel: '=?',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                onChange: '&',
                onSelect: '&',
                onBlur: '&',
                disable: '@',
                readonly: '@',
                multiple: '@',
                datakey: '@',
                removable: '@',
                autocomplete: '@',
                filterkeys: '@',
                optionformat: '@',
                displayformat: '@',
                width: '@'
            },
            link: function (scope, element, attrs) {
                var options, filterKeys;
                scope.defaultText = "";
                var disableBlurEvent = true;
                if (attrs.id != undefined || attrs.id != null) {
                    scope.multiSelectId = attrs.id;
                    element.removeAttr('id');
                }
                else {
                    multiSelectId += multiSelectId;
                    scope.multiSelectId = 'multiselect-' + multiSelectId;
                }
                scope.labelForMultiSelectId = 'label-for-' + scope.multiSelectId;
                scope.displayformat = scope.displayformat ? scope.displayformat : '{title}';
                var modelConfig = scope.$watch('ngModel', function (newValue) {
                    if (newValue) {
                         scope.selectedOptions = newValue;
                    }
                   
                });

                scope.multiSelectFocus = function () {
                    if (!scope.$eval(scope.disable) && !scope.$eval(scope.readonly))
                        $("#" + scope.multiSelectId).focus();
                };

                scope.setDisplayFormat = function (item) {
                    var displayArray = scope.displayformat.substring(1, scope.displayformat.length - 1);
                    displayArray = displayArray.replace(/  +/g, ' ');
                    var valu = "";
                    var arrayD = displayArray.split('} {'), arrDLen = arrayD.length;
                    for (var i = 0; i < arrDLen; i++) {
                        valu += item[arrayD[i]] + " ";
                    }
                    return valu;
                }
                var currentSelectForDelete = scope.ngModel.length;

             
                scope.ngKeyDown = function (event) {

                    var evntKeyCode = event.keyCode;
                    if (evntKeyCode === 40 && event.target.value == '') {
                        event.stopImmediatePropagation();
                    }
                    if (scope.ngModel.length > 0) {
                        if ((evntKeyCode === 8 || evntKeyCode === 46) && scope.defaultText == "") {
                            if (currentSelectForDelete >= scope.ngModel.length) {
                                currentSelectForDelete = scope.ngModel.length - 1;
                                if ((scope.ngModel[currentSelectForDelete].selectForDelete) === false) {
                                    scope.ngModel[currentSelectForDelete].selectForDelete = true;
                                    currentSelectForDelete = scope.ngModel.length - 1;
                                }
                                else {
                                    scope.ngModel.splice(currentSelectForDelete, 1);
                                     currentSelectForDelete = scope.ngModel.length;

                                    var isInvalidId = _.find(scope.ngModel, { "isInvalid": true });
                                    if (!isInvalidId) {
                                        scope.invalidEmailId = false;
                                        scope.validate = false;
                                        scope.errorMessage = null;
                                    }
                                }
                            }
                            else if ((scope.ngModel[currentSelectForDelete].selectForDelete) === true) {
                                scope.ngModel.splice(currentSelectForDelete, 1);
                               
                                currentSelectForDelete = scope.ngModel.length;
                            }
                        }
                        else if (evntKeyCode === 37 && scope.defaultText == "") {
                            if (currentSelectForDelete > 0) {
                                scope.ngModel[currentSelectForDelete - 1].selectForDelete = true;

                                if (currentSelectForDelete < scope.ngModel.length)
                                    scope.ngModel[currentSelectForDelete].selectForDelete = false;

                                currentSelectForDelete--;
                            }
                        }
                        else if (evntKeyCode === 39 && scope.defaultText == "") {
                            if (currentSelectForDelete < scope.ngModel.length -1) {
                                scope.ngModel[currentSelectForDelete + 1].selectForDelete = true;

                                if (currentSelectForDelete >= 0)
                                    scope.ngModel[currentSelectForDelete].selectForDelete = false;

                                currentSelectForDelete++;
                            }
                        }
                        else {
                            if (currentSelectForDelete < scope.ngModel.length) {
                                scope.ngModel[currentSelectForDelete].selectForDelete = false;
                            } else {
                                var isInvalidId = _.find(scope.ngModel, { "isInvalid": true });
                                if (isInvalidId) {
                                    scope.invalidEmailId = true;
                                } else {
                                    scope.invalidEmailId = false;
                                    scope.validate = false;
                                    scope.errorMessage = null;
                                }
                            }
                        }
                    } else {
                        scope.invalidEmailId = false;
                        scope.validate = false;
                        scope.errorMessage = null;
                    }
                };

                var checkEmailValidation = function (event, onBlur) {
                    if (event.keyCode == 13 || event.keyCode == 9 || onBlur) {

                        var currentTextValue = element.find('.multiselect-input').val().split(';'),
                            pattern = /^([a-z\d!#$%&'*+\-\/=?^_`{|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+(\.[a-z\d!#$%&'*+\-\/=?^_`{|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+)*|"((([ \t]*\r\n)?[ \t]+)?([\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*(([ \t]*\r\n)?[ \t]+)?")@(([a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF][a-z\d\-._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]*[a-z\d\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])\.)+([a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|[a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF][a-z\d\-._~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]*[a-z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])\.?$/i;

                        var filteredArray = [],
                            invalidEmailArray = []; 
                        angular.forEach(currentTextValue, function (item) {
                            if (item) filteredArray.push(item.trim());
                        });
                        var filteredLen = filteredArray.length;

                        for (var i = 0; i < filteredLen; i++) {
                            var filterdItem = filteredArray[i];
                            if (filterdItem != '') {
                                var currentItem = { UserName: filterdItem, value: filterdItem };
                                if (!pattern.test(filterdItem)) {
                                    currentItem.isInvalid = true;
                                    scope.invalidEmailId = true;
                                    invalidEmailArray.push(currentItem);
                                } else {
                                    currentItem.isInvalid = false;
                                    scope.invalidEmailId = false;
                                }

                                if (!currentItem.isInvalid) {
                                    scope.ngModel.push(currentItem);
                                    scope.setDisplayFormat(currentItem);
                                    scope.defaultText = "";
                                  var timeout = $timeout(function () {
                                        scope.onSelect({
                                            $event: {
                                                data: currentItem
                                            }
                                           
                                        });
                                        currentSelectForDelete = scope.ngModel.length;
                                        scope.validateRules();
                                        disableBlurEvent = true;
                                        $timeout.cancel(timeout);
                                        timeout = null;
                                  });

                                }
                                else {
                                    scope.validateRules();
                                }
                            }
                            else {
                                return false;
                            }
                        }
                        var result = invalidEmailArray.map(function (item) { return item.UserName; });
                        scope.defaultText = result.join(';');
                        if (result.length > 0)
                            scope.invalidEmailId = true;
                        scope.validateRules();
                    }
                };

              
                scope.ngKeyUp = function (event, onBlur) {
                    checkEmailValidation(event, onBlur);
                    var evtTrgt = $(event.target), defaultWidth = 250;
                    var timeIntClear =$timeout(function () {
                        if (event.keyCode == 13 && evtTrgt.parent('.multiselect-chip-wrap').find('.multiselect-input').val().length == 0) {
                             evtTrgt.width(defaultWidth);
                        } else {
                            var ele = evtTrgt.parent('.multiselect-chip-wrap').find('.multiselect-input');
                            if (ele.val().length >= 32) {
                                defaultWidth = ele.val().length;
                                evtTrgt.width(defaultWidth * 10);
                            } else {
                                
                                evtTrgt.width(defaultWidth);
                            }
                        }

                        $timeout.cancel(timeIntClear);
                        timeIntClear = null;
                    });
                };


                scope.deleteSelected = function (elementIndex) {
                    disableBlurEvent = false;
                    scope.ngModel.splice(elementIndex, 1);                   
                    $("#" + scope.multiSelectId).focus();
                    var isInvalidId = _.find(scope.ngModel, { "isInvalid": true });
                    if (scope.ngModel.length === 0 || !isInvalidId) {
                        scope.invalidEmailId = false;
                        scope.validate = false;
                        scope.errorMessage = null;
                        return;
                    }
                };

                var onvalidateConfig = scope.$watch('validate', function (newVal, oldVal) {
                    if (newVal) {
                        scope.validateRules();
                    }
                });

                scope.ngChange = function (e) {
                    scope.onChange({
                        $event: {
                            data: angular.element('#' + scope.multiSelectId)
                        }
                    });
                };

                scope.ngBlur = function (e) {
                    function checkChipIsDeleted() {
                        if (disableBlurEvent) {
                            scope.ngKeyUp(e, true);
                        }
                        disableBlurEvent = true;
                        $timeout.cancel(toutPromise);
                        toutPromise = null;
                    }
                    //Timeout is being added to differentiate between blur and delete chip click event.  
                    var toutPromise = $timeout(checkChipIsDeleted, 200);
                    scope.onBlur({ $event: e });
                };

                scope.validateRules = function () {
                    if (scope.readonly == 'true') {
                        return;
                    }

                    var isInvalidId = _.find(scope.ngModel, { "isInvalid": true });
                    if (scope.invalidEmailId || isInvalidId) {
                        scope.validate = true;
                        scope.errorMessage = $translate.instant("invalidEmailErrMsg");
                        return;
                    }

                    if (scope.$eval(scope.isMandatory) && (scope.ngModel + '' == '' || scope.ngModel == null || scope.ngModel == undefined)) {
                        scope.validate = true;
                        scope.errorMessage = $translate.instant("enterValueErrMsg");
                        return;
                    }

                    scope.validate = false;
                    scope.errorMessage = null;

                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false, rulesLen = rules.length;

                        for (var i = 0; i < rulesLen; i++) {
                            var rulesItem = rules[i];
                            if (typeof rulesItem == 'object') {
                                if (eval((rulesItem.rule).replace(/this/g, 'scope.ngModel'))) {
                                    scope.validate = true;
                                    scope.errorMessage = rulesItem.error;
                                    break;
                                }
                            }
                            else {
                                if (!isFoundInvalid) {
                                    if (typeof scope.ngModel != 'object')
                                        var data = scope.ngModel;
                                    else
                                        var data = scope.displayModel;

                                    RuleEngine.isValid(rulesItem, function (e) {
                                        scope.validate = true;
                                        scope.errorMessage = e.errorData.error;
                                        isFoundInvalid = true;
                                    }, data);
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                };


                if (angular.isDefined(scope.filterkeys) && scope.filterkeys.trim().indexOf('[') == 0) {
                    filterKeys = scope.filterkeys ? scope.$eval(scope.filterkeys) : ['title'];
                }
                else {
                    filterKeys = scope.filterkeys ? scope.$eval('[' + scope.filterkeys + ']') : ['title'];
                }
                var optionFormat = scope.optionformat ? scope.optionformat : '{title}';
                var displayFormat = scope.displayformat ? scope.displayformat : '{title}';

                function getFormattedData(data) {
                    var dataLen = data.length;
                    if (!data || dataLen == 0) {
                        return [];
                    }
                    for (var i = 0; i < dataLen; i++) {
                        var str = displayFormat;
                        try {
                            var parentSplit = str.split('{'), parentSplitLen = parentSplit.length;
                            for (var j = 0; j < parentSplitLen; j++) {
                                var childSplit = parentSplit[j].split('}'), childSplitLen = childSplit.length;
                                for (var k = 0; k < childSplitLen; k++) {
                                    var childItem = childSplit[k];
                                    if (childItem.indexOf('.') > 0 || data[i].hasOwnProperty(childItem)) {
                                        str = str.replace(new RegExp("{" + childItem + "}", "ig"), eval('data[i].' + childItem));
                                    }
                                }
                            }
                        }
                        catch (e) { }
                        data[i].value = str.trim();
                    }
                    return data;
                };

           var optionsConfig =  scope.$watch('options', function (newOptions) {
                    var selector = $('#' + scope.multiSelectId);
                    try {
                        if (!selector.devbridgeAutocomplete()) {
                            selector.devbridgeAutocomplete({
                                filterKeys: filterKeys,
                                optionFormat: optionFormat,
                                displayFormat: displayFormat,
                                lookup: getFormattedData(newOptions),
                                width: scope.width,
                                onSelect: function (suggestion) {

                                    scope.$evalAsync(function () {
                                        scope.ngModel.push(suggestion);
                                    });
                                    $(this).focus();
                                    scope.defaultText = "";
                                    var interval = $timeout(function () {
                                        scope.defaultText = "";
                                        scope.onSelect({
                                            $event: {
                                                data: suggestion
                                            }
                                        });
                                        currentSelectForDelete = scope.ngModel.length;
                                        scope.validateRules();
                                        $timeout.cancel(interval);
                                        interval = null;
                                    });
                                    angular.element('.autocomplete-suggestions').hide();

                                }
                            });
                        }
                        else {
                            selector.devbridgeAutocomplete().setLookup(getFormattedData(newOptions));
                        }
                    }
                    catch (e) { }
                });

                /*
				 * Destroy autocomplete on scope destroy
				 */
                scope.$on('$destroy', function () {
                    if ($('#' + scope.multiSelectId).devbridgeAutocomplete()) {
                        $('#' + scope.multiSelectId).devbridgeAutocomplete().dispose();
                    }
                    modelConfig();
                    onvalidateConfig();
                    optionsConfig();
                });

            },
            templateUrl: 'shared/directives/uiElements/smartMultiselect/smartMultiselectTemplate.html'
        }
    }]
	)
})();
/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Popup
 * @description This directive is useful for creating a popup.
 * 
 * @attr {String} template-url
 *    Template url that is expected to appear as popup contents
 * @attr {Boolean} show
 *    Popup will toggle as soon as value of this attribute changes
 * @attr {String} modal-type
 *    Modal type. Possible values are 'large' or 'small'.
 * @attr {Boolean} dismissible
 *   If set to true, popup will not hide when clicked outside. Default value is true.
 * @attr {Function} on-hide
 *    Callback function when popup hides
 * 
 * @example
 Controller:
 $scope.showPopup = false;
 $scope.onPopupHide = function() {
      $scope.showPopup = false;
 };
Usage:
 <smart-popup template-url="abc.html" show="{{showPopup}}" on-hide="onPopupHide()"></smart-popup>
 <button ng-click="showPopup=true">Click here</button>
 */

(function () {
    'use strict';
    angular.module('SMART2').directive('smartPopup', ['$rootScope', '$parse', '$timeout', '$smartModal', '$focusOnField', function ($rootScope, $parse, $timeout, $smartModal, $focusOnField) {
        return {
            restrict: 'E',
            replace: true,
            scope: true,
            controller: ["$controller", "$scope", "$attrs", "$scoper", function ($controller, $scope, $attrs, $scoper) {
                var _scope = $scope,
                    ctrl,
                popupConfig = $scoper.getScope(_scope, $attrs.popupConfig);

                if (popupConfig) {
                    if (popupConfig.controller) {
                        var launchObj = {
                            $scope: _scope
                        };
                        if (popupConfig.resolve) {
                            var val;
                            angular.forEach(popupConfig.resolve, function (value, key) {
                                if (typeof value == "function") {
                                    val = value();
                                } else {
                                    val = value;
                                }
                                this[key] = val;
                            }, launchObj);
                        }
                        ctrl = $controller(popupConfig.controller, launchObj);
                        ctrl.$$smartModal = true;
                    }
                } else {
                    ctrl = _scope;
                };
                return ctrl;
            }],
            link: function (scope, element, attrs, controller) {

                var onHide = $parse(attrs.onHide),
                    triggeredElement;
                // Callback for complete popup close i.e this callback executes after popup animation over.
                if (attrs.afterCompleteClosePopup) {
                    var afterCompleteClosePopup = $parse(attrs.afterCompleteClosePopup);
                }

                var topPositionBeforeModalOpen = 0;

                scope.isCancelButton = (attrs.cancelButton) ? scope.$eval(attrs.cancelButton) : false;

                scope.headerUrl = attrs.headerUrl;
                scope.contentUrl = attrs.contentUrl;
                scope.footerUrl = attrs.footerUrl;
                scope.templateUrl = attrs.templateUrl;
                scope.modalType = attrs.type;
                scope.isDraggable = attrs.isDraggable;

                //Cleaning floating elements on drag
                function cleanFloatingElements() {
                    element.find("[id^=typeahead-]").each(function (i, el) {
                        var autoComplete = $(this).data().autocomplete;
                        if (autoComplete && autoComplete.visible) {
                            autoComplete.hide();
                        }
                    });
                }
                //End of cleaning floating elements on drag

                if (scope.isDraggable) {
                    angular.element(element).draggable({
                        start: function () {
                            cleanFloatingElements();
                        },
                        containment: ".is-popup-Draggable"
                    });
                };

                var tOut;
                attrs.$observe('expandCollapse', function (value) {
                    scope.expandCollapse = value;
                    tOut = setTimeout(function () {

                        angular.element(scope.expandCollapse).click(function () {
                            var expandCollapse = angular.element(scope.expandCollapse),
                                $modal = expandCollapse.closest('.modal'),
                                $modalHeader = expandCollapse.closest('.modal .modal-header'),
                                $leanOverlay = expandCollapse.parents('body').find('.lean-overlay');
                            $modal.addClass('expand-css-trans');
                            var innerTout1 = setTimeout(function () {
                                $modalHeader.toggleClass('extra-nav-wrap expand-header expand-css-trans');
                                clearTimeout(innerTout1);
                                innerTout1 = null;
                            }, 500);

                            var innerTout2 = setTimeout(function () {
                                $modal.removeClass('expand-css-trans');
                                clearTimeout(innerTout2);
                                innerTout2 = null;
                            }, 200);

                            $modal.toggleClass('expand-css');
                            expandCollapse.parent('.modal-header').next().next('.modal-footer_new').find('.modal-close').click(function () {
                                $modal.removeClass('expand-css');
                                $modalHeader.removeClass('extra-nav-wrap expand-header expand-css-trans');
                                $leanOverlay.css('display', 'block');
                            });
                            if ($modal.hasClass('expand-css')) {
                                $leanOverlay.css('display', 'none');
                                $modal.css('border-radius', '0');
                            }
                            else {
                                $leanOverlay.css('display', 'block');
                            }
                        });
                    }, 1000);
                });


                /*
                 *  Unbind window keyup listener and assign tabindex back to .picker elements
                 */
                var reset = function () {
                  //  $(window).off('keyup', onWindowKeyUp);
                    angular.element('.picker').attr("tabindex", 0);
                    //COMMENTED: TWO-5672 impact   angular.element(document).scrollTop(topPositionBeforeModalOpen);
                };


                /*
                 *  window on key up event listener
                 */
                //var onWindowKeyUp = function (e) {
                //    if (angular.element(e.target).closest('.modal').length == 0 && e.keyCode == 9) {
                //        angular.element(element.find(':focusable')[0]).focus();
                //    }
                //};


                /*
                 * Show pop up
                 */
                var $popup, onShow = attrs.$observe('show', function (value) {
                    if (angular.isDefined(value)) {
                        if (scope.$eval(value)) {
                            triggeredElement = document.activeElement;
                            angular.element(triggeredElement).addClass('currentPopupTriggerer');
                            topPositionBeforeModalOpen = angular.element(document).scrollTop();
                            angular.element(element).openModal({
                                dismissible: scope.$eval(attrs.dismissible),
                                beforeOpen: function () {
                                    $popup = angular.element(element).data();
                                    if (scope.isDraggable) {
                                        angular.element('body').addClass('is-popup-Draggable');
                                    }
                                },
                                complete: function () {
                                    if (angular.isFunction(onHide)) {
                                        scope.$apply(function () {
                                            onHide(scope, { e: "" });
                                        });
                                    }
                                    reset();

                                    //  Check if popup is opened by uigrid-compatible element
                                    if (window.isPopupOpenedByUIGridCompatibleElement) {
                                        //  Following event is listened inside uigrid-compatible dir
                                        $rootScope.$emit("popupClosed");
                                        window.isPopupOpenedByUIGridCompatibleElement = undefined;
                                    }

                                    if (element.hasClass("noTransform")) {
                                        var toutpromise = setTimeout(function () {
                                            element.css('top', 0).removeClass('noTransform');
                                            clearTimeout(toutpromise);
                                            toutpromise = null;
                                        }, 100);
                                    }
                                },
                                ready: function () {
                                    //  Check if popup is opened by uigrid-compatible element
                                    if (window.isPopupOpenedByUIGridCompatibleElement) {
                                        $rootScope.$emit("popupOpened");
                                    }
                                    var cancelTOut = $timeout(function () {
                                        if (scope.isDraggable) {
                                            var $body = angular.element('body'),
                                                $modalUiDragable = angular.element('.modal.ui-draggable');
                                            var bodyHeight = $body.height() / 2,
                                             modalHeight = $modalUiDragable.height() / 2,
                                            bodyWidth = $body.width() / 2,
                                            modalWidth = $modalUiDragable.width() / 2;

                                            $(element).css({ 'position': "absolute", 'top': (bodyHeight - modalHeight) / 2, 'margin': 0, 'left': (bodyWidth - modalWidth) });
                                        }
                                        else {
                                            var t = window.innerHeight / 2 - element.outerHeight() / 2;
                                            element.css('top', t);
                                        };
                                        $(element).addClass('noTransform');

                                        //Auto focus first feild / manage tab index

                                      //  $(window).on('keyup', onWindowKeyUp);

                                        //Remove picker tabindex when popup to avoid focus on picker element
                                        angular.element('.picker').removeAttr("tabindex");
                                        $timeout.cancel(cancelTOut);
                                        cancelTOut = null;
                                    });
                                    $timeout(function () {
                                        var $firstField = element.find("a, input[type=text],input[type=radio]:checked,input[type=checkbox], button, textarea, [tabindex='0']").not(":disabled, :hidden, [tabindex = -1]").first();
                                        $focusOnField($firstField);
                                    }, 600);
                                }
                            });
                        }
                        else {
                            var el = angular.element(element),
                                isPopupInit = el.data("overlay-id") === undefined ? false : true;

                            // isPopupInit variable is used  to check whether popup is initiated or not.
                            if (isPopupInit) {
                                el.closeModal({
                                    complete: function () {
                                        if (attrs.afterCompleteClosePopup)
                                            afterCompleteClosePopup(scope, {});

                                        if (scope.isDraggable) {
                                            angular.element('body').removeClass('is-popup-Draggable');
                                        }
                                        if (controller.$$smartModal === true) {
                                            $smartModal.destroyModal({ $view: el, $scope: scope });
                                        }
                                        angular.element(".currentPopupTriggerer").focus().removeClass('currentPopupTriggerer');
                                        triggeredElement = null;
                                    }
                                });

                                if (element.hasClass("noTransform")) {
                                    var tOutTemp = setTimeout(function () {
                                        element.css('top', 0).removeClass('noTransform');
                                        clearTimeout(tOutTemp);
                                        tOutTemp = null;
                                    }, 100);
                                }
                            }
                            //  remove the listener and add tabindex back on picker
                            reset();

                            //  Check if popup is opened by uigrid-compatible element
                            if (window.isPopupOpenedByUIGridCompatibleElement) {
                                //  Following event is listened inside uigrid-compatible dir
                                $rootScope.$emit("popupClosed");
                                window.isPopupOpenedByUIGridCompatibleElement = undefined;
                            }
                        }
                    }
                });

                scope.$on('$destroy', function () {
                    onShow();
                    reset();
                    if ($popup) {
                        $($popup.associatedOverlay).remove();
                        $smartModal.destroyModal({ $view: element });
                    }
                    clearTimeout(tOut);
                    tOut = null;
                    angular.element(scope.expandCollapse).off('click');
                });
            },
            templateUrl: 'shared/directives/uiElements/smartPopUp/smartPopUpTemplate.html'
        };
    }])
    .factory("$scoper", function () {
        return {
            getScope: function (scope, deep) {
                if (deep) {
                    var a, b = deep.split(".");
                    var bLength = b.length;
                    if (bLength > 1) {
                        a = scope;
                        for (var i = 0; i < bLength; i++) {
                            var sortCn = b[i].match(/(\[\d+\])+$/);
                            if (sortCn && sortCn.length > 0) {
                                var subScope = b[i].substr(0, b[i].indexOf('['));
                                a = a[subScope];
                                sortCn = sortCn[0].replace(/\]\[/g, ',').replace(/[\[\]]/g, '').split(",");
                                for (var j = 0; j < sortCn.length; j++) {
                                    a = a[sortCn[j]];
                                }
                            } else {
                                a = a[b[i]];
                            };
                        }
                    } else {
                        a = scope[deep];
                    }
                }
                return a;
            }
        };
    })
    .service("$smartModal", ["$timeout", "$compile", function ($timeout, $compile) {
        var _this = this;

        _this.open = function (config) {
            _this.initModal(config);
        }

        _this.initModal = function (config) {
            var attrs = [
                "show='{{" + (config.show || "") + "}}'",
                "popup-config='" + (config.$config || "") + "'",
                "on-hide='" + (config.onHide || "") + "'",
                "after-complete-close-popup='{{" + (config.afterCompleteClosePopup || "") + "}}'",
                "cancel-button='" + (config.cancelButton || "") + "'",
                "template-url='" + (config.templateUrl || "") + "'",
                "header-url='" + (config.headerUrl || "") + "'",
                "content-url='" + (config.contentUrl || "") + "'",
                "footer-url='" + (config.footerUrl || "") + "'",
                "type='" + (config.type || "") + "'",
                "is-draggable='" + (config.isDraggable || "") + "'",
                "expand-collapse='" + (config.expandCollapse || "") + "'",
                "dismissible='" + (config.dismissible || "") + "'",
                "class='" + (config.class || "") + "'"
            ]
                , smartpopDir = '<smart-popup ' + attrs.join(" ") + '> </smart-popup>';

            var popup = $compile(smartpopDir)(config.$scope);
            popup.appendTo("body");
        }

        _this.destroyModal = function (modal) { // this method invoke automatically once popup goes hide and also executed on scope $destroy.
            modal.$view && modal.$view.remove();
            modal.$scope && modal.$scope.$destroy();
        }
    }]);
})();
/**
   * @memberof SMART2
   * @ngdoc directive
   * @name Radio
   * @description This directive is useful for creating a radio button or a group of radio buttons.
   * 
   * @attr {String} label
   *    Label to be displayed for identification of this ui element
   * @attr {Array} options
   *    Number of radio buttons to be created. Only one option can be selected at a time.
   * @attr {Object} ng-model
   *    Default selected option. This is expected to be one of the 'options'.
   * @attr {Object} ng-model-options
   *    https://docs.angularjs.org/api/ng/directive/ngModelOptions. 
   *    <a href="SMART2.Textfield.html">Click here</a> and scoll down to 'Textfield with ng-model-options' to see example reference.
   * @attr {String} datakey
   *    A property of an option to be used to display the label for option. Default value is 'title'.
   * @attr {String} layout
   *    'vertical' or 'horizontal' layout
   * @attr {Boolean} validate
   *    If set to true, this ui element will be validated on the basis of rules passed to it
   * @attr {Array} rules 
   *    Rules to be evaluated when this element's blur event is fired. A rule must have 'rule' and 'errorMessage' properties (keys).
   *    'rule' must be a condition or group of conditions. 'errorMessage' will be the message to be displayed when corresponding rule fails. See example for more.
   * @attr {String} error-message 
   *    Error message to be displayed. This attribute can be set at any point to display an error message.
   * @attr {Boolean} is-mandatory 
   *    If set to true, default error message will be displayed when blur event is fired and this ui element is left blank
   * @attr {Boolean} is-visible 
   *    If set to true, this ui element will be displayed on form regardless of 'is-mandatory' property's value. 
   *    This ui element can be removed from form by clicking 'x' button on top right corner of this ui element.
   * @attr {Number} colspan
   *    Number of columns to be occupied by this ui element. 1 column is equal to 1 ui element.
   *    Default value is 1.
   *    For e.g. If colspan is set to 2, this ui element will occupy width of 2 ui elements (fields).
   * @attr {Function} on-change
   *    Callback function when any of the buttons from radio group is selected
   * @type cool
   * 
   * @example
   Dynamic:
   Controller:
       $scope.config = {
            "modelData": {
                "currency": { "code": "", "name": "EUR" }
            }, 
            "formConfig": {
                "sections": [
                    {
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "Currency",
                                        "type": "radio",
                                        "isMandatory": true,
                                        "data": "currency",
                                        "colspan": 1,
                                        "onChange": "onChange",  //  controller function
                                        "attributes": {
                                            "options": [{
                                                "code": "$",
                                                "name": "USD"
                                            }, {
                                                "code": "",
                                                "name": "EUR"
                                            }],
                                            "datakey": "name"
                                        },
                                        "rules": [
                                            { 
                                                "rule": "this.title == \"Option 2\"", 
                                                "error": "Invalid selection" 
                                            }
                                        ]
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
   
   * @example
   Static:
   Controller:
       $scope.currencyOptions = [{
            "code": "$",
            "name": "USD"
       }, {
           "code": "",
           "name": "EUR"
       }];
       $scope.selectedCurrency = { "code": "", "name": "EUR" };
       $scope.onChange = function(selectedCurrency) {
           console.log(selectedCurrency);
       };
   Usage:
       <smart-radio label="Currency" ng-model="selectedCurrency" options="currencyOptions" datakey="name" on-change="onChange(selectedCurrency)"></smart-radio> 

   * @example
   Radio with disabled option:
   Controller:
       $scope.currencyOptions = [{
            "code": "$",
            "name": "USD",
            "disable": true
       }, {
           "code": "",
           "name": "EUR"
       }];
       $scope.selectedCurrency = { "code": "", "name": "EUR" };
   Usage:
       <smart-radio label="Currency" ng-model="selectedCurrency" options="currencyOptions" datakey="name"></smart-radio> 
   */

(function () {
    'use strict';
    var radioGroupId = 0;

    angular.module('SMART2').directive('smartRadio', ['$timeout', '$translate', 'ScrollTo', 'RuleEngine', function ($timeout, $translate, ScrollTo, RuleEngine) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                label: '@',
                options: '=?',
                ngModelCopy: '=?ngModel',
                isMandatory: '@',
                isVisible: '=?',
                layout: '@',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                errorMessage: '@',
                onChange: '&',
                removable: '@',
                datakey: '@',
                optionId: '@',
                groupId: '@'
            },
            link: function (scope, element, attrs, ngModelCtrl) {
                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

                var isNgModelFunction = typeof scope.ngModelCopy == 'function';

                // key to be used to bind options
                scope.dataKey = scope.datakey ? scope.datakey : 'title';

                //uniqueID
                radioGroupId = radioGroupId + 1;
                scope.radioGrouptId = (attrs.groupId) ? attrs.groupId : "radio-group-" + radioGroupId;

                if (typeof attrs.optionId != "undefined") {
                    scope.optionId = attrs.optionId;
                }

                //check is gap
                scope.isGap = (attrs.gap) ? scope.$eval(attrs.gap) : false;

                scope.layout = scope.layout ? scope.layout : 'horizontal';


                /*
                 *  Following code has been added to make ng-model-options work
                 *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                 */
                if (isNgModelFunction) {
                    try {
                        ngModelCtrl.$render = function () {
                            scope.ngModel = ngModelCtrl.$modelValue;
                            scope.selectedOption = scope.ngModel;
                        };
                    }
                    catch (e) { }
                }

                var updateView = function () {
                    if (isNgModelFunction) {
                        try {
                            ngModelCtrl.$setViewValue(scope.ngModel);
                        }
                        catch (e) { }
                    }
                };


                /*
                 * Focus field when focus is set to true
                 */
                var onFocus = scope.$watch('focus', function (newVal) {
                    if (newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        scope.focus = false;
                    }
                });

                /*
                 * Validate field whene validate is set to true
                 */
                var onValidate = scope.$watch('validate', function (newValue) {
                    if (newValue != undefined && newValue) {
                        scope.validateRules();
                    }
                });

                /*
                 * Watch needs to be added on ngModel
                 */
                var onNgModel = scope.$watch(isNgModelFunction ? 'ngModel' : 'ngModelCopy', function (newVal) {
                    scope.selectedOption = newVal;
                }, true);

                /*
                 * Validate rules
                 */
                scope.validateRules = function () {
                    if (scope.$eval(scope.isMandatory) && (isNgModelFunction && (scope.ngModel === '' || scope.ngModel === undefined || scope.ngModel === null)) || (!isNgModelFunction && (scope.ngModelCopy === '' || scope.ngModelCopy === undefined || scope.ngModelCopy === null))) {
                        scope.validate = true;
                        scope.errorMessage = $translate.instant('selectOptionErrMsg');
                        return;
                    }

                    scope.validate = false;
                    scope.errorMessage = null;

                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false,
                            ruleLen = rules.length;

                        for (var i = 0; i < ruleLen; i++) {
                            var ruleT = rules[i]; // temp hold
                            if (typeof ruleT == 'object') {
                                if (eval((ruleT.rule).replace(/this/g, 'scope.selectedOption'))) {
                                    scope.validate = true;
                                    scope.errorMessage = ruleT.error;
                                    break;
                                }
                                else {
                                    if (!isFoundInvalid) {
                                        RuleEngine.isValid(ruleT, function (e) {
                                            scope.validate = true;
                                            scope.errorMessage = e.errorData.error;
                                            isFoundInvalid = true;
                                        });
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                };

                scope.ngChange = function (selectedOption) {
                    // Commented below code for fixing TWO-2748
                    //if (!scope.$eval(scope.isMandatory) && angular.isDefined(scope.selectedOption) && scope.selectedOption[scope.dataKey] == selectedOption[scope.dataKey]) {
                    //    scope.selectedOption = '';
                    //}
                    //else {
                    //    scope.selectedOption = selectedOption;
                    //}

                    // Added below code for fixing TWO-2748
                    scope.selectedOption = selectedOption;

                    if (!scope.groupId) {
                        if (isNgModelFunction) {
                            scope.ngModel = scope.selectedOption;
                        }
                        else {
                            scope.ngModelCopy = scope.selectedOption;
                        }
                    }
                    updateView();
                    scope.validateRules();
                    var toutPromise = $timeout(function () {
                        scope.onChange();
                        $timeout.cancel(toutPromise); // cancel the timeout promise to avoid any leakage.
                    });
                };

                scope.$on('$destroy', function () {
                    onFocus();
                    onValidate();
                    onNgModel();
                    element.remove();
                    scope = null;
                });
            },
            templateUrl: 'shared/directives/uiElements/smartRadio/smartRadioTemplate.html'
        };
    }]);
})();
(function () {
    /**
     * @memberof SMART2
     * @ngdoc directive
     * @name Widget Error Field 
     * @description This directive is useful for displaying total error field in widget form
     * 
     * @attr {Object} showerrorsPanel: scope variable, that need to be declared in the controller.
     *    
     * @attr {String} customfieldsSelector: customfields-selector=".linkError, .red-text"
     *    class and id can be passed 
     *    
     * @attr {String} frmWidgetId: frm-widget-id="formWidgetUniqueIdTest1"
     *    widget Id need to be specified here.
     *
     * @example
     Dynamic:
     Controller:
         $scope.onErrorFound = {
            "error": false, // change value for triggering the error count.
            "isWarningHeader": false, // set true for displaying the error band.
            "noMoreErrors": false // 
        };

      Usage:
         <smart-read-errors showerrors-panel="onErrorFound" customfields-selector=".linkError" frm-widget-id="formWidgetUniqueIdTest1" class="bandcontainer clearfix"></smart-read-errors>
     * 
     */

    'use strict';
    angular.module('SMART2')
    .directive('smartReadErrors', function ($rootScope, $compile, $timeout) {
        return {
            restrict: 'EA',
            templateUrl: 'shared/directives/uiElements/smartReadErrors/smartReadErrorsTemplate.html',
            replace: true,
            scope: true,
            link: function (scope, element, attrs) {
                scope.counter = 0;
                scope.emptyText = "";
                scope.leftLabelText = "Show only error field";
                var invalids = [],
                    count = 0,
                    currentManualFocus = '',
                    isManualFocus = true,
                    topMinus = 300,
                    timeoutPeriod = 300,
                    fieldsSelector = "input.invalid, .invalid input, textarea.invalid";

                fieldsSelector += attrs.customfieldsSelector ? ", " + attrs.customfieldsSelector : "";
                scope.onErrorFound = scope[attrs.showerrorsPanel];
                scope.nextDisable = false;
                scope.prevDisable = false;
                var formWidgetId = attrs.frmWidgetId;
                var onblurEvent = function () {
                    $timeout(function () {
                        invalids = $('#' + formWidgetId).find(fieldsSelector);
                        var invLen = invalids.length - 1;
                        if (scope.counter != invLen) {
                            count--;

                            if (count < 0) {
                                count = (scope.counter - invLen) < 0 ? 0 : invLen;
                            }
                            scope.counter = invLen;
                        }
                        if (invLen === 0) {
                            $timeout(function () {
                                scope.onErrorFound.isWarningHeader = false; // close the yellow bar
                            }, 3000);

                        }
                        isManualFocus = true;
                        //scope.counter = invLen;
                    }, timeoutPeriod);
                };


                // To set focus on 
                function focusElem(a_indx) {
                    var top,
                        timeoutPeriodTemp = 0,
                        $invalidDom = invalids.eq(a_indx);

                    if (!$invalidDom.closest('.collapsible-body').hasClass('displayBlock')) {
                        $invalidDom.closest('.collapsible-container').find('.collapsible-header').trigger('click');
                        timeoutPeriodTemp = 350;
                    }

                    $timeout(function () {
                        top = $invalidDom.offset().top - $('#subheaderwrapper').height();
                        //if (top > 300) {
                        $(window).scrollTop(top - 40);
                        //}
                        if ($invalidDom.is("span")) {
                            $invalidDom.closest('div').find('button, [href], input, select, textarea')[0].focus();
                        } else {
                            if ($invalidDom.closest('span').length) {
                                $invalidDom.closest('span').find('.dropdown-button').focus();
                            } else {

                                $invalidDom.focus();
                            }
                        }
                        scope.nextDisable = false;
                        scope.prevDisable = false;
                    }, timeoutPeriodTemp + timeoutPeriod);

                }
                // On focus to maintain the counter
                var onFocusEvent = function (e) {
                    if (isManualFocus) {
                        invalids = $('#' + formWidgetId).find(fieldsSelector);
                        currentManualFocus = $(this);
                        var currInd = invalids.index(currentManualFocus);
                        count = currInd >= 0 ? currInd : count;
                    }
                }

                // Needed for tabbing navigation using tab key

                //var onKeyPressEvent = function (e) {
                //    var char = e.which || e.keyCode;
                //    if (scope.onErrorFound.isTabSwitch && char === 9) {

                //        e.preventDefault();

                //        if (e.shiftKey) {
                //            scope.prev()
                //        } else {
                //            scope.next()
                //        }
                //    }
                //};

                //$(window).keydown(function (e) {

                //    onKeyPressEvent(e);
                //});

                scope.closeErrorHeader = function () {
                    scope.onErrorFound.isWarningHeader = !scope.onErrorFound.isWarningHeader;
                }

                var watchSaveClick = scope.$watch('onErrorFound.error', function (newValue, oldValue) {

                    if (newValue !== oldValue) {
                        $timeout(function () {
                            invalids = $('#' + formWidgetId).find(fieldsSelector);
                            if (invalids.length > 0) {
                                scope.onErrorFound.noMoreErrors = false;
                                scope.onErrorFound.isWarningHeader = true;
                                invalids.blur(onblurEvent).focus(onFocusEvent)
                                scope.counter = invalids.length - 1;
                                focusElem(0);
                                isManualFocus = false; // No user manual focus
                            } else {
                                scope.onErrorFound.noMoreErrors = true;
                                //scope.onErrorFound.isWarningHeader = '';
                                //scope.onErrorFound.isWarningHeader = false;
                            }
                        }, 1000);

                    }

                });
                scope.next = function () {
                    scope.nextDisable = true;
                    scope.prevDisable = true;
                    isManualFocus = true;
                    invalids = $('#' + formWidgetId).find(fieldsSelector);
                    var invLen = invalids.length - 1;

                    if (count < invLen) {
                        isManualFocus = false;
                        focusElem(count + 1);
                        if (scope.counter === invLen) {
                            count++;
                        }
                    } else {
                        isManualFocus = false;
                        count = 0;
                        focusElem(count);
                    };
                    //scope.counter = invLen;
                };

                scope.prev = function () {
                    scope.nextDisable = true;
                    scope.prevDisable = true;
                    isManualFocus = true;
                    invalids = $('#' + formWidgetId).find(fieldsSelector);
                    var newLen = invalids.length - 1;
                    if (count > 0) {
                        isManualFocus = false;
                        focusElem(count - 1);
                        if (scope.counter === newLen) {
                            count--;
                        }
                    } else {
                        isManualFocus = false;
                        focusElem(newLen);
                        count = newLen;
                    };
                    //scope.counter = newLen;
                };

                // Destroy event
                scope.$on('$destroy', function () {
                    watchSaveClick(); // Deregister
                    invalids.unbind(); // unbind all events
                    invalids = [];
                    scope = {}; // nullify the scope
                });

            }
        }
    })
})(angular);
//resizeable Sidebar
(function () {
    'use strict';
    angular.module('SMART2').directive('resizeableSidebar',[function () {
        return {
            restrict: 'A',
            scope: {
                disableResize: '=?',
                collapseCallback : '&',
                scrollCallback : '&',
                leftPanelWidthCallback : '&'
            },
            link: function(scope, element, attrs) {
              var elementWidth = element.innerWidth();
              var collapseCallback = scope.$eval(scope.collapseCallback);
              var scrollCallback = scope.$eval(scope.scrollCallback);
              var leftPanelWidthCallback = scope.$eval(scope.leftPanelWidthCallback);
              var leftPanel = element.find('.leftPanel');
              var resizableDiv = document.createElement('div');
              resizableDiv.id = 'panelexpandorreports';
              resizableDiv.className = 'panelexpandorreports';
              leftPanel.prepend(resizableDiv);
              var getResizableDiv = element.find('.panelexpandorreports');
              var clickableDiv = document.createElement('div');
              clickableDiv.id = 'panelexpandorreportsdiv';
              clickableDiv.className = 'panelexpandorreportsdiv';
              getResizableDiv.prepend(clickableDiv);
              scope.$watch('disableResize', function (disableResize) {
                    if (disableResize) {
                        $('#panelexpandorreports').addClass('disableCursorAction');
                    } else {
                        $('#panelexpandorreports').removeClass('disableCursorAction');
                    }
                });
                var restrictWidth = 0,
                minDraggableWidth = attrs.minWidth || 100,
                lowDraggableWidth = attrs.lowWidth || 100,
                midDraggableWidth = attrs.midWidth || 282;
                var maxDraggableWidth = window.innerWidth / 2;//$(window).width() / 2;
                var UiLeftPosition = 0;
                var UiOriginalPosition = 0;
                var windowWidthBeforeResize = window.innerWidth //$(window).width();
                var leftPecent = midDraggableWidth / windowWidthBeforeResize * 100;
                var currentwindowWidth = window.innerWidth //$(window).width();
                // on window resize calculations
                $(window).resize(function() {                
                    //maxDraggableWidth  = $(window).width() / 2;
                    //restrictWidth = maxDraggableWidth - minDraggableWidth;
                    currentwindowWidth = window.innerWidth //$(window).width();
                    maxDraggableWidth = currentwindowWidth / 2
                    UiLeftPosition = currentwindowWidth * leftPecent / 100;
                    UiLeftPosition = Math.max(midDraggableWidth, UiLeftPosition); 
                    windowWidthBeforeResize = currentwindowWidth;
                    $(".leftPanel").animate({
                        'margin-left': -UiLeftPosition,
                        width: UiLeftPosition
                    }, {
                        duration: 500,
                        queue: false,
                    }).addClass('overflowVisible');
                    $(".wrapper--withSidebar").animate({
                        'margin-left': UiLeftPosition
                    }, {
                        duration: 500,
                        queue: false
                    }).addClass('overflowVisible');
                    $(".panelexpandorreports").animate({
                            left: UiLeftPosition,
                            backgroundColor:'#ccc'
                    }, {
                        duration: 500,
                        queue: false,
                        complete: function(){
                            $(".panelexpandorreports").removeClass('dragLine');                                            
                        }
                    }).addClass('dragLine');
                    leftPanelWidthCallback(UiLeftPosition,elementWidth);
                });
                
                //var maxDraggableWidth  = window.innerWidth / 2, //attrs.maxWidth ||
                  element.on('click mouseover.leftPanel', '#leftPanel', function () {
                        var $panelExp = $('#panelexpandorreports');
                        if (!$panelExp.data('ui-draggable')) {
                            $panelExp.draggable({
                                axis: 'x',
                                drag: function (e, ui) {
                                    restrictWidth = maxDraggableWidth - minDraggableWidth;
                                    $('.panelexpandorreports').addClass('panelexpandorreports-nohover');
                                    //ui.position.left = Math.max(minDraggableWidth, ui.position.left);  
                                    ui.position.left = Math.min(maxDraggableWidth, ui.position.left);
                                    UiLeftPosition = ui.position.left;
                                    UiOriginalPosition = ui.originalPosition.left; 
                                    leftPecent = UiLeftPosition / windowWidthBeforeResize * 100;   
                                    leftPanelWidthCallback(ui.position.left,elementWidth);      
                                },
                                stop: function (e, ui) {                               
                                    if(ui.position.left < lowDraggableWidth){                    
                                       collapseCallback();
                                       $('#panelexpandorreports').css('left', ui.originalPosition.left);
                                    } else if ((ui.position.left >= lowDraggableWidth) && (ui.position.left <= midDraggableWidth)) {
                                        element.removeClass('conditionalLftPanelTransition');
                                        /*var marginLeftValue = parseInt($('.wrapper--withSidebar').css('margin-left')) - (ui.originalPosition.left - ui.position.left);
                                        $(".leftPanel").animate({
                                           'margin-left': -marginLeftValue,
                                            width: ui.position.left
                                        }, {
                                            duration: 500,
                                            queue: false
                                        });

                                        $(".wrapper--withSidebar").animate({
                                            'margin-left': marginLeftValue
                                        }, {
                                            duration: 500,
                                            queue: false
                                        });
                                        // $panelExp.css('left', 282);*/                                 
                                       // setTimeout(function () {
                                        $(".leftPanel").animate({
                                            'margin-left': -midDraggableWidth,
                                            width: midDraggableWidth                                           
                                        }, {
                                            duration: 500,
                                            queue: false,
                                           // complete: function(){
                                            //  $(".leftPanel").removeClass('overflowVisible');
                                            //}
                                        }).addClass('overflowVisible');
                                        $(".wrapper--withSidebar").animate({
                                            'margin-left': midDraggableWidth,
                                        }, {
                                            duration: 500,
                                            queue: false,
                                            //complete: function(){
                                            //  $(".leftPanel").removeClass('overflowVisible');
                                           // }
                                        }).addClass('overflowVisible');
                                        $(".panelexpandorreports").animate({
                                               left: midDraggableWidth,
                                               backgroundColor:'#ccc'
                                        }, {
                                            duration: 500,
                                            queue: false,
                                            complete: function(){
                                              $(".panelexpandorreports").removeClass('dragLine');                                            
                                            }
                                        }).addClass('dragLine');
                                       // }, 400);
                                    } else {                                   
                                        element.removeClass('conditionalLftPanelTransition');
                                        var marginLeftValue = parseInt($('.wrapper--withSidebar').css('margin-left')) - (ui.originalPosition.left - ui.position.left);
                                        $(".leftPanel").animate({
                                           'margin-left': -marginLeftValue,
                                            width: ui.position.left
                                        }, {
                                            duration: 500,
                                            queue: false,
                                           // complete: function(){
                                          //    $(".leftPanel").removeClass('overflowVisible');
                                          //  }
                                        }).addClass('overflowVisible');
                                        $(".wrapper--withSidebar").animate({
                                            'margin-left': marginLeftValue
                                        }, {
                                            duration: 500,
                                            queue: false,
                                          //  complete: function(){
                                          //    $(".leftPanel").removeClass('overflowVisible');
                                           // }
                                        }).addClass('overflowVisible'); 
                                    }
                                    scrollCallback(); 
                                    $('.panelexpandorreports').removeClass('panelexpandorreports-nohover');
                                }
                            });
                        } 
                });
            },
        }
    }]);
})();
(function () {
    'use strict';
    var scrollCounter = 0;

    angular.module('SMART2').directive('smartScroll', ['$parse', '$timeout', '$window', function ($parse, $timeout, $window) {
        return {
            restrict: 'EA',
            replace: false,
            transclude: true,
            scope: true,
            link: function (scope, element, attrs) {
				//Setting for fixed header on scroll
                var isFixedHeader = attrs.isFixedHeader ? true : false,
                    isScrollDate = attrs.hideDate == 'true' ? true : false,
                    onBreakPoints = attrs.onBreakPoints ? $parse(attrs.onBreakPoints.replace(/\(\)/, '(e)')) : false,
                    onScrollLockUnlock = attrs.onScrollLockUnlock ? $parse(attrs.onScrollLockUnlock.replace(/\(\)/, '(e)')) : false;

                scope.fixedHeader = function (e) {
                    var _this = $(e.target),
            		tableElem = _this.find(">").eq(0).find(">").eq(0), // this is depending on the smartScroll directive html structure!
            		 elScrollTop = _this.scrollTop();

                    if (elScrollTop > 0 && !_this.data('appended')) {
                        // reset display styles so column widths are correct when measured below
                        tableElem.find('thead, tbody, tfoot').css('display', '');

                        // set widths of columns
                        tableElem.find('tr:first-child th').each(function (i, thElem) {
                            var tdElems = tableElem.find('tbody > tr:first-child > td').eq(i),
            				columnWidth = tdElems.length ? tdElems.get(0).offsetWidth : thElem.offsetWidth;

                            if (tdElems.length) {
                                tdElems.css('width', columnWidth + 'px');
                            }
                            if (thElem) {
                                $(thElem).css('width', columnWidth + 'px');
                            }
                        });

                        var tbl = $('<table>');
                        var theader = tableElem.find('thead tr:first-child').clone();
                        tableElem.find('thead tr:first-child').css('opacity', '0');
                        tbl.append(theader);
                        tbl.addClass("fixed-header-when-scrolled");
                        _this.before(tbl);
                        _this.data('appended', true);
                    }
                    else if (elScrollTop == 0) {
                        _this.parent().find(".fixed-header-when-scrolled").remove();
                        tableElem.find('thead tr:first-child').css('opacity', '1');
                        _this.data('appended', false);
                    }
                };

                function scrollBreakPoints(scrollTop, direction) {
                    if (attrs.scrollBreakPoints) {
                        var breakPConfig = JSON.parse(attrs.scrollBreakPoints),
                            BCkeys = Object.keys(breakPConfig),
                            srElements = element.find(BCkeys.join(","));

                        for (var z = 0; z < BCkeys.length; z++) {
                            element.find(BCkeys[z]).data("configSele", BCkeys[z]);
                        }

                        if (srElements.length > 0) {
                            srElements.each(function (i, e) {
                                var el = $(e),
                                    pos = el.position(),
                                    bConfig = breakPConfig[el.data("configSele")],
                                    touchValue = function () {
                                        var r;
                                        if (typeof bConfig.top == "number") {
                                            r = bConfig.top * parseInt(scope.scrollHeight);
                                        } else {
                                            r = parseInt(bConfig.top);
                                        }

                                        return r;
                                    }();

                                if (direction == "upward" && pos.top <= touchValue && !el.data("fired")) {
                                    el.data("fired", true);
                                    onBreakPoints(scope, {
                                        e: {
                                            index: i,
                                            direction: "upward"
                                        }
                                    });
                                    scope.$digest();
                                } else if (direction == "downward" && ((bConfig.reverse === true ? pos.top + el.outerHeight() : pos.top) >= (touchValue)) && el.data("fired")) {
                                    el.data("fired", false);
                                    onBreakPoints(scope, {
                                        e: {
                                            index: i,
                                            direction: "downward"
                                        }
                                    });
                                    scope.$digest();
                                };
                            });
                        };
                    };
                };

            	//unique ID for scroll
                scrollCounter = scrollCounter + 1;
                scope.scrollid = 'scroll-' + scrollCounter;

                //custom config
                var customConfig;
                attrs.$observe('scrollConfig', function (value) {
                    if (value) {
                        customConfig = scope.$eval(attrs.scrollConfig);
                    };
                });

                //scroll config
                var scrollConfig = {},
                onScrollEnd = $parse(attrs.onScrollEnd),
                onScrollToTop = $parse(attrs.onScrollToTop),
                onScrollInProgress = $parse(attrs.onScrollInProgress);

                attrs.$observe('height', function (value) {
                    if (value) {                               
                        if (angular.isFunction(onScrollEnd) || angular.isFunction(onScrollToTop)) {
                            scrollConfig.onScroll = function (y, x) {
                                if (y.maxScroll > 0 && y.scroll >= y.maxScroll && angular.isFunction(onScrollEnd)) {
                                    onScrollEnd(scope, { e: "" });
                                }
                                if (y.scroll == 0 && angular.isFunction(onScrollToTop)) {
                                    onScrollToTop(scope, { e: "" });
                                }
                                else if (y.maxScroll > y.scroll > 0 && angular.isFunction(onScrollInProgress)) {
                                    onScrollInProgress(scope, { e: "" });
                                }
                                angular.element('.fixeddd').hide();
                            };
                        }
                    

                        if (!attrs.vOffset) {
                            if (value == "parent") {
                                scope.scrollHeight = element.parent().outerHeight();
                                $(window).resize(resizeHeight100P);
                            } else {
                                scope.scrollHeight = value;
                            }
                        } else if (attrs.vOffset) {
                        	// If scroll to be responsive excluding an offset
                            $(window).unbind("resize", resizeHeight100P);
                        	scope.scrollHeight = $window.innerHeight - parseInt(attrs.vOffset);
                        } else {
                        	scope.scrollHeight = value;
                        }
                    }
                });

                function resizeHeight100P(a) {
                    scope.scrollHeight = element.parent().outerHeight();
                    scope.$digest();
                };

                if (attrs.vOffset || attrs.hOffset) {
                	// Resize event if scroll to be responsive excluding an offset
                	$(window).bind('resize', function () {
                        scope.scrollHeight = $window.innerHeight - parseInt(attrs.vOffset);
                        scope.$digest();
                        $timeout(function () {
                			if (attrs.vOffset) {
                				if (element.closest('.modal').length > 0) {
                					var modalHeight = element.closest('.modal').height();
                					element.closest('.modal').css('top', window.innerHeight / 2 - modalHeight / 2 + 'px');
                				}
                			}
                		});
                	});
                }
                attrs.$observe('vOffset', function (newVal) {
                    scope.scrollHeight = $window.innerHeight - parseInt(newVal);
                });
                scope.$on('scrollTopToBottom', function (event, args) {
                    element.find('.scrollbar-outer').animate({ scrollTop: args }, "slow");
                });

                var onScrollHEnd = $parse(attrs.onScrollHEnd);
                var onScrollHToTop = $parse(attrs.onScrollHToTop);
                var onScrollHInProgress = $parse(attrs.onScrollHInProgress);

                var eleWidth = element.css('width');
                scope.scrollWidth = parseInt(eleWidth) ? eleWidth : '100%';

                attrs.$observe('width', function (value) {
                	if (value) {
                		if (angular.isFunction(onScrollHEnd) || angular.isFunction(onScrollHToTop)) {
                			scrollConfig.onScroll = function (y, x) {
                				if (x.maxScroll > 0 && x.scroll == x.maxScroll && angular.isFunction(onScrollHEnd)) {
                					onScrollHEnd(scope, { e: "" });
                			}
                				if (x.scroll == 0 && angular.isFunction(onScrollHToTop)) {
                					onScrollHToTop(scope, { e: "" });
                				}
                				else if (x.maxScroll > x.scroll > 0 && angular.isFunction(onScrollHInProgress)) {
                					onScrollHInProgress(scope, { e: "" });
                			}
                		};
                	};
                		scope.scrollWidth = value;
                }
                });

                attrs.$observe('connectScrolls', function (value) {
                	if (value) {
                		var value = JSON.parse(value),
                			scrollTopSourceStorage = 0;

                		scrollConfig.onScroll = function (y, x) {
                			var $vSource = $('.' + value.vSource),
							$vSourceP = $vSource.parent().parent(),
							$hSource = $('.' + value.hSource),
							$hSourceP = $hSource.parent().parent(),
							$vertical = $('.' + value.vertical),
							$verticalP = $vertical.parent().parent(),
                			$horizontal = $('.' + value.horizontal);

                			var sourceHeight = $vSource.height();
                			var scrollTopSource = $vSourceP.scrollTop(),
                			scrollTopConnect = $verticalP.scrollTop();

                			if (scrollTopSource > scrollTopSourceStorage) {
                				if (scrollTopSource > scrollTopConnect) {
                					$verticalP.scrollTop(scrollTopSource);
                				}
                			}
                			else if (scrollTopSource < scrollTopSourceStorage) {
                				if (scrollTopSource < scrollTopConnect) {
                					$verticalP.scrollTop(scrollTopSource);
                				}
                			}
                			else {
                				var scrollLeft = $hSourceP.scrollLeft();
                				$horizontal.scrollLeft(scrollLeft);
                			}
                			scrollTopSourceStorage = scrollTopSource;
                			angular.element('.fixeddd').hide();
                		};
					}
                });

                function dateHideOnScroll(e) {
                    element.find("input.datepicker").each(function (i, el) {
                        var dobj = $(el).data("daterangepicker");
                        if (dobj && dobj.isShowing) {
                            dobj.hide()
                        }
                    });
                }
                //Cleaning floating elements on scroll
                var lastOpenSelectDD;
                function cleanFloatingElements(e) {
                    element.find("[id^=typeahead-]").each(function (i, el) {
                        var autoComplete = $(this).data().autocomplete;
                        if (autoComplete && autoComplete.visible) {
                            autoComplete.hide();
                        }
                    });
                    /* close select-dropdown */
                    var $selectDd = $window.lastOpenedDropdownConfig;
                    if ($selectDd && $selectDd != lastOpenSelectDD && $selectDd.origin.hasClass('select-dropdown')) {
                        $selectDd.origin.trigger('close');
                    }
                    lastOpenSelectDD = $selectDd;
                }
                //End of cleaning floating elements on scroll
                var lockScrollObser = false;
                attrs.$observe("lockScroll", function (a) {
                    if (!lockScrollObser) {
                        lockScrollObser = true;
                        $timeout(ls.bind(this, a));
                    } else {
                        ls(a);
                    }
                });

                function ls(a) {
                    if (a) {
                        var $scroller = element.find(".scroll-content");
                        if (a == "true") {
                            $scroller.data("scrolltop", $scroller.scrollTop());
                            $scroller.get(0).addEventListener("scroll", lockScroll, true);
                            if (onScrollLockUnlock) {
                                onScrollLockUnlock(scope, { e: 'locked' });
                                scope.$digest();
                            }
                        } else if (a == "false") {
                            $scroller.get(0).removeEventListener("scroll", lockScroll, true);
                            if (onScrollLockUnlock) {
                                onScrollLockUnlock(scope, { e: 'unLocked' });
                                scope.$digest();
                            }
                        }
                }
				
                };
                //Cleaning floating elements on scroll
                function cleanFloatingElements(e) {
                	element.find("[id^=typeahead-]").each(function (i, el) {
                		var autoComplete = $(this).data().autocomplete;
                		if (autoComplete && autoComplete.visible) {
                			autoComplete.hide();
                		}
                	});
                }
            	//End of cleaning floating elements on scroll
                function lockScroll(e) {
                    var st = $(this).data("scrolltop");
                    this.scrollTop = st;
                    e.stopPropagation();
                    return false;
                };

                var scrollOnUpdate = {
                        handlers: [],
                        addHandlers: function (func) {
                            this.handlers.push(func);
                        }
                    };

                scrollConfig.onUpdate = function () {
                    var _this = this,
                        _arguments = arguments;

                    scrollOnUpdate.handlers.forEach(function (func) {
                        if (typeof func === "function") {
                            func.apply(_this, _arguments);
                        }
                    });
                };

                scrollOnUpdate.addHandlers(function (y, x) {
                    if (y.closest('.modal.noTransform').length > 0) {
                        var modalHeight = y.closest('.modal').height();
                        y.closest('.modal').css('top', window.innerHeight / 2 - modalHeight / 2 + 'px');
                    }
                });

                var scrollToElement,
                    scrollToElementName;
                if (attrs.scrollToElement) {

                    scrollOnUpdate.addHandlers(function (y, x) {
                        var $scrollToElementName = y.find(scrollToElementName.content);
                        if (scrollToElementName && scrollToElementName.status && $scrollToElementName.length) {
                            y.animate({ scrollTop: (($scrollToElementName.offset().top - y.children('div').offset().top) - 10) }, "slow");
                        }
                    });

                    scrollToElement = attrs.$observe('scrollToElement', function (value) {
                        scrollToElementName = attrs.scrollToElement && JSON.parse(attrs.scrollToElement);
                    });
                }

                setTimeout(function () {
                    var scrollWrapper = angular.element('#' + scope.scrollid);
                    var mergedConfig = angular.merge(scrollConfig, customConfig);
                    scrollWrapper.scrollbar(mergedConfig);

                	//Fixed header on scroll
                    var scrlTop;
                    scrollWrapper.scroll(function (e) {
                        var _this = $(this),
                            currScrlTop = _this.scrollTop(),
                            dir;

                        if (isFixedHeader) {
                            scope.fixedHeader(e);
                        } else if (isScrollDate) {
                            dateHideOnScroll(e);
                        }
                        if (attrs.scrollBreakPoints) {
                            if (currScrlTop > scrlTop) {
                                dir = "upward";
                            } else if (currScrlTop < scrlTop) {
                                dir = "downward";
                            };
                            scrollBreakPoints(currScrlTop, dir);
                        }
                        cleanFloatingElements(e);
                        scrlTop = currScrlTop;
                    });
                    scrlTop = scrollWrapper.scrollTop();

                    // for ie update the icon inside the smartscroll
                    var ua = window.navigator.userAgent, use = scrollWrapper.find('use');
                    if (ua.indexOf('MSIE') !== undefined || ua.indexOf('Trident/') !== undefined || ua.indexOf('Edge/') !== undefined) {
                        if (use.length > 0) {
                            use.each(function () {
                                var _this = angular.element(this), currentItem = _this.attr("xlink:href");
                                _this.attr("xlink:href", "").attr("xlink:href", currentItem);
                    });

                        }
                    }
                });

                scope.$on('$destroy', function () {
                    if (scrollToElement) {
                        scrollToElement();
                    }
                });
            },
            templateUrl: 'shared/directives/uiElements/smartScroll/smartScrollTemplate.html'
        };
    }]);
})();


(function () {
    'use strict';
    angular.module('SMART2').directive('smartLazyLoad', function () {
        return {
            restrict: 'A',
            scope: {
                smartLazyLoad: '&'
            },
            link: function (scope, element, attrs) {
                var scrollElement = element.closest('.scrollbar-outer');
                scrollElement.scroll(function () {
                    if (this.scrollTop + this.offsetHeight >= this.scrollHeight) {
                        scope.$apply(function () {
                            scope.smartLazyLoad();
                        });
                    }
                });
            }
        }
    });
})();
(function() {
    'use strict';
    
    angular.module('SMART2').directive('smartPlaceholder', ['$translate', 'ScrollTo', function ($translate, ScrollTo) {
        return {
            restrict: 'A',
            replace: true,
            link: function (scope, element, attrs) {
                window.activePlaceholder = element;
				var tmpPlaceholder = getHTMLPlaceholder(scope);
                element.addClass((!scope.property.isMandatory ? 'optionalField ' : '') + ((scope.property.attributes.readonly ? 'readOnlyField' : '')));
                element.find('.smart-ph-label').html('<span>' + $translate.instant(scope.property.label) + '</span>');
                element.find('.smart-ph-value').html('<span>' + tmpPlaceholder + '</span>');
                element.attr('title', tmpPlaceholder);
				
				if (tmpPlaceholder != '') {
                    element.find('.smart-ph-label').addClass('active');
                }

                if (scope.property.attributes.disable || scope.property.attributes.readonly) {
                    element.find('.smart-ph-value').addClass('disabled');
                }
                else {
                    element.attr('tabindex', 0);
                }
				
                var onAttributesChange = scope.$watchGroup(['property.attributes.disable', 'property.attributes.readonly', 'model.' + scope.property.data, 'property.validate', 'property.focus'], function (newVal, oldVal) {
					//	disable and readonly change listener
					if(!angular.equals(newVal[0], oldVal[0]) || !angular.equals(newVal[1], oldVal[1])) {
					    if (newVal[0] || newVal[1]) {
					        element.find('.smart-ph-value').addClass('disabled');
					        element.attr('tabindex', -1);
					    }
					    else {
					        element.find('.smart-ph-value').removeClass('disabled');
					        element.attr('tabindex', 0);
					    }
					}
					
					//	data change listener
					if(!angular.equals(newVal[2], oldVal[2])) {
						tmpPlaceholder = getHTMLPlaceholder(scope);
						element.find('.smart-ph-value').html('<span>' + tmpPlaceholder + '</span>');
						element.attr('title', tmpPlaceholder);
						if (tmpPlaceholder != '') {
							element.find('.smart-ph-label').addClass('active');
						}
						else {
						    element.find('.smart-ph-label').removeClass('active');
						}
					}

                    //	validate change listener
					if (!angular.equals(newVal[3], oldVal[3])) {
					    if (scope.property.validate) {
					        if ((angular.isUndefined(scope.property.attributes.readonly) || scope.property.attributes.readonly == false) &&
                                (angular.isUndefined(scope.property.attributes.disable) || scope.property.attributes.disable == false)) {
					            validate();
					        }
					        scope.property.validate = false;
					    }
					}

                    //	focus change listener
					if (!angular.equals(newVal[4], oldVal[4])) {
					    if (scope.property.focus) {
					        ScrollTo.perform(element, angular.element('#' + scope.formWidgetId));
					        scope.onFocus();
					        scope.property.focus = false;
					    }
					}
                });

                var validate = function () {
                    var model = eval('scope.model.' + scope.property.data);
                    var error;

                    if(scope.property.isMandatory) {
                        if ((scope.property.attributes.type === 'text' || angular.isUndefined(scope.property.attributes.type)) && (angular.isUndefined(model) || model == null || model.trim() == '')) {
                            error = $translate.instant("enterValueErrMsg");
                        }
                        else if (scope.property.attributes.type == 'autocomplete' && (angular.isUndefined(model) || model == null || model == '' || (model && model.hasOwnProperty('value') && model.value.trim() == ''))) {
                            error = $translate.instant("enterValueErrMsg");
                        }
                        else if (scope.type == 'number' && isNaN(scope.ngModel)) {
                            error = $translate.instant("enterNumberErrMsg");
                        }
                    }

                    if (angular.isUndefined(error) && scope.property.rules) {
                        var rules = scope.property.rules;

                        for (var i = 0; i < rules.length; i++) {
                            if (typeof rules[i] == 'object') {
                                if (eval((rules[i].rule).replace(/this/g, model))) {
                                    error = rules[i].error;
                                    break;
                                }
                            }
                        }
                    }

                    if (error) {
                        element.find('.smart-ph-label').addClass('active');
                        element.find('.smart-ph-value').addClass('invalid');
                        element.find('.smart-ph-error').html(error);
                        //scope.$parent.errorMessage = error;
                    }
                    else {
                        element.find('.smart-ph-value').removeClass('invalid');
                        element.find('.smart-ph-error').html('');
                        if (tmpPlaceholder == '') {
                            element.find('.smart-ph-label').removeClass('active');
                        }
                        //scope.$parent.errorMessage = undefined;
                    }
                };

                //validate();
                
                scope.onFocus = function (e) {
                    if (scope.property.attributes.disable || scope.property.attributes.readonly) {
                        return;
                    }
                    scope.$parent.isPreviewMode = false;
                };

                scope.onRemoveButtonClick = function (e) {
                    scope.property.isVisible = !scope.property.isVisible;
                    e.stopPropagation();
                };

                scope.$parent.onEditableRender = function (editableScope, editableEle) {
                    editableEle.find('input').focus();
                    editableEle.find('input').select();
                    element.attr('tabindex', -1);
                    if (this.errorMessage) {
                        editableEle.find('input').addClass('invalid');
                        editableEle.find('label').attr('data-error', this.errorMessage);
                        this.errorMessage = undefined;
                    }
                };

                scope.$parent.onStopEdit = function (editableScope, editableEle) {
                    this.isPreviewMode = true;
                    if (editableScope.errorMessage != undefined || editableScope.errorMessage != null) {
                        this.errorMessage = editableScope.errorMessage;
                        setTimeout(function () {
                            window.activePlaceholder.find('.smart-ph-label').addClass('active');
                            window.activePlaceholder.find('.smart-ph-value').addClass('invalid');
                            window.activePlaceholder.find('.smart-ph-error').html(editableScope.errorMessage);
                        });
                    }
                };

                scope.$on('$destroy', function () {
                    onAttributesChange();
                });
            },
            templateUrl: 'shared/directives/uiElements/smartSection/smartPlaceholderTemplate.html'
        };
    }]);

	
	var setPrecisionLimits = function (number, decimalPrecision, minMaxPrecision) {
        if (number != undefined) {
            var arr = (number.toString()).split('e')
            if (arr.length > 1 && parseInt(arr[1]) < 0) {
                number = (number).toFixed(6);
            }
            var tempArr = number.toString().split('.');
            if (tempArr != undefined && tempArr.length > 1) {
                var preDecimal = tempArr[0];
                if (preDecimal != 0 && preDecimal.toString().length > 20) {
                    var tempVal = preDecimal.toString().substring(0, 19);
                    number = parseInt(tempVal);
                }
            }
            else {
                if (number != 0 && number.toString().length > 20) {
                    var tempVal = number.toString().substring(0, 19);
                    number = parseInt(tempVal);
                }
            }
            if (decimalPrecision != undefined) {
                number = parseFloat(parseFloat(number).toFixed(decimalPrecision));
            }
            else if (minMaxPrecision !== undefined && minMaxPrecision !== '') {
                var splitPrecision = JSON.parse(minMaxPrecision);
                if (splitPrecision.length > 2 || splitPrecision.length < 1) {
                    //	don't do anything
                }
                else {
                    var lowerPrecisionLimit = splitPrecision[0];
                    var highPrecisionLimit = splitPrecision[1];

                    var postDecimalNumbers = ((number + "").split(".")[1] != undefined) ? (number + "").split(".")[1].length : 0;

                    if (postDecimalNumbers == 0) {
                        //	don't do anything
                    }
                    else if (lowerPrecisionLimit > postDecimalNumbers && postDecimalNumbers < highPrecisionLimit && postDecimalNumbers != 0) {
                        number = parseFloat(parseFloat(number).toFixed(lowerPrecisionLimit));
                    }
                    else if (postDecimalNumbers >= highPrecisionLimit && postDecimalNumbers != 0) {
                        var fixed = Math.pow(10, highPrecisionLimit);
                        number = Math.floor(number * fixed) / fixed;
                    }
                }
            }
        }
        return number;
    };


    var getFormattedDate = function (dateVal, dateFormat, isSetFromGrid) {
        var output = '';
        dateFormat = dateFormat.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
        var isDateBlank = false;
        var doesContainDateString = isSetFromGrid == 'true' ? true : (dateVal + '').toLowerCase().indexOf('date') > -1 ? true : false;

        if (dateVal == "" || dateVal == null) {
            dateVal = Date.now();
            isDateBlank = true;
        }
        else {
            if (doesContainDateString) {
                var tmpModel = (dateVal + '').replace(new RegExp("/", "ig"), '');
                tmpModel = tmpModel.split('+');
                tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + dateVal + '").getTime()') : tmpModel[0]));
                output = moment(tmpModel).format(dateFormat);
            }
            else {
                if (Object.prototype.toString.call(dateVal) !== '[object Date]') {
                    dateVal = parseInt(dateVal);
                }
            }
        }

        if (!isDateBlank) {
            if (!doesContainDateString) {
                output = moment(dateVal).format(dateFormat);
            }
        }
        else {
            output = "";
        }

        return output;
    };

    var getHTMLPlaceholder = function (scope) {
        var placeHolder;
        var tmpModel = eval("scope.model." + scope.property.data);

        switch (scope.property.type) {
            case 'textfield':
                switch (scope.property.attributes.type) {
                    case 'number':
                        placeHolder = setPrecisionLimits(tmpModel, scope.property.attributes.decimalprecision, scope.property.attributes.minmaxprecision);
                        break;

                    case 'date':
                        placeHolder = getFormattedDate(tmpModel, scope.property.attributes.format);
                        break;

                    case 'autocomplete':
                        if (tmpModel == undefined || tmpModel == null || tmpModel == '') {
                            return '';
                        }
                        var str = scope.property.attributes.displayformat, evalResult, evaluatedKeysCounter = 0, nullKeysCounter = 0;
                        try {
                            var parentSplit = str.split('{');
                            for (var j = 0; j < parentSplit.length; j++) {
                                var childSplit = parentSplit[j].split('}');
                                for (var k = 0; k < childSplit.length; k++) {
                                    if (childSplit[k].indexOf('.') > 0 || tmpModel.hasOwnProperty(childSplit[k])) {
                                        evalResult = eval('tmpModel.' + childSplit[k]);
                                        evaluatedKeysCounter++;
                                        if (evalResult == undefined || evalResult == null || (evalResult + '').trim().length == 0) {
                                            evalResult = '';
                                            nullKeysCounter++;
                                        }
                                        str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), evalResult);
                                    }
                                }
                            }
                            if (evaluatedKeysCounter == nullKeysCounter) {
                                str = '';
                            }
                        }
                        catch (e) { }
                        str === undefined || str === null || str === 'undefined' || str === 'null' ? '' : str;
                        placeHolder = str;
                        break;

                    default:
                        placeHolder = eval("scope.model." + scope.property.data);
                        break;
                }
                break;

            case 'dropdown':
            case 'select':
                placeHolder = (eval("scope.model." + scope.property.data + (scope.property.attributes.displaykey ? "." + scope.property.attributes.displaykey : (scope.property.attributes.datakey ? "" + scope.property.attributes.datakey : ""))));
                break;
        }
        return placeHolder == null || placeHolder == undefined ? '' : placeHolder;
    };
	
})();    
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Section
   * @description This directive is useful for creating a section.
   * 
   * @attr {String} label
   *    Label to be displayed on section header. If 'is-header' is set to true, label will be displayed on section header.
   * @attr {Boolean} plain
   *    If set to true, section with no style will be generated
   * @attr {Boolean} is-collapsible
   *    If set to true, section will be collapsible
   * @attr {String} header-template
   *    This attribute is useful for creating sections with custom header templates.
   *    'header-template' is expected to be an URL of a template.
   * @attr {Boolean} is-active
   *    If set to false and if 'is-collapsible' is set to true, section will be displayed in collapsed mode. Default value is true.      
   * @attr {Boolean} is-header
   *    If set to true, section-header will be displayed. Default value is true.
   * 
   * @example
   Dynamic:
   Controller:
       $scope.config = {
            "modelData": {
                "firstName": "Sushant"
            }, 
            "formConfig": {
                "sections": [
                    {
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "First name",
                                        "type": "textfield",
                                        "isMandatory": true,
                                        "data": "firstName"
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
    
   * @example 
   Dynamic: (Section with header)
   Controller:
       $scope.config = {
            "modelData": {
                "firstName": "Sushant"
            }, 
            "formConfig": {
                "sections": [
                    {
                        "label": "Section header",
                        "isHeader": true,
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "First name",
                                        "type": "textfield",
                                        "isMandatory": true,
                                        "data": "firstName"
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

   * @example 
   Dynamic: (Section with custom header-template)
   Controller:
       $scope.config = {
            "modelData": {
                "firstName": "Sushant"
            }, 
            "formConfig": {
                "sections": [
                    {
                        "headerTemplate": "abc.html",
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "First name",
                                        "type": "textfield",
                                        "isMandatory": true,
                                        "data": "firstName"
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

   * @example 
   Dynamic: (Section with collapsible header)
   Controller:
       $scope.config = {
            "modelData": {
                "firstName": "Sushant"
            }, 
            "formConfig": {
                "sections": [
                    {
                        "headerTemplate": "abc.html",
                        "isCollapsible": true,
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "First name",
                                        "type": "textfield",
                                        "isMandatory": true,
                                        "data": "firstName"
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

   * @example
   Static:
   <smart-section>
        Section contents will go here
    </smart-section> 

   * @example
   Static: (Section with header)
   <smart-section label="Section Header" is-header="true">
        Section contents will go here
   </smart-section>

   * @example
   Static: (Section with collpsible header)
   <smart-section is-collapsible="true">
        Section contents will go here
   </smart-section>
        
   * @example
   Static: (Section with header and content place holder)
   <smart-section is-header="true">
        <smart-section-header>
            Section header will go here
        </smart-section-header>
        <smart-section-content>
            Section contents will go here
        </smart-section-content>
    </smart-section>    
   */

(function() {
    'use strict';
    var Textid = 16011982;
    var sectionCounter = 0;
    
    angular.module('SMART2').directive('smartSection', ['$timeout', '$parse', function ($timeout, $parse) {
        return {
            restrict: 'E',
            replace: true,
            transclude: {
                'header': '?smartSectionHeader',
                'body': '?smartSectionBody'
            },
            scope: {
                config: '=?',
                model: '=?',
                label: '@',
                isSequential: '@',
                isMandatory: '@',
                isDraggable: '@',
                parentScope: '=?',
                formWidgetId: '@',
                isCollapsible: '@',
                enableFieldPreview: '@',
                headerTemplate: '@',
                isActive: '=?',
                isHeader: '@',
                plain: '@',
                onClick: '&',
                onHeaderClick: '&',
                revisionMode:'@',
                isSwitchable: '@',
                onClickSwitchable: '&'
            },
            link: function (scope, element, attrs) {
                scope.isSwitchFunc = function () {
                    scope.onClickSwitchable({ "section": scope.config });
                }
               if (attrs.id !== '' || attrs.id !== undefined || attrs.id !== null) {
                    scope.sectionId = attrs.id;
                }
                else {
                    scope.sectionId = 'section-' + sectionCounter;
                    sectionCounter++;
                }

                element.attr('id', scope.sectionId);

                scope.collapsible = scope.$eval(scope.isCollapsible) == true ? true : false;
                scope.active = angular.isUndefined(scope.isActive) || scope.isActive == true ? true : false;
                scope.header = scope.$eval(scope.isHeader) ? true : false;

                if(!scope.collapsible) {
                    scope.active = true;
                }
                else {
                    scope.header = true;
                }

                scope.isCollapsed = scope.active;

                if(!scope.headerTemplate) {
                    scope.headerTemplate = '';
                }
                scope.formLoaderConfig = { bgwhite: true, plain: true, center: true, message: "" };
				/*
				 * Update optional field item
				 */
                var onRowsConfig = scope.$watch('config.rows', function (newConfig) {
                    if(newConfig) {
                        var rowsLen = scope.config.rows.length;
                        for (var j = 0; j < rowsLen; j++) {
                            var propLength = scope.config.rows[j].properties.length;
                            for (var k = 0; k < propLength; k++) {
                                var tData = scope.config.rows[j].properties[k];
                                if (!tData.isMandatory) {
                                    updateOptionalField(tData);
								}
							}
						}
                    }
                }, true);
                    
                var updateOptionalField = function (item) {
                    var optFieldLen = scope.config.optionalFields.length;
                    for (var i = 0; i < optFieldLen; i++) {
                        var tData = scope.config.optionalFields[i];
                        if (item.label == tData.label) {
                            tData.visible = item.isVisible;
							return;
						}
					}
				};


                /*
                 * Get row's visible properties length
                 */
                var getVisiblePropertiesLength = function (rowIndex) {
                    var visiblePropertiesLength = 0,
                        rowsPropLen = scope.config.rows[rowIndex].properties.length;
                    for (var i = 0; i < rowsPropLen; i++) {
                        var tData = scope.config.rows[rowIndex].properties[i];
                        if (tData.isVisible && !tData.isHidden) {
                            visiblePropertiesLength++;
                        }
                    }
                    return visiblePropertiesLength;
                };


                scope.onOptionalFieldClick = function (isLabelClicked, item) {
                    if (isLabelClicked && item.isVisible) {
                        return;
                    }

                    /*
                     *  If row's visible properties length is 0
                     *  then splice the row and push it at the end of section
                     */
                    var tmpRow = scope.config.rows[item.rowIndex],
                        tmpPropIndxData = tmpRow.properties[item.propertyIndex];
                    if (!scope.$eval(scope.isSequential) && getVisiblePropertiesLength(item.rowIndex) == 0) {
                        scope.config.rows.splice(item.rowIndex, 1);
                        scope.config.rows.push(tmpRow);
                        item.rowIndex = scope.config.rows.length - 1;
                    }

                    tmpPropIndxData.isVisible = !tmpPropIndxData.isVisible;

                    /*
                     *  scope.isSequential is set to 'true', form-widget-property would be added 
                     *  where it is positioned in the JSON structure else 
                     *  form-widget-property would be added at the end of row
                     */
                    if (!scope.$eval(scope.isSequential) && tmpPropIndxData.isVisible) {
                        //var tmpProperty = scope.config.rows[item.rowIndex].properties[item.propertyIndex];
                        tmpRow.properties.splice(item.propertyIndex, 1);
                        tmpRow.properties.push(tmpPropIndxData);
                        var rowsPropLength = scope.config.rows[item.rowIndex].properties.length;
                        for (var i = 0; i < rowsPropLength; i++) {
                            var optLength = scope.config.optionalFields.length;
                            for (var j = 0; j < optLength; j++) {
                                if (tmpRow.properties[i].label == scope.config.optionalFields[j].label) {
                                    scope.config.optionalFields[j].propertyIndex = i;
                                }
                            }
                        }
                    }
                    item.visible = !item.visible;
                    //  Expand the section
                    if (item.visible) {
                        var clearMe = setTimeout(function () {
                            expandSection();
                            clearTimeout(clearMe);
                            clearMe = null;
                        }, 250);
                    }
                };

                var isActiveTriggered = false;

                /*
                 * Expand section if isActive is set to true
                 */
                var onIsActive = scope.$watch('isActive', function (newValue) {
                	if (angular.isDefined(newValue) && newValue) {
                		isActiveTriggered = true;
                    	expandSection();
                    	scope.isActive = false;
                    }
                });


                /*
                 * On optional field click listener
                 */
                var onOptionalFieldClick = scope.$on('optionalFieldClick', function (event, args) {
                    try {
                        if (args.item.sectionKey === scope.config.key) {
                            scope.onOptionalFieldClick(args.isLabelClicked, args.item);
                        }
                    }
                    catch(e) {}
                });


                /*
                 *  Expand section
                 */
                var expandSection = function () {
                    var collapsibleHdr = element.find('.collapsible-header');
                    if (!collapsibleHdr.hasClass('active')) {
                        collapsibleHdr.trigger('click');
                    }
                    else if (!collapsibleHdr.hasClass('active')) {
                        collapsibleHdr.trigger('click');
                    }
                };

                var isClicked = false

               var clrTimeout = setTimeout(function () {
                    element.find('.collapsible-header').click(function () {
                    	var ele = this;

                        scope.$evalAsync(function () {
                        	if (isClicked && !isActiveTriggered)
                        		return;
                        	
                        	isClicked = true;
                            scope.isCollapsed = angular.element(ele).hasClass('active');
                            scope.active = scope.isCollapsed;
                            scope.onHeaderClick();
                            scope.onClick();
                        	setTimeout(function () {
                        	    isClicked = false;
                        	}, 500);
                        	isActiveTriggered = false;
                            clearTimeout(clrTimeout);
                            clrTimeout = null;
                        });
                    });
                });

                
                /*
                 *  Expand section on header focus
                 */
                scope.onSectionHeaderFocus = function (e) {
                    if ($(e.target).hasClass('section-header-focuser') && !scope.active) {
                        scope.config.isContentLoaded = true;
                        scope.active = true;
                        //scope.isCollapsed = true;
                        expandSection();
                    }
                    /* in focus for section move on top */
                    var conf = scope.config.key,
                     formwidget = scope.formWidgetId,
                     $itemSelected = $('#' + conf),
                     staticTopmargin = 64; // 64 is subheader height

                    var displacementItem = $itemSelected.offset().top - angular.element('#' + formwidget + '-sortable').offset().top;

                    displacementItem = displacementItem + staticTopmargin;
                    setTimeout(function () {
                        angular.element('body,html').animate({
                            scrollTop: displacementItem
                        }, "medium");
                    }, 200);
                    /* in focus for section move on top end */
                };
                

                /*
                 *  Remove all listeners on scope destroy
                 */
                scope.$on('$destroy', function () {
                    onRowsConfig();
                    onIsActive();
                    onOptionalFieldClick();
                    element.find('.collapsible-header').off('click');
                });
            },
            templateUrl: 'shared/directives/uiElements/smartSection/smartSectionTemplate.html'
        };
    }]);
    
    var angular2BootstrapTimeout;

    angular.module('SMART2').directive('smartSectionItemRenderer', ['$compile', 'formWidgetUtils', '$translate', '$templateCache', '$timeout', function ($compile, formWidgetUtils, $translate, $templateCache, $timeout) {
        return {
            restrict: 'E',
            replace: false,
            link: function (scope, element, attrs) {
                var html = "", commonAttributes;

                if (scope.section) {
                    if (scope.section.controller) {
                        //  Creating dataModel variable so that child controller can access it using $scope.formDataModel
                        scope.formDataModel = scope.$parent.$parent.$parent.modelData;

                        html += '<div ng-controller="' + scope.section.controller + '">';
                    }

                    if (scope.section.isLazyLoadEnabled) {
                        scope.section.isActive = false;
                    }

                    //scope.section.isContentLoaded = !angular.copy(scope.section.isLazyLoadEnabled);

                    //  Section's primary attribute and can be optional
                    scope.extendedSectionConfig = angular.extend({
                        isMandatory: false,
                        isCollapsible: true,
                        isDraggable: false,
                        isHeader: true,
                        isActive: true,
                        isHidden: true,
                        isSwitchable: false,
                        isFieldPreviewEnabled: false,
                        isSectionDisable: false,
                        isLazyLoadEnabled: false,
                        headerTemplate: ''
                    }, scope.section);

                    scope.section.isLoading = true;
                    scope.section.isContentLoaded = false; // !angular.copy(scope.section.isLazyLoadEnabled);

                    var cancelTOut = $timeout(function () {
                        scope.section.isLoading = false;
                        scope.section.isContentLoaded = !angular.copy(scope.section.isLazyLoadEnabled);
                        $timeout.cancel(cancelTOut);
                        cancelTOut = null;
                    }, scope.$index * 500);

                    commonAttributes = ' label="{{section.label | translate}}" config="section" model="modelData" plain="{{section.plain}}" is-sequential="{{isSequential}}" ' + formWidgetUtils.getAttributesMapping('primary', scope.extendedSectionConfig, scope, true) + ' parent-scope="' + (scope.section.controller ? '$parent.$$childTail' : '$parent.$parent.$parent.$parent') + '" form-widget-id="{{formWidgetId}}" ';

                    commonAttributes += "revision-mode=" + ((!scope.revisionMode || scope.revisionMode == "false") ? "'false'" : "'true'"); // added for revision mode

                    html += '<smart-section id=' + scope.formWidgetId + '-section-' + scope.$index + ' ' + (scope.enableFieldPreview ? ' enable-field-preview="true" ' : ' ') + commonAttributes + formWidgetUtils.mapEvents([
                        { type: 'on-click', listener: 'onSectionClick(section)' },
                        // { type: 'on-header-click', listener: formWidgetUtils.generateFunctionWithParams(scope.section.onHeaderClick, '$parent.$parent.$parent.$parent', true) },
                        { type: 'on-header-click', listener: 'onSectionHeaderClick(section)' },
                          { type: 'on-click-switchable', listener: formWidgetUtils.generateFunctionWithParams(scope.section.onClickSwitchable, '$parent.$parent.$parent.$parent', true) }
                    ]) + '></smart-section>';

                    if (scope.section.controller) {
                        html += '</div>';
                    }
                }
                else {
                    var ngModelMapping, optionsMapping;


                    if (scope.property.type == 'subsection') {
                        ngModelMapping = 'model-data="model.' + scope.property.data + '"' + 'form-model="model"';
                    }
                    else if (scope.property.type == 'dropdown') {
                        ngModelMapping = 'ng-model="model.' + scope.property.data + '"';
                        if (angular.isDefined(scope.property.optionsData))
                            optionsMapping = 'options="model.' + scope.property.optionsData + '"';
                    }
                    else {
                        ngModelMapping = 'ng-model="model.' + scope.property.data + '"';

                        try {
                            if (scope.property.attributes.ngModelOptions.getterSetter) {
                                ngModelMapping = 'ng-model="parentScope.' + scope.property.data + '"';
                            }
                        }
                        catch (e) { }
                    }

                    var areaType = false;
                    if (typeof scope.property.attributes != 'undefined' && typeof scope.property.attributes.type != 'undefined' && scope.property.attributes.type == 'area')
                    	areaType = true;

                    commonAttributes = ' class="' + formWidgetUtils.getColspanClass(scope.property.colspan) + (scope.property.type != 'subsection' ? (scope.property.type == 'textfield' && areaType) ? ' area-height-manager' : ' line-height-manager' : '') + '" label="{{property.label | translate}}" focus="' + (typeof scope.property.focus == 'string' ? 'parentScope.' + scope.property.focus : 'property.focus') + '" validate="' + (typeof scope.property.validate == 'string' ? 'parentScope.' + scope.property.validate : 'property.validate') + '" ' + ngModelMapping + ' ' + optionsMapping + ' ' + formWidgetUtils.getAttributesMapping('primary', scope.property, scope) + ' parent-element="{{formWidgetId}}" ' + formWidgetUtils.getAttributesMapping('secondary', scope.property.attributes, scope);

                    switch (scope.property.type) {
                        case 'textfield':
                            var enableFieldPreview = scope.enableFieldPreview == 'true' || scope.enableFieldPreview == true;

                            if (enableFieldPreview) {
                                scope.isPreviewMode = true;
                                html = '<div style="margin-bottom: 15px;" class="' + formWidgetUtils.getColspanClass(scope.property.colspan) + ' input-field" smart-placeholder ng-if="isPreviewMode"></div>';
                            }
                            else {
                                html = '';
                            }

                            html += '<smart-textfield' + (enableFieldPreview ? ' ng-if="!isPreviewMode" ' : ' ') + commonAttributes + formWidgetUtils.mapEvents([
                                { type: 'on-change', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onChange, 'parentScope') },
                                { type: 'on-focus', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onFocus, 'parentScope') },
                                { type: 'on-blur', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onBlur, 'parentScope') },
                                { type: 'on-key-up', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onKeyUp, 'parentScope') },
                                { type: 'on-key-down', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onKeyDown, 'parentScope') },
                                { type: 'on-key-press', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onKeyPress, 'parentScope') },
                                { type: 'on-enter', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onEnter, 'parentScope') },
                                { type: 'on-select', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onSelect, 'parentScope') },
                                { type: 'on-date-change', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onDateChange, 'parentScope') },
                                { type: 'on-destroy', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onDestroy, 'parentScope') }
                            ]) + '></smart-textfield>';
                            break;

                        case 'dropdown':
                        case 'select':
                            html = '<smart-select validate="property.validate" ' + commonAttributes + formWidgetUtils.mapEvents([
                                { type: 'on-change', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onChange, 'parentScope') },
                                { type: 'on-destroy', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onDestroy, 'parentScope') }
                            ]) + '></smart-select>';
                            break;

                        case 'radio':
                            html = '<smart-radio gap="true"' + commonAttributes + formWidgetUtils.mapEvents([
                                { type: 'on-change', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onChange, 'parentScope') },
                                { type: 'on-destroy', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onDestroy, 'parentScope') }
                            ]) + '></smart-radio>';
                            break;

                        case 'checkbox':
                            html = '<smart-checkbox fill="true" min-height="50px" ' + commonAttributes + formWidgetUtils.mapEvents([
                                { type: 'on-change', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onChange, 'parentScope') },
                                { type: 'on-destroy', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onDestroy, 'parentScope') }
                            ]) + '></smart-checkbox>';
                            break;

                        case 'switch':
                            html = '<smart-switch ' + commonAttributes + formWidgetUtils.mapEvents([
                                { type: 'on-change', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onChange, 'parentScope') },
                                { type: 'on-destroy', listener: formWidgetUtils.generateFunctionWithParams(scope.property.onDestroy, 'parentScope') }
                            ]) + '></smart-switch>';
                            break;

                        case 'subsection':
                            /*
                             *  Check if subsection is angular2 enabled i.e. if sub-section should boostrap Angular2 app
                             */
                            if (scope.property.isAngular2Enabled) {
                                html = $templateCache.get(scope.property.templateUrl);
                            }
                            else {
                                /*
                                 *  Convert onLoad function in a way that function name should be converted to subsection controller function
                                 *  and its parameteres should be converted into parent controller's variables
                                 */
                                var onLoadFunction = '';
                                if (scope.property.onLoad == '' || scope.property.onLoad == undefined || scope.property.onLoad == null) {
                                    scope.property.onLoad = '';
                                }
                                if (scope.property.onLoad != '') {
                                    onLoadFunction = formWidgetUtils.generateFunctionWithParams(scope.property.onLoad, 'parentScope');
                                    onLoadFunction = onLoadFunction.replace('parentScope.' + scope.property.onLoad.split('(')[0], '$$$childHead.' + scope.property.onLoad.split('(')[0]);
                                    onLoadFunction = onLoadFunction.replace(',property', '');
                                }
                                html = '<smart-subsection class="' + formWidgetUtils.getColspanClass(scope.property.colspan) + ' padding0" controller="{{property.controller}}" init="{{property.init}}" template-url="{{property.templateUrl}}" parent-scope="parentScope" widget-scope="parentScope.$parent.$parent.$parent"' + commonAttributes + formWidgetUtils.mapEvents([
                                    { type: 'on-load', listener: onLoadFunction }
                                ]) + '></smart-subsection>';
                            }
                            break;

                        case 'revision':
                            var revisionAttrs = [
                                "class = '" + formWidgetUtils.getColspanClass(scope.property.colspan) + "'",
                                "label='{{::property.label | translate}}'",
                                "old-data='::property.attributes.oldData'",
                                "new-data='::property.attributes.newData' ng-if='::property.label'"
                            ].join(" ");
                            html = '<smart-revision '+ revisionAttrs +'></smart-revision>';
                            break;
                    }
                }
                element.html(html);

                if (scope.property && scope.property.isAngular2Enabled) {
                    if (angular2BootstrapTimeout) {
                        clearInterval(angular2BootstrapTimeout);
                        angular2BootstrapTimeout = undefined;
                    }
                    angular2BootstrapTimeout = setInterval(function () {
                        //  Angular2 app is ready to be bootstrapped
                        if (window.SmartAngular2) {
                            window.SmartAngular2.bootstrap();
                            clearInterval(angular2BootstrapTimeout);
                        }
                    }, 250);
                }
                else {
                    $compile(element.contents())(scope);
                }
            }
        };
    }]);


    //angular.module('SMART2').directive('smartSectionPreview', ['$compile', '$translate', function ($compile, $translate) {
    //    return {
    //        restrict: 'AE',            
    //        scope: false,
    //        link: function (scope, element, attrs) {
    //            var html = "";
    //            var config = scope.$parent.config;
    //            var model = scope.$parent.model;
                

    //            function getObjectValue(field, model, dataKey)
    //            {
    //                if (field.type)
    //                {
    //                    switch (field.type)
    //                    {
    //                        case 'textfield':
    //                            if (field.attributes.type)
    //                            {
    //                                if (field.attributes.type == 'autocomplete') {
    //                                    var obj = eval("model." + field.data);
    //                                    if (obj)
    //                                    {
    //                                        if (field.attributes.displayformat.indexOf('-') > -1)
    //                                        {
    //                                            var splittedDisplayFormat = field.attributes.displayformat.split('-');
    //                                            var result = "";
    //                                            for (var i = 0; i < splittedDisplayFormat.length; i++) {
    //                                                result += eval("obj." + splittedDisplayFormat[i].replace('{', '').replace('}', ''));
    //                                                if (i < splittedDisplayFormat.length - 1)
    //                                                    result += '--';
    //                                            }
    //                                            return (result ? result : '--');
    //                                        }
    //                                        var tVal = eval("obj." + field.attributes.displayformat.replace('{', '').replace('}', ''));
    //                                        return (tVal ? tVal : '--');
    //                                    }
    //                                    return '--'; //eval("model." + field.data + "." + field.attributes.displayformat.replace('{', '').replace('}', ''));
    //                                }
    //                                else if (field.attributes.type == 'date') {
    //                                    return getFormatedDate( eval("model." + field.data ), field.attributes.format);
    //                                }
    //                            }
    //                            var tVal = eval("model." + field.data);
    //                            return (tVal ? tVal : '');
    //                            break;
    //                        case 'dropdown':
    //                            var obj = eval("model." + field.data);
    //                            if (obj) {
    //                                if (field.attributes.datakey.indexOf('-') > -1) {
    //                                    var splittedDisplayFormat = field.attributes.datakey.split('-');
    //                                    var result = "";
    //                                    for (var i = 0; i < splittedDisplayFormat.length; i++) {
    //                                        result += eval("obj." + splittedDisplayFormat[i].replace('{', '').replace('}', ''));
    //                                        if (i < splittedDisplayFormat.length - 1)
    //                                            result += '--';
    //                                    }
    //                                    return result;
    //                                }
    //                                var tVal = eval("obj." + field.attributes.datakey.replace('{', '').replace('}', ''));
    //                                return (tVal ? tVal : '--');
    //                            }
    //                            return '--';
    //                            break;
    //                        case 'subsection':
    //                            var obj = eval("model." + field.data);
    //                            if (obj) {
    //                                if (dataKey) {
    //                                    if (dataKey.indexOf('-') > -1) {
    //                                        var splittedDisplayFormat = dataKey.split('-');
    //                                        var result = "";
    //                                        for (var i = 0; i < splittedDisplayFormat.length; i++) {
    //                                            result += eval("obj." + splittedDisplayFormat[i].replace('{', '').replace('}', ''));
    //                                            if (i < splittedDisplayFormat.length - 1)
    //                                                result += '--';
    //                                        }
    //                                        return result;
    //                                    }
    //                                    var tVal = eval("obj." + dataKey.replace('{', '').replace('}', ''));
    //                                    return (tVal ? tVal : '--');
    //                                }
    //                            }
    //                            return '--';
    //                            break;
    //                        default:
    //                            return eval("model." + field.data)
    //                            break;
                                
    //                    }
    //                }
    //                return eval("model." + field.data)
    //            }


    //            function getFormatedDate(dateObj, dateFormate) {
    //                dateFormate = dateFormate.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
    //               return moment(dateObj).format(dateFormate);
    //                //var tmpModel = (stringdate + '').replace(new RegExp("/", "ig"), '');
    //                // tmpModel = tmpModel.split('+');
    //                // tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + tmpModel.join('+') + '").getTime()') : tmpModel[0]));
    //                //return moment(tmpModel).format(dateFormate);
    //            }
    //            function GetFieldLabel(field, model)
    //            {
                   
    //                return $translate.instant(field.label);
    //            }

    //            for (var i = 0; i < config.rows.length; i++)
    //            {
                   
    //                html+= "<div class=\"row\" > <div class=\"col s12\" >";
    //                var row = config.rows[i];
    //                for (var j = 0; j < row.properties.length; j++)
    //                {
    //                    Textid++;
    //                    var field = row.properties[j];
    //                    if (field.isVisible && !field.isHidden) {
    //                        if (field.type) {
    //                            if (field.type == 'subsection')
    //                            {
    //                                if (field.attributes) {
    //                                    if (field.attributes.previewData) {
    //                                        for (var x = 0; x < field.attributes.previewData.length; x++) {
    //                                            Textid++;
    //                                            var previewField = field.attributes.previewData[x];
    //                                            html += "<div class=\"col s12 m6 l4 xl3 xxl2 line-height-manager input-field\" ><div class=\"elements-include\">" +
    //                                           "<input type=\"text\"  id=\"txt-" + Textid + "\" class=\"left-align ng-not-empty\" value=\"" + getObjectValue(field, model, previewField.data) + "\" readonly=\"readonly\" disabled />" +
    //                                           "<label  id=\"label-for-txt-" + Textid + "\"  for=\"txt-" + Textid + "\" class=\"active\" >" + GetFieldLabel(previewField, model) + "</label></div></div>";
    //                                        }
    //                                    }
    //                                }
    //                            }
    //                            else
    //                            {
    //                                html += "<div class=\"col s12 m6 l4 xl3 xxl2 line-height-manager input-field\" ><div class=\"elements-include\">" +
    //                               "<input type=\"text\"  id=\"txt-" + Textid + "\" class=\"left-align ng-not-empty\" value=\"" + getObjectValue(field, model) + "\" readonly=\"readonly\" disabled />" +
    //                               "<label  id=\"label-for-txt-" + Textid + "\"  for=\"txt-" + Textid + "\" class=\"active\" >" + GetFieldLabel(field, model) + "</label></div></div>";
    //                            }
    //                        } else {
    //                            html += "<div class=\"col s12 m6 l4 xl3 xxl2 line-height-manager input-field\" ><div class=\"elements-include\">" +
    //                                "<input type=\"text\"  id=\"txt-" + Textid + "\" class=\"left-align ng-not-empty\" value=\"" + getObjectValue(field, model) + "\" readonly=\"readonly\" disabled />" +
    //                                "<label  id=\"label-for-txt-" + Textid + "\"  for=\"txt-" + Textid + "\" class=\"active\" >" + GetFieldLabel(field, model) + "</label></div></div>";
    //                        }
    //                    }
    //                    }
    //                    html+="</div></div>";


    //            }



    //            element.html(html);              
    //            //$compile(element.contents())(scope);
                
    //        }
    //    };
    //}]);


    //angular.module('SMART2').directive('smartFieldPreview', ['$compile', '$translate', function ($compile, $translate) {
    //    return {
    //        restrict: 'AE',
    //        scope: false,
    //        link: function (scope, element, attrs) {
    //            var config = scope.config;
    //            var localScope = scope;

    //            if (config.attributes) {
    //                var unbinedWatcher = scope.$watch(config.attributes.previewWatch, function (val) {
    //                    if (val) {
    //                        if (config.isVisible) {
    //                            var obj = localScope;
    //                            var html = "";
    //                            var fields = config.attributes.previewData;
    //                            if (fields) {
    //                                for (var x = 0; x < fields.length; x++) {
    //                                    Textid++;
    //                                    var previewField = fields[x];
    //                                    var lbl = $translate.instant(previewField.label);
    //                                    var val = eval('obj.$parent.' + previewField.data);
    //                                    if (!val) {
    //                                        val = '--';
    //                                    }
    //                                    html += "<div class=\"col s12 m6 l4 xl3 xxl2 line-height-manager input-field\" ><div class=\"elements-include\">" +
    //                                   "<input type=\"text\"  id=\"txt-" + Textid + "\" class=\"left-align ng-not-empty\" value=\"" + val + "\" readonly=\"readonly\" disabled />" +
    //                                   "<label  id=\"label-for-txt-" + Textid + "\"  for=\"txt-" + Textid + "\" class=\"active\" >" + lbl + "</label></div></div>";
    //                                }
    //                                //Textid++;
    //                                //html += "<div class=\"col s12 m6 l4 xl3 xxl2 line-height-manager input-field\" ><div class=\"elements-include\">" +
    //                                //"<input type=\"text\"  id=\"txt-" + Textid + "\" class=\"left-align ng-not-empty\" value=\"" + val + "\" readonly=\"readonly\" disabled />" +
    //                                //"<label  id=\"label-for-txt-" + Textid + "\"  for=\"txt-" + Textid + "\" class=\"active\" >" + scope.$parent.label + "</label></div></div>";

    //                                element.html(html);
    //                            }
    //                        }
    //                        unbinedWatcher();
    //                    }
    //                });
    //            }
    //        }

    //    };
    //}]);

})();    
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Select
   * @description This directive is useful for creating a select ui element.
   * 
   * @attr {String} label
   *    Label to be displayed for identification of this ui element
   * @attr {Array} options
   *    Number of options to be created
   * @attr {Var} ng-model
   *    Default selected option. Please refer example for more details.
   * @attr {Object} ng-model-options
   *    https://docs.angularjs.org/api/ng/directive/ngModelOptions. 
   *    <a href="SMART2.Textfield.html">Click here</a> and scoll down to 'Textfield with ng-model-options' to see example reference.
   * @attr {String} datakey
   *    ng-model variable will be updated on the basis of this property. datakey will be used to display an option when displaykey is not set.
   * @attr {String} displaykey
   *    A property of an option to be used to display an option
   * @attr {Boolean} disable
   *    If set to true, none of the options can be selected
   * @attr {Boolean} focus 
   *    If set to true, this ui element will be focused
   * @attr {Boolean} validate
   *    If set to true, this ui element will be validated on the basis of rules passed to it
   * @attr {Array} rules 
   *    Rules to be evaluated when this element's blur event is fired. A rule must have 'rule' and 'errorMessage' properties (keys).
   *    'rule' must be a condition or group of conditions. 'errorMessage' will be the message to be displayed when corresponding rule fails. See example for more.
   * @attr {String} error-message 
   *    Error message to be displayed. This attribute can be set at any point to display an error message.
   * @attr {Boolean} is-mandatory 
   *    If set to true, default error message will be displayed when blur event is fired and this ui element is left blank
   * @attr {Boolean} is-visible 
   *    If set to true, this ui element will be displayed on form regardless of 'is-mandatory' property's value. 
   *    This ui element can be removed from form by clicking 'x' button on top right corner of this ui element.
   * @attr {Number} colspan
   *    Number of columns to be occupied by this ui element. 1 column is equal to 1 ui element.
   *    Default value is 1.
   *    For e.g. If colspan is set to 2, this ui element will occupy width of 2 ui elements (fields).
   * @attr {Function} on-change
   *    Callback function when option is changed
   * 
   * @example
   Dynamic:
   Controller:
       $scope.config = {
            "modelData": {
                "currency": { "code": "", "name": "EUR" }
            }, 
            "formConfig": {
                "sections": [
                    {
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "Currency",
                                        "type": "dropdown",      //  select will also work
                                        "isMandatory": true,
                                        "data": "currency",
                                        "colspan": 1,
                                        "onChange": "onChange",  //  controller function
                                        "attributes": {
                                            "options": [{
                                                "code": "$",
                                                "name": "USD"
                                            }, {
                                                "code": "",
                                                "name": "EUR"
                                            }],
                                            "datakey": "name"
                                        },
                                        "rules": [
                                            { 
                                                "rule": "this.title == \"Option 2\"", 
                                                "error": "Invalid selection" 
                                            }
                                        ]
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

   * @example
   Static:
   Controller:
       $scope.currencyOptions = [{
            "code": "$",
            "name": "USD"
       }, {
           "code": "",
           "name": "EUR"
       }];
       $scope.selectedCurrency = { "code": "", "name": "EUR" };
       $scope.onChange = function(selectedCurrency) {
           console.log(selectedCurrency);
       };
   Usage:
       <smart-select label="Currency" ng-model="selectedCurrency" options="currencyOptions" on-change="onChange(selectedCurrency)"></smart-select> 

   * @example
   Select with disabled state:
   <smart-select label="Currency" ng-model="selectedCurrency" options="currencyOptions" datakey="name" disable="true"></smart-radio> 

   * @example
   Select with ng-model as 'String' (In following example, when an option is selected, ng-model would be either '$' or ''):
   Controller:
       $scope.currencyOptions = [{
            "code": "$",
            "name": "USD"
       }, {
           "code": "",
           "name": "EUR"
       }];
       $scope.selectedCurrency = "$";
       $scope.onChange = function(selectedCurrency) {
           console.log(selectedCurrency);
       };
   Usage:
       <smart-select label="Currency" ng-model="selectedCurrency" options="currencyOptions" datakey="code" displaykey="name" on-change="onChange(selectedCurrency)"></smart-select> 

   * @example
   Select with disabled option:
   Controller:
       $scope.currencyOptions = [{
            "code": "$",
            "name": "USD",
            "disable": true
       }, {
           "code": "",
           "name": "EUR"
       }];
       $scope.selectedCurrency = { "code": "", "name": "EUR" };
       $scope.onChange = function(selectedCurrency) {
           console.log(selectedCurrency);
       };
   Usage:
       <smart-select label="Currency" ng-model="selectedCurrency" options="currencyOptions" datakey="name" on-change="onChange(selectedCurrency)"></smart-select> 
   */

(function() {
    'use strict';
    var selectId = 0;
    angular.module('SMART2').directive('smartSelect', ['$timeout', '$window', '$translate', 'ScrollTo', 'RuleEngine','smartSelectService',
         (typeof isDirectiveV2enabled !== 'undefined' ? (isDirectiveV2enabled() == true ? smartSelectFunc2 : smartSelectFunc1) : smartSelectFunc1)
    ]);

    function smartSelectFunc1($timeout, $window, $translate, ScrollTo, RuleEngine) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                label: '@',
                options: '=?',
                ngModelCopy: '=?ngModel',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                onChange: '&',
                disable: '@',
                multiple: '@',
                datakey: '@',
                displaykey: '@',
                removable: '@',
                preview: '@',
                customoption: '@',
                showinfo: '@',
                showwarning: '@',
                customMessage: '@'
            },
            link: function (scope, element, attrs, ngModelCtrl) {
                //debugger;
                var options, isNgModelWatchAdded = false;
                var onNgModel = function () { };
                scope.selectOptions = [];
                var typeOfNgModel;

                var isNgModelFunction = typeof scope.ngModelCopy == 'function';

                // create unique id
                selectId = selectId + 1;
                scope.dropDownId = "dropdown-" + selectId;

                // key to be used to bind options
                scope.dataKey = scope.datakey ? scope.datakey : 'title';
                scope.displayKey = scope.displaykey ? scope.displaykey : scope.dataKey;

                /*
                 *  Following code has been added to make ng-model-options work
                 *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                 */
                if (isNgModelFunction) {
                    try {
                        ngModelCtrl.$render = function () {
                            scope.ngModel = ngModelCtrl.$modelValue;
                            scope.selectedOption = scope.ngModel;
                        };
                    }
                    catch (e) { }
                }

                var updateView = function () {
                    if (isNgModelFunction) {
                        try {
                            ngModelCtrl.$setViewValue(scope.ngModel);
                        }
                        catch (e) { }
                    }
                };
                /*
                 * Check if new option is added
                 */
                //scope.customOption = 
                scope.labelVal = "";
                scope.customOptionReset = false;
                var onOptions = scope.$watch('options', function (newOptions) {
                    if (!newOptions) {
                        return;
                    }
                    var optLen = newOptions.length;
                    if (newOptions && optLen > 0) {
                        //if (scope.label && newOptions[0][scope.dataKey] != scope.label) {
                        var selLabel;
                        if (scope.label) {
                            selLabel = scope.label;
                        } else {
                            selLabel = $translate.instant('chooseOptionMsg');
                        }
                        var isDisabledOpt = true;
                        if (scope.customoption) {
                            selLabel = scope.customoption;
                            isDisabledOpt = false;
                            scope.customOptionReset = true;
                        }
                        if (scope.dataKey === scope.displayKey) {
                            options = [{ title: selLabel, disable: isDisabledOpt, id: 'fakeOptionId' }].concat(newOptions);
                            options[0][scope.displayKey] = options[0].title;
                        }
                        else {
                            var firstOption = { disable: isDisabledOpt, id: 'fakeOptionId' };
                            firstOption[scope.dataKey] = selLabel;
                            firstOption[scope.displayKey] = selLabel;
                            options = [firstOption].concat(newOptions)
                        }

                        //if (scope.$eval(scope.isMandatory)) {
                        //    options = newOptions;
                        //}
                        //else {

                        //    options = [{ title: selLabel, disable: false, id: 'fakeOptionId' }].concat(newOptions);
                        //    options[0][scope.displayKey] = options[0].title;
                        //}
                        //}
                        //else {
                        //    options = newOptions;
                        //}
                    }
                    else {
                        return;
                    }

                    var optionGroups = [],
                        oldOptLen = options.length;

                    for (var i = 0; i < oldOptLen; i++) {
                        if (options[i].hasOwnProperty('groupName') && optionGroups.indexOf(options[i].groupName) == -1) {
                            optionGroups.push(options[i].groupName);
                        }
                    }

                    //if (optionGroups.length > 0) {
                    //    options.splice(0, 1);
                    //}

                    scope.optionGroups = angular.copy(optionGroups);

                    scope.selectOptions = options;

                    //if (!scope.selectedOption) {
                    //    scope.selectedOption = options[0];
                    //}

                    //try {
                    //    scope.selectedOptionString = angular.copy(scope.selectedOption[scope.dataKey]);
                    //}
                    //catch (e) { }

                    if (!isNgModelWatchAdded) {
                        onNgModel = scope.$watch(isNgModelFunction ? 'ngModel' : 'ngModelCopy', function (newVal) {
                            if (angular.isUndefined(typeOfNgModel) && (newVal !== '' && newVal != undefined && newVal != null)) {
                                typeOfNgModel = typeof newVal;
                            }
                            var newValueCopy;

                            if (typeOfNgModel == 'string' || typeOfNgModel == 'number') {
                                for (var i = 0; i < oldOptLen; i++) {
                                    if (newVal == options[i][scope.dataKey]) {
                                        newValueCopy = options[i];
                                        break;
                                    }
                                }
                            }
                            else {
                                newValueCopy = newVal;
                            }
                            scope.selectedOption = angular.copy(newValueCopy);

                            try {
                                if (!scope.selectedOption) {
                                    scope.selectedOption = angular.copy(options[0]);
                                } else if (!scope.selectedOption[scope.displayKey]) {
                                    scope.selectedOption = angular.copy(options[0]);
                                }
                                scope.selectedOptionString = angular.copy(scope.selectedOption[scope.dataKey]);
                                if (options[0] != scope.selectedOption[scope.dataKey]) {
                                    scope.labelVal = scope.selectedOption[scope.dataKey];
                                    if (scope.customoption && scope.customoption != scope.selectedOption[scope.dataKey]) {
                                        scope.customOptionReset = false;
                                    }
                                }
                            }
                            catch (e) { }

                            var tOut = setTimeout(function () {
                                var el = angular.element("#" + scope.dropDownId);
                                el.material_select();
                                el.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                                    if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                    setTimeout(function () {
                                        var $dropdownDiv = el.parent().find(".dropdown-content.select-dropdown.active"),
                                            listElOffset;
                                        $dropdownDiv.scrollTop(0);
                                        listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                            return obj[scope.dataKey]== scope.ngModelCopy[scope.dataKey];
                                        }))).offset();
                                        if (listElOffset) {
                                            $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                        }
                                      }, 0);
                                   }
                                });
                                //el.parent().find("input.select-dropdown").bind("close", function () {
                                //    var _this = $(this);
                                //  scope.ngChange(_this.val());
                                //});
                                clearTimeout(tOut);
                                tOut = null;
                            });
                            // selectFixdd();

                        }, true);

                        isNgModelWatchAdded = true;
                    }
                    else { //If options are changes dynamically then again .material_select() will fired to update latest options in materialize select.
                        var selectTout = setTimeout(function () {
                            angular.element("#" + scope.dropDownId).material_select();
                            element.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                                if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                    setTimeout(function () {
                                        var $dropdownDiv = element.parent().find(".dropdown-content.select-dropdown.active"),
                                        listElOffset;
                                        $dropdownDiv.scrollTop(0);
                                        listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                            return obj[scope.dataKey] == scope.ngModelCopy[scope.dataKey];
                                        }))).offset();
                                        if (listElOffset) {
                                            $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                        }
                                    }, 0);
                                            }
                            });
                            clearTimeout(selectTout);
                            selectTout = null;
                        });
                    }
                    var disableTOut = setTimeout(function () {
                        var el = angular.element("#" + scope.dropDownId);
                        el.children().eq(0).attr("disabled", "disabled");
                        el.material_select();
                        el.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                            if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                setTimeout(function () {
                                    var $dropdownDiv = el.parent().find(".dropdown-content.select-dropdown.active"),
                                            listElOffset;
                                    $dropdownDiv.scrollTop(0);
                                    listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                        return obj[scope.dataKey] == scope.ngModelCopy[scope.dataKey];
                                    }))).offset();
                                    if (listElOffset) {
                                        $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                    }
                                }, 0);
                            }
                        });
                        // el.parent().find("input.select-dropdown").bind("close", function () {
                        //    var _this = $(this);
                        //    scope.ngChange(_this.val());
                        //});
                        clearTimeout(disableTOut);
                        disableTOut = null;
                    });

                    // selectFixdd();

                    /*   function selectFixdd() {
                           setTimeout(function () {
                               if (scope.$eval(attrs.fixed)) {
                                   $(element).find('input.select-dropdown').bind('focus', function (e) {
                                       (function ($t) {
                                           setTimeout(function () {
                                               $(element).find('.dropdown-content').addClass('fixeddd');
                                               var topOffset = $(e.target).offset().top - $(window).scrollTop();
                                               var ddCnt = $t.next('.dropdown-content');
                                               ddCnt.css({
                                                   'left': $(e.target).offset().left + 'px', 'top': topOffset + 'px'
                                               });
                                               ddCnt.attr('style', function (i, s) { return s + 'display: block !important;' });

                                               var ddHgt = ddCnt.css('height'),
                                                   winHgt = angular.element(window).height();
                                               if ((parseInt(ddHgt) + topOffset) > winHgt) {
                                                   var diffHgt = (parseInt(ddHgt) + topOffset) - winHgt;
                                                   ddCnt.css('top', (topOffset - diffHgt - 15) + 'px');
                                               }

                                               angular.element($window).on("scroll.smartFixedSmartSelect", function () {
                                                   if (ddCnt.hasClass('active'))
                                                       ddCnt.hide();
                                               });
                                           });
                                       })($(this));
                                   });
                               }
                           }, 500);
                       }
                       */
                }, true);

                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);


                /*
                 * Watch needs to be added on disable since element needs to be updated
                 */
                var sOption = scope.label;
                var onDisable = scope.$watch('disable', function (newVal) {
                    var isDisableTout = setTimeout(function () {
                        var el = angular.element("#" + scope.dropDownId);
                        el.material_select();
                        element.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                            if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                    setTimeout(function() {
                                        var $dropdownDiv = element.parent().find(".dropdown-content.select-dropdown.active"),
                                            listElOffset;
                                        $dropdownDiv.scrollTop(0);
                                        listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                            return obj[scope.dataKey]== scope.ngModelCopy[scope.dataKey];
                                    }))).offset();
                                        if (listElOffset) {
                                            $dropdownDiv.scrollTop(listElOffset.top -$dropdownDiv.offset().top);
                                            }
                                            }, 0);
                            }
                        });
                        el.parent().find("input.select-dropdown").bind("close", function () {
                            /*var _this = $(this);
                            if (scope.ngModelCopy != _this.val()) {
                                scope.ngModelCopy = {
                                    title: _this.val()
                                };
                                scope.ngModelCopy[scope.dataKey] = _this.val();
                            }*/
                            scope.validateRules()
                        });
                        clearTimeout(isDisableTout);
                        isDisableTout = null;
                    });
                });



                /*
                 * Focus field when focus is set to true
                 */
                var onFocus = scope.$watch('focus', function (newVal) {
                    if (newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        scope.focus = false;
                    }
                });

                /*
                 * Validate field whene validate is set to true
                 */
                var onValidate = scope.$watch('validate', function (newValue) {
                    if (newValue != undefined && newValue) {
                        scope.validateRules();
                    }
                });

                /*
                 * Validate rules
                 */
                scope.validateRules = function () {
                    //debugger;
                    scope.validate = false;
                    scope.errorMessage = null;
                    if (scope.$eval(scope.isMandatory) && scope.label) {
                        if (!scope.ngModelCopy || scope.ngModelCopy.name === scope.label || (scope.customoption && scope.ngModelCopy.name === scope.customoption) || scope.ngModelCopy[scope.dataKey] === scope.label) {
                            scope.validate = true;
                            scope.errorMessage = scope.customMessage ? scope.customMessage : $translate.instant("selectOptionErrMsg");
                            return;
                        }
                    }
                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false,
                            ruleLength = rules.length;

                        for (var i = 0; i < ruleLength; i++) {
                            if (typeof rules[i] == 'object') {
                                if (eval((rules[i].rule).replace(/this/g, 'scope.selectedOption'))) {
                                    scope.validate = true;
                                    scope.errorMessage = rules[i].error;
                                    break;
                                }
                            } else {
                                if (!isFoundInvalid) {
                                    RuleEngine.isValid(rules[i], function (e) {
                                        scope.validate = true;
                                        scope.errorMessage = e.errorData.error;
                                        isFoundInvalid = true;
                                    });
                                }
                                else {
                                    break;
                                }
                            }

                        }
                    }
                };
                var ch = false;
                scope.ngChange = function (selectedOption, manual) {
                    if (!manual) ch = true;
                    sOption = selectedOption;
                    if (selectedOption == scope.customoption) {
                        scope.customOptionReset = true;
                        //options[0][scope.dataKey] = scope.label;
                    }
                    else {
                        scope.customOptionReset = false;
                    }

                    var tmpSelectedOption;
                    if (!scope.$eval(scope.isMandatory) && selectedOption == options[0][scope.displayKey] && scope.optionGroups.length == 0) {
                        tmpSelectedOption = '';
                    }
                    else {
                        var optLen = options.length;
                        for (var i = 0; i < optLen; i++) {
                            if (options[i][scope.dataKey] == selectedOption) {
                                tmpSelectedOption = options[i];
                                break;
                            }
                        }
                    }
                    if (isNgModelFunction) {
                        if (typeOfNgModel == 'string' || typeOfNgModel == 'number') {
                            scope.ngModel = tmpSelectedOption[scope.dataKey];
                        }
                        else {
                            scope.ngModel = tmpSelectedOption;
                        }
                    }
                    else {
                        if (typeOfNgModel == 'string' || typeOfNgModel == 'number') {
                            if (!scope.$eval(scope.isMandatory) && (selectedOption == options[0][scope.displayKey] || selectedOption == undefined || selectedOption == 'fakeOptionId')) {
                                scope.ngModelCopy = '';
                            }
                            else {
                                scope.ngModelCopy = tmpSelectedOption[scope.dataKey];
                            }
                        }
                        else {
                            scope.ngModelCopy = tmpSelectedOption;
                        }
                    }
                    scope.labelVal = "";
                    if (selectedOption == scope.label && selectedOption == options[0][scope.displayKey]) {
                        scope.labelVal = selectedOption;
                    }
                    updateView();
                    scope.selectedOption = tmpSelectedOption == '' ? options[0] : angular.copy(tmpSelectedOption);
                    scope.validateRules();
                    var clrTout = $timeout(function () {
                        scope.onChange();
                        $timeout.cancel(clrTout);
                        clrTout = null;
                    });
                };


                scope.$on('$destroy', function () {
                    angular.element("#" + scope.dropDownId).material_select('destroy');
                    onOptions();
                    onDisable();
                    onNgModel();
                    onFocus();
                    onValidate();
                    angular.element($window).off("scroll.smartFixedSmartSelect");
                });
            },
            templateUrl: 'shared/directives/uiElements/smartSelect/smartSelectTemplate.html'
        };
    }

    
    function smartSelectFunc2($timeout, $window, $translate, ScrollTo, RuleEngine, smartSelectService) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                label: '@',
                options: '=?',
                ngModelCopy: '=?ngModel',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                onChange: '&',
                disable: '@',
                multiple: '@',
                datakey: '@',
                displaykey: '@',
                removable: '@',
                preview: '@',
                customoption: '@',
                showinfo: '@',
                showwarning: '@',
                clienterror: '=?',
                customMessage: '@'
            },
            compile: function() {
                return {
                    post: function (scope, element, attrs, ngModelCtrl) {
                        $(document).ready(function () {// To avoid flicker and timeout
                            // Declare all the vars at the top
                            var options = [],
                                isNgModelWatchAdded = false,
                                 onNgModel = function () { },
                                 typeOfNgModel,
                                isNgModelFunction = typeof scope.ngModelCopy == 'function';

                            scope.selectOptions = [];
                            // create unique id
                            selectId = selectId + 1;
                            scope.dropDownId = "dropdown_" + selectId;
                            // key to be used to bind options
                            scope.dataKey = scope.datakey ? scope.datakey : 'title';
                            scope.displayKey = scope.displaykey ? scope.displaykey : scope.dataKey;

                            /*
                             *  Following code has been added to make ng-model-options work
                             *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                             */
                            if (isNgModelFunction) {
                                try {
                                    ngModelCtrl.$render = function () {
                                        scope.ngModel = ngModelCtrl.$modelValue;
                                        scope.selectedOption = scope.ngModel;
                                    };
                                }
                                catch (e) { }
                            }
                            var updateView = function () {
                                if (isNgModelFunction) {
                                    try {
                                        ngModelCtrl.$setViewValue(scope.ngModel);
                                    }
                                    catch (e) { }
                                }
                            };
                            /*
                             * Check if new option is added
                             */
                            scope.labelVal = "";
                            scope.customOptionReset = false;

                            //To be triggered if option binding is delayed
                            function watchOptions(a_options) {
                                var optLen = a_options.length;
                                if (a_options && optLen > 0) {
                                    var selLabel,
                                        isDisabledOpt = true;
                                    if (scope.label) {
                                        selLabel = scope.label;
                                    } else {
                                        selLabel = $translate.instant('chooseOptionMsg');
                                    }

                                    if (scope.customoption) {
                                        selLabel = scope.customoption;
                                        isDisabledOpt = false;
                                        scope.customOptionReset = true;
                                    }
                                    if (scope.dataKey === scope.displayKey) {
                                        options = [{ title: selLabel, disable: isDisabledOpt, id: 'fakeOptionId' }].concat(a_options);
                                        options[0][scope.displayKey] = options[0].title;
                                    }
                                    else {
                                        var firstOption = { disable: isDisabledOpt, id: 'fakeOptionId' };
                                        firstOption[scope.dataKey] = selLabel;
                                        firstOption[scope.displayKey] = selLabel;
                                        options = [firstOption].concat(a_options)
                                    }
                                    scope.selectOptions = options;
                                    var optionGroups = [],
                                        len = options.length;
                                    for (var i = 0; i < len; i++) {
                                        var tmp = options[i];
                                        if (tmp.hasOwnProperty('groupName') && optionGroups.indexOf(tmp.groupName) == -1) {
                                            optionGroups.push(tmp.groupName);
                                        }
                                    }
                                    scope.optionGroups = angular.copy(optionGroups);
                                    watchModel();
                                    smartSelectService.buildOptionsList(scope.optionGroups, scope.selectOptions,scope,element);
                                } else {
                                    return;
                                };

                            }

                            // This function watches the selected value from the 
                            // dropdown and triggers on selection change
                            function watchModel() {
                                if (!isNgModelWatchAdded) {
                                    onNgModel = scope.$watch(isNgModelFunction ? 'ngModel' : 'ngModelCopy', function (newVal) {
                                        if (angular.isUndefined(typeOfNgModel) && (newVal !== '' && newVal != undefined && newVal != null)) {
                                            typeOfNgModel = typeof newVal;
                                        }
                                        var newValueCopy;
                                        if (typeOfNgModel == 'string' || typeOfNgModel == 'number') {
                                            var len = options.length;
                                            for (var i = 0; i < len; i++) {
                                                var tmp = options[i];
                                                if (newVal == tmp[scope.dataKey]) {
                                                    newValueCopy = tmp;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (typeOfNgModel == 'object') {
                                            scope.ngModel = newValueCopy = newVal;
                                        }
                                        else {
                                            newValueCopy = newVal;
                                        }
                                        scope.selectedOption = angular.copy(newValueCopy);

                                        try {
                                            if (!scope.selectedOption) {
                                                scope.selectedOption = angular.copy(options[0]);
                                            } else if (!scope.selectedOption[scope.displayKey]) {
                                                scope.selectedOption = angular.copy(options[0]);
                                            }
                                            scope.selectedOptionString = angular.copy(scope.selectedOption[scope.dataKey]);
                                            if (options[0] != scope.selectedOption[scope.dataKey]) {
                                                scope.labelVal = scope.selectedOption[scope.dataKey];
                                                if (scope.customoption && scope.customoption != scope.selectedOption[scope.dataKey]) {
                                                    scope.customOptionReset = false;
                                                }
                                            }
                                        }
                                        catch (e) { }
                                        smartSelectService.buildOptionsList(scope.optionGroups, scope.selectOptions, scope, element);
                                        smartSelectService.updateLabelTemplate(scope, element);// added for update the label
                                        angular.element("#" + scope.dropDownId).material_select();
                                        element.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                                            if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                                setTimeout(function () {
                                                    var $dropdownDiv = element.parent().find(".dropdown-content.select-dropdown.active"),
                                                        listElOffset;
                                                    $dropdownDiv.scrollTop(0);
                                                    listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                                        return obj[scope.dataKey] == scope.ngModelCopy[scope.dataKey];
                                                    }))).offset();
                                                    if (listElOffset) {
                                                        $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                                    }
                                                }, 0);
                                            }
                                        });
                                        //selectFixdd();
                                        element.parent().find("input.select-dropdown").bind("close", function () {
                                            scope.validateRules()
                                        }); 
                                    });
                                    isNgModelWatchAdded = true;

                                } else { //If options are changes dynamically then again .material_select() will fired to update latest options in materialize select.
                                   var clrTout = setTimeout(function () {
                                       angular.element("#" + scope.dropDownId).material_select();
                                       element.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                                           if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                            setTimeout(function () {
                                                var $dropdownDiv = element.parent().find(".dropdown-content.select-dropdown.active"),
                                        listElOffset;
                                                $dropdownDiv.scrollTop(0);
                                                listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                                    return obj[scope.dataKey] == scope.ngModelCopy[scope.dataKey];
                                                }))).offset();
                                                if (listElOffset) {
                                                    $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                                }
                                            }, 0);
                                               }
                                        });
                                        element.parent().find("input.select-dropdown").bind("close", function () {
                                            scope.validateRules()
                                        });
                                        clearTimeout(clrTout);
                                        clrTout = null;
                                    });
                                }
                            }

                            //watchOptions(scope.options); // onload data binding
                            //To update value incase of late binding
                            var collectionWatch = scope.$watchCollection('options', function (newValue) {
                                if (newValue) {
                                    watchOptions(newValue);
                                }
                            });

                            /*function selectFixdd() {
                                if (attrs.fixed) {
                                    $(element).find('input.select-dropdown').bind('focus', function (e) {
                                        (function ($t) {
                                            var drpContent = $(element).find('.dropdown-content').addClass('fixeddd');
                                            var topOffset = $(e.target).offset().top - $(window).scrollTop();
                                            var ddCnt = $t.next('.dropdown-content');
                                            ddCnt.css({
                                                'left': $(e.target).offset().left + 'px', 'top': topOffset + 'px'
                                            });
                                            ddCnt.attr('style', function (i, s) { return s + 'display: block !important;' });

                                            var ddHgt = ddCnt.css('height'),
                                                winHgt = angular.element(window).height();
                                            if ((parseInt(ddHgt) + topOffset) > winHgt) {
                                                var diffHgt = (parseInt(ddHgt) + topOffset) - winHgt;
                                                ddCnt.css('top', (topOffset - diffHgt - 15) + 'px');
                                            }

                                            angular.element($window).on("scroll.smartFixedSmartSelect", function () {
                                                if (ddCnt.hasClass('active'))
                                                    ddCnt.hide();
                                            });
                                            drpContent = null;
                                        })($(this));
                                    });
                                }
                            }
                            */
                            scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

                            /*
                             * Watch needs to be added on disable since element needs to be updated
                             */
                            var sOption = scope.label;
                            // Use watchgroup to watch all
                            //Below declerations are to make watchGroup work on models
                            scope.disable = (scope.disable) ? scope.disable : 1;
                            scope.validate = (scope.validate) ? scope.validate : 2;
                            var watchGrp = scope.$watchGroup(['disable', 'validate', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
                                if (newVal[0] !== oldVal[0]) {
                                    var el = angular.element("#" + scope.dropDownId);
                                    if ((scope.disable === true && scope.disable !== 1) || (jQuery.type(scope.disable) === "string" && (scope.disable === "true"))) {
                                        el.prop('disabled', 'disabled');
                                        el.prop("readonly", true);
                                        el.attr('tabindex', -1);
                                        el.material_select();
                                        el.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                                            if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                                setTimeout(function () {
                                                    var $dropdownDiv = el.parent().find(".dropdown-content.select-dropdown.active"),
                                            listElOffset;
                                                    $dropdownDiv.scrollTop(0);
                                                    listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                                        return obj[scope.dataKey] == scope.ngModelCopy[scope.dataKey];
                                                    }))).offset();
                                                    if (listElOffset) {
                                                        $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                                    }
                                                }, 0);
                                            }
                                        });
                                        el.parent().find("input.select-dropdown").bind("close", function () {
                                            scope.validateRules()
                                        });
                                    }else
                                    {
                                        el.prop('disabled', false);
                                        el.prop("readonly", false);
                                        el.removeAttr('tabindex');
                                    }
                                    angular.element("#" + scope.dropDownId).material_select();
                                    element.parent().find("input.select-dropdown").off("openSelectList").on("openSelectList", function () {
                                        if (this.value !== '' && this.value !== void 0 && this.value !== null) {
                                        setTimeout(function () {
                                            var $dropdownDiv = element.parent().find(".dropdown-content.select-dropdown.active"),
                                                listElOffset;
                                            $dropdownDiv.scrollTop(0);
                                            listElOffset = $dropdownDiv.find("li").eq(_.indexOf(scope.selectOptions, scope.selectOptions.find(function (obj) {
                                                return obj[scope.dataKey] == scope.ngModelCopy[scope.dataKey];
                                            }))).offset();
                                            if (listElOffset) {
                                                $dropdownDiv.scrollTop(listElOffset.top - $dropdownDiv.offset().top);
                                            }
                                        }, 0);
                                    }
                                    });
                                }
                                if (newVal[1] !== oldVal[1] || newVal[2] !== oldVal[2]) {
                                    scope.validateRules();
                                }
                                if (newVal[3] != oldVal[3] || newVal[4] != oldVal[4]) {
                                    if (scope.showinfo || scope.showwarning) {
                                        element.addClass('field-has-icon');
                                    }
                                    else {
                                        element.removeClass('field-has-icon');
                                    }
                                }
                            });

                            var onFocus = scope.$watch('focus', function (newVal) {
                                if (newVal) {
                                    ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                                    scope.focus = false;
                                    var clrMe = setTimeout(function () {
                                        element.find('input').focus();
                                        clearTimeout(clrMe);
                                        clrMe = null;
                                    }, 1000);
                                }
                            });

                            /*
                            * Validate rules
                            */
                            scope.validateRules = function () {
                                scope.validate = false;
                                scope.errorMessage = null;
                                if (scope.$eval(scope.isMandatory) && scope.label && !scope.clienterror) {
                                    if (!scope.ngModelCopy || scope.ngModelCopy.name === scope.label || (scope.customoption && scope.ngModelCopy.name === scope.customoption) || scope.ngModelCopy[scope.dataKey] === scope.label) {
                                        scope.validate = true;
                                        scope.errorMessage = scope.customMessage ? scope.customMessage : $translate.instant("selectOptionErrMsg");
                                        // return;
                                    }
                                }
                                if (scope.clienterror) {
                                    scope.validate = true;
                                    scope.errorMessage = $translate.instant("clientErrMsg");
                                }
                                if (scope.rules && !scope.clienterror) {
                                    var rules = scope.$eval(scope.rules);
                                    var isFoundInvalid = false,
                                        len = rules.length;

                                    for (var i = 0; i < len; i++) {
                                        var tmp = rules[i];
                                        if (typeof tmp == 'object') {
                                            if (eval((tmp.rule).replace(/this/g, 'scope.selectedOption'))) {
                                                scope.validate = true;
                                                scope.errorMessage = tmp.error;
                                                break;
                                            }
                                        } else {
                                            if (!isFoundInvalid) {
                                                RuleEngine.isValid(tmp, function (e) {
                                                    scope.validate = true;
                                                    scope.errorMessage = e.errorData.error;
                                                    isFoundInvalid = true;
                                                });
                                            }
                                            else {
                                                break;
                                            }
                                        }

                                    }
                                }
                                var containerElm = element;
                                var validateElm = $(element).find('#' + scope.dropDownId + '_validate');
                                if (scope.validate == true && scope.errorMessage != null) {

                                    if (!containerElm.hasClass('invalid')) {
                                        containerElm.addClass('invalid');
                                        
                                    }

                                    if (validateElm.length > 0) {
                                        validateElm.html(scope.errorMessage);
                                    }
                                    else {
                                        containerElm.append(smartSelectService.buildValidationTemplate(scope));
                                        validateElm = $(element).find('#' + scope.dropDownId + '_validate');
                                        validateElm.html(scope.errorMessage);
                                    }

                                }
                                else {
                                    if (containerElm.hasClass('invalid')) {
                                        containerElm.removeClass('invalid');
                                    }

                                    if (validateElm.length > 0) {
                                        validateElm.remove();
                                    }

                                }
                            };

                            scope.hideShowField = function () {
                                scope.isVisible = !scope.isVisible;
                            };

                            var onSelectChange = function (elm) {
                                if (scope.selectOptions && scope.selectOptions.length>0) {
                                    var selectedOption;
                                    var selectedVal = elm.target.options[elm.target.options.selectedIndex].value;// elm.find(":selected").val();

                                    selectedOption = selectedVal;

                                    sOption = selectedOption;
                                    if (selectedOption == scope.customoption) {
                                        scope.customOptionReset = true;
                                    }
                                    else {
                                        scope.customOptionReset = false;
                                    }

                                    var tmpSelectedOption;
                                    if (!scope.$eval(scope.isMandatory) && selectedOption == options[0][scope.displayKey] && scope.optionGroups.length == 0) {
                                        tmpSelectedOption = '';
                                    }
                                    else {
                                        var len = options.length;
                                        for (var i = 0; i < len; i++) {
                                            if (typeof options[i][scope.dataKey] == 'string') {
                                                if (options[i][scope.dataKey].replace(/&quot;/g, '"') == selectedOption) {
                                                    tmpSelectedOption = options[i];
                                                    break;
                                                }
                                            }
                                            else {
                                                if (options[i][scope.dataKey] == selectedOption) {
                                                    tmpSelectedOption = options[i];
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (isNgModelFunction) {
                                        if (typeOfNgModel == 'string' || typeOfNgModel == 'number') {
                                            scope.ngModel = tmpSelectedOption[scope.dataKey];
                                        }
                                        else {
                                            scope.ngModel = tmpSelectedOption;
                                        }
                                    }
                                    else {
                                        if (typeOfNgModel == 'string' || typeOfNgModel == 'number') {
                                            if (!scope.$eval(scope.isMandatory) && (selectedOption == options[0][scope.displayKey] || selectedOption == undefined || selectedOption == 'fakeOptionId')) {
                                                scope.ngModelCopy = '';
                                            }
                                            else {
                                                scope.ngModelCopy = tmpSelectedOption[scope.dataKey];
                                            }
                                        }
                                        else {
                                            scope.ngModelCopy = tmpSelectedOption;
                                            scope.ngModel = scope.ngModelCopy;
                                        }
                                    }
                                    scope.labelVal = "";
                                    if (selectedOption == scope.label && selectedOption == options[0][scope.displayKey]) {
                                        scope.labelVal = selectedOption;
                                    }
                                    updateView();                                    
                                    $(element).find('#' + scope.dropDownId + '_label').html(scope.label);

                                    scope.selectedOption = tmpSelectedOption == '' ? options[0] : angular.copy(tmpSelectedOption);
                                    scope.validateRules();
                                   var cancelTout =  $timeout(function () {
                                        scope.$apply();
                                        scope.onChange();
                                        $timeout.cancel(cancelTout);
                                        cancelTout = null;
                                    });
                                }
                            };

                            smartSelectService.buildTemplate(scope, element, onSelectChange);
                            if (scope.clienterror) {
                                scope.validateRules();
                            }

                            scope.$on('$destroy', function () {
                                angular.element("#" + scope.dropDownId).material_select('destroy');
                                collectionWatch();
                                watchGrp();
                                angular.element($window).off("scroll.smartFixedSmartSelect");
                                $(element).find('input.select-dropdown').unbind('focus');
                                $(element).find('input.select-dropdown').unbind('close');
                            });
                            setTimeout(function(){
                             if(scope.label != '' && scope.label != undefined)
                                 $(element).find('#' + scope.dropDownId + '_label').html(scope.label);
                            },0)
                        });
                    }
                }

            }
        }
    }

    angular.module('SMART2').factory('smartSelectService', ['ScrollTo', 'RuleEngine', '$templateCache', '$compile', smartSelectServiceFunc])
    function smartSelectServiceFunc(ScrollTo, RuleEngine, $templateCache, $compile) {

        var buildOptionalFieldTemplate = function (scope) {
            if ((scope.isMandatory!= undefined && scope.isMandatory=='false') && scope.isRemovable == true) {
                var optionalField = $templateCache.get('shared/directives/uiElements/smartSelect/smartSelectOptionalFieldTemplate.html');
                optionalField = optionalField.replace('{{id}}', scope.dropDownId + '_opField');
                return optionalField;
            }
            return '';
        };
        var buildSelectTemplate = function (scope) {
            var html = $templateCache.get('shared/directives/uiElements/smartSelect/smartSelectOptionTemplate.html');
            html = html.replace('{{id}}', scope.dropDownId);
            return html;
        };
        var buildValidationTemplate = function (scope) {
            var html = $templateCache.get('shared/directives/uiElements/smartSelect/smartSelectValidationTemplate.html');
            html = html.replace('{{id}}', scope.dropDownId + '_validate');
            return html;
        };
        var updateLabelTemplate = function (scope, element) {
            var elmLabel = element.find('#' + scope.dropDownId + '_label');
            if (scope.label != scope.labelVal) {
                elmLabel.removeClass('ng-hide');
            } else {
                elmLabel.addClass('ng-hide');

            }
        };
        var buildLabelTemplate = function (scope) {
            if (scope.label && scope.label != scope.labelVal) {
                var html = $templateCache.get('shared/directives/uiElements/smartSelect/smartSelectLabelTemplate.html');
                html = html.replace('{{id}}', scope.dropDownId + '_label');
                html = html.replace('{{dropDownId}}', scope.dropDownId);
                html = html.replace('{{label}}', scope.label);
                html = html.replace('{{title}}', scope.label);
                return html;
            } else {
                return '';
            };
        };
        var buildInfoTemplate = function (scope) {
            var html = $templateCache.get('shared/directives/uiElements/smartSelect/smartSelectInfoTemplate.html');;
            //if (scope.showinfo || scope.showwarning) {
                
            //    html = $templateCache.get('shared/directives/uiElements/smartSelect/smartSelectInfoTemplate.html');
            //}
            return html;
        };


        var buildTemplate = function (scope,element, onChangeCallback) {
            var container = element // $('<div/>', { id: scope.dropDownId + '_container' });
            
            var css = 'input-field';
            if ((scope.isMandatory == 'false') && scope.isRemovable == true) {
                css += ' optionalField line-height-manager';
            }
            if (scope.preview === true) {
                css += ' selectPreview';
            }
            if (!scope.customoption) {
                css += ' defaultSelected';
            }
            if (scope.validate === true && scope.errorMessage) {
                css += ' invalid';
            }
            if (scope.showinfo || scope.showwarning){
                css += ' field-has-icon'
            }
            if (scope.showinfo && scope.showwarning) {
                css += ' field-has-two-icons'
            }
            
            container.attr("id", scope.dropDownId + '_container').addClass(css);

            container.append(buildOptionalFieldTemplate(scope));
            container.append(buildLabelTemplate(scope));
            container.append(buildSelectTemplate(scope));
            container.append(buildValidationTemplate(scope));
            container.append($compile(buildInfoTemplate(scope))(scope));
            //if (scope.showinfo || scope.showwarning) {
            //    container.append($compile(buildInfoTemplate(scope))(scope));
            //}

            element.append(container);
            var elm = $(element).find('#' + scope.dropDownId);
            elm.bind("change", function (el) {
                //console.log(el);
                onChangeCallback(el);
            });
            var optionalField = $(element).find('#' + scope.dropDownId + '_opField > i');
            if (typeof optionalField != 'undefined' && optionalField.length > 0)
            {
                optionalField.bind("click", scope.hideShowField);

            }

            if (scope.disable === 'true' || scope.disable === true) {
                elm.prop("readonly", true);
                elm.attr("disabled", "disabled");
                elm.attr('tabindex', -1);
            }

        };

        var buildOptionsList = function (OptionGroups, options,scope,element) {
            var optHtml = '',
                optionLength = options.length;
            if (OptionGroups && OptionGroups.length > 0) {

            }
            else {
                if (options && optionLength > 0 && scope.dataKey === scope.displayKey) {
                    angular.forEach(options, function (option) {
                        var selected = '';
                        if (angular.equals(option, scope.selectedOption) || angular.equals(scope.ngModel, option) || angular.equals(scope.ngModelCopy, option) || angular.equals(option[scope.dataKey], scope.selectedOptionString)) {
                            selected = ' selected="selected"';
                        }
                        //if (option.name == scope.label) {
                        //    $(element).find('#' + scope.dropDownId + '_label').html('');                            
                        //}
                        optHtml += '<option value="' + option[scope.dataKey] + '"  ' + (option.disable ? 'disabled="disabled"' : '') + ' ' + selected + '>' + option[scope.displayKey] + '</option>'
                    });
                } else if (options && optionLength > 0 && scope.dataKey !== scope.displayKey) {
                    angular.forEach(options, function (option) {
                        var selected = '';
                        if (angular.equals(option, scope.selectedOption) || angular.equals(scope.ngModel, option) || angular.equals(scope.ngModelCopy, option) || angular.equals(option[scope.dataKey], scope.selectedOptionString)) {
                            selected = ' selected="selected"';
                        }
                        optHtml += '<option value="' + option[scope.dataKey] + '"  ' + (option.disable ? 'disabled="disabled"' : '') + ' ' + selected + '>' + option[scope.displayKey] + '</option>'
                    });
                }
            }

            if (options[0][scope.datakey] == scope.label && options[0].disable && scope.datakey == 'title' && (!scope.selectedOption || options[0] == scope.selectedOption)) {
                $(element).find('#' + scope.dropDownId + '_label').html('');
            }

            $(element).find('#' + scope.dropDownId).html(optHtml);
        };

        var service = {
            buildOptionsList: buildOptionsList,
            buildTemplate: buildTemplate,
            buildValidationTemplate: buildValidationTemplate,
            updateLabelTemplate: updateLabelTemplate
        };
        return service;
    }
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('optionalField', ['$timeout', '$translate', function ($timeout, $translate) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {

                $timeout(function () {
                    if (attrs.isMandatory !== "true") {
                        element.find("label").append('<span class="optionalFieldTxt">' + '(' + $translate.instant('textfieldOptionalLabel') + ')' + '</span>');
                        element.addClass('optionalFieldInPopup');
                    }

                    if (element.hasClass('hierarchylinktxt')) {
                        element.append('<span class="optionalFieldTxt">' + '(' + $translate.instant('textfieldOptionalLabel') + ')' + '</span>');
                    }

                }, 500);
            }
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').service('StickyElements',[ function () {

		var stickyElementsObj = [];

		this.get = function () {
			var stickyElementsHeight = 0;
			if (stickyElementsObj.length > 0) {
				angular.forEach(stickyElementsObj, function (value, key) {
					stickyElementsHeight = stickyElementsHeight + value.height();
				});
			}
			return {
				height: stickyElementsHeight,
				listOfElements: stickyElementsObj
			};
		}

		this.set = function (obj) {
			stickyElementsObj = obj;
		}
    }])
	.directive('stickyHeader', ['$window', 'StickyElements', function ($window, StickyElements) {
		return {
			restrict: 'A',
			scope: true,
			link: function ($scope, $elem, $attrs) {
				var $win = angular.element($window);
				var elem = $elem[0];

				$scope.scrollType = $attrs.scrollType;

				if ($scope.scrollType === "page") {
					$win.bind('scroll', function (e) {
						if (elem.offsetParent !== null) {
							var windowScrollTop = $win[0].scrollY || $win[0].pageYOffset;
							var elScrollTop = $(elem).offset().top;
							var elScrollTopOriginal = $(elem).offset().top;
							var stickyElementHeight = StickyElements.get().height;
							if (angular.isDefined(angular.element('.grid-fixed-container').height())) {
								stickyElementHeight = stickyElementHeight + angular.element('.grid-fixed-container').height();
							}
							if (angular.isDefined(angular.element('.alert-bar--fixed-to-nav').height())) {
								stickyElementHeight = stickyElementHeight + angular.element('.alert-bar--fixed-to-nav').height();
							}
							if (angular.isDefined(angular.element('.breadcrum-container').height())) {
								stickyElementHeight = stickyElementHeight + angular.element('.breadcrum-container').height();
							}

							var elemforStick = angular.element($attrs.stickyHeader);
							if (elemforStick && elemforStick.length > 0) {
							    stickyElementHeight = stickyElementHeight + elemforStick.height();
							}

							var theadHgt = $(elem).find('thead').height();

							var tbodyHgt = $(elem).find('tbody').not('.dummyThead').height();
							var $dummyThead = $(elem).find('.dummyThead');

							if (windowScrollTop + stickyElementHeight > elScrollTop && windowScrollTop + stickyElementHeight < (elScrollTop + tbodyHgt)) {
								elScrollTopOriginal = elScrollTop;
								stickTableHeader(stickyElementHeight, $scope.scrollType);
								if (!$dummyThead.length)
									$("<tbody class='dummyThead'><tr><td style='height:" + theadHgt + "px'></td></tr></tbody>").insertAfter($(elem).find('thead'));
							} else {
								angular.element(elem.querySelectorAll('thead')).css({ 'display': '', 'top': '', 'position': '', 'background': '' });
								if ($dummyThead.length)
									$dummyThead.remove();
							}
						}
					});
				}

				function stickTableHeader(top, scrollType) {
					var topVal = top;
					// reset display styles so column widths are correct when measured below
					angular.element(elem.querySelectorAll('thead, tbody, tfoot')).css('display', '');

					// set widths of columns
					angular.forEach(elem.querySelectorAll('tr:first-child th'), function (thElem, i) {
					     var tdSel = 'tbody tr' + (!$attrs.columnMap ? '' : $attrs.columnMap) + ':first-child td:nth-child(' + (i + 1) + ')',
                           tdElems = elem.querySelector(tdSel);

						var columnWidth = tdElems ? tdElems.offsetWidth : thElem.offsetWidth;

						if (tdElems) {
							tdElems.style.width = columnWidth + 'px';
						}
						if (thElem) {
							thElem.style.width = columnWidth + 'px';
						}
					});

					angular.element(elem.querySelectorAll('thead')).css({ 'top': topVal, 'position': 'fixed', 'background': '#ffffff', 'z-index': '2' });

					angular.element(elem.querySelectorAll('tbody')).css({
						'height': 'inherit',
						'overflow': 'hidden'
					});
				}
			}
		};
	}]);
})();
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Sub-section
   * @description This directive is useful for creating subsection with custom behaviour.
   * 
   * @attr {Var} ng-model
   *    Data to be passed to subsection controller. ngModel can be accessed as $scope.ngModel.data. Any modifications done on $scope.ngModel.data will reflect in actual data model.
   * @attr {String} template-url
   *    Template to be rendered inside subsection ui element
   * @attr {Number} colspan
   *    Number of columns to be occupied by this ui element. 1 column is equal to 1 ui element.
   *    Default value is 1.
   *    For e.g. If colspan is set to 2, this ui element will occupy width of 2 ui elements (fields).
   * @attr {Function} on-load
   *    Callback function when subsection is rendered. This is expected to be subsection controller function and parameters which are passed are expected to be form-widget controllers variables.
   * 
   * @example
   Dynamic:
   Controller:
       $scope.config = {
            "modelData": {
                "location": {
                    "address1": "Building no. 3, Mindspace IT park",
                    "address2": "Airoli",
                    "city": "Navi Mumbai",
                    "state": "MH",
                    "country": "India"
                }
            },
            "formConfig": {
                "sections": [
                    {
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "",
                                        "type": "subsection",
                                        "isMandatory": true,
                                        "data": "location",
                                        "templateUrl": "abc.html",
                                        "colspan": 1
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
    
   * @example
    Static:
    Controller:
        $scope.location = { "address1": "Building no. 3, Mindspace IT park", "address2": "Airoli", "city": "Navi Mumbai", "state": "MH", "country": "India" };
       
    Usage:
        <smart-subsection template-url="abc.html" ng-model="location"></smart-subsection> 
   */

(function() {
    'use strict';
    var subsectionId = 0;
    
    angular.module('SMART2').directive('smartSubsection', ['$compile', 'ScrollTo', function ($compile, ScrollTo) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                modelData: '=?',
                templateUrl: '@',
                controller: '@',
                isMandatory: '@',
                isVisible: '=',
                focus: '=?',
                parentElement: '@',
                parentScope: '=?',
                removable: '@',
                formModel: '=?',
				init: '@'
            },
            link: function (scope, element, attrs) {
                scope.onLoad = attrs.onLoad;

                subsectionId = subsectionId + 1;
                scope.subsectionId = 'subsection-' + subsectionId;

              

                if (typeof scope.modelData == 'function') {
                    scope.ngModel = {
                        data: scope.modelData()
                    };
                }
                else {

                    scope.ngModel = {
                        data: scope.modelData
                    };
                    /*
                     *  Listen the changes on model data and update sub-section data
                     */
                    var onModelData = scope.$watch('modelData', function (newVal) {
                        scope.ngModel = {
                            data: newVal
                        };
                    }, true);

                    /*
                     *  Listen the changes send it to parent scope
                     */
                    var onNgModelData = scope.$watch('ngModel.data', function (newVal) {
                        scope.modelData = newVal;
                    }, true);

                }           /*
                 * Focus the textfield as soon as the focus is set to true
                 */
                var onFocus = scope.$watch('focus', function (newVal, oldVal) {
                    if (newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        scope.focus = false;
                    }
                });

                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

                if (scope.controller == '') {
                    element.html('<div ng-class="{\'optionalField\': isMandatory == \'false\' && isRemovable}"><div class="optionalFieldHover highlight" ng-if="isMandatory == \'false\' && isRemovable" ng-include="\'shared/directives/uiElements/commonTemplates/optionalFieldRemoveButton.html\'"></div><div ng-include="templateUrl" on-subsection-load></div></div>');
                }
                else {
                	element.html('<div ng-class="{\'optionalField\': isMandatory == \'false\' && isRemovable}"><div class="optionalFieldHover highlight" ng-if="isMandatory == \'false\' && isRemovable" ng-include="\'shared/directives/uiElements/commonTemplates/optionalFieldRemoveButton.html\'"></div><div ng-controller="' + scope.controller + '" ng-init="' + scope.init + '" ng-include="templateUrl" on-subsection-load></div></div>');
                }
                $compile(element.contents())(scope);

                scope.$on('$destroy', function () {
                    onModelData();
                    onNgModelData();
                    onFocus();
                });
            }
        };
    }]);


    angular.module('SMART2').directive('onSubsectionLoad', ['$parse', function ($parse) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                if (angular.isDefined(scope.onLoad)) {
                    scope.$eval(scope.onLoad);
                }
            }
        };
    }]);
})();    
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Switch
   * @description This directive is useful for creating a switch.
   *
   * @attr {String} label
   *    Label to be displayed for identification of this ui element
   * @attr {Boolean} ng-model
   *    Switch's default state (selected or unselected)
   * @attr {Object} ng-model-options
   *    https://docs.angularjs.org/api/ng/directive/ngModelOptions. 
   *    <a href="SMART2.Textfield.html">Click here</a> and scoll down to 'Textfield with ng-model-options' to see example reference.
   * @attr {Boolean} disable
   *    If value of this attribute is set to true, switch will not be clickable
   * @attr {Boolean} focus 
   *    If set to true, this ui element will be focused
   * @attr {Boolean} validate
   *    If set to true, this ui element will be validated on the basis of rules passed to it
   * @attr {Array} rules 
   *    Rules to be evaluated when this element's blur event is fired. A rule must have 'rule' and 'errorMessage' properties (keys).
   *    'rule' must be a condition or group of conditions. 'errorMessage' will be the message to be displayed when corresponding rule fails. See example for more.
   * @attr {String} error-message 
   *    Error message to be displayed. This attribute can be set at any point to display an error message.
   * @attr {Boolean} is-mandatory 
   *    If set to true, default error message will be displayed when blur event is fired and this ui element is left blank
   * @attr {Boolean} is-visible 
   *    If set to true, this ui element will be displayed on form regardless of 'is-mandatory' property's value. 
   *    This ui element can be removed from form by clicking 'x' button on top right corner of this ui element.
   * @attr {Number} colspan
   *    Number of columns to be occupied by this ui element. 1 column is equal to 1 ui element.
   *    Default value is 1.
   *    For e.g. If colspan is set to 2, this ui element will occupy width of 2 ui elements (fields).
   * @attr {Function} on-change
   *    Callback function when switch state is changed 
   * 
   * @example
   Dynamic:
   Controller:
       $scope.config = {
            "modelData": {
                "isUrgent": true
            }, 
            "formConfig": {
                "sections": [
                    {
                        "isMandatory": true,
                        "rows": [
                            {
                                "properties": [
                                    {
                                        "label": "Urgent",
                                        "type": "switch",
                                        "isMandatory": true,
                                        "data": "isUrgent",
                                        "colspan": 1,
                                        "onChange": "onChange"  //  controller function ,
                                        "rules": [
                                            { 
                                                "rule": "this == true", 
                                                "error": "Checkbox should not be selected" 
                                            }
                                        ]
                                    }
                                ]    
                            }
                        ]
                    }
                ]
            }
        };
    Usage:
        <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
   
   * @example
   Static:
   Controller:
       $scope.isUrgent = true;
       $scope.onChange = function(isUrgent) {
           console.log(isUrgent);
       };
   Usage:
       <smart-switch label="Urgent" ng-model="isUrgent" on-change="onChange(isUrgent)"></smart-switch>
       
   * @example
   Disabled switch:
   <smart-switch disable="true"></smart-switch>     
   */
  
(function() {
    'use strict';
    
    angular.module('SMART2').directive('smartSwitch', ['$timeout', 'ScrollTo', 'RuleEngine', function ($timeout, ScrollTo, RuleEngine) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                //ngModel: '=?',
                disable: '@',
                isMandatory: '@',
                isVisible: '=?',
                label: '@',
                rightLabel: '=?',
                leftLabel:'=?',
                minHeight: '@',
                fill: '@',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                errorMessage: '@',
                onChange: '&',
                removable: '@',
                additionaltext: '=additionaltext'
            },
            link: function (scope, element, attrs, ngModelCtrl) {
                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);
    
                scope.fill = scope.$eval(scope.fill) == undefined ? true : scope.$eval(scope.fill);
                scope.leftLbl = "Off";
                scope.rightLbl = "On";

                if (typeof scope.leftLabel != "undefined")
                    scope.leftLbl = scope.leftLabel;
                if (typeof scope.rightLabel!="undefined")
                    scope.rightLbl = scope.rightLabel;


                /*
                 *  Following code has been added to make ng-model-options work
                 *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                 */
                try {
                    ngModelCtrl.$render = function () {
                        scope.ngModel = ngModelCtrl.$modelValue;
                    };
                }
                catch (e) { }

                var updateView = function () {
                    try {
                        ngModelCtrl.$setViewValue(scope.ngModel);
                    }
                    catch (e) { }
                };

                
                /*
                 * Focus field when focus is set to true
                 */
                var onFocus = scope.$watch('focus', function(newVal) {
                    if(newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        scope.focus = false;
                    }
                });
                
                /*
                 * Validate field whene validate is set to true
                 */
                var onValidate = scope.$watch('validate', function(newValue) {
                    if(newValue != undefined && newValue) {
                        scope.validateRules();
                    }
                });
                
                /*
                 * Validate rules
                 */
                scope.validateRules = function () {
                    scope.validate = false;
                    scope.errorMessage = null;

                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false;

                        for (var i = 0; i < rules.length; i++) {
                            if (typeof rules[i] == 'object') {
                                if (eval((rules[i].rule).replace(/this/g, 'scope.ngModel'))) {
                                    scope.validate = true;
                                    scope.errorMessage = rules[i].error;
                                    break;
                                }
                                else {
                                    if (!isFoundInvalid) {
                                        RuleEngine.isValid(rules[i], function (e) {
                                            scope.validate = true;
                                            scope.errorMessage = e.errorData.error;
                                            isFoundInvalid = true;
                                        });
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                };
                
                scope.ngChange = function () {
                    updateView();
                    scope.validateRules();
                    $timeout(function() {
                        scope.onChange();
                    });
                };

                scope.$on('$destroy', function () {
                    onFocus();
                    onValidate();
                });
            },
            templateUrl: 'shared/directives/uiElements/smartSwitch/smartSwitchTemplate.html'
        };
    }]);
})();    
/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Tabs-control
 * @description This directive is useful for creating a tabs control.
 *
 * @attr {Array} tab-config
 *    Tabs config. Please see example for more.
 * @attr {String} width
 *    Width of tabs holder. Default value is '100%'.
 *
 * @example
 Tabs Config in default case
  $scope.tabsData = [{
 "title" : "Tab 1",
 "contentUrl" : "tab1.html",
 "active" : true
 }, {
 "title" : "Tab 2",
 "contentUrl" : "tab2.html"
 }, {
 "title" : "Tab 3",
 "contentUrl" : "tab3.html"
 }];
 
 *@example
 Controller in case default tab styling is to be overriden(set htmlmode=true and pass template url in tabsUrl):
 $scope.tabsData = [{
 "title" : "Tab 1",
 "contentUrl" : "tab1.html",
 "active" : true,
 "htmlmode":true,
 "tabsUrl":"template1.html"
 }, {
 "title" : "Tab 2",
 "contentUrl" : "tab2.html",
 "htmlmode":true,
 "tabsUrl":"template2.html"
 }, {
 "title" : "Tab 3",
 "contentUrl" : "tab3.html",
 "htmlmode":true,
 "tabsUrl":"template3.html"
 }];

 Usage:
 <smart-tabs tab-config="{{tabsData}}" width="60%" header-template="test_template.html"></smart-tabs>
 */

(function() {
	'use strict';
	var tabsId = 0;

	angular.module('SMART2').directive('smartTabs', ['$timeout','$parse','$focusOnField',
	function ($timeout, $parse, $focusOnField) {
		return {
			restrict : 'E',
			replace : true,
			scope: true,
			link: function (scope, element, attrs) {
                if(attrs.showCount == 'true') {
                    scope.showCount = true;
                }
			    var d = new Date().getTime();
			    scope.uniqueID = 'xxx2xxxpxxxoxxx'.replace(/[xy]/g, function (c) {
			        var r = (d + Math.random() * 16) % 16 | 0;
			        d = Math.floor(d / 16);
			        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
			    });

			    var selectionCallback = $parse(attrs.onSelect),
				    tabWidth = attrs.width,
				    tabParent = element.find('.tabparent'),
				    currentTab;

			    scope.revisionMode = ((!attrs.revisionMode || attrs.revisionMode == "false") ? false : true);
				tabParent.css('width', tabWidth);
				var timeoutCanel = $timeout(function() {
					var tabs = element.find('.tabs');
					tabs.tabs();
					$timeout.cancel(timeoutCanel);
				});
				//scope.stickTabs = false;

				scope.vertical = attrs.vertical;
				scope.tabPanelHeight = angular.isDefined(attrs.tabPanelHeight) ? scope.vertical == 'true' ? attrs.tabPanelHeight : '100%' : '100%';

				//uniqueID
				tabsId = tabsId + 1;
				scope.tabId = "tab-" + tabsId;
				var tabWidthInFloat = parseFloat(tabWidth);
				var remainingWidth = (100 - tabWidthInFloat) + "%";
				//var rightHeaderStyle="{'background-color':'red';'width':"+remainingWidth+";'margin-left'}";
				scope.headerStyle = {
					"width" : remainingWidth,
					"margin-left" : tabWidth,
					"height" : '48px'
				};
				scope.headerTemplate = attrs.headerTemplate;
				attrs.$observe('tabConfig', function (value) {
				    scope.tabConfig = scope.$eval(value);
				    var activeTabContent = currentTab;
				    var item = _.find(scope.tabConfig, function (item) { return item.active == true; });
                    if (currentTab && currentTab.htmlmode && item == undefined) {
                        for (var i = 0; i < scope.tabConfig.length; i++) {
                            var tTab = scope.tabConfig[i];
                            if (tTab.title.toLowerCase() === activeTabContent.title.toLowerCase()) {
                                tTab.active = true;
                               }
			    	}
				    }
				    currentTab = (_.find(scope.tabConfig, function (tab) {
				        return tab.active;
				    }));
				    if (currentTab) {
				        currentTab.isLoaded = true;
				        scope.selectedTabContentUrl = currentTab.contentUrl;
				        //scope.tabClickCallback(currentTab);
				    }
				});

				//attrs.$observe('stickTabs', function (value) {
				//    scope.stickTabs = scope.$eval(value);
				//});

				//scope.$on('checkTabIsDirty', function (event, data) {
				//    currentTab.isTabValidate = scope[currentTab.onBeforeTabChange] && scope[currentTab.onBeforeTabChange]();
				//});

				scope.tabClickCallback = function (item) {
				    var returnObject = angular.copy(item);
				    returnObject.previousTab = currentTab;
				    returnObject.previousTab.active = false;
				    currentTab = item;
				    item.active = true;
				    item.isLoaded = true;
                    //returnObject.previousTab.isTabValidate = scope[returnObject.previousTab.onBeforeTabChange] && scope[returnObject.previousTab.onBeforeTabChange]();
				    if (angular.isFunction(selectionCallback)) {
				        selectionCallback(scope, { 'e': returnObject });
				    }
				    //TWO-6116  fixed.
				    //$timeout(function () {
				    //    scope.$broadcast('scrollTopToBottom', element.find('.scroll-container').outerHeight());
				    //}, 800);
				};

				scope.tabbingOnKeyDown = function (evt, $index, tabType) {
				    var moveTo;
				    if (evt.keyCode == 38 && angular.isDefined(tabType) || evt.keyCode == 37 && !angular.isDefined(tabType)) {
				        moveTo = $index - 1;
				        if (!(moveTo < 0)) {
				            element.find('.tab').eq(moveTo).focus();
				        }
				    }
				    else if (evt.keyCode == 40 && angular.isDefined(tabType) || evt.keyCode == 39 && !angular.isDefined(tabType)) {
				        moveTo = $index + 1;
				        if (!(moveTo >= scope.tabConfig.length)) {
				            element.find('.tab').eq(moveTo).focus();
				        }
				    }
				    else if (evt.keyCode == 13) {
				        scope.tabClickCallback(scope.tabConfig[$index]);
				    }
				    else if (evt.keyCode == 9) {
				        var firstFieldFocus = element.find("tabContent").find("a, input, textarea, [tabindex]").first();
				        $focusOnField(firstFieldFocus);
				    }
				    evt.stopPropagation();
				};
                
				scope.showTabArrows = false;
				scope.disableNext = false;
				scope.disablePrev = true;
				var isMovableTabs = true;
				var tabHorizontalWidth, tabWrapperWidth, totalTabWidth, def, transValue, tempValue = 0;

				function setTabs() {
				    $timeout(function () {
				        tabHorizontalWidth = element.find("#tabs-horizontal-" + scope.uniqueID).width();
				        totalTabWidth = element.find("#tabs-horizontal-" + scope.uniqueID).find(".tabs-wrapper")[0].scrollWidth; //.width() doesn't return overflowed width of child element

				        if (totalTabWidth > tabHorizontalWidth) {
				            scope.showTabArrows = true;
				        }

				        $timeout(function () {
				            tabWrapperWidth = element.find("#tabs-horizontal-" + scope.uniqueID).find(".tabs-wrapper").width();
				            def = totalTabWidth - tabWrapperWidth;
				        });
				    });
				}

				scope.$on('LastRepeaterElement', function (attrs, elem) {
				    if (elem.is("li") && isMovableTabs && attrs.nextback) {
				        setTabs();
				        isMovableTabs = false;
				    }
				});

				scope.getTabsDimensions = function () {
				    return {
				        'w': element.find("#tabs-horizontal-" + scope.uniqueID).width()
				    };
				};
				scope.$watch(scope.getTabsDimensions, function (newValue, oldValue) {
				    if (newValue.w != oldValue.w && attrs.nextback) {
				        setTabs();
				    }
				}, true);

				scope.goRight = function () {
				    if (!scope.disableNext) {
				        tempValue = tempValue + 175;
				        if (tempValue < def) {
				            transValue = -Math.abs(tempValue);
				            element.find("#tabs-horizontal-" + scope.uniqueID).find(".tabs-wrapper ul.tabs").css("transform", "translateX(" + transValue + "px)");
				            scope.disablePrev = false;
				        }
				        else {
				            tempValue = def;
				            transValue = -Math.abs(tempValue);
				            element.find("#tabs-horizontal-" + scope.uniqueID).find(".tabs-wrapper ul.tabs").css("transform", "translateX(" + transValue + "px)");
				            scope.disablePrev = false;
				            scope.disableNext = true;
				        }
				    }
				}

				scope.goLeft = function () {
				    if (!scope.disablePrev) {
				        tempValue = tempValue - 175;
				        if (tempValue < def && tempValue > 0) {
				            transValue = -Math.abs(tempValue);
				            element.find("#tabs-horizontal-" + scope.uniqueID).find(".tabs-wrapper ul.tabs").css("transform", "translateX(" + transValue + "px)");
				            scope.disableNext = false;
				        }
				        else {
				            tempValue = 0;
				            transValue = tempValue;
				            element.find("#tabs-horizontal-" + scope.uniqueID).find(".tabs-wrapper ul.tabs").css("transform", "translateX(" + transValue + "px)");
				            scope.disableNext = false;
				            scope.disablePrev = true;
				        }
				    }
				}
				
                
				scope.$on('$destroy', function () {
				    tabParent = null;
				    element.remove();
				    scope = null;
				});
			},
			templateUrl : 'shared/directives/uiElements/smartTabs/smartTabsTemplate.html'
		};
	}]);
})();

/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Character-restrict
 * @description This directive is useful for preventing character from entering in text field .
 * 
 * @attr {String} patternreg
 *    Js Regex pattern need to be entered
 * 
 * @example
 Dynamic: 
  Usage:
      <smart-textfield model-data="config.modelData" smart-character-restrict pattern="[^\w\s-()]"></smart-form-widget>
 */

(function (angular) {
    'use strict';
    angular.module('SMART2').directive('smartCharacterRestrict', function () {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var keyCheckRe = new RegExp(attrs.patternreg, 'ig'),
                    valueCheckRe = attrs.validationreg ? new RegExp(attrs.validationreg, 'ig') : false,
                    valueRegexPassed,
                    allowCharacterFlag = attrs.allowpaste;

                element
                    .off('keypress.smartcharacterrestrict')
                    .on('keypress.smartcharacterrestrict', 'input', function (inputValue) {
                        keyCheckRe.compile(attrs.patternreg, 'ig');
                        if (inputValue.key == null) {
                            return ''
                        }

                        if (keyCheckRe.test(inputValue.key)) {
                            inputValue.preventDefault();
                        }

                        if (valueCheckRe) {
                            valueCheckRe.compile(attrs.validationreg, 'ig');
                            valueRegexPassed = valueCheckRe.test(inputValue.target.value + inputValue.key)
                            if (valueRegexPassed == false) {
                                inputValue.preventDefault();
                            }
                        }
                    });

                element
                    .off('paste.smartcharacterrestrict')
                    .on('paste.smartcharacterrestrict', 'input', function (inputValue) {
                        if (allowCharacterFlag === 'true') {

                        } else {
                            return false;
                        }

                    });
            }
        }
    });
})(angular);
/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Textfield
 * @description This directive is useful for creating a textfield or a date-picker or a auto-complete ui element depending upon the 'type' passed.
 * 
 * @attr {String} label
 *    Label to be displayed for identification of this ui element
 * @attr {String} placeholder
 *    Hint text to be displayed in textfield
 * @attr {String} align
 *    Text alignment. Possible values are left, center, right.
 * @attr {Boolean} autocomplete 
 *    This attribute is useful for turning off browser's default autocomplete behaviour
 * @attr {Number} maxlength
 *    Number of characters allowed in textfield
 * @attr {Number} decimalprecision
 *    Number of characters allowed after decimal precision in textfield
 * @attr {Number} min
 *    Minimum value allowed in textfield 
 * @attr {Number} max
 *    Maximum value allowed in textfield
 * @attr {Number} minmaxprecision
 *    Number of characters that should be visible in number type textfield. Internally filter is applied for the given numbers. Data to be sent in array format with 2 array contents 
 * @attr {Var} ng-model
 *    Default value to be displayed in textfield
 * @attr {Object} ng-model-options
 *    https://docs.angularjs.org/api/ng/directive/ngModelOptions
 * @attr {Boolean} focus 
 *    If set to true, this ui element will be focused
 * @attr {Boolean} validate
 *    If set to true, this ui element will be validated on the basis of rules passed to it
 * @attr {Array} rules 
 *    Rules to be evaluated when this element's blur event is fired. A rule must have 'rule' and 'errorMessage' properties (keys).
 *    'rule' must be a condition or group of conditions. 'errorMessage' will be the message to be displayed when corresponding rule fails. See example for more.
 * @attr {String} error-message 
 *    Error message to be displayed. This attribute can be set at any point to display an error message.
 * @attr {Boolean} is-mandatory 
 *    If set to true, default error message will be displayed when blur event is fired and this ui element is left blank
 * @attr {Boolean} is-visible 
 *    If set to true, this ui element will be displayed on form regardless of 'is-mandatory' property's value. 
 *    This ui element can be removed from form by clicking 'x' button on top right corner of this ui element.
 * @attr {Number} colspan
 *    Number of columns to be occupied by this ui element. 1 column is equal to 1 ui element.
 *    Default value is 1.
 *    For e.g. If colspan is set to 2, this ui element will occupy width of 2 ui elements (fields).
 * @attr {String} type 
 *    Type of textfield. Default value is 'text'. Possible values are area (textarea), number, email, date, autocomplete.
 * @attr {Boolean} readonly 
 *    If set to true, textfield cannot be editable. Textfield's blur and focus events will still be fired (default behaviour).
 * @attr {Boolean} disable 
 *    If set to true, textfield cannot be editable. Textfield's blur and focus events will not be fired (default behaviour).
 * @attr {Function} on-focus
 *    Callback function when ui element's focus event is fired
 * @attr {Function} on-blur
 *    Callback function when ui element's blur event is fired
 * @attr {Function} on-key-up
 *    Callback function when ui element's keyup event is fired
 * @attr {Function} on-key-down
 *    Callback function when ui element's keydown event is fired
 * @attr {Function} on-key-press
 *    Callback function when ui element's keypress event is fired
 * @attr {Function} on-enter
 *    Callback function when ENTER (RETURN) key is pressed
 * 
 * @example
 Dynamic:
 Controller:
     $scope.config = {
          "modelData": {
              "companyName": "GEP"
          }, 
          "formConfig": {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "Company name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "isVisible": false,
                                      "data": "companyName",
                                      "colspan": 1,
                                      "validate": false,
                                      "focus": false,
                                      "onFocus": "onFocus",
                                      "onBlur": "onBlur" 
                                      "onChange": "onChange"
                                      "onKeyPress": "onKeyPress"
                                      "onKeyUp": "onKeyUp"
                                      "onKeyDown": "onKeyDown",
                                      "attributes": {
                                          "type": "number"
                                          "maxlength": "",
                                          "decimalprecision": "",
                                          "minmaxprecision": [2,5],
                                          "disable": true,
                                          "readonly": true,
                                          "align": "left",
                                          "placeholder": "",
                                          "autocomplete": false
                                      },
                                      "rules": [
                                          { 
                                              "rule": "this.length > 10", 
                                              "errorMessage": "Length should not be greater than 10" 
                                          }
                                      ]
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          }
      };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

 * @example
 Textfield with ng-model-options. This example is applicable only if one wants to use 'ng-model-options' with 'getterSetter' option. Otherwise VM
 does not need to be used as 'ng-model' or 'data'.
 Dynamic:
 Controller:
     var defaultCompanyName = 'GeP';
     this.companyName = function (val) {
         if (val !== undefined) {
             defaultCompanyName = val;
         }
         return defaultCompanyName;
     };

     $scope.config = {
          "modelData": {
              "companyName": "GEP"
          }, 
          "formConfig": {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "Company name",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "isVisible": false,
                                      "data": "controllerVM.companyName",
                                      "attributes": {
                                          "ngModelOptions": { getterSetter: true }
                                      },
                                      "rules": [
                                          { 
                                              "rule": "this.length > 10", 
                                              "errorMessage": "Length should not be greater than 10" 
                                          }
                                      ]
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          }
      };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

 * @example
 Textfield with ng-model-options. This example is applicable only if one wants to use 'ng-model-options' with 'getterSetter' option. Otherwise VM
 does not need to be used as 'ng-model' or 'data'.
 Static:
 Controller:
     angular.module('SMART2', []).controller('textFieldController', ['$scope', function($scope) {
         var defaultCompanyName = 'GeP';
         this.companyName = function (val) {
             if (val !== undefined) {
                 defaultCompanyName = val;
             }
             return defaultCompanyName;
         };
     }]);
  Usage:
      <div ng-controller="textFieldController as textFieldVM">
        <smart-textfield ng-model="textFieldVM.companyName" ng-model-options="{getterSetter: true}"></smart-textfield>
      </div>

 * @example
 Static:
 Controller:
      $scope.companyName = "GEP";
 Usage:
      <smart-textfield label="First name" ng-model="companyName"></smart-textfield>
      
 * @example
 Textfield with events: 
 '$event' passed in callback functions in following example is angular event. 
  <smart-textfield on-focus="onFocus()" 
                   on-blur="onBlur()" 
                   on-change="onChange($event)"
                   on-key-press="onKeyPress($event)"
                   on-key-up="onKeyUp($event)"
                   on-key-down="onKeyDown($event)"></smart-textfield>        
 */


/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Date-picker
 * @description This directive is useful for creating a date picker. This directive is derived from 'textfield' directive. All the attributes of 'textfield' directive are applicable to this directive. Following are some additional attributes.
 * 
 * @attr {String} format 
 *    Date format. For e.g. dd/MM/yyyy. For more details browse https://docs.angularjs.org/api/ng/filter/date
 * @attr {Var} ng-model
 *    Default date to be displayed. 'ng-model' is expected to be in milliseconds (timestamp) or javascript date. For e.g. 5656534324368 or "2014-09-18T10:03:58" or "Fri Mar 04 2016 13:10:56 GMT+0530 (IST)"
 * 
 * @example
 Dynamic: (Timestamp)
 Controller:
     $scope.config = {
          "modelData": {
              "date": 1457094173954
          }, 
          "formConfig": {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "Date",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "date",
                                      "attributes": {
                                          "type": "date",
                                          "format": "dd/MM/yyyy"
                                      }
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          }
      };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

 * @example
 Dynamic: (Javascript date)
 Controller:
     $scope.config = {
          "modelData": {
              "date": "Fri Mar 04 2016 17:50:50 GMT+0530 (IST)"
          }, 
          "formConfig": {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "Date",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "date",
                                      "attributes": {
                                          "type": "date",
                                          "format": "dd/MM/yyyy"
                                      }
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          }
      };
  Usage:
      <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>

 * @example
 Static: (Timestamp)
 Controller:
      $scope.date = 1457094173954;
 Usage:
      <smart-textfield type="date" label="Date" ng-model="date"><smart-textfield> 
      
 * @example
 Static: (Javascript date)
 Controller:
      $scope.date = "Fri Mar 04 2016 17:50:50 GMT+0530 (IST)";
 Usage:
      <smart-textfield type="date" label="Date" ng-model="date"><smart-textfield>         
 */


/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Auto-complete
 * @description This directive is useful for creating an auto-complete ui element. This directive is derived from 'textfield' directive. All the attributes of 'textfield' directive are applicable to this directive. Following are some additional attributes.
 * 
 * @attr {Object} ng-model
 *    Default value to be displayed in textfield. 'ng-model' is expected to be an object having property (key) set in 'datakey' attribute.
 * @attr {Array} filterkeys
 *    An array of properties (keys) on which filtering to be applied. Suggestions will get filtered on the basis of properties (keys) passed in array.
 * @attr {String} optionformat
 *    A single suggestion format (template)
 * @attr {String} displayformat
 *    A format in which the data in textfield to be displayed
 * @attr {Boolean} loading 
 *    This attribute can be used to display a loader while autosuggest data is being fetched from the server.
 * @attr {Function} on-select
 *    Callback when a suggestion is selected
 * 
 * @example
 Dynamic:
 Controller:
     $scope.onChange = function(uiElementConfig) {
          uiElementConfig.attributes.options = [
              {
                  "UserId": 28360,
                  "UserName": "SRUser1@outlook.com",
                  "FirstName": "SR ",
                  "LastName": "User1"
              }, {
                  "UserId": 28977,
                  "UserName": "test1",
                  "FirstName": "Test",
                  "LastName": ""
              }, {
                  "UserId": 57950,
                  "UserName": "HShah",
                  "FirstName": "Harshit",
                  "LastName": "Shah"
              }
          ];
     };
     $scope.onSelect = function(autoSuggestData) {
         console.log(autoSuggestData);
         //   autoSuggestData will be updated every time a new suggestion is chosen. Passing 'model' in 'onSelect' is optional.
     };
     $scope.config = {
          "modelData": {
              "autoSuggestData": { "UserId": 28360, "UserName": "SRUser1@outlook.com", "FirstName": "SR", "LastName": "User1", "title": "SR User1" }
          }, 
          "formConfig": {
              "sections": [
                  {
                      "isMandatory": true,
                      "rows": [
                          {
                              "properties": [
                                  {
                                      "label": "Auto complete",
                                      "type": "textfield",
                                      "isMandatory": true,
                                      "data": "autoSuggestData",
                                      "onChange": "onChange",
                                      "onSelect": "onSelect(autoSuggestData)",
                                      "attributes": {
                                          "type": "autocomplete",
                                          "options": [],
                                          "filterkeys": ["FirstName", "LastName"],
                                          "optionformat": "<span>{FirstName} {LastName}</span>",
                                          "displayformat": "{FirstName} {LastName}",
                                          "loading": false
                                      }
                                  }
                              ]    
                          }
                      ]
                  }
              ]
          }
     };
  Usage:
     <smart-form-widget form-config="config.formConfig" model-data="config.modelData"></smart-form-widget>
 * @example
 Static:
 Controller:
     $scope.autoCompleteData = { "UserId": 28360, "UserName": "SRUser1@outlook.com", "FirstName": "SR", "LastName": "User1", "title": "SR User1" };
     $scope.onChange = function(e) {
          //  Textfield's value can be found in e.data[0].value
          //  See console for more
          console.log(e);
          $scope.options = [
              {
                  "UserId": 28360,
                  "UserName": "SRUser1@outlook.com",
                  "FirstName": "SR ",
                  "LastName": "User1"
              }, {
                  "UserId": 28977,
                  "UserName": "test1",
                  "FirstName": "Test",
                  "LastName": ""
              }, {
                  "UserId": 57950,
                  "UserName": "HShah",
                  "FirstName": "Harshit",
                  "LastName": "Shah"
              }
          ]; 
     };
     $scope.onSelect = function(autoCompleteData) {
         console.log(autoCompleteData);
         //   autoCompleteData will be updated every time a new suggestion is chosen. Passing 'model' in 'onSelect' is optional.
     };
 Usage:
     <smart-textfield type="autocomplete" label="Auto complete" ng-model="autoCompleteData" filterkeys="['FirstName', 'LastName']" optionformat="<span>{FirstName} {LastName}</span>" displayformat="{FirstName} {LastName}" options="options" on-change="onChange($event)" on-select="onSelect(autoCompleteData)"></smart-textfield>
 */


(function () {
    'use strict';
    var textfieldId = 19820116;
    //var directiveV2 = true;
    //var isDirectiveV2enabled = function () { return true; }
    $(function () {
        angular.element('body').off('click').on('click', '.daterangepicker', function (e) {
            e.stopPropagation();
        });
    });

    angular.module('SMART2').directive('smartTextfield', ['$rootScope', '$timeout', '$translate', 'ScrollTo', 'RuleEngine', 'smartTextFieldService', 'smartTextField3Service', '$filter', '$window', 'persistenceService',
        (typeof isDirectiveV2enabled !== 'undefined' ? (isDirectiveV2enabled() === true || isDirectiveV2enabled() === 'V3' ? smartTextField3Func : smartTextFieldFunc) : smartTextFieldFunc)]);


    function smartTextFieldFunc($rootScope, $timeout, $translate, ScrollTo, RuleEngine, $window) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                label: '@',
                //ngModel: '=?',
                modelOptions: '=?',
                options: '=?',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                onChange: '&',
                onFocus: '&',
                onBlur: '&',
                onKeyUp: '&',
                onKeyDown: '&',
                onKeyPress: '&',
                onEnter: '&',
                onSelect: '&',
                onDestroy: '&',
                onDateChange: '&',
                errorMessage: '@',
                errorModel: '=?',
                setFromGrid: '@',
                //  input element's attribute except for listeners should be in small letters
                type: '@',
                align: '@',
                datanumeric: '@',
                spinner: '@',
                step: '@',
                format: '@',    //  date format
                timePicker: '@', //boolean value if date with time picker
                isValueDateObj: '@',
                readonly: '@',
                disable: '@',
                prefixicon: '@',
                suffixicon: '@',
                maxlength: '@',
                min: '@',
                max: '@',
                timePicker12Hour: '@',
                minuteIncrement: '@',
                charactercounter: '@',
                decimalprecision: '@',
                minmaxprecision: '@',
                placeholder: '@',
                autocomplete: '@',
                removable: '@',
                datakey: '@',
                filterkeys: '@',
                optionformat: '@',
                displayformat: '@',
                width: '@',      //  autosuggest container width
                minchars: '@',   //  autosuggest min chars
                loading: '@',     //  loader while autosuggest data is being fetched
                count: '@',
                noSuggestionNotice: '@',
                showNoSuggestion: '@',
                clearListOnFocus: '@',
                retainDisplayModelAutocomplete: '@',
                showinfo: '@',
                showwarning: '@'
            },
            link: function (scope, element, attrs, ngModelCtrl) {
                scope.modelOptions = scope.modelOptions === false ? {} : !scope.modelOptions ? {
                    updateOn: 'default blur change',
                    debounce: { 'default': 300, 'blur': 0, 'change': 0 }
                } : scope.modelOptions;
                scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
                scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
                scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
                scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon
                var timePicker = (typeof scope.timePicker == undefined ? false : scope.timePicker == 'true' ? true : false);
                scope.format = (scope.format ? scope.format : timePicker ? 'DD/MM/YYYY h:mm' : 'DD/MM/YYYY');
                scope.count = 0;
                var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
                var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
                showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
                var number, rulesValidationEvent;
                scope.type = angular.isDefined(scope.type) ? scope.type : 'text';


                if (scope.type == 'number') {
                    element.bind("DOMMouseScroll mousewheel onmousewheel", function (event) {

                        // for IE
                        event.returnValue = false;
                        // for Chrome and Firefox
                        if (event.preventDefault) {
                            event.preventDefault();
                        }

                    });
                }


                var uniqueIDGenerator = function () {
                    var d = new Date().getTime();
                    var uniqueID = 'xx2xxpxxoxx'.replace(/[xy]/g, function (c) {
                        var r = (d + Math.random() * 16) % 16 | 0;
                        d = Math.floor(d / 16);
                        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                    });
                    return uniqueID;
                };

                if (attrs.validateOn) {
                    rulesValidationEvent = attrs.validateOn;
                }
                else {
                    rulesValidationEvent = 'blur';
                }


                /*
                 *  Following code has been added to make ng-model-options work
                 *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                 */
                try {
                    ngModelCtrl.$render = function () {
                        scope.ngModel = ngModelCtrl.$modelValue;
                    };
                }
                catch (e) { }

                var updateView = function () {
                    try {
                        ngModelCtrl.$setViewValue(scope.ngModel);
                    }
                    catch (e) { }
                };


                function checkIfActive() {
                    if (scope.readonly == 'true') {
                        return true;
                    }
                    if (scope.type == 'number' && scope.ngModel !== 0 + '' && scope.placeholder === '' && (scope.ngModel === '' || isNaN(scope.ngModel) || scope.ngModel === undefined || scope.ngModel === null)) {
                        return false;
                    }
                    if (scope.type != 'number' && scope.type != 'autocomplete' && scope.placeholder === '' && (scope.ngModel === '' || scope.ngModel === undefined || scope.ngModel === null)) {
                        return false;
                    }
                    if (scope.type == 'autocomplete' && scope.placeholder === '' && (scope.displayModel === '' || scope.displayModel === undefined || scope.displayModel === null)) {
                        return false;
                    }
                    return true;
                }


                function setPrecisionLimits() {
                    number = scope.ngModel;
                    if (number != undefined) {
                        var arr = (number.toString()).split('e')
                        if (arr.length > 1 && parseInt(arr[1]) < 0) {
                            number = (number).toFixed(6);
                            scope.ngModel = number;
                        }
                        var tempArr = number.toString().split('.');
                        if (tempArr != undefined && tempArr.length > 1) {
                            var preDecimal = tempArr[0];
                            if (preDecimal != 0 && preDecimal.toString().length > 20) {
                                var tempVal = preDecimal.toString().substring(0, 19);
                                scope.ngModel = parseInt(tempVal);
                            }
                        }
                        else {
                            if (number != 0 && number.toString().length > 20) {
                                var tempVal = number.toString().substring(0, 19);
                                scope.ngModel = parseInt(tempVal);
                            }
                        }
                        if (scope.decimalprecision != undefined) {
                            scope.ngModel = parseFloat(parseFloat(scope.ngModel).toFixed(scope.decimalprecision));
                        }
                        else if (scope.minmaxprecision !== undefined && scope.minmaxprecision !== '') {
                            var splitPrecision = JSON.parse(scope.minmaxprecision);
                            if (splitPrecision.length > 2 || splitPrecision.length < 1)
                                return;
                            var lowerPrecisionLimit = splitPrecision[0];
                            var highPrecisionLimit = splitPrecision[1];

                            var postDecimalNumbers = ((scope.ngModel + "").split(".")[1] != undefined) ? (scope.ngModel + "").split(".")[1].length : 0;

                            if (postDecimalNumbers == 0)
                                return;

                            if (lowerPrecisionLimit > postDecimalNumbers && postDecimalNumbers < highPrecisionLimit && postDecimalNumbers != 0) {
                                scope.ngModel = parseFloat(parseFloat(scope.ngModel).toFixed(lowerPrecisionLimit));
                            }
                            else if (postDecimalNumbers >= highPrecisionLimit && postDecimalNumbers != 0) {
                                var fixed = Math.pow(10, highPrecisionLimit);
                                scope.ngModel = Math.floor(scope.ngModel * fixed) / fixed;
                            }
                        }
                    }
                }

                scope.isActive = checkIfActive();

                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

                if (attrs.id != undefined || attrs.id != null) {
                    scope.textfieldId = attrs.id;
                    element.removeAttr('id');
                }
                else {
                    textfieldId = uniqueIDGenerator();
                    scope.textfieldId = 'txt-' + textfieldId;
                }

                scope.labelForTextfieldId = 'label-for-' + scope.textfieldId;

                /*
                * Skip tab key focus, if the field is readonly
                */
                setTimeout(function () {
                    if (scope.readonly == 'true' && scope.type != 'date') {
                        angular.element('#' + scope.textfieldId).attr('tabindex', -1);
                    }

                    try {
                        if (angular.isDefined(scope.$parent.$parent.onEditableRender)) {
                            scope.$parent.$parent.onEditableRender(scope, element);
                        }
                    }
                    catch (e) { }
                });

                /*
                 * Validate the textfield as soon as the validate is set to true
                 */
                var unbindValidate = scope.$watch('validate', function (newVal, oldVal) {
                    if (newVal) {
                        scope.validateRules();
                    }
                });

                /*
                 * Focus the textfield as soon as the focus is set to true
                 */
                var unbindFocus = scope.$watch('focus', function (newVal, oldVal) {
                    if (newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        //  settimeout is added to avoid $digest already in progress
                        setTimeout(function () {
                            var el = angular.element('#' + scope.textfieldId);
                            if (scope.label) {
                                el.trigger('click');
                                el.focus();
                            } else {
                                // if label is undefined or empty then directly focus on input element 
                                if (el.is("input")) {
                                    el.focus();
                                } else {
                                    el.find("input").focus();
                                }
                            }
                        }, 100); // increased timer hotfix for focus cell in ui-grid
                        scope.focus = false;
                    }
                });
                var checkRule = function () {
                    var rules = scope.$eval(scope.rules);
                    var isFoundInvalid = false;

                    for (var i = 0; i < rules.length; i++) {
                        if (typeof rules[i] == 'object') {
                            if (eval((rules[i].rule).replace(/this/g, scope.type == 'autocomplete' ? 'scope.displayModel' : 'scope.ngModel'))) {
                                scope.validate = true;
                                scope.errorMessage = rules[i].error;
                                scope.errorModel = rules[i].error;
                                break;
                            } else {
                                if (scope.type === 'date') {
                                    angular.element('#' + scope.textfieldId).removeClass('invalid');
                                }
                            }
                        }
                        else {
                            if (!isFoundInvalid) {
                                if (typeof scope.ngModel != 'object')
                                    var data = scope.ngModel;
                                else
                                    var data = scope.displayModel;

                                RuleEngine.isValid(rules[i], function (e) {
                                    scope.validate = true;
                                    scope.errorMessage = e.errorData.error;
                                    scope.errorModel = e.errorData.error;
                                    isFoundInvalid = true;
                                }, data);
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
                /*
                 * Validate textfield rules
                 */
                scope.validateRules = function () {
                    if (scope.readonly == 'true') {
                        scope.isActive = true;
                        return;
                    }

                    if ((scope.type === 'text' || scope.type === 'area') && angular.isString(scope.ngModel)) {
                        if (attrs.noTrim == 'true') {
                            scope.ngModel = scope.ngModel;
                        } else {
                            scope.ngModel = scope.ngModel.trim();
                        }
                        ngModelCtrl.$setViewValue(scope.ngModel);
                    }

                    if ((scope.type == 'autocomplete' && scope.$eval(scope.isMandatory) && (scope.displayModel == '' || scope.displayModel == null || scope.displayModel == undefined || scope.ngModel.id === 0)) || (scope.type != 'autocomplete' && scope.$eval(scope.isMandatory) && (scope.ngModel + '' == '' || scope.ngModel == null || scope.ngModel == undefined))) {
                        scope.validate = true;
                        scope.errorMessage = $translate.instant('enterValueErrMsg');
                        scope.errorModel = $translate.instant('enterValueErrMsg');
                        return;
                    }

                    if (scope.type == 'number') {
                        if (!scope.$eval(scope.isMandatory) && isNaN(scope.ngModel)) {
                            angular.element('#' + scope.textfieldId).val('');
                            return;
                        }
                        if (!scope.$eval(scope.isMandatory) && scope.ngModel === null) {
                            if (scope.rules) {
                                checkRule();
                            }
                            return;
                        }
                        if (scope.$eval(scope.isMandatory) && isNaN(scope.ngModel) || (!scope.$eval(scope.isMandatory) && number == undefined)) {
                            scope.validate = true;
                            scope.errorMessage = $translate.instant('enterNumberErrMsg');
                            scope.errorModel = $translate.instant('enterNumberErrMsg');
                            return;
                        }
                    }

                    if (scope.type == 'date' && !scope.rules) {
                        $('#' + scope.textfieldId).removeClass('invalid');
                    }

                    scope.validate = false;
                    scope.errorMessage = null;
                    scope.errorModel = null;

                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false;

                        for (var i = 0; i < rules.length; i++) {
                            if (typeof rules[i] == 'object') {
                                if (eval((rules[i].rule).replace(/this/g, scope.type == 'autocomplete' ? 'scope.displayModel' : 'scope.ngModel'))) {
                                    scope.validate = true;
                                    scope.errorMessage = rules[i].error;
                                    break;
                                }
                            }
                            else {
                                if (!isFoundInvalid) {
                                    if (typeof scope.ngModel != 'object')
                                        var data = scope.ngModel;
                                    else
                                        var data = scope.displayModel;

                                    RuleEngine.isValid(rules[i], function (e) {
                                        scope.validate = true;
                                        scope.errorMessage = e.errorData.error;
                                        isFoundInvalid = true;
                                    }, data);
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                };


                //  callback events
                var isDateBlank = false;
                scope.ngChange = function (e) {
                    if (scope.type == 'number') {
                        if (scope.ngModel == null || scope.ngModel == undefined)
                            scope.count = 0;
                        setPrecisionLimits();
                    }
                    scope.isActive = checkIfActive();
                    if (rulesValidationEvent == 'change') {
                        scope.validateRules();
                    }

                    if (scope.type != 'autocomplete') {
                        updateView();
                    }

                    //  Value of 'e' is undefined in ng-change
                    scope.onChange({
                        $event: {
                            data: angular.element('#' + scope.textfieldId),
                            displayModel: scope.displayModel
                        }
                    });
                };

                scope.ngFocus = function (e) {
                    if (scope.type === 'autocomplete' || scope.clearListOnFocus === "true") {
                        var Obj = element.find('input').devbridgeAutocomplete();
                        if (element.find('input').val() == '' && Obj) {
                            Obj.clear();
                        }
                    }
                    scope.isActive = true;
                    scope.validate = false;
                    if (rulesValidationEvent == 'focus') {
                        scope.validateRules();
                    }
                    scope.onFocus({ $event: e });
                };

                scope.ngBlur = function (e) {
                    if (scope.type == 'number') {
                        if (scope.min != undefined || scope.min != null) {
                            if (scope.ngModel == undefined || scope.ngModel == null || isNaN(scope.ngModel)) {
                                $('#' + scope.textfieldId).val('');
                            }
                        }
                    }
                    if (scope.type == 'date' && isDateBlank) {
                        $timeout(function () {
                            var targetedEle = document.activeElement;
                            if (!(angular.element(targetedEle).hasClass('monthselect') || angular.element(targetedEle).hasClass('yearselect') || angular.element(targetedEle).hasClass('hourselect') || angular.element(targetedEle).hasClass('minuteselect'))) {
                                //  scope.ngModel = null;
                                scope.dateModel = null;
                            }
                            if (angular.isFunction(scope.onDateChange)) {
                                scope.onDateChange({
                                    $date: scope.ngModel
                                });
                            }
                        });
                    }
                    if (scope.type === 'autocomplete') {
                        if (scope.ngModel && scope.displayformat) {
                            var splittedDisplayFormat = [];
                            if (scope.displayformat.indexOf(":") > 0)
                                splittedDisplayFormat = scope.displayformat.split(':');
                            else if (scope.displayformat.indexOf("-") > 0)
                                splittedDisplayFormat = scope.displayformat.split('-');
                            else
                                splittedDisplayFormat = scope.displayformat.split('-');
                            var result = "";
                            for (var i = 0; i < splittedDisplayFormat.length; i++) {
                                result += eval("scope.ngModel." + splittedDisplayFormat[i].replace('{', '').replace('}', ''));
                                if (i < splittedDisplayFormat.length - 1) {
                                    if (scope.displayformat.indexOf("-") > 0)
                                        result += '-';
                                    else if (scope.displayformat.indexOf(":") > 0)
                                        result += ':';
                                }
                            }
                            if (scope.retainDisplayModelAutocomplete !== "true") {
                                if (result !== scope.displayModel)
                                    scope.displayModel = '';
                            }
                        }
                    }
                    //as debounce is used smartTextField templates for updating model, $timeout is used to keep validateRules() on blur in sync
                    $timeout(function () {
                        if (scope.type == 'date') {
                            if (pickerObj && pickerObj.isShowing) {
                                return;
                            }
                            else {
                                scope.validateRules();
                                scope.isActive = checkIfActive();
                            }
                        }
                        else {
                            scope.validateRules();
                            scope.isActive = checkIfActive();

                            try {
                                if (angular.isDefined(scope.$parent.$parent.onStopEdit)) {
                                    scope.$parent.$parent.onStopEdit(scope, element);
                                }
                            }
                            catch (e) { }
                        }
                    })

                    //  had to use jQuery because 'active' class does not get removed sometimes even if scope.isActive's value is false
                    scope.isActive || scope.validate ? angular.element('#' + scope.labelForTextfieldId).addClass('active') : angular.element('#' + scope.labelForTextfieldId).removeClass('active');

                    //  had to use jQuery because 'invalid' class does not get removed sometimes even if scope.validate's value is false
                    if (attrs.charactercounter) {
                        scope.validate && scope.errorMessage ? angular.element('#' + scope.textfieldId).addClass('invalid') : angular.element('#' + scope.textfieldId).removeClass('invalid');
                    }
                    scope.focus = false;
                    scope.onBlur({ $event: e });
                };

                scope.ngKeyUp = function (e) {
                    if (scope.type == 'date') {
                        if (e.which != 32) {
                            var currentInputValue = $('#' + scope.textfieldId).val();
                            if (currentInputValue == "") {
                                scope.ngModel = null;
                                scope.dateModel = "";
                                isDateBlank = true;
                                ngModelCtrl.$setViewValue('');
                                if (angular.isFunction(scope.onDateChange)) {
                                    scope.onDateChange({
                                        $date: scope.ngModel
                                    });
                                }
                            }
                        }
                    }
                    if (rulesValidationEvent == 'keyUp') {
                        scope.validateRules();
                    }
                    scope.onKeyUp({ $event: e });
                };

                scope.ngKeyDown = function (e) {
                    if (rulesValidationEvent == 'keyDown') {
                        scope.validateRules();
                    }
                    //to control number of down arrow,up arrow signs on number fields
                    if (scope.type === "number" && (e.keyCode == 38 || e.keyCode == 40))
                        e.preventDefault();
                    scope.onKeyDown({ $event: e });

                };

                scope.ngKeyPress = function (e) {
                    if (scope.type == 'number' || attrs.datanumeric) {
                        //to control number of +,-, signs and alphabets on number fields
                        var charCode = e.charCode || e.keyCode,
                        textValue = e.currentTarget.value,
                        decimalDigit = [],
                        cc = String.fromCharCode(charCode),
                        escapeChars = [37, 38, 39, 40, 46, 8];

                        if (isNaN(cc) && (escapeChars.indexOf(charCode) == -1)) {
                            e.preventDefault();
                        }
                        // Restrict the 2 dots entering
                        if (textValue.toString().indexOf('.') !== -1 && charCode == 46) {
                            e.preventDefault();
                        }

                        if (textValue) {
                            decimalDigit = textValue.toString().split('.');
                        }
                        // Restrict the decimal value from entering
                        if (attrs.decimalprecision) {
                            if (charCode == 46 && parseInt(attrs.decimalprecision) == 0) {
                                e.preventDefault();
                            }
                            if (decimalDigit.length == 2) {
                                if (decimalDigit[1] && decimalDigit[1].length >= parseInt(attrs.decimalprecision, 10)) {
                                    e.preventDefault();
                                }
                            }
                        }
                        if (scope.min != undefined || scope.min != null) {
                            if (scope.min >= 0 && e.charCode == 45) {
                                e.preventDefault();
                            }
                        }
                    }

                    if (rulesValidationEvent == 'keyPress') {
                        scope.validateRules();
                    }
                    scope.onKeyPress({ $event: e });
                    if (e.charCode == 13) {
                        scope.onEnter({ $event: e });
                    }

                    // because of debounce has applied on smart-textfield, here we need to do DOM manipulation i.e. e.target.value to get latest value from textfield
                    if (e.target.value.length === attrs.maxlength && e.charCode !== 0) {
                        e.preventDefault();
                    }
                };


                /*
                 * This function is required to generate value attribute 
                 * and useful when up/down key is pressed
                 */
                function getFormattedData(data) {
                    if (!data || data.length == 0) {
                        return [];
                    }
                    for (var i = 0; i < data.length; i++) {
                        var str = displayFormat;
                        try {
                            var parentSplit = str.split('{');
                            for (var j = 0; j < parentSplit.length; j++) {
                                var childSplit = parentSplit[j].split('}');
                                for (var k = 0; k < childSplit.length; k++) {
                                    if (childSplit[k].indexOf('.') > 0 || data[i].hasOwnProperty(childSplit[k])) {
                                        str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), eval('data[i].' + childSplit[k]));
                                    }
                                }
                            }
                        }
                        catch (e) { }
                        data[i].value = str.trim();
                    }
                    return data;
                };


                /*
                 * Get plain display data
                 */
                function getDisplayData(data) {
                    if (data == undefined || data == null || data == '') {
                        return '';
                    }
                    var str = displayFormat, evalResult, evaluatedKeysCounter = 0, nullKeysCounter = 0;
                    try {
                        var parentSplit = str.split('{');
                        for (var j = 0; j < parentSplit.length; j++) {
                            var childSplit = parentSplit[j].split('}');
                            for (var k = 0; k < childSplit.length; k++) {
                                if (childSplit[k].indexOf('.') > 0 || data.hasOwnProperty(childSplit[k])) {
                                    evalResult = eval('data.' + childSplit[k]);
                                    evaluatedKeysCounter++;
                                    if (evalResult == undefined || evalResult == null || (evalResult + '').trim().length == 0) {
                                        evalResult = '';
                                        nullKeysCounter++;
                                    }
                                    str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), evalResult);
                                }
                            }
                        }
                        if (evaluatedKeysCounter == nullKeysCounter) {
                            str = '';
                        }
                    }
                    catch (e) { }
                    return str === undefined || str === null || str === 'undefined' || str === 'null' ? '' : str;
                }


                /*
                 *  Convert timestamp to UTC timestamp 
                 */
                function toUTC(date) {
                    return Date.UTC(
                        date.getFullYear()
                        , date.getMonth()
                        , date.getDate()
                        , date.getHours()
                        , date.getMinutes()
                        , date.getSeconds()
                        , date.getMilliseconds()
                    );
                };
                scope.isValueDateObj = false;
                var doesContainDateString = false;
                var dateFormate = scope.format;
                function getGridFormatToTimestamp(stringdate) {
                    var tmpModel = (stringdate + '').replace(new RegExp("/", "ig"), '');
                    // tmpModel = tmpModel.split('+');
                    // tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + tmpModel.join('+') + '").getTime()') : tmpModel[0]));
                    return moment(tmpModel).format(dateFormate);
                }
                var pickerObj;
                function createDatePicker() {
                    $timeout(function () {
                        var picker = angular.element('#' + scope.textfieldId);
                        var callApplyFuncFlag = true;
                        function setDateFormate(datePar) {
                            if (doesContainDateString) {
                                scope.ngModel = '\/Date(' + (datePar.unix() * 1000) + ')\/';
                            } else {
                                if (scope.isValueDateObj) {
                                    var tempDate = datePar.format();
                                    scope.ngModel = new Date(tempDate);
                                } else {
                                    scope.ngModel = (datePar.unix() * 1000);
                                }
                            }
                            ngModelCtrl.$setViewValue(scope.ngModel);
                            isDateBlank = false;
                            if (angular.isFunction(scope.onDateChange)) {
                                scope.onDateChange({ $date: scope.ngModel });
                            }
                        }
                        var minDate = angular.isDefined(scope.min) ? doesContainDateString ? getGridFormatToTimestamp(scope.min) : moment(parseInt(scope.min)).format(dateFormate) : '';
                        var maxDate = angular.isDefined(scope.max) ? doesContainDateString ? getGridFormatToTimestamp(scope.max) : moment(parseInt(scope.max)).format(dateFormate) : '';

                        var timePicker24Hour = angular.isDefined(scope.timePicker12Hour) ? false : true;
                        var timePickerIncrement = angular.isDefined(scope.minuteIncrement) ? scope.$eval(scope.minuteIncrement) : 1;

                        pickerObj = picker.daterangepicker({
                            "singleDatePicker": true,
                            "showDropdowns": true,
                            "timePicker": timePicker,
                            "timePicker24Hour": timePicker24Hour,
                            "timePickerIncrement": timePickerIncrement,
                            "autoApply": false,
                            "opens": "right",
                            "drops": "down",
                            "minDate": minDate,
                            "maxDate": maxDate,
                            "locale": {
                                "format": dateFormate,
                                'cancelLabel': $translate.instant('cancelBtn'),
                                'applyLabel': $translate.instant('applyBtn')
                            }
                        }, function (start, end, label) {
                            callApplyFuncFlag = false;
                            setDateFormate(end);
                        }).bind("show.daterangepicker", function () { // callback on after open datepicker
                            var pos = pickerObj.container.offset(),
                                wHeight = window.innerHeight,
                                srTop = $(window).scrollTop();
                            if ((pos.top + pickerObj.container.outerHeight() - srTop) > wHeight) { // if datepicker goes down then push it up
                                pickerObj.drops = "up";
                                pickerObj.move();
                            } else if (pos.top < srTop) { // else if datepicker goes up then push it down
                                pickerObj.drops = "down";
                                pickerObj.move();
                            }
                        }).data("daterangepicker");

                        picker.on('apply.daterangepicker', function (ev, pickerr) {
                            if (callApplyFuncFlag) {
                                setDateFormate(pickerr.endDate)
                            }
                            callApplyFuncFlag = true;
                        });

                        if (isDateBlank) {
                            picker.val('');
                            scope.ngModel = "";
                            ngModelCtrl.$setViewValue('');
                        };
                    });
                }

                switch (scope.type) {
                    case 'autocomplete':
                        // key to be used to bind options
                        var filterKeys;
                        if (angular.isDefined(scope.filterkeys) && scope.filterkeys.trim().indexOf('[') == 0) {
                            filterKeys = scope.filterkeys ? scope.$eval(scope.filterkeys) : ['title'];
                        }
                        else {
                            filterKeys = scope.filterkeys ? scope.$eval('[' + scope.filterkeys + ']') : ['title'];
                        }
                        var optionFormat = scope.optionformat ? scope.optionformat : '{title}';
                        var displayFormat = scope.displayformat ? scope.displayformat : '{title}';

                        /*
                         * Check if the options are updated
                         */
                        var autoCompleteField;
                        var unbindOptions = scope.$watch('options', function (newOptions) {
                            try {
                                if (!$('#' + scope.textfieldId).devbridgeAutocomplete()) {
                                    autoCompleteField = $('#' + scope.textfieldId).devbridgeAutocomplete({
                                        filterKeys: filterKeys,
                                        optionFormat: optionFormat,
                                        displayFormat: displayFormat,
                                        lookup: getFormattedData(newOptions),
                                        width: scope.width,
                                        showNoSuggestionNotice: showNoSuggestion,
                                        noSuggestionNotice: noSuggestionNotice,
                                        minChars: angular.isDefined(scope.minchars) ? parseInt(scope.minchars) : 1,
                                        onSelect: function (suggestion) {
                                            angular.element('#' + scope.labelForTextfieldId).trigger('click');
                                            scope.$evalAsync(function () {
                                                scope.displayModel = getDisplayData(suggestion);
                                                scope.ngModel = suggestion;
                                                updateView();
                                                $timeout(function () {
                                                    scope.onSelect({
                                                        $event: {
                                                            data: suggestion
                                                        }
                                                    });
                                                });
                                            });
                                        }
                                    }).devbridgeAutocomplete();
                                }
                                else {
                                    $('#' + scope.textfieldId).devbridgeAutocomplete().setLookup(getFormattedData(newOptions));
                                }
                            }
                            catch (e) { }
                        });

                        /*
                         * Destroy autocomplete on scope destroy
                         */
                        scope.$on('$destroy', function () {
                            if ($('#' + scope.textfieldId).devbridgeAutocomplete()) {
                                $('#' + scope.textfieldId).devbridgeAutocomplete().dispose();
                            }
                            destroyEverythingElse();
                        });
                        break;
                    case 'date':
                        /*
                         * Destroy datepicker on scope destroy
                         */
                        scope.$on('$destroy', function () {
                            angular.element('#' + scope.textfieldId + '_root').remove();
                            destroyEverythingElse();
                        });
                        break;
                    case 'text':
                    case 'area':
                    case 'number':
                        scope.$on('$destroy', function () {
                            destroyEverythingElse();
                        });
                        break;
                }

                //Closing the suggestions on scroll to prevent overlapping issue
                angular.element($window).scroll(function (e) {
                    hideAutoOnScroll();
                });

                angular.element(".modal, .modal-content").scroll(function (e) {
                    hideAutoOnScroll();
                });

                function hideAutoOnScroll() {
                    if (autoCompleteField != undefined) {
                        if (autoCompleteField.visible) {
                            autoCompleteField.hide();
                        }
                    }
                }

                /*
                 *  Update 'active' class when textfield's value is updated
                 */
                switch (scope.type) {
                    case 'autocomplete':
                    case 'text':
                    case 'area':
                    case 'number':
                        var unbindNumber = scope.$watch('ngModel', function (newVal) {
                            if (scope.type == 'autocomplete' && angular.isDefined(newVal)) {
                                scope.displayModel = getDisplayData(newVal);
                            }
                            if (scope.type == 'number') {
                                setPrecisionLimits();
                            }
                            if (attrs.decimalprecision && attrs.datanumeric) {
                                setPrecisionLimits();
                            }
                            scope.isActive = checkIfActive();
                            if (rulesValidationEvent == 'change') {
                                scope.validateRules();
                            }
                            if (scope.type == 'area') {
                                $timeout(function () {
                                    angular.element('#' + scope.textfieldId).trigger('autoresize');
                                });
                            }
                        });
                        break;

                    case 'date':
                        var unbindDateModel = scope.$watch('dateModel', function (newVal) {
                            scope.isActive = checkIfActive();
                            if (rulesValidationEvent == 'change') {
                                scope.validateRules();
                            }
                        });
                        var unbindNgModel = scope.$watch('ngModel', function (newVal) {
                            dateFormate = scope.format.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
                            isDateBlank = false;
                            doesContainDateString = scope.setFromGrid == 'true' ? true : (newVal + '').toLowerCase().indexOf('date') > -1 ? true : false;
                            if (newVal == "" || newVal == null) {
                                newVal = Date.now();
                                isDateBlank = true;
                                scope.isValueDateObj = false;
                            } else {
                                if (doesContainDateString) {
                                    var tmpModel = (newVal + '').replace(new RegExp("/", "ig"), '');
                                    tmpModel = tmpModel.split('+');
                                    tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + newVal + '").getTime()') : tmpModel[0]));
                                    scope.dateModel = moment(tmpModel).format(dateFormate);
                                }
                                else {
                                    if (Object.prototype.toString.call(newVal) === '[object Date]') {
                                        scope.isValueDateObj = true;
                                    } else {
                                        newVal = parseInt(newVal);
                                    }
                                }
                            }

                            //scope.placeholder = scope.format;
                            scope.placeholder = scope.placeholder == undefined || scope.placeholder == null || scope.placeholder == "" ? 'DD/MM/YYYY' : scope.placeholder; // to consider custom placeholder value and not only the format of the date-time picker

                            if (!isDateBlank) {
                                if (!doesContainDateString) {
                                    scope.dateModel = moment(newVal).format(dateFormate);
                                }
                            } else {
                                scope.dateModel = "";
                            }
                            createDatePicker();
                        });
                        var unbindMin = scope.$watch('min', function (n) {
                            createDatePicker();
                        });
                        var unbindMax = scope.$watch('max', function (n) {
                            createDatePicker();
                        });
                        break;

                    default:
                        var unbindNgModel = scope.$watch('ngModel', function (newVal) {
                            scope.isActive = checkIfActive();
                            if (rulesValidationEvent == 'change') {
                                scope.validateRules();
                            }
                        });
                        break;
                }

                if (scope.datanumeric == 'true') {
                    scope.spinner = typeof attrs.spinner == 'undefined' ? 'true' : scope.spinner;
                    scope.step = typeof attrs.step == 'undefined' ? 1 : scope.step;
                    $timeout(function () {
                        angular.element('#' + scope.textfieldId).inputNumber(scope.spinner, scope.step);
                    });
                }


                function destroyEverythingElse() {
                    element.off(); // deregister all event handlers
                    $('#' + scope.textfieldId).off();
                    $('#' + scope.labelForTextfieldId).off();

                    if (unbindValidate)
                        unbindValidate();
                    if (unbindFocus)
                        unbindFocus();
                    if (unbindOptions)
                        unbindOptions();
                    if (unbindNumber)
                        unbindNumber();
                    if (unbindDateModel)
                        unbindDateModel();
                    if (angular.isFunction(scope.onDestroy)) {
                        scope.onDestroy({});
                    }
                    // Removing contents of HTML from DOM
                    $('#' + scope.textfieldId).remove();
                    $('#' + scope.labelForTextfieldId).remove();
                }
            },
            templateUrl: 'shared/directives/uiElements/smartTextfield/smartTextfieldTemplate.html'
        };
    }


    function smartTextField2Func($rootScope, $timeout, $translate, ScrollTo, RuleEngine, smartTextFieldService, smartTextField3Service, $filter) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                label: '@',
                ngModel: '=?',
                options: '=?',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                onChange: '&',
                onFocus: '&',
                onBlur: '&',
                onKeyUp: '&',
                onKeyDown: '&',
                onKeyPress: '&',
                onEnter: '&',
                onSelect: '&',
                onDestroy: '&',
                onDateChange: '&',
                errorMessage: '@',
                errorModel: '=?',
                setFromGrid: '@',
                //  input element's attribute except for listeners should be in small letters
                type: '@',
                align: '@',
                datanumeric: '@',
                spinner: '@',
                step: '@',
                format: '@',    //  date format
                timePicker: '@', //boolean value if date with time picker
                isValueDateObj: '@',
                readonly: '@',
                disable: '@',
                prefixicon: '@',
                suffixicon: '@',
                maxlength: '@',
                min: '@',
                max: '@',
                timePicker12Hour: '@',
                minuteIncrement: '@',
                charactercounter: '@',
                decimalprecision: '@',
                minmaxprecision: '@',
                placeholder: '@',
                autocomplete: '@',
                removable: '@',
                datakey: '@',
                filterkeys: '@',
                optionformat: '@',
                displayformat: '@',
                width: '@',      //  autosuggest container width
                minchars: '@',   //  autosuggest min chars
                loading: '@',     //  loader while autosuggest data is being fetched
                count: '@',
                noSuggestionNotice: '@',
                showNoSuggestion: '@',
                clearListOnFocus: '@',
                retainDisplayModelAutocomplete: '@',
                showinfo: '@',
                showwarning: '@',
                clienterror: '=?',
                isTitleVisible: '@'
            },
            compile: function () {
                return {
                    post: function (scope, element, attrs, ngModelCtrl) {
                        if (scope.type === undefined || scope.type === 'text' || scope.type === 'area' || scope.type === 'password') {
                            smartTextField_TextFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate);
                        }
                        else if (scope.type === 'date') {

                            SmartTextField_DateFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate);
                        }
                        else if (scope.type === 'autocomplete') {

                            SmartTextField_AutocompleteFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate);

                        }
                        else if (scope.type == 'number') {
                            smartTextField_NumFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $filter, $translate);
                        }
                        else {
                            function SmartTextField_NumberFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate) {
                                scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
                                scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
                                scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
                                scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
                                scope.count = 0;
                                var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
                                var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
                                showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
                                var number, rulesValidationEvent;
                                scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
                                textfieldId++;
                                scope.textfieldId = 'tf_' + textfieldId;
                                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

                                if (attrs.validateOn) {
                                    rulesValidationEvent = attrs.validateOn;
                                }
                                else {
                                    rulesValidationEvent = 'blur';
                                }



                                scope.onTextChange = function (e) {
                                    scope.ngModel = e.target.value;
                                    smartTextFieldService.updateTextValue(scope, element);
                                    smartTextFieldService.setActiveClass(scope, element);
                                    // if (rulesValidationEvent == 'change') {
                                    smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
                                    smartTextFieldService.updateTextFieldClass(scope, element);
                                    //  }
                                    scope.onChange({ $event: e });
                                };

                                scope.ngBlur = function (e) {

                                    scope.focus = false;
                                    smartTextFieldService.updateTextValue(scope, element);
                                    smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
                                    smartTextFieldService.setActiveClass(scope, element);
                                    smartTextFieldService.updateTextFieldClass(scope, element);




                                    scope.onBlur({ $event: e });
                                }

                                scope.ngKeyPress = function (e) {
                                    scope.onKeyPress({ $event: e });
                                };





                                /*
                             *  Following code has been added to make ng-model-options work
                             *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                             */
                                //try {
                                //    ngModelCtrl.$render = function () {
                                //        scope.ngModel = ngModelCtrl.$modelValue;
                                //        smartTextFieldService.updateTextValue(scope, element);
                                //    };
                                //}
                                //catch (e) { }

                                scope.prevModel = scope.ngModel;
                                var updateView = function () {
                                    try {
                                        if (scope.ngModel !== scope.prevModel) {
                                            $timeout(function () {
                                                scope.prevModel = scope.ngModel;
                                            });

                                        }
                                        //ngModelCtrl.$setViewValue(scope.ngModel);
                                        smartTextFieldService.updateTextValue(scope, element);
                                    }
                                    catch (e) { }
                                };



                                var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

                                    scope.isActive = smartTextFieldService.checkIfActive(scope, element);


                                    smartTextFieldService.updateTextValue(scope, element);
                                    smartTextFieldService.setActiveClass(scope, element);
                                    smartTextFieldService.updateTextFieldClass(scope, element);
                                });

                                var unbindAttributesWatcher = scope.$watchGroup(['isMandatory', 'disable', 'readonly', 'focus', 'validate', 'isRemovable'], function (newVal, oldVal) {

                                    if (newVal[4] != oldVal[4]) {
                                        smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
                                    }
                                    smartTextFieldService.setActiveClass(scope, element);
                                    smartTextFieldService.updateTextFieldClass(scope, element);


                                });

                                scope.hideShowField = function () {
                                    scope.isVisible = !scope.isVisible;
                                };



                                smartTextFieldService.buildTemplate(scope, element, scope.onTextChange);

                                scope.$on('$destroy', function () {
                                    unbindModelWatcher();
                                    unbindAttributesWatcher();
                                });
                            }
                            SmartTextField_NumberFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate);
                        }
                        //$timeout(function () {
                        //    element.find("input").trigger('blur'); // initiate with initial value
                        //});

                    }
                }

            }
        }
    }

    function smartTextField3Func($rootScope, $timeout, $translate, ScrollTo, RuleEngine, smartTextFieldService, smartTextField3Service, $filter, $window, persistenceService) {
        return {
            restrict: 'E',
            replace: true,
            require: '?ngModel',
            scope: {
                label: '@',
                ngModel: '=?',
                options: '=?',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                onChange: '&',
                onFocus: '&',
                onBlur: '&',
                onKeyUp: '&',
                onKeyDown: '&',
                onKeyPress: '&',
                onEnter: '&',
                onSelect: '&',
                onDestroy: '&',
                onDateChange: '&',
                errorMessage: '@',
                errorModel: '=?',
                setFromGrid: '@',
                //  input element's attribute except for listeners should be in small letters
                type: '@',
                align: '@',
                datanumeric: '@',
                spinner: '@',
                step: '@',
                format: '@',    //  date format
                regionalFormat: '@',    //  regional date format
                timePicker: '@', //boolean value if date with time picker
                isValueDateObj: '@',
                readonly: '@',
                disable: '@',
                prefixicon: '@',
                suffixicon: '@',
                maxlength: '@',
                min: '@',
                max: '@',
                timePicker12Hour: '@',
                minuteIncrement: '@',
                charactercounter: '@',
                decimalprecision: '@',
                minmaxprecision: '@',
                placeholder: '@',
                autocomplete: '@',
                removable: '@',
                datakey: '@',
                filterkeys: '@',
                optionformat: '@',
                displayformat: '@',
                width: '@',      //  autosuggest container width
                minchars: '@',   //  autosuggest min chars
                loading: '@',     //  loader while autosuggest data is being fetched
                count: '@',
                noSuggestionNotice: '@',
                showNoSuggestion: '@',
                clearListOnFocus: '@',
                retainDisplayModelAutocomplete: '@',
                showinfo: '@',
                showwarning: '@',
                isTitleVisible: '@',
                clienterror: '=?',
                id: '@',
                masterData: '@',
                currencySymbol: '=?'
            },
            compile: function () {
                return {
                    post: function (scope, element, attrs, ngModelCtrl) {
                        //console.log(scope.id);
                        //console.log(scope.masterData);
                        if (scope.type === undefined || scope.type === 'text' || scope.type === 'area' || scope.type === 'password') {
                            smartTextField3_TextFunc(scope, element, attrs, ngModelCtrl, smartTextField3Service, $timeout, $translate);
                        }
                        else if (scope.type === 'date') {

                            SmartTextField3_DateFunc(scope, element, attrs, ngModelCtrl, smartTextField3Service, $timeout, $translate);
                        }
                        else if (scope.type === 'autocomplete') {

                            SmartTextField3_AutocompleteFunc(scope, element, attrs, ngModelCtrl, smartTextField3Service, $timeout, $translate, $window, persistenceService);

                        }
                        else if (scope.type == 'number') {
                            smartTextField3_NumFunc(scope, element, attrs, ngModelCtrl, smartTextField3Service, $timeout, $filter, $translate);
                        }
                        else {
                            function SmartTextField_NumberFunc(scope, element, attrs, ngModelCtrl, smartTextField3Service, $timeout, $translate) {
                                scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
                                scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
                                scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
                                scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
                                scope.count = 0;
                                var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
                                var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
                                showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
                                var number, rulesValidationEvent;
                                scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
                                textfieldId++;
                                scope.textfieldId = 'tf_' + textfieldId;
                                scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

                                if (attrs.validateOn) {
                                    rulesValidationEvent = attrs.validateOn;
                                }
                                else {
                                    rulesValidationEvent = 'blur';
                                }



                                scope.onTextChange = function (e) {
                                    scope.ngModel = e.target.value;
                                    smartTextField3Service.updateTextValue(scope, element);
                                    smartTextField3Service.setActiveClass(scope, element);
                                    // if (rulesValidationEvent == 'change') {
                                    smartTextField3Service.validateRules(scope, ngModelCtrl, element, attrs);
                                    smartTextField3Service.updateTextFieldClass(scope, element);
                                    //  }
                                    scope.onChange({ $event: e });
                                };

                                scope.ngBlur = function (e) {

                                    scope.focus = false;
                                    smartTextField3Service.updateTextValue(scope, element);
                                    smartTextField3Service.validateRules(scope, ngModelCtrl, element, attrs);
                                    smartTextField3Service.setActiveClass(scope, element);
                                    smartTextField3Service.updateTextFieldClass(scope, element);




                                    scope.onBlur({ $event: e });
                                }

                                scope.ngKeyPress = function (e) {
                                    scope.onKeyPress({ $event: e });
                                };





                                /*
                             *  Following code has been added to make ng-model-options work
                             *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
                             */
                                //try {
                                //    ngModelCtrl.$render = function () {
                                //        scope.ngModel = ngModelCtrl.$modelValue;
                                //        smartTextField3Service.updateTextValue(scope, element);
                                //    };
                                //}
                                //catch (e) { }

                                scope.prevModel = scope.ngModel;
                                var updateView = function () {
                                    try {
                                        if (scope.ngModel !== scope.prevModel) {
                                            $timeout(function () {
                                                scope.prevModel = scope.ngModel;
                                            });

                                        }
                                        //ngModelCtrl.$setViewValue(scope.ngModel);
                                        smartTextField3Service.updateTextValue(scope, element);
                                    }
                                    catch (e) { }
                                };



                                var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

                                    scope.isActive = smartTextField3Service.checkIfActive(scope, element);


                                    smartTextField3Service.updateTextValue(scope, element);
                                    smartTextField3Service.setActiveClass(scope, element);
                                    smartTextField3Service.updateTextFieldClass(scope, element);
                                });

                                var unbindAttributesWatcher = scope.$watchGroup(['isMandatory', 'disable', 'readonly', 'focus', 'validate', 'isRemovable'], function (newVal, oldVal) {

                                    if (newVal[4] != oldVal[4]) {
                                        smartTextField3Service.validateRules(scope, ngModelCtrl, element, attrs);
                                    }
                                    smartTextField3Service.setActiveClass(scope, element);
                                    smartTextField3Service.updateTextFieldClass(scope, element);


                                });

                                scope.hideShowField = function () {
                                    scope.isVisible = !scope.isVisible;
                                };



                                smartTextField3Service.buildTemplate(scope, element, scope.onTextChange);

                                scope.$on('$destroy', function () {
                                    unbindModelWatcher();
                                    unbindAttributesWatcher();
                                });
                            }
                            SmartTextField_NumberFunc(scope, element, attrs, ngModelCtrl, smartTextField3Service, $timeout, $translate);
                        }
                        //$timeout(function () {
                        //    element.find("input").trigger('blur'); // initiate with initial value
                        //});

                    }
                }

            }
        }
    }

    function smartTextField_TextFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate) {
        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
        var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
        showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);
        scope.showTitle = scope.isTitleVisible == undefined || scope.isTitleVisible == null || scope.isTitleVisible == 'true' ? true : false;

        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }

        scope.onTextChange = function (e) {
            //scope.ngModel = e.target.value;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);

            smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
            smartTextFieldService.setActiveClass(scope, element);
            // if (rulesValidationEvent == 'change') {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.updateTextFieldClass(scope, element);
            //  }
            scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {
            scope.focus = false;
            scope.onBlur({ $event: e });
            $timeout(function () {
                //updateView();

                smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
            });
        }

        scope.ngKeyPress = function (e) {
            scope.typing = true;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);
            updateView();
            if (attrs.onKeyPress) {
                scope.onKeyPress({ $event: e });
            }
            if (attrs.onEnter && e.charCode == 13) {
                scope.onEnter({ $event: e });
            }
        };

        scope.ngKeyUp = function (e) {
            scope.validate = false;
            scope.typing = true;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);
            updateView();
            scope.onKeyUp({ $event: e });
        };

        scope.ngKeyDown = function (e) {
             scope.typing = true;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);
            updateView();
            scope.onKeyDown({ $event: e });
        };

        scope.ngFocus = function (e) {
            scope.onFocus({ $event: e });
        };

        scope.prevModel = smartTextFieldService.modal.getModal(scope, ngModelCtrl);
        var updateView = function () {
            try {
                if (smartTextFieldService.modal.getModal(scope, ngModelCtrl) !== scope.prevModel) {

                    /* Removed $timeout due to ngBlur gets fired before scope.ngModel */
                    $timeout(function () {
                        scope.prevModel = smartTextFieldService.modal.getModal(scope, ngModelCtrl);

                        if (typeof scope.ngModel === 'function') {
                            smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                        }
                    });
                    //scope.$apply();
                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
            }
            catch (e) { }
        };

        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateTextValue(scope, element);
        //    };
        //}
        //catch (e) { }
        var unbindModelWatcher;
        if (typeof scope.ngModel != 'function') {
            unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

                scope.isActive = smartTextFieldService.checkIfActive(scope, element);
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
                if(scope.typing === true) scope.typing = false;
                smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
            });
        } else {
            unbindModelWatcher = scope.$watch(function () { return scope.ngModel(); }, function (newVal, oldVal) {
                if (newVal != oldVal) {
                     scope.typing = false;
                    scope.isActive = smartTextFieldService.checkIfActive(scope, element);


                    smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                    smartTextFieldService.setActiveClass(scope, element);
                    smartTextFieldService.updateTextFieldClass(scope, element);
                }

            }, true);
        }

        //var unbindAttributesWatcher = scope.$watchGroup(['isMandatory', 'disable', 'readonly', 'focus', 'validate', 'isRemovable'], function (newVal, oldVal) {

        //    if (newVal[4] != oldVal[4]) {
        //        smartTextFieldService.validateRules(scope, ngModelCtrl, element,attrs);
        //    }
        //    smartTextFieldService.setActiveClass(scope, element);
        //    smartTextFieldService.updateTextFieldClass(scope, element);


        //});

        var unbindOtherWatcher;
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();
            }

        });
        unbindOtherWatcher = scope.$watchGroup(['isMandatory', 'focus', 'validate', 'isRemovable', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
            if (newVal[2] != oldVal[2] || newVal[4] != oldVal[4]) { //validate
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);

                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
            }
            if (newVal[5] != oldVal[5] || newVal[6] != oldVal[6]) {
                if (scope.showinfo || scope.showwarning) {
                    element.find('> .input-field').addClass('field-has-icon');
                }
                else {
                    element.find('> .input-field').removeClass('field-has-icon');
                }
            }
            if (newVal[1] || newVal[1] == "true") {
                element.find('input').focus();
            }
        });

        //function bindOtherWatcher() {
        //    if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
        //        //if (!angular.isDefined(unbindOtherWatcher)) {

        //        //}
        //    }
        //    else {
        //        if (angular.isDefined(unbindOtherWatcher)) {
        //            unbindOtherWatcher();
        //        }
        //    }
        //}
        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };
        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange, attrs);
        updateView();

        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }

        //bindOtherWatcher();
        //setTimeout(function () {
        //    //if (scope.readonly == 'true') {
        //    //    angular.element('#' + scope.textfieldId).attr('tabindex', -1);
        //    //}
        //    try {
        //        if (angular.isDefined(scope.$parent.$parent.onEditableRender)) {
        //            scope.$parent.$parent.onEditableRender(scope, element);
        //        }
        //    }
        //    catch (e) { }
        //});

        scope.$on('$destroy', function () {
            unbindModelWatcher();
            unbindAttributesWatcher();
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
        });
    }

    function SmartTextField_DateFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate) {
        if (scope.timePicker === 'true') {
            scope.timePicker = true;
        }

        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null || scope.placeholder == "" ? moment.localeData()._longDateFormat.L : scope.placeholder;
        if (scope.timePicker == true) {
            scope.placeholder = moment.localeData()._longDateFormat.L + ' ' + moment.localeData()._longDateFormat.LT;
        }

        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        scope.datetimePicker = (typeof scope.timePicker == undefined ? false : scope.timePicker === true ? true : false);
        scope.format = (scope.format ? scope.format : scope.datetimePicker ? 'DD/MM/YYYY h:mm' : 'DD/MM/YYYY');
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

        scope.applyClientZone = false;
        scope.isValueDateObj = false;
        scope.doesContainDateString = false;
        scope.dateFormat = scope.format;
        scope.isDateBlank = false;

        if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
            scope.dateFormat = moment.localeData().longDateFormat('L');
            if (scope.timePicker == true) {
                scope.dateFormat = moment.localeData().longDateFormat('L') + ' ' + moment.localeData().longDateFormat('LT');
            }
            scope.format = scope.dateFormat;
        }
        scope.convertIntoUTC = false;
        if (typeof convertIntoUTC != 'undefined') {
            scope.convertIntoUTC = convertIntoUTC;
        }

        //if (angular.isDefined(scope.$parent.$parent.property)) {
        //    //this property (applyClientZone) comes from Config.js
        //    if (angular.isDefined(scope.$parent.$parent.property.applyClientZone)) {
        //        scope.applyClientZone = scope.$parent.$parent.property.applyClientZone;
        //    }
        //}



        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }



        scope.onTextChange = function (e) {
            //scope.ngModel = e.target.value;
            // smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.setActiveClass(scope, element);
            // if (rulesValidationEvent == 'change') {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.updateTextFieldClass(scope, element);
            //  }
            scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {
            if (scope.isDateBlank) {
                var targetedEle = document.activeElement;
                if (!(angular.element(targetedEle).hasClass('monthselect') || angular.element(targetedEle).hasClass('yearselect') || angular.element(targetedEle).hasClass('hourselect') || angular.element(targetedEle).hasClass('minuteselect'))) {
                    //  scope.ngModel = null;
                    scope.dateModel = null;
                }
                if (angular.isFunction(scope.onDateChange)) {
                    scope.onDateChange({
                        $date: scope.ngModel
                    });
                }
            }

            scope.focus = false;
            //smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);




            scope.onBlur({ $event: e });
        }

        scope.ngKeyUp = function (e) {
            if (e.which != 32) {
                var currentInputValue = $('#' + scope.textfieldId).val();
                if (currentInputValue == "") {
                    scope.ngModel = null;
                    scope.dateModel = ""
                    scope.isDateBlank = true;
                    if (angular.isFunction(scope.onDateChange)) {
                        scope.onDateChange({
                            $date: scope.ngModel
                        });
                    }
                }
            }

            if (rulesValidationEvent == 'keyUp') {
                scope.validateRules();
            }
            scope.onKeyUp({ $event: e });
        };

        scope.ngKeyDown = function (e) {
            if (rulesValidationEvent == 'keyDown') {
                scope.validateRules();
            }
            ////to control number of down arrow,up arrow signs on number fields
            //if (e.keyCode == 38 || e.keyCode == 40)
            //    e.preventDefault();
            scope.onKeyDown({ $event: e });
        };

        scope.ngKeyPress = function (e) {

            if (rulesValidationEvent == 'keyPress') {
                scope.validateRules();
            }
            scope.onKeyPress({ $event: e });
            if (e.charCode == 13) {
                scope.onEnter({ $event: e });
            }
        };





        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateDateValue(scope, element);
        //    };
        //}
        //catch (e) { }

        scope.prevModel = scope.ngModel;
        var updateView = function () {
            try {
                if (scope.ngModel !== scope.prevModel) {
                    $timeout(function () {
                        scope.prevModel = scope.ngModel;
                    });

                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateDateValue(scope, element);
            }
            catch (e) { }
        };



        //var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {


        //});


        var unbindOtherWatcher;
        var unbindMin;
        var unbindMax
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();
            }

        });

        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };

        function bindOtherWatcher() {
            if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
                if (!angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher = scope.$watchGroup(['isMandatory', 'focus', 'validate', 'isRemovable', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
                        if (newVal[2] != oldVal[2] || newVal[4] != oldVal[4]) { //validate
                            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);

                            smartTextFieldService.setActiveClass(scope, element);
                            smartTextFieldService.updateTextFieldClass(scope, element);
                        }

                        if (newVal[1] || newVal[1] == "true") {
                            element.find('input').focus();
                        }

                        if (newVal[5] != oldVal[5] || newVal[6] != oldVal[6]) {
                            if (scope.showinfo || scope.showwarning) {
                                element.find('> .input-field').addClass('field-has-icon');
                            }
                            else {
                                element.find('> .input-field').removeClass('field-has-icon');
                            }
                        }
                    });
                }
                if (!angular.isDefined(unbindMin)) {
                    unbindMin = scope.$watch('min', function (n) {
                        smartTextFieldService.createDatePicker(scope, element, ngModelCtrl);
                    });
                }
                if (!angular.isDefined(unbindMax)) {
                    unbindMax = scope.$watch('max', function (n) {
                        smartTextFieldService.createDatePicker(scope, element, ngModelCtrl);
                    });
                }

            }
            else {
                if (angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher();
                }
                if (angular.isDefined(unbindMin)) {
                    unbindMin();
                }
                if (angular.isDefined(unbindMax)) {
                    unbindMax();
                }
            }
        }




        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange);
        smartTextFieldService.updateDateClass(scope, element);
        smartTextFieldService.assignDateEvents(scope, element);
        bindOtherWatcher();
        var unbindDateModel = scope.$watch('dateModel', function (newVal) {
            if (newVal) {
                scope.isActive = smartTextFieldService.checkIfActive(scope, element);
                if (rulesValidationEvent == 'change') {
                    scope.validateRules();
                }
                smartTextFieldService.updateDateValue(scope, element);
            }
        });
        var timeOffset = 20; // this is a fixed number in-case of timeZoneOffset is not defined.
        scope.updatingDateModel = function (dateObj) {
            if (typeof timeZoneOffset != 'undefined') {
                timeOffset = timeZoneOffset;
            }

            if (timeOffset == 20) {
                var adjustTimeZone = 0;
                if (moment().zone() == -720) {
                    adjustTimeZone = -1;
                }
                scope.dateModel = moment(dateObj).add(adjustTimeZone, 'second').format(scope.dateFormat);
            }
            else {
                var adjustTimeZone = 0;
                if (timeOffset == -12) {
                    adjustTimeZone = -1;
                }

                if (typeof dateObj == 'object') {
                    if (timeZoneOffset != 20) {
                        scope.dateModel = moment(dateObj).add(timeOffset * 60, 'minute').add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                    else {
                        scope.dateModel = moment(dateObj).add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                } else {
                    if (timeZoneOffset != 20) {
                        scope.dateModel = moment(dateObj).utc().zone(timeOffset * -1).add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                    else {
                        scope.dateModel = moment(dateObj).utc().add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                    //scope.dateModel = moment(dateObj).zone(timeOffset * -1).utc().add(adjustTimeZone, 'second').format(scope.dateFormat);
                }
            }

        }
        // should be modified to discard UTC Convertion 
        var unbindNgModel = scope.$watch('ngModel', function (newVal) {
            if (scope.timePicker === 'true') {
                scope.timePicker = true;
            }
            if (!scope.dateModifiedbyUser) {
                scope.dateFormat = scope.format.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
                if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
                    scope.dateFormat = moment.localeData().longDateFormat('L');
                    if (scope.timePicker == true) {
                        scope.dateFormat = moment.localeData().longDateFormat('L') + ' ' + moment.localeData().longDateFormat('LT');
                    }
                    scope.format = scope.dateFormat;
                }

                scope.isDateBlank = false;
                scope.doesContainDateString = scope.setFromGrid == 'true' ? true : (newVal + '').toLowerCase().indexOf('date') > -1 ? true : false;
                if (newVal == "" || newVal == null || typeof newVal == 'function') {
                    newVal = Date.now();
                    scope.isDateBlank = true;
                    scope.isValueDateObj = false;
                } else {
                    if (scope.doesContainDateString) {
                        var dateStr = (newVal + '').replace(new RegExp("/", "ig"), '');
                        var tmpModel = dateStr;
                        if (dateStr.indexOf('Date') <= -1) {
                            tmpModel = tmpModel.split('+');
                            tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + newVal + '").getTime()') : tmpModel[0]));
                        }
                        scope.updatingDateModel(tmpModel);
                        //scope.dateModel = moment(tmpModel).format(scope.dateFormat);
                        //smartTextFieldService.updateDateValue(scope, element);
                    }
                    else {
                        if (Object.prototype.toString.call(newVal) === '[object Date]') {
                            scope.isValueDateObj = true;
                        } else if (Object.prototype.toString.call(newVal) === '[object String]' && newVal.indexOf('T') > 0) {
                            //scope.isValueDateObj = true;
                        } else {
                            newVal = parseInt(newVal);
                        }
                    }
                }

                scope.placeholder = scope.format;
                //scope.placeholder = scope.placeholder == undefined || scope.placeholder == null || scope.placeholder == "" ? 'DD/MM/YYYY' : scope.placeholder; // to consider custom placeholder value and not only the format of the date-time picker

                if (!scope.isDateBlank) {
                    if (!scope.doesContainDateString) {
                        //if (scope.applyClientZone) {
                        //    scope.dateModel = moment(newVal).parseZone().format(scope.dateFormat);
                        //}
                        //else {
                        scope.updatingDateModel(newVal);
                        //scope.dateModel = moment(newVal).format(scope.dateFormat);
                        //}
                    }
                } else {
                    scope.dateModel = "";
                }
                smartTextFieldService.updateDateValue(scope, element);
                smartTextFieldService.createDatePicker(scope, element, ngModelCtrl);
            }
            scope.isActive = smartTextFieldService.checkIfActive(scope, element);
            scope.dateModifiedbyUser = false;

            //smartTextFieldService.updateDateValue(scope, element);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);

        });

        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }

        scope.$on('$destroy', function () {
            //unbindModelWatcher();
            unbindAttributesWatcher();
            unbindNgModel();
            unbindDateModel();
            if (angular.isDefined(unbindMin)) {
                unbindMin();
            }
            if (angular.isDefined(unbindMax)) {
                unbindMax();
            }
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
        });
    }

    function SmartTextField_AutocompleteFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate) {
        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
        var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
        showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }



        scope.onTextChange = function (e) {

            console.log(scope.displayModel);

            //updateView();

            //console.log(scope.displayModel);
            scope.onChange({
                $event: {
                    data: element.find('#' + scope.textfieldId),
                    displayModel: scope.displayModel
                }
            });

            ////scope.ngModel = e.target.value;
            //smartTextFieldService.updateAutocompleteValue (scope, element);
            //smartTextFieldService.setActiveClass(scope, element);
            //// if (rulesValidationEvent == 'change') {
            //smartTextFieldService.validateRules(scope, ngModelCtrl, element);
            //smartTextFieldService.updateTextFieldClass(scope, element);
            ////  }
            ////scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {


            if (scope.ngModel && scope.displayformat) {
                var splittedDisplayFormat = [];
                if (scope.displayformat.indexOf(":") > 0)
                    splittedDisplayFormat = scope.displayformat.split(':');
                else if (scope.displayformat.indexOf("-") > 0)
                    splittedDisplayFormat = scope.displayformat.split('-');
                else
                    splittedDisplayFormat = scope.displayformat.split('-');
                var result = "";
                for (var i = 0; i < splittedDisplayFormat.length; i++) {
                    result += eval("scope.ngModel." + splittedDisplayFormat[i].replace('{', '').replace('}', ''));
                    if (i < splittedDisplayFormat.length - 1) {
                        if (scope.displayformat.indexOf("-") > 0)
                            result += '-';
                        else if (scope.displayformat.indexOf(":") > 0)
                            result += ':';
                    }
                }

                // P2P-16866
                if (scope.retainDisplayModelAutocomplete !== "true") {

                    if (e.target.value.trim() == '' || result !== scope.displayModel) {
                        scope.displayModel = '';
                    }
                }

            }


            scope.focus = false;
            smartTextFieldService.updateAutocompleteValue(scope, element);
            $timeout(function () {
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            });
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);

            try {
                if (angular.isDefined(scope.$parent.$parent.onStopEdit)) {
                    scope.$parent.$parent.onStopEdit(scope, element);
                }
            }
            catch (e) { }



            scope.onBlur({ $event: e });
        }

        scope.ngKeyPress = function (e) {
            ////console.log("The text has been changed.");
            ////updateView();

            ////var val = e.target.value;

            //scope.displayModel = e.target.value;

            if (rulesValidationEvent == 'keyPress') {
                scope.validateRules();
            }
            scope.onKeyPress({ $event: e });
            if (e.charCode == 13) {
                scope.onEnter({ $event: e });
            }


        };
        scope.elmVal = null;
        scope.ngKeyUp = function (e) {
            ////console.log("The text has been changed.");
            ////updateView();

            //if (e.target.value != '' && e.target.value != scope.elmVal) {
            //    scope.elmVal = e.target.value;
            //    scope.onChange({
            //        $event: {
            //            data: element.find('#' + scope.textfieldId),
            //            displayModel: e.target.value
            //        }
            //    });
            //}




        };

        scope.search = function (e) {
            if (e.target.value != '' && e.target.value != scope.elmVal) {
                scope.elmVal = e.target.value;
                scope.onChange({
                    $event: {
                        data: element.find('#' + scope.textfieldId),
                        displayModel: e.target.value
                    }
                });
            }
        };

        scope.ngFocus = function (e) {
            var elm = element.find('#' + scope.textfieldId);
            var Obj = elm.devbridgeAutocomplete();
            if (elm.val() == '' && Obj) {
                Obj.clear();
                scope.elmVal = '';
            }
            scope.onFocus({ $event: e });
        }


        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateAutocompleteValue(scope, element);
        //    };
        //}
        //catch (e) { }

        scope.prevModel = scope.ngModel;
        var updateView = function () {
            try {
                if (scope.ngModel !== scope.prevModel) {
                    $timeout(function () {
                        scope.prevModel = scope.ngModel;
                    });

                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateAutocompleteValue(scope, element);
            }
            catch (e) { }
        };



        var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

            scope.displayModel = smartTextFieldService.getDisplayData(newVal, scope);

            scope.isActive = smartTextFieldService.checkIfActive(scope, element);


            smartTextFieldService.updateAutocompleteValue(scope, element);
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);
        });

        var unbindOtherWatcher;
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();

            }

        });

        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };

        function bindOtherWatcher() {
            if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
                if (!angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher = scope.$watchGroup(['focus', 'isRemovable'], function (newVal, oldVal) {
                        smartTextFieldService.setActiveClass(scope, element);
                        smartTextFieldService.updateTextFieldClass(scope, element);
                    });
                }
            }
            else {
                if (angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher();
                }
            }
        }


        var unbindValidationWatcher = scope.$watchGroup(['isMandatory', 'validate', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
            if (newVal[1] != oldVal[1] || newVal[2] != oldVal[2]) {
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            }
            if (newVal[3] != oldVal[3] || newVal[4] != oldVal[4]) {
                if (scope.showinfo || scope.showwarning) {
                    element.find('> .input-field').addClass('field-has-icon');
                }
                else {
                    element.find('> .input-field').removeClass('field-has-icon');
                }
            }
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);
        });







        // key to be used to bind options
        var filterKeys;
        if (angular.isDefined(scope.filterkeys) && scope.filterkeys.trim().indexOf('[') == 0) {
            filterKeys = scope.filterkeys ? scope.$eval(scope.filterkeys) : ['title'];
        }
        else {
            filterKeys = scope.filterkeys ? scope.$eval('[' + scope.filterkeys + ']') : ['title'];
        }
        var optionFormat = scope.optionformat ? scope.optionformat : '{title}';
        scope.ndisplayFormat = scope.displayformat ? scope.displayformat : '{title}';

        /*
         * Check if the options are updated
         */
        var unbindOptions = scope.$watch('options', function (newOptions) {
            try {
                if (!$('#' + scope.textfieldId).devbridgeAutocomplete()) {
                    $('#' + scope.textfieldId).devbridgeAutocomplete({
                        filterKeys: filterKeys,
                        optionFormat: optionFormat,
                        displayFormat: scope.ndisplayFormat,
                        lookup: smartTextFieldService.getFormattedData(newOptions, scope),
                        width: scope.width,
                        showNoSuggestionNotice: showNoSuggestion,
                        noSuggestionNotice: noSuggestionNotice,
                        minChars: angular.isDefined(scope.minchars) ? parseInt(scope.minchars) : 1,
                        onSelect: function (suggestion) {
                            angular.element(document).trigger('click');
                            scope.$evalAsync(function () {
                                scope.displayModel = smartTextFieldService.getDisplayData(suggestion, scope);
                                scope.ngModel = suggestion;
                                updateView();
                                $timeout(function () {
                                    scope.onSelect({
                                        $event: {
                                            data: suggestion
                                        }
                                    });
                                });
                            });
                        }
                    });
                }
                else {
                    $('#' + scope.textfieldId).devbridgeAutocomplete().setLookup(smartTextFieldService.getFormattedData(newOptions, scope));
                }
            }
            catch (e) { }
        });



        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange, attrs);
        smartTextFieldService.assignAutocompleteEvents(scope, element);
        bindOtherWatcher();

        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }

        scope.$on('$destroy', function () {
            unbindModelWatcher();
            unbindAttributesWatcher();
            unbindOptions();
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
            unbindValidationWatcher();
        });
    }

    function smartTextField_NumFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $filter, $translate) {
        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
        var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
        showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);
        scope.showTitle = scope.isTitleVisible == undefined || scope.isTitleVisible == null || scope.isTitleVisible == 'true' ? true : false;


        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }



        scope.onTextChange = function (e) {

            // if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
            var num = element.find('#' + scope.textfieldId).autoNumeric('get');
            if (num != '') {
                scope.ngModel = parseFloat(element.find('#' + scope.textfieldId).autoNumeric('get'));
            }
            else {
                scope.ngModel = null;
            }
            //}
            //else {
            //    scope.ngModel = parseFloat(e.target.value);
            //}
            updateView();
            //scope.ngModel = parseFloat(e.target.value);
            //smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.setActiveClass(scope, element);
            // if (rulesValidationEvent == 'change') {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.updateTextFieldClass(scope, element);
            //  }
            scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {
            //if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {

            var num = element.find('#' + scope.textfieldId).autoNumeric('get');
            if (num != '') {
                scope.ngModel = parseFloat(element.find('#' + scope.textfieldId).autoNumeric('get'));
            }
            else {
                scope.ngModel = null;
            }
            //}
            //else {
            //    var num = e.target.value;
            //    if (num.trim() != '') {
            //        scope.ngModel = parseFloat(num);
            //    }
            //    else {
            //        scope.ngModel = null;
            //    }
            //}
            updateView();
            scope.focus = false;
            //smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);




            scope.onBlur({ $event: e });
        }

        scope.ngKeyPress = function (e) {
            if (scope.type == 'number' || attrs.datanumeric) {
                //to control number of +,-, signs and alphabets on number fields
                var charCode = e.charCode || e.keyCode,
                textValue = e.currentTarget.value,
                decimalDigit = [],
                cc = String.fromCharCode(charCode),
                escapeChars = [37, 38, 39, 40, 46, 8];

                if (isNaN(cc) && (escapeChars.indexOf(charCode) == -1)) {
                    e.preventDefault();
                }
                // Restrict the 2 dots entering
                if (textValue.toString().indexOf('.') !== -1 && charCode == 46) {
                    e.preventDefault();
                }

                if (textValue) {
                    decimalDigit = textValue.toString().split('.');
                }
                // Restrict the decimal value from entering
                if (attrs.decimalprecision) {
                    if (charCode == 46 && parseInt(attrs.decimalprecision) == 0) {
                        e.preventDefault();
                    }
                    if (decimalDigit.length == 2) {
                        if (decimalDigit[1] && decimalDigit[1].length >= parseInt(attrs.decimalprecision, 10)) {
                            e.preventDefault();
                        }
                    }
                }
                if (scope.min != undefined || scope.min != null) {
                    if (scope.min >= 0 && e.charCode == 45) {
                        e.preventDefault();
                    }
                }
            }

            if (rulesValidationEvent == 'keyPress') {
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            }
            scope.onKeyPress({ $event: e });
            if (e.charCode == 13) {
                scope.onEnter({ $event: e });
            }

            // because of debounce has applied on smart-textfield, here we need to do DOM manipulation i.e. e.target.value to get latest value from textfield
            if (angular.isDefined(attrs.maxlength) && e.target.value.length == attrs.maxlength && e.charCode !== 0) {
                e.preventDefault();
            }
        };




        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateTextValue(scope, element);
        //    };
        //}
        //catch (e) { }

        scope.prevModel = scope.ngModel;
        var updateView = function () {
            try {
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateTextValue(scope, element);
                //smartTextFieldService.updateTextValue(scope, element);
                if (scope.ngModel != null) {
                    var min = 0;
                    var max = 0;
                    if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
                        if (scope.minmaxprecision == undefined || scope.minmaxprecision == '') {
                            min = 0;
                            max = 0;
                        }
                        else {
                            min = MinPrecessionValue;//global default
                            max = MaxPrecessionValue;//global default
                        }
                    }
                    else {
                        if (scope.minmaxprecision !== undefined && scope.minmaxprecision !== '') {
                            var splitPrecision = JSON.parse(scope.minmaxprecision);
                            if (splitPrecision.length == 2) {
                                min = splitPrecision[0];
                                max = splitPrecision[1];
                            }
                        }
                    }
                    try {
                        if (scope.minmaxprecision) {
                            min = JSON.parse(scope.minmaxprecision)[0];
                            max = JSON.parse(scope.minmaxprecision)[1];
                        }
                    }
                    catch (e) {
                        console.log(e)
                    }
                    element.find('#' + scope.textfieldId).val($filter('minPrecisionHandler')(scope.ngModel, min, max, false))
                    if (!scope.ngModel) {
                        var num = element.find('#' + scope.textfieldId).autoNumeric('get');
                        if (num != '') {
                            scope.ngModel = parseFloat(element.find('#' + scope.textfieldId).autoNumeric('get'));
                            smartTextFieldService.setActiveClass(scope, element);
                            smartTextFieldService.updateTextFieldClass(scope, element);
                        }
                        else {
                            scope.ngModel = null;
                        }
                    }

                    if (scope.ngModel !== scope.prevModel) {
                        $timeout(function () {
                            scope.prevModel = scope.ngModel;
                        });
                    }


                }
            }
            catch (e) { }
        };



        var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

            scope.isActive = smartTextFieldService.checkIfActive(scope, element);


            updateView();
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);
        });


        //var unbindAttributesWatcher = scope.$watchGroup(['isMandatory', 'disable', 'readonly', 'focus', 'validate', 'isRemovable'], function (newVal, oldVal) {

        //    if (newVal[4] != oldVal[4]) {
        //        smartTextFieldService.validateRules(scope, ngModelCtrl, element,attrs);
        //    }
        //    smartTextFieldService.setActiveClass(scope, element);
        //    smartTextFieldService.updateTextFieldClass(scope, element);


        //});

        var unbindOtherWatcher;
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();
            }

        });


        function bindOtherWatcher() {
            if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
                if (!angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher = scope.$watchGroup(['isMandatory', 'focus', 'validate', 'isRemovable', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
                        if (newVal[2] != oldVal[2] || newVal[4] != oldVal[4]) { //validate
                            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);

                            smartTextFieldService.setActiveClass(scope, element);
                            smartTextFieldService.updateTextFieldClass(scope, element);
                        }
                        if (newVal[5] != oldVal[5] || newVal[6] != oldVal[6]) {
                            if (scope.showinfo || scope.showwarning) {
                                element.find('> .input-field').addClass('field-has-icon');
                            }
                            else {
                                element.find('> .input-field').removeClass('field-has-icon');
                            }
                        }
                        if (newVal[1] || newVal[1] == "true") {
                            element.find('input').focus();
                        }
                    });
                }
            }
            else {
                if (angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher();
                }
            }
        }




        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };



        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange);
        if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
            if (scope.minmaxprecision == undefined || scope.minmaxprecision == '') {
                element.find('#' + scope.textfieldId).autoNumeric('init', {
                    mDec: 0,
                    aPad: false,
                    aSep: thousandSep,
                    aDec: decimalSep,
                    vMin: Number.NEGATIVE_INFINITY,
                    vMax: Number.POSITIVE_INFINITY
                });
            } else {
                element.find('#' + scope.textfieldId).autoNumeric();
            }
        } else {
            var thousandSep = ',';
            var decimalSep = '.';
            var highPrecisionLimit = 0;
            if (scope.minmaxprecision !== undefined && scope.minmaxprecision !== '') {
                var splitPrecision = JSON.parse(scope.minmaxprecision);
                if (splitPrecision.length == 2) {
                    var lowerPrecisionLimit = splitPrecision[0];
                    highPrecisionLimit = splitPrecision[1];
                }
            }
            element.find('#' + scope.textfieldId).autoNumeric('init', {
                mDec: highPrecisionLimit,
                aPad: false,
                aSep: thousandSep,
                aDec: decimalSep,
                vMin: Number.NEGATIVE_INFINITY,
                vMax: Number.POSITIVE_INFINITY,
            });
        }
        bindOtherWatcher();
        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }
        //setTimeout(function () {
        //    //if (scope.readonly == 'true') {
        //    //    angular.element('#' + scope.textfieldId).attr('tabindex', -1);
        //    //}
        //    try {
        //        if (angular.isDefined(scope.$parent.$parent.onEditableRender)) {
        //            scope.$parent.$parent.onEditableRender(scope, element);
        //        }
        //    }
        //    catch (e) { }
        //});

        scope.$on('$destroy', function () {
            unbindModelWatcher();
            unbindAttributesWatcher();
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
        });
    }



    function smartTextField3_TextFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate) {
        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
        var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
        showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);
        scope.showTitle = scope.isTitleVisible == undefined || scope.isTitleVisible == null || scope.isTitleVisible == 'true' ? true : false;
        scope.typing = false;
        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }
        if (scope.type === 'area') {
            $timeout(function () {
                angular.element('#' + scope.textfieldId).trigger('autoresize');
            });
        }
        scope.onTextChange = function (e) {
            //scope.ngModel = e.target.value;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);

            smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
            smartTextFieldService.setActiveClass(scope, element);
            // if (rulesValidationEvent == 'change') {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.updateTextFieldClass(scope, element);
            //  }
            scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {
            $timeout(function () {
                //updateView();
                scope.focus = false;
                scope.typing = false;
                smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);

                scope.onBlur({ $event: e });
                if (scope.type == "area" && scope.ngModel == "") {
                    $(angular.element('#' + scope.textfieldId)).css("overflow", "hidden");
                }
            });
        }

        scope.ngKeyPress = function (e) {
            scope.typing = true;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);
            updateView();
            if (attrs.onKeyPress) {
                scope.onKeyPress({ $event: e });
            }
            if (attrs.onEnter && e.charCode == 13) {
                scope.onEnter({ $event: e });
            }
        };
        var viewTimeout;
        scope.ngKeyUp = function (e) {
            scope.typing = true;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);
            clearInterval(viewTimeout);
            viewTimeout=setInterval(function(){
				clearInterval(viewTimeout);
				updateView();
			},1500);
            scope.onKeyUp({ $event: e });
            if (scope.type == "area") {
                if ($(angular.element('#' + scope.textfieldId)).height() < 64)
                    $(angular.element('#' + scope.textfieldId)).css("overflow", "hidden");
                else
                    $(angular.element('#' + scope.textfieldId)).css("overflow", "auto");
            }
        };

        scope.ngKeyDown = function (e) {
            scope.typing = true;
            smartTextFieldService.modal.setModal(scope, e.target.value, ngModelCtrl);
            updateView();
            scope.onKeyDown({ $event: e });
        };

        scope.ngFocus = function (e) {
            scope.onFocus({ $event: e });
        };

        scope.prevModel = smartTextFieldService.modal.getModal(scope, ngModelCtrl);
        var updateView = function () {
            try {
                if (smartTextFieldService.modal.getModal(scope, ngModelCtrl) !== scope.prevModel) {

                    /* Removed $timeout due to ngBlur gets fired before scope.ngModel */
                    $timeout(function () {
                        scope.prevModel = smartTextFieldService.modal.getModal(scope, ngModelCtrl);

                        if (typeof scope.ngModel === 'function') {
                            smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                        }
                    });
                    //scope.$apply();
                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
            }
            catch (e) { }
        };

        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateTextValue(scope, element);
        //    };
        //}
        //catch (e) { }
        var unbindModelWatcher;
        if (typeof scope.ngModel != 'function') {
            unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

                scope.isActive = smartTextFieldService.checkIfActive(scope, element);


                smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                if (scope.type === 'area') {
                    $timeout(function () {
                        angular.element('#' + scope.textfieldId).trigger('autoresize');
                    });
                }
            });
        } else {
            unbindModelWatcher = scope.$watch(function () { return scope.ngModel(); }, function (newVal, oldVal) {
                if (newVal != oldVal) {
                    scope.isActive = smartTextFieldService.checkIfActive(scope, element);


                    smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                    smartTextFieldService.setActiveClass(scope, element);
                    smartTextFieldService.updateTextFieldClass(scope, element);
                    if (scope.type === 'area') {
                        $timeout(function () {
                            angular.element('#' + scope.textfieldId).trigger('autoresize');
                        });
                    }
                }

            }, true);
        }

        //var unbindAttributesWatcher = scope.$watchGroup(['isMandatory', 'disable', 'readonly', 'focus', 'validate', 'isRemovable'], function (newVal, oldVal) {

        //    if (newVal[4] != oldVal[4]) {
        //        smartTextFieldService.validateRules(scope, ngModelCtrl, element,attrs);
        //    }
        //    smartTextFieldService.setActiveClass(scope, element);
        //    smartTextFieldService.updateTextFieldClass(scope, element);


        //});

        var unbindOtherWatcher;
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                if(scope.type === 'area'){
                    smartTextFieldService.buildTemplate(scope, element, scope.onTextChange,attrs);
                    smartTextFieldService.updateTextValue(scope, element, ngModelCtrl);
                }
                bindOtherWatcher();
            }

        });
        unbindOtherWatcher = scope.$watchGroup(['isMandatory', 'focus', 'validate', 'isRemovable', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
            if (newVal[2] != oldVal[2] || newVal[4] != oldVal[4]) { //validate
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);

                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
            }
            if (newVal[5] != oldVal[5] || newVal[6] != oldVal[6]) {
                if (scope.showinfo || scope.showwarning) {
                    element.find('> .input-field').addClass('field-has-icon');
                }
                else {
                    element.find('> .input-field').removeClass('field-has-icon');
                }
            }
            if (newVal[1] || newVal[1] == "true") {
                element.find('input').focus();
            }
        });

        //function bindOtherWatcher() {
        //    if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
        //        //if (!angular.isDefined(unbindOtherWatcher)) {

        //        //}
        //    }
        //    else {
        //        if (angular.isDefined(unbindOtherWatcher)) {
        //            unbindOtherWatcher();
        //        }
        //    }
        //}
        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };
        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange, attrs);
        updateView();

        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }

        //bindOtherWatcher();
        //setTimeout(function () {
        //    //if (scope.readonly == 'true') {
        //    //    angular.element('#' + scope.textfieldId).attr('tabindex', -1);
        //    //}
        //    try {
        //        if (angular.isDefined(scope.$parent.$parent.onEditableRender)) {
        //            scope.$parent.$parent.onEditableRender(scope, element);
        //        }
        //    }
        //    catch (e) { }
        //});

        scope.$on('$destroy', function () {
            unbindModelWatcher();
            unbindAttributesWatcher();
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
        });
    }

    function SmartTextField3_DateFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate) {
        if (scope.timePicker === 'true') {
            scope.timePicker = true;
        }

        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null || scope.placeholder == "" ? moment.localeData()._longDateFormat.L : scope.placeholder;
        if (scope.timePicker == true) {
            if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
                scope.placeholder = scope.regionalFormat ? scope.regionalFormat : moment.localeData()._longDateFormat.L + ' ' + moment.localeData()._longDateFormat.LT;
            }
            else {
                scope.placeholder = moment.localeData()._longDateFormat.L + ' ' + moment.localeData()._longDateFormat.LT;
            }
        }

        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        scope.datetimePicker = (typeof scope.timePicker == undefined ? false : scope.timePicker === true ? true : false);
        scope.format = (scope.format ? scope.format : scope.datetimePicker ? 'DD/MM/YYYY h:mm' : 'DD/MM/YYYY');
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

        scope.applyClientZone = false;
        scope.isValueDateObj = false;
        scope.doesContainDateString = false;
        scope.dateFormat = scope.format;
        scope.isDateBlank = false;

        if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
            if (scope.regionalFormat) {
                scope.dateFormat = scope.regionalFormat;
            }
            else {
                if (scope.timePicker == true) {
                    scope.dateFormat = moment.localeData().longDateFormat('L') + ' ' + moment.localeData().longDateFormat('LT');
                }
                else {
                    scope.dateFormat = moment.localeData().longDateFormat('L');
                }
            }
            scope.format = scope.dateFormat;
        }

        scope.convertIntoUTC = false;
        if (typeof convertIntoUTC != 'undefined') {
            scope.convertIntoUTC = convertIntoUTC;
        }

        //if (angular.isDefined(scope.$parent.$parent.property)) {
        //    //this property (applyClientZone) comes from Config.js
        //    if (angular.isDefined(scope.$parent.$parent.property.applyClientZone)) {
        //        scope.applyClientZone = scope.$parent.$parent.property.applyClientZone;
        //    }
        //}



        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }



        scope.onTextChange = function (e) {
            //scope.ngModel = e.target.value;
            // smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.setActiveClass(scope, element);
            // if (rulesValidationEvent == 'change') {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.updateTextFieldClass(scope, element);
            //  }
            scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {
            if (scope.isDateBlank) {
                var targetedEle = document.activeElement;
                if (!(angular.element(targetedEle).hasClass('monthselect') || angular.element(targetedEle).hasClass('yearselect') || angular.element(targetedEle).hasClass('hourselect') || angular.element(targetedEle).hasClass('minuteselect'))) {
                    //  scope.ngModel = null;
                    scope.dateModel = null;
                }
                if (angular.isFunction(scope.onDateChange)) {
                    scope.onDateChange({
                        $date: scope.ngModel
                    });
                }
            }

            var selectedDate = smartTextFieldService.getSelectedDate();
            if (selectedDate == '') {
                $('#' + scope.textfieldId).val('');
            }
            if ($('#' + scope.textfieldId).find('input').daterangepicker())
                $('#' + scope.textfieldId).find('input').daterangepicker().daterangepicker();
            if (angular.isDefined(selectedDate) && scope.datetimePicker && selectedDate.indexOf('Date(') <= -1)
                $('#' + scope.textfieldId).val(smartTextFieldService.getPreviousDate());
            smartTextFieldService.setSelectedDate(undefined);
            scope.focus = false;
            //smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);




            scope.onBlur({ $event: e });
        }

        scope.ngKeyUp = function (e) {
            if (e.which != 32) {
                var currentInputValue = $('#' + scope.textfieldId).val();
                smartTextFieldService.setSelectedDate($('#' + scope.textfieldId).val());
                if (currentInputValue == "") {
                    scope.ngModel = null;
                    scope.dateModel = ""
                    scope.isDateBlank = true;
                    if (angular.isFunction(scope.onDateChange)) {
                        scope.onDateChange({
                            $date: scope.ngModel
                        });
                    }
                }
            }

            if (rulesValidationEvent == 'keyUp') {
                scope.validateRules();
            }
            scope.onKeyUp({ $event: e });
        };

        scope.ngKeyDown = function (e) {
            if (rulesValidationEvent == 'keyDown') {
                scope.validateRules();
            }
            ////to control number of down arrow,up arrow signs on number fields
            //if (e.keyCode == 38 || e.keyCode == 40)
            //    e.preventDefault();
            scope.onKeyDown({ $event: e });
        };

        scope.ngKeyPress = function (e) {

            if (rulesValidationEvent == 'keyPress') {
                scope.validateRules();
            }
            scope.onKeyPress({ $event: e });
            if (e.charCode == 13) {
                scope.onEnter({ $event: e });
            }
        };





        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateDateValue(scope, element);
        //    };
        //}
        //catch (e) { }

        scope.prevModel = scope.ngModel;
        var updateView = function () {
            try {
                if (scope.ngModel !== scope.prevModel) {
                    $timeout(function () {
                        scope.prevModel = scope.ngModel;
                    });

                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateDateValue(scope, element);
            }
            catch (e) { }
        };



        //var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {


        //});


        var unbindOtherWatcher;
        var unbindMin;
        var unbindMax
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();
            }

        });

        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };

        function bindOtherWatcher() {
            if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
                if (!angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher = scope.$watchGroup(['isMandatory', 'focus', 'validate', 'isRemovable', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
                        if (newVal[2] != oldVal[2] || newVal[4] != oldVal[4]) { //validate
                            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);

                            smartTextFieldService.setActiveClass(scope, element);
                            smartTextFieldService.updateTextFieldClass(scope, element);
                        }

                        if (newVal[1] || newVal[1] == "true") {
                            element.find('input').focus();
                        }

                        if (newVal[5] != oldVal[5] || newVal[6] != oldVal[6]) {
                            if (scope.showinfo || scope.showwarning) {
                                element.find('> .input-field').addClass('field-has-icon');
                            }
                            else {
                                element.find('> .input-field').removeClass('field-has-icon');
                            }
                        }
                    });
                }
                if (!angular.isDefined(unbindMin)) {
                    unbindMin = scope.$watch('min', function (n) {
                        smartTextFieldService.createDatePicker(scope, element, ngModelCtrl);
                    });
                }
                if (!angular.isDefined(unbindMax)) {
                    unbindMax = scope.$watch('max', function (n) {
                        smartTextFieldService.createDatePicker(scope, element, ngModelCtrl);
                    });
                }

            }
            else {
                if (angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher();
                }
                if (angular.isDefined(unbindMin)) {
                    unbindMin();
                }
                if (angular.isDefined(unbindMax)) {
                    unbindMax();
                }
            }
        }




        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange);
        smartTextFieldService.updateDateClass(scope, element);
        smartTextFieldService.assignDateEvents(scope, element);
        bindOtherWatcher();
        var unbindDateModel = scope.$watch('dateModel', function (newVal) {
            if (newVal) {
                scope.isActive = smartTextFieldService.checkIfActive(scope, element);
                if (rulesValidationEvent == 'change') {
                    scope.validateRules();
                }
                smartTextFieldService.updateDateValue(scope, element);
            }
        });
        var timeOffset = 20; // this is a fixed number in-case of timeZoneOffset is not defined.
        scope.updatingDateModel = function (dateObj) {
            if (typeof timeZoneOffset != 'undefined') {
                timeOffset = timeZoneOffset;
            }

            if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable && scope.regionalFormat) {
                timeOffset = 0;
            }

            if (timeOffset == 20) {
                var adjustTimeZone = 0;
                if (moment().zone() == -720) {
                    adjustTimeZone = -1;
                }
                scope.dateModel = moment(dateObj).add(adjustTimeZone, 'second').format(scope.dateFormat);
            }
            else {
                var adjustTimeZone = 0;
                if (timeOffset == -12) {
                    adjustTimeZone = -1;
                }

                if (typeof dateObj == 'object') {
                    if (timeZoneOffset != 20) {
                        scope.dateModel = moment(dateObj).add(timeOffset * 60, 'minute').add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                    else {
                        scope.dateModel = moment(dateObj).add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                } else {
                    if (timeZoneOffset != 20) {
                        scope.dateModel = moment(dateObj).utc().zone(timeOffset * -1).add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                    else {
                        scope.dateModel = moment(dateObj).utc().add(adjustTimeZone, 'second').format(scope.dateFormat);
                    }
                    //scope.dateModel = moment(dateObj).zone(timeOffset * -1).utc().add(adjustTimeZone, 'second').format(scope.dateFormat);
                }
            }

        }
        // should be modified to discard UTC Convertion 
        var unbindNgModel = scope.$watch('ngModel', function (newVal) {
            if (scope.timePicker === 'true') {
                scope.timePicker = true;
            }
            if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable && scope.regionalFormat) {
                $timeout(function () {
                    scope.dateModel = element.find('input').val();
                }, 250);
            }
            if (!scope.dateModifiedbyUser) {
                if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
                    if (scope.regionalFormat) {
                        scope.dateFormat = scope.regionalFormat;
                    }
                    else {
                        if (scope.timePicker == true) {
                            scope.dateFormat = moment.localeData().longDateFormat('L') + ' ' + moment.localeData().longDateFormat('LT');
                        }
                        else {
                            scope.dateFormat = moment.localeData().longDateFormat('L');
                        }
                    }
                    scope.dateFormat = scope.dateFormat.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
                    scope.format = scope.dateFormat;
                }
                else {
                    scope.dateFormat = scope.format.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
                }

                scope.isDateBlank = false;
                scope.doesContainDateString = scope.setFromGrid == 'true' ? true : (newVal + '').toLowerCase().indexOf('date') > -1 ? true : false;
                if (newVal == "" || newVal == null || typeof newVal == 'function') {
                    newVal = Date.now();
                    scope.isDateBlank = true;
                    scope.isValueDateObj = false;
                } else {
                    if (scope.doesContainDateString) {
                        var dateStr = (newVal + '').replace(new RegExp("/", "ig"), '');
                        var tmpModel = dateStr;
                        if (dateStr.indexOf('Date') <= -1) {
                            tmpModel = tmpModel.split('+');
                            tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + newVal + '").getTime()') : tmpModel[0]));
                        }
                        scope.updatingDateModel(tmpModel);
                        //scope.dateModel = moment(tmpModel).format(scope.dateFormat);
                        //smartTextFieldService.updateDateValue(scope, element);
                    }
                    else {
                        if (Object.prototype.toString.call(newVal) === '[object Date]') {
                            scope.isValueDateObj = true;
                        } else if (Object.prototype.toString.call(newVal) === '[object String]' && newVal.indexOf('T') > 0) {
                            //scope.isValueDateObj = true;
                        } else {
                            newVal = parseInt(newVal);
                        }
                    }
                }

                scope.placeholder = scope.format;
                //scope.placeholder = scope.placeholder == undefined || scope.placeholder == null || scope.placeholder == "" ? 'DD/MM/YYYY' : scope.placeholder; // to consider custom placeholder value and not only the format of the date-time picker

                if (!scope.isDateBlank) {
                    if (!scope.doesContainDateString) {
                        //if (scope.applyClientZone) {
                        //    scope.dateModel = moment(newVal).parseZone().format(scope.dateFormat);
                        //}
                        //else {
                        scope.updatingDateModel(newVal);
                        //scope.dateModel = moment(newVal).format(scope.dateFormat);
                        //}
                    }
                } else {
                    scope.dateModel = "";
                }
                smartTextFieldService.updateDateValue(scope, element);
                smartTextFieldService.createDatePicker(scope, element, ngModelCtrl);
            }
            scope.isActive = smartTextFieldService.checkIfActive(scope, element);
            scope.dateModifiedbyUser = false;

            //smartTextFieldService.updateDateValue(scope, element);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);

        });

        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }

        scope.$on('$destroy', function () {
            //unbindModelWatcher();
            unbindAttributesWatcher();
            unbindNgModel();
            unbindDateModel();
            if (angular.isDefined(unbindMin)) {
                unbindMin();
            }
            if (angular.isDefined(unbindMax)) {
                unbindMax();
            }
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
        });
    }


    function SmartTextField3_AutocompleteFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $translate, $window, persistenceService) {
        if (typeof scope.id != 'undefined' && typeof scope.masterData != 'undefined') {
            scope.masterData = JSON.parse(scope.masterData);
            if (scope.masterData.hasOwnProperty('parentId')) {
                persistenceService.setDocumentFields(scope.masterData.parentId, scope.id);
            }
            else {
                persistenceService.setDocumentFields(null, scope.id);
            }
        }

        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
        var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
        showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);

        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }



        scope.onTextChange = function (e) {

            console.log(scope.displayModel);

            //updateView();

            //console.log(scope.displayModel);
            scope.onChange({
                $event: {
                    data: element.find('#' + scope.textfieldId),
                    displayModel: scope.displayModel
                }
            });

            ////scope.ngModel = e.target.value;
            //smartTextFieldService.updateAutocompleteValue (scope, element);
            //smartTextFieldService.setActiveClass(scope, element);
            //// if (rulesValidationEvent == 'change') {
            //smartTextFieldService.validateRules(scope, ngModelCtrl, element);
            //smartTextFieldService.updateTextFieldClass(scope, element);
            ////  }
            ////scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {


            if (scope.ngModel && scope.displayformat) {
                var splittedDisplayFormat = [];
                if (scope.displayformat.indexOf(":") > 0)
                    splittedDisplayFormat = scope.displayformat.split(':');
                else if (scope.displayformat.indexOf("-") > 0)
                    splittedDisplayFormat = scope.displayformat.split('-');
                else
                    splittedDisplayFormat = scope.displayformat.split('-');
                var result = "";
                for (var i = 0; i < splittedDisplayFormat.length; i++) {
                    result += eval("scope.ngModel." + splittedDisplayFormat[i].replace('{', '').replace('}', ''));
                    if (i < splittedDisplayFormat.length - 1) {
                        if (scope.displayformat.indexOf("-") > 0)
                            result += '-';
                        else if (scope.displayformat.indexOf(":") > 0)
                            result += ':';
                    }
                }

                // P2P-16866
                if (scope.retainDisplayModelAutocomplete !== "true") {

                    if (e.target.value.trim() == '' || result !== scope.displayModel) {
                        scope.displayModel = '';
                    }
                }

            }


            scope.focus = false;
            smartTextFieldService.updateAutocompleteValue(scope, element);
            $timeout(function () {
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            });
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);

            try {
                if (angular.isDefined(scope.$parent.$parent.onStopEdit)) {
                    scope.$parent.$parent.onStopEdit(scope, element);
                }
            }
            catch (e) { }



            scope.onBlur({ $event: e });
        }

        scope.ngKeyPress = function (e) {
            ////console.log("The text has been changed.");
            ////updateView();

            ////var val = e.target.value;

            //scope.displayModel = e.target.value;

            if (rulesValidationEvent == 'keyPress') {
                scope.validateRules();
            }
            scope.onKeyPress({ $event: e });
            if (e.charCode == 13) {
                scope.onEnter({ $event: e });
            }


        };
        scope.elmVal = null;
        scope.ngKeyUp = function (e) {
            ////console.log("The text has been changed.");
            ////updateView();

            //if (e.target.value != '' && e.target.value != scope.elmVal) {
            //    scope.elmVal = e.target.value;
            //    scope.onChange({
            //        $event: {
            //            data: element.find('#' + scope.textfieldId),
            //            displayModel: e.target.value
            //        }
            //    });
            //}




        };

        scope.search = function (e) {
            scope.checkMasterFlag = false;
            if (e.target.value != '' && e.target.value != scope.elmVal) {
                scope.elmVal = e.target.value;
                scope.onChange({
                    $event: {
                        data: element.find('#' + scope.textfieldId),
                        displayModel: e.target.value
                    }
                });
            }
            else {
                if (typeof scope.id != 'undefined') {
                    getMasterDataList(scope.id, scope.masterData);
                }
            }
        };

        scope.ngFocus = function (e) {
            var elm = element.find('#' + scope.textfieldId);
            var Obj = elm.devbridgeAutocomplete();
            if (elm.val() == '' && Obj) {
                scope.checkMasterFlag = true;
                Obj.clear();
                scope.elmVal = '';
            }

            if (typeof scope.id != 'undefined' && elm.val() == '') {
                getMasterDataList(scope.id, scope.masterData);
            }

            scope.onFocus({ $event: e });
        }




        function getMasterDataList(id, masterDataConfig)
        {
            if (typeof masterDataConfig == 'string') {
                masterDataConfig = JSON.parse(masterDataConfig);
                scope.masterData = masterDataConfig;
            }
            try {
                if (persistenceService.masterPersistenceService.getAutoSuggestList(id, masterDataConfig).length > 0) {
                    if (!$('#' + scope.textfieldId).devbridgeAutocomplete() || $('#' + scope.textfieldId).devbridgeAutocomplete() && ($('#' + scope.textfieldId).devbridgeAutocomplete().options.filterKeys != filterOptions.filterKeys) && ($('#' + scope.textfieldId).devbridgeAutocomplete().options.displayFormat != filterOptions.displayFormat) && ($('#' + scope.textfieldId).devbridgeAutocomplete().options.optionFormat != filterOptions.optionFormat)) {
                        if ($('#' + scope.textfieldId).devbridgeAutocomplete()) {
                            $('#' + scope.textfieldId).devbridgeAutocomplete('dispose');
                            $('#' + scope.textfieldId).devbridgeAutocomplete();

                        }
                        filterOptions.lookup = persistenceService.masterPersistenceService.getAutoSuggestList(id, masterDataConfig)

                        autoCompleteField = $('#' + scope.textfieldId).devbridgeAutocomplete(filterOptions).devbridgeAutocomplete();

                    }


                    $('#' + scope.textfieldId).devbridgeAutocomplete().setLookup(persistenceService.masterPersistenceService.getAutoSuggestList(id, masterDataConfig));
                    if ($('#' + scope.textfieldId).devbridgeAutocomplete().options.lookup != [] && $('#' + scope.textfieldId).val().length == 0) {
                        var elm = $(element).find('#' + scope.textfieldId);
                        elm.off('change', false);
                        elm.off("blur", false);
                        scope.checkMasterFlag = true;
                    }
                    else {
                        var elm = $(element).find('#' + scope.textfieldId);
                        elm.on("change", function (el) {
                            //console.log(el);
                            //onChangeCallback(el);
                        });
                        elm.on("blur", scope.ngBlur);

                    }
                }

            }
            catch (e) {
                console.log(e);
            }
        }



        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateAutocompleteValue(scope, element);
        //    };
        //}
        //catch (e) { }

        scope.prevModel = scope.ngModel;
        var updateView = function () {
            try {
                if (scope.ngModel !== scope.prevModel) {
                    $timeout(function () {
                        scope.prevModel = scope.ngModel;
                    });

                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateAutocompleteValue(scope, element);
            }
            catch (e) { }
        };



        var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

            scope.displayModel = smartTextFieldService.getDisplayData(newVal, scope);

            scope.isActive = smartTextFieldService.checkIfActive(scope, element);     
            if (scope.id) {
                persistenceService.masterPersistenceService.setSelectedValue(scope.id, scope.masterData, newVal);
            }

            smartTextFieldService.updateAutocompleteValue(scope, element);
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);
        });

        var unbindOtherWatcher;
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();

            }

        });

        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };

        function bindOtherWatcher() {
            if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
                if (!angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher = scope.$watchGroup(['focus', 'isRemovable'], function (newVal, oldVal) {
                        smartTextFieldService.setActiveClass(scope, element);
                        smartTextFieldService.updateTextFieldClass(scope, element);
                    });
                }
            }
            else {
                if (angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher();
                }
            }
        }


        var unbindValidationWatcher = scope.$watchGroup(['isMandatory', 'validate', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
            if (newVal[1] != oldVal[1] || newVal[2] != oldVal[2]) {
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            }
            if (newVal[3] != oldVal[3] || newVal[4] != oldVal[4]) {
                if (scope.showinfo || scope.showwarning) {
                    element.find('> .input-field').addClass('field-has-icon');
                }
                else {
                    element.find('> .input-field').removeClass('field-has-icon');
                }
            }
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);
        });







        // key to be used to bind options
        var filterKeys;
        if (angular.isDefined(scope.filterkeys) && scope.filterkeys.trim().indexOf('[') == 0) {
            filterKeys = scope.filterkeys ? scope.$eval(scope.filterkeys) : ['title'];
        }
        else {
            filterKeys = scope.filterkeys ? scope.$eval('[' + scope.filterkeys + ']') : ['title'];
        }
        var optionFormat = scope.optionformat ? scope.optionformat : '{title}';
        scope.ndisplayFormat = scope.displayformat ? scope.displayformat : '{title}';

        /*
         * Check if the options are updated
         */
        var autoCompleteField;
        var unbindOptions = scope.$watch('options', function (newOptions) {
            try {
                var checkobj = {};
                if (typeof scope.id != 'undefined') {
                    var key = scope.id;

                    checkobj = scope.masterData;//persistenceService.masterPersistenceService.getPersistenceConfig(key);

                }

                if (scope.checkMasterFlag) {

                    var suggestedObjs = _.filter(newOptions, function (option) {
                        return option[checkobj.filterKey] == scope.suggestedObject.filterKey

                    });
                    if (suggestedObjs.length > 0) {
                        var suggestObj = suggestedObjs[0];
                        angular.element(document).trigger('click');
                        scope.$evalAsync(function () {
                            scope.displayModel = scope.suggestedObject.displayKey;
                            scope.ngModel = suggestObj;
                            updateView();
                            $timeout(function () {
                                scope.onSelect({
                                    $event: {
                                        data: suggestObj
                                    }
                                });
                            });
                        });
                    }

                }
                else {
                    if (!$('#' + scope.textfieldId).devbridgeAutocomplete() || $('#' + scope.textfieldId).devbridgeAutocomplete() && ($('#' + scope.textfieldId).devbridgeAutocomplete().options.filterKeys != searchOptions.filterKeys) && ($('#' + scope.textfieldId).devbridgeAutocomplete().options.displayFormat != searchOptions.displayFormat)) {
                        if ($('#' + scope.textfieldId).devbridgeAutocomplete()) {
                            $('#' + scope.textfieldId).devbridgeAutocomplete('dispose');
                            $('#' + scope.textfieldId).devbridgeAutocomplete();

                        }
                        searchOptions.lookup = smartTextFieldService.getFormattedData(newOptions, scope);
                        autoCompleteField = $('#' + scope.textfieldId).devbridgeAutocomplete(searchOptions).devbridgeAutocomplete();

                    }
                    $('#' + scope.textfieldId).devbridgeAutocomplete().setLookup(smartTextFieldService.getFormattedData(newOptions, scope));
                }
            }
            catch (e) { }
        });



        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange, attrs);
        smartTextFieldService.assignAutocompleteEvents(scope, element);
        bindOtherWatcher();

        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }

        //Closing the suggestions on scroll to prevent overlapping issue
        angular.element($window).scroll(function (e) {
            hideAutoOnScroll();
        });

        angular.element(".modal, .modal-content").scroll(function (e) {
            hideAutoOnScroll();
        });

        function hideAutoOnScroll() {
            if (autoCompleteField != undefined) {
                if (autoCompleteField.visible) {
                    autoCompleteField.hide();
                }
            }
        }

        var checkMasterFlag = false;


        var searchOptions = {
            filterKeys: filterKeys,
            optionFormat: optionFormat,
            displayFormat: scope.ndisplayFormat,
            //lookup: smartTextFieldService.getFormattedData(newOptions, scope),
            width: scope.width,
            showNoSuggestionNotice: showNoSuggestion,
            noSuggestionNotice: noSuggestionNotice,
            minChars: angular.isDefined(scope.minchars) ? parseInt(scope.minchars) : 1,
            onSelect: function (suggestion) {
                angular.element(document).trigger('click');
                scope.$evalAsync(function () {		
                    scope.suggestedObject = suggestion;
                    scope.displayModel = smartTextFieldService.getDisplayData(suggestion, scope);
                    scope.ngModel = suggestion;
                    updateView();
                    $timeout(function () {	
                        if (scope.id) {
                            persistenceService.masterPersistenceService.saveMasterDataForRootField(scope.id, scope.masterData, scope.suggestedObject);
                        }
                        scope.onSelect({
                            $event: {
                                data: suggestion
                            }
                        });
                    });
                });
            }
        };
        var filterOptions = {
            filterKeys: '[displayKey]',
            optionFormat: '{displayKey}',
            displayFormat: '{displayKey}',
            //lookup: persistenceService.masterPersistenceService.getAutoSuggestList(id),//smartTextFieldService.getFormattedData(newOptions, scope),
            width: scope.width,
            showNoSuggestionNotice: showNoSuggestion,
            noSuggestionNotice: noSuggestionNotice,
            minChars: 0,
            onSelect: function (suggestion) {
                angular.element(document).trigger('click');
                scope.$evalAsync(function () {

                    scope.suggestedObject = suggestion;

                    $timeout(function () {
                        persistenceService.masterPersistenceService.saveMasterDataForRootField(scope.id, scope.masterData, scope.suggestedObject);
                        scope.onChange({

                            $event: {
                                data: element.find('#' + scope.textfieldId),
                                displayModel: element.find('#' + scope.textfieldId).val()

                            }
                        });
                        element.find('#' + scope.textfieldId).focus();
                        scope.checkMasterFlag = true;

                    });
                });
            }
        };



        scope.$on('$destroy', function () {
            unbindModelWatcher();
            unbindAttributesWatcher();
            unbindOptions();
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
            unbindValidationWatcher();
        });
    }
        
    function smartTextField3_NumFunc(scope, element, attrs, ngModelCtrl, smartTextFieldService, $timeout, $filter, $translate) {
        scope.placeholder = scope.placeholder == undefined || scope.placeholder == null ? '' : scope.placeholder;
        scope.ngModel = scope.ngModel == undefined || scope.ngModel == null ? '' : scope.ngModel;
        scope.textAlign = scope.align == undefined || scope.align == null ? 'left' : scope.align;
        scope.suffixicon = ((scope.suffixicon == undefined || scope.suffixicon == null) && scope.type == "date") ? "#icon_Calendar" : scope.suffixicon; //  date picker icon                    
        scope.count = 0;
        var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
        var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
        showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
        var number, rulesValidationEvent;
        scope.type = angular.isDefined(scope.type) ? scope.type : 'text';
        textfieldId++;
        scope.textfieldId = 'tf_' + textfieldId;
        scope.isRemovable = scope.$eval(scope.removable) == undefined ? true : scope.$eval(scope.removable);
        scope.showTitle = scope.isTitleVisible == undefined || scope.isTitleVisible == null || scope.isTitleVisible == 'true' ? true : false;


        if (attrs.validateOn) {
            rulesValidationEvent = attrs.validateOn;
        }
        else {
            rulesValidationEvent = 'blur';
        }



        scope.onTextChange = function (e) {

            // if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
            var num = element.find('#' + scope.textfieldId).autoNumeric('get');
            if (num != '') {
                scope.ngModel = parseFloat(element.find('#' + scope.textfieldId).autoNumeric('get'));
            }
            else {
                scope.ngModel = null;
            }
            //}
            //else {
            //    scope.ngModel = parseFloat(e.target.value);
            //}
            updateView();
            //scope.ngModel = parseFloat(e.target.value);
            //smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.setActiveClass(scope, element);
            // if (rulesValidationEvent == 'change') {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.updateTextFieldClass(scope, element);
            //  }
            scope.onChange({ $event: e });
        };

        scope.ngBlur = function (e) {
            //if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {

            var num = element.find('#' + scope.textfieldId).autoNumeric('get');
            if (num != '') {
                scope.ngModel = parseFloat(element.find('#' + scope.textfieldId).autoNumeric('get'));
            }
            else {
                scope.ngModel = null;
            }
            //}
            //else {
            //    var num = e.target.value;
            //    if (num.trim() != '') {
            //        scope.ngModel = parseFloat(num);
            //    }
            //    else {
            //        scope.ngModel = null;
            //    }
            //}
            updateView();
            scope.focus = false;
            //smartTextFieldService.updateTextValue(scope, element);
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);




            scope.onBlur({ $event: e });
        }

        scope.ngKeyPress = function (e) {
            if (scope.type == 'number' || attrs.datanumeric) {
                //to control number of +,-, signs and alphabets on number fields
                var charCode = e.charCode || e.keyCode,
                    textValue = e.currentTarget.value,
                    decimalDigit = [],
                    cc = String.fromCharCode(charCode),
                    escapeChars = [37, 38, 39, 40, 46, 8];

                if (isNaN(cc) && (escapeChars.indexOf(charCode) == -1)) {
                    e.preventDefault();
                }
                // Restrict the 2 dots entering
                if (textValue.toString().indexOf('.') !== -1 && charCode == 46) {
                    e.preventDefault();
                }

                if (textValue) {
                    decimalDigit = textValue.toString().split('.');
                }
                // Restrict the decimal value from entering
                if (attrs.decimalprecision) {
                    if (charCode == 46 && parseInt(attrs.decimalprecision) == 0) {
                        e.preventDefault();
                    }
                    if (decimalDigit.length == 2) {
                        if (decimalDigit[1] && decimalDigit[1].length >= parseInt(attrs.decimalprecision, 10)) {
                            e.preventDefault();
                        }
                    }
                }
                if (scope.min != undefined || scope.min != null) {
                    if (scope.min >= 0 && e.charCode == 45) {
                        e.preventDefault();
                    }
                }
            }

            if (rulesValidationEvent == 'keyPress') {
                smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
            }
            scope.onKeyPress({ $event: e });
            if (e.charCode == 13) {
                scope.onEnter({ $event: e });
            }

            // because of debounce has applied on smart-textfield, here we need to do DOM manipulation i.e. e.target.value to get latest value from textfield
            if (angular.isDefined(attrs.maxlength) && e.target.value.length == attrs.maxlength && e.charCode !== 0) {
                e.preventDefault();
            }
        };




        /*
     *  Following code has been added to make ng-model-options work
     *  ngModelCtrl.$render & ngModelCtrl.$setViewValue serve the purpose
     */
        //try {
        //    ngModelCtrl.$render = function () {
        //        scope.ngModel = ngModelCtrl.$modelValue;
        //        smartTextFieldService.updateTextValue(scope, element);
        //    };
        //}
        //catch (e) { }

        scope.prevModel = scope.ngModel;
        var updateView = function () {
            try {
                //ngModelCtrl.$setViewValue(scope.ngModel);
                smartTextFieldService.updateTextValue(scope, element);
                //smartTextFieldService.updateTextValue(scope, element);
                if (scope.ngModel != null) {
                    var min = 0;
                    var max = 0;
                    if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
                        if (scope.minmaxprecision == undefined || scope.minmaxprecision == '') {
                            min = 0;
                            max = 0;
                        }
                        else {
                            min = MinPrecessionValue;//global default
                            max = MaxPrecessionValue;//global default
                        }
                    }
                    else {
                        if (scope.minmaxprecision !== undefined && scope.minmaxprecision !== '') {
                            var splitPrecision = JSON.parse(scope.minmaxprecision);
                            if (splitPrecision.length == 2) {
                                min = splitPrecision[0];
                                max = splitPrecision[1];
                            }
                        }
                    }
                    try {
                        if (scope.minmaxprecision) {
                            min = JSON.parse(scope.minmaxprecision)[0];
                            max = JSON.parse(scope.minmaxprecision)[1];
                        }
                    }
                    catch (e) {
                        console.log(e)
                    }
                    var valueToModel;
                    if (scope.ngModel === '') {
                        valueToModel = scope.ngModel;
                    }else if (scope.currencySymbol) {
                        valueToModel = scope.currencySymbol + $filter('minPrecisionHandler')(scope.ngModel, min, max, false);
                    }else {
                        valueToModel = $filter('minPrecisionHandler')(scope.ngModel, min, max, false);
                    }
                    element.find('#' + scope.textfieldId).val(valueToModel);
                    if (!scope.ngModel) {
                        var num = element.find('#' + scope.textfieldId).autoNumeric('get');
                        if (num != '') {
                            scope.ngModel = parseFloat(element.find('#' + scope.textfieldId).autoNumeric('get'));
                            smartTextFieldService.setActiveClass(scope, element);
                            smartTextFieldService.updateTextFieldClass(scope, element);
                        }
                        else {
                            scope.ngModel = null;
                        }
                    }

                    if (scope.ngModel !== scope.prevModel) {
                        $timeout(function () {
                            scope.prevModel = scope.ngModel;
                        });
                    }


                }
            }
            catch (e) { }
        };



        var unbindModelWatcher = scope.$watch('ngModel', function (newVal) {

            scope.isActive = smartTextFieldService.checkIfActive(scope, element);


            updateView();
            smartTextFieldService.setActiveClass(scope, element);
            smartTextFieldService.updateTextFieldClass(scope, element);
        });


        //var unbindAttributesWatcher = scope.$watchGroup(['isMandatory', 'disable', 'readonly', 'focus', 'validate', 'isRemovable'], function (newVal, oldVal) {

        //    if (newVal[4] != oldVal[4]) {
        //        smartTextFieldService.validateRules(scope, ngModelCtrl, element,attrs);
        //    }
        //    smartTextFieldService.setActiveClass(scope, element);
        //    smartTextFieldService.updateTextFieldClass(scope, element);


        //});

        var unbindOtherWatcher;
        var unbindAttributesWatcher = scope.$watchGroup(['disable', 'readonly'], function (newVal, oldVal) {
            if (newVal[0] !== oldVal[0] || newVal[1] !== oldVal[1]) {
                smartTextFieldService.setActiveClass(scope, element);
                smartTextFieldService.updateTextFieldClass(scope, element);
                bindOtherWatcher();
            }

        });


        function bindOtherWatcher() {
            if ((angular.isDefined(scope.disable) && (scope.disable == false || scope.disable == 'false')) || ((angular.isDefined(scope.readonly) && (scope.readonly == false || scope.readonly == 'false')))) {
                if (!angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher = scope.$watchGroup(['isMandatory', 'focus', 'validate', 'isRemovable', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
                        if (newVal[2] != oldVal[2] || newVal[4] != oldVal[4]) { //validate
                            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);

                            smartTextFieldService.setActiveClass(scope, element);
                            smartTextFieldService.updateTextFieldClass(scope, element);
                        }
                        if (newVal[5] != oldVal[5] || newVal[6] != oldVal[6]) {
                            if (scope.showinfo || scope.showwarning) {
                                element.find('> .input-field').addClass('field-has-icon');
                            }
                            else {
                                element.find('> .input-field').removeClass('field-has-icon');
                            }
                        }
                        if (newVal[1] || newVal[1] == "true") {
                            element.find('input').focus();
                        }
                    });
                }
            }
            else {
                if (angular.isDefined(unbindOtherWatcher)) {
                    unbindOtherWatcher();
                }
            }
        }




        scope.hideShowField = function () {
            scope.isVisible = !scope.isVisible;
        };



        smartTextFieldService.buildTemplate(scope, element, scope.onTextChange);
        if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
            if (scope.minmaxprecision == undefined || scope.minmaxprecision == '') {
                element.find('#' + scope.textfieldId).autoNumeric('init', {
                    aSign: scope.currencySymbol,
                    mDec: 0,
                    aPad: false,
                    aSep: thousandSep,
                    aDec: decimalSep,
                    vMin: Number.NEGATIVE_INFINITY,
                    vMax: Number.POSITIVE_INFINITY
                });
            } else {
                element.find('#' + scope.textfieldId).autoNumeric();
            }
        }
        else {
            var thousandSep = ',';
            var decimalSep = '.';
            var highPrecisionLimit = 0;
            if (scope.minmaxprecision !== undefined && scope.minmaxprecision !== '') {
                var splitPrecision = JSON.parse(scope.minmaxprecision);
                if (splitPrecision.length == 2) {
                    var lowerPrecisionLimit = splitPrecision[0];
                    highPrecisionLimit = splitPrecision[1];
                }
            }
            element.find('#' + scope.textfieldId).autoNumeric('init', {
                aSign: scope.currencySymbol,
                mDec: highPrecisionLimit,
                aPad: false,
                aSep: thousandSep,
                aDec: decimalSep,
                vMin: Number.NEGATIVE_INFINITY,
                vMax: Number.POSITIVE_INFINITY,
            });
        }
        bindOtherWatcher();
        if (scope.clienterror) {
            smartTextFieldService.validateRules(scope, ngModelCtrl, element, attrs);
        }
        //setTimeout(function () {
        //    //if (scope.readonly == 'true') {
        //    //    angular.element('#' + scope.textfieldId).attr('tabindex', -1);
        //    //}
        //    try {
        //        if (angular.isDefined(scope.$parent.$parent.onEditableRender)) {
        //            scope.$parent.$parent.onEditableRender(scope, element);
        //        }
        //    }
        //    catch (e) { }
        //});

        scope.$on('$destroy', function () {
            unbindModelWatcher();
            unbindAttributesWatcher();
            if (angular.isDefined(unbindOtherWatcher)) {
                unbindOtherWatcher();
            }
        });
    }




    angular.module('SMART2').factory('smartTextFieldService', ['ScrollTo', 'RuleEngine', '$templateCache', '$compile', '$translate', '$timeout', smartTextFieldServiceFunc])
    function smartTextFieldServiceFunc(ScrollTo, RuleEngine, $templateCache, $compile, $translate, $timeout) {
        var checkIfActive = function (scope) {
            if (typeof scope.readonly !== 'undefined' && scope.readonly == 'true') {
                return true;
            }
            if (scope.type == 'number' && scope.ngModel !== 0 + '' && (typeof scope.placeholder !== 'undefined' && scope.placeholder === '') && (typeof scope.ngModel === 'undefined' || scope.ngModel === '' || isNaN(scope.ngModel) || scope.ngModel === undefined || scope.ngModel === null)) {
                return false;
            }
            if (scope.type != 'number' && scope.type != 'autocomplete' && (typeof scope.placeholder !== 'undefined' && scope.placeholder === '') && (typeof scope.ngModel === 'undefined' || scope.ngModel === '' || scope.ngModel === undefined || scope.ngModel === null)) {
                return false;
            }
            if (scope.type == 'autocomplete' && (typeof scope.placeholder !== 'undefined' && scope.placeholder === '') && (typeof scope.ngModel === 'undefined' || scope.displayModel === '' || scope.displayModel === undefined || scope.displayModel === null)) {
                return false;
            }
            return true;
        }

        var setActiveClass = function (scope, element, eventType) {
            scope.active = checkIfActive(scope);
            var el = element.find('#' + scope.textfieldId + '_label');

            if ((typeof scope.active !== 'undefined' && scope.active == true) || (typeof scope.validate !== 'undefined' && scope.validate == true)) {
                if (!el.hasClass('active')) {
                    el.addClass('active');
                }
            } else {
                if (el.hasClass('active')) {
                    el.removeClass('active');
                }
            }
        }

        var updateTextFieldClass = function (scope, element) {
            var elm = $(element).find('#' + scope.textfieldId);
            var elmContainer = $(element).find('#' + scope.textfieldId + '_container');
            var lbl = $(element).find('#' + scope.textfieldId + '_label');
            if (typeof scope.validate !== 'undefined' && scope.validate == true && typeof scope.errorMessage !== 'undefined' && scope.errorMessage) {
                if (!elm.hasClass('invalid')) {
                    elm.addClass('invalid');
                    lbl.attr('data-error', $translate.instant(scope.errorMessage));
                }
            }
            else {
                if (elm.hasClass('invalid')) {
                    elm.removeClass('invalid');
                    lbl.attr('data-error', '');
                }
            }

            if (typeof scope.textAlign !== 'undefined' && scope.textAlign == 'right') {
                if (!elm.hasClass('right-align')) {
                    elm.addClass('right-align');
                }
                if (!lbl.hasClass('right-align')) {
                    lbl.addClass('right-align');
                }
            }
            else {
                if (elm.hasClass('right-align')) {
                    elm.removeClass('right-align');
                }
                if (lbl.hasClass('right-align')) {
                    lbl.removeClass('right-align');
                }
            }

            if (typeof scope.textAlign !== 'undefined' && scope.textAlign == 'left') {
                if (!elm.hasClass('left-align')) {
                    elm.addClass('left-align');
                }
                if (!lbl.hasClass('left-align')) {
                    lbl.addClass('left-align');
                }
            }
            else {
                if (elm.hasClass('left-align')) {
                    elm.removeClass('left-align');
                }
                if (lbl.hasClass('left-align')) {
                    lbl.removeClass('left-align');
                }
            }

            if ((typeof scope.readonly !== 'undefined' && (scope.readonly == true || scope.readonly == 'true')) || (typeof scope.disable !== 'undefined' && (scope.disable === 'true' || scope.disable === true))) {
                elm.prop("readonly", true);
                elm.attr("disabled", "disabled");
                elm.attr('tabindex', -1);
                elmContainer.addClass('readOnlyField');
                if (elm.hasClass('invalid')) {
                    elm.removeClass('invalid');
                    lbl.attr('data-error', '');
                }
            }
            else {
                elm.prop("readonly", false);
                elm.attr("disabled", false);
                elm.removeAttr('tabindex');
                elmContainer.removeClass('readOnlyField');
            }


            if (typeof scope.autocomplete != 'undefiend' && (scope.autocomplete == 'true' || scope.autocomplete == true))// "{{autocomplete?'on':'off'}}")
            {

            }
            else {
                // elm.autocomplete().disable();
            }

            //if (typeof scope.disable !== 'undefined' && scope.disable == true) {
            //    elm.attr("disabled", "disabled")
            //}
            //else {
            //    elm.attr("disabled", false);
            //}


            if (!elm.hasClass('ng-valid')) {
                elm.addClass('ng-pristine ng-valid ng-scope ng-touched');
            }


            if (typeof scope.placeholder !== 'undefined' && scope.placeholder != '') {
                elm.attr("placeholder", scope.placeholder)
            }

            //Optional Field
            var optionalField = $(element).find('#' + scope.textfieldId + '_opField');
            if ((typeof scope.isMandatory !== 'undefined' && (scope.isMandatory == 'false' || scope.isMandatory == false)) && (scope.isRemovable == true || scope.isRemovable == 'true')) {
                var container = $(element).find('#' + scope.textfieldId + '_container');
                if (typeof optionalField == 'undefiend' || (typeof optionalField !== 'undefiend' && optionalField.length == 0)) {
                    container.append(buildOptionalFieldTemplate(scope));
                    optionalField = $(element).find('#' + scope.textfieldId + '_opField');
                    if (typeof optionalField != 'undefined' && optionalField.length > 0) {
                        optionalField.bind("click", scope.hideShowField);
                    }
                }
                if (!container.hasClass('optionalField')) {
                    container.addClass('optionalField');
                }

            }
            else {
                if (typeof optionalField !== 'undefiend' && optionalField.length > 0) {
                    optionalField.remove();
                }
            }

            if (scope.type === 'text' || scope.type === 'number' || scope.type === 'area') {
                if (typeof scope.maxlength != 'undefined') {
                    if (parseInt(scope.maxlength) > -1) {
                        elm.attr('maxlength', parseInt(scope.maxlength));
                    }
                }
            }

            var className = '';
            if (element.length > 0) {
                className = element[0].className;
                className = className.replace('ng-hide', "");
                element.removeClass(className);
            }
            elmContainer.addClass(className);
        }

        var buildOptionalFieldTemplate = function (scope) {
            if ((typeof scope.isMandatory !== 'undefined' && (scope.isMandatory == 'false' || scope.isMandatory === false)) && (scope.isRemovable == true || scope.isRemovable == 'true')) {
                var optionalField = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldOptionalFieldTemplate.html');
                optionalField = optionalField.replace('{{id}}', scope.textfieldId + '_opField');
                return optionalField;
            }
            return '';
        };

        var buildPrefixiconTemplate = function (scope) {
            if (typeof scope.prefixicon !== 'undefined' && scope.prefixicon) {
                var html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldprefixiconTemplate.html');
                html = html.replace('{{id}}', scope.textfieldId + '_prefixicon');
                html = html.replace('{{prefixicon}}', scope.prefixicon);
                return html;
            }
            return '';
        };

        var buildSpinnerTemplate = function (scope) {
            if (!scope.type == 'autocomplete' && typeof scope.loading !== 'undefined' && scope.loading == true) {
                var html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldSpinnerTemplate.html');
                html = html.replace('{{id}}', scope.textfieldId + '_spinner');
                return html;
            }
            return '';
        };

        var buildTextFieldTemplate = function (scope) {
            var html = '';

            if (scope.type === 'area' && scope.readonly === 'true') {
                html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextareaReadonlyElementTemplate.html');
            } else if (scope.type === 'area') {
                html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextareaElementTemplate.html');
            }
            else {
                html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldElementTemplate.html');
            }
            if (scope.type === 'password') {
                html = html.replace('type="text"', 'type="password"');
            }
            html = html.replace('{{id}}', scope.textfieldId);
            html = html.replace('{{showHideReadMoreContent}}', 'showHideReadMoreContent' + scope.textfieldId);
            html = html.replace('{{showLessContent}}', $translate.instant('showLess'));
            html = html.replace('{{showMoreContent}}', $translate.instant('showMoreContent'));
            return html;
        };

        var buildInfoIconTemplate = function (scope) {
            var html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldinfoiconTemplate.html');
            //if (scope.showwarning || scope.showinfo) {
            //    html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldinfoiconTemplate.html');
            //}
            return html;
        };

        //var buildWarningIconTemplate = function (scope) {
        //    var html = '';
        //    if (scope.showwarning || scope.showinfo) {
        //        html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldwarningiconTemplate.html');
        //    }
        //    return html;
        //};

        var buildLabelTemplate = function (scope) {
            var html = '';
            //if (typeof scope.label !== 'undefined' && scope.label.trim() != '') {
            html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldLabelTemplate.html');
            html = html.replace('{{id}}', scope.textfieldId + '_label');
            html = html.replace('{{textfieldId}}', scope.textfieldId);
            html = html.replace('{{label}}', typeof scope.label === 'undefined' ? '' : scope.label);
            if (!scope.label) {
                html = html.replace('class=""', 'class="empty-label"');
            }

            //}
            return html;
        };

        var buildTemplate = function (scope, element, onChangeCallback, attrs) {
            var container = $('<div/>', { id: scope.textfieldId + '_container' });// document.createElement('div');

            var css = '';
            if ((scope.isMandatory === false || scope.isMandatory === 'false') && scope.isRemovable === true) {
                css += ' optionalField';
            }
            if (scope.showinfo || scope.showwarning) {
                css += ' field-has-icon';
                //if (scope.showinfo && scope.showwarning) {
                //    css += ' field-has-two-icons';
                //}
            }
            if (scope.readonly === 'true' || scope.disable === 'true') {
                css += ' readOnlyField';
            }
            //if (!scope.customoption) {
            //    css += ' defaultSelected';
            //}
            //if (scope.validate === true && scope.errorMessage) {
            //    css += ' invalid';
            //}
            var className = '';
            if (element.length > 0) {
                className = element[0].className;
                element.removeClass(className);
            }
            container.addClass(className + ' input-field ' + css);


            container.append('<div class="elements-include">' + buildOptionalFieldTemplate(scope) + buildPrefixiconTemplate(scope) + buildSpinnerTemplate(scope) + buildTextFieldTemplate(scope) + buildLabelTemplate(scope) + '</div>');
            container.append($compile(buildInfoIconTemplate(scope))(scope));
            //if (scope.showinfo || scope.showwarning) {
            //    container.append($compile(buildInfoIconTemplate(scope))(scope));
            //}

            element.html(container);
            var elm = $(element).find('#' + scope.textfieldId);
            elm.on("change", function (el) {
                //console.log(el);
                onChangeCallback(el);
            });
            elm.on("blur", scope.ngBlur);

            if (scope.type != undefined && scope.type == 'number') {
                // elm.attr('type', 'number');

                if (scope.min != undefined && scope.min != null) {
                    if ($.isNumeric(scope.min)) {
                        elm.attr('min', scope.min);
                    }
                }
                if (scope.max != undefined && scope.max != null) {
                    if ($.isNumeric(scope.max)) {
                        elm.attr('max', scope.max);
                    }
                }

                elm.bind('keypress', scope.ngKeyPress);



            } else if (scope.type != undefined && scope.type == 'autocomplete') {
                elm.on("focus", scope.ngFocus);

                if (attrs.onKeyPress || attrs.onEnter) {
                    elm.bind('keypress', debounce(scope.ngKeyPress, 250));
                }
            } else if (scope.type != undefined && (scope.type == 'area' || scope.type == 'text')) {

                // Need to add debounce for updating the ngModel
                if (attrs.onKeyPress || attrs.onEnter) {
                    elm.bind('keypress', debounce(scope.ngKeyPress, 250));
                }
                //if (attrs.onKeyUp) {
                //    elm.bind('keyup', debounce(scope.ngKeyUp, 250));
                //}
                if (attrs.onKeyDown) {
                    elm.bind('keydown', debounce(scope.ngKeyDown, 250));
                }
                if (attrs.onFocus) {
                    elm.bind('focus', scope.ngFocus);
                }
                // Need to optimize this line, post finding of better approach. It is required for filtering ng-repeat
                elm.bind('keyup', scope.ngKeyUp);
            }


            var optionalField = $(element).find('#' + scope.textfieldId + '_opField > i');
            if (typeof optionalField != 'undefined' && optionalField.length > 0) {
                optionalField.bind("click", scope.hideShowField);

            }
            updateTextFieldClass(scope, element);
            setActiveClass(scope, element);

            if (angular.isDefined(scope.charactercounter) && scope.charactercounter == 'true') {
                elm.attr('length', scope.maxlength);
                elm.characterCounter();
            }

        };

        var updateTextValue = function (scope, element, ngModelCtrl) {
            var elm = element.find('#' + scope.textfieldId),
                addClassElem = element.find('#showHideReadMoreContent' + scope.textfieldId),
                showLessContent = element.find('.readOnlyshowLess'),
                showMoreContent = element.find('.readOnlyShowMore');
            if (!addClassElem.hasClass('areareadOnlyContentPara2')) {

                if ((modal.getModal(scope, ngModelCtrl)).length < 150) {
                    showLessContent.hide();
                    showMoreContent.hide();
                } else if ((modal.getModal(scope, ngModelCtrl)).length > 150) {
                    showLessContent.hide();
                    showMoreContent.show();
                }
            }

            if (!addClassElem.hasClass('areareadOnlyContentPara2')) {

                addClassElem.addClass('ellipsis areareadOnlyContentPara1');
            }
            if (scope.type === 'area' && scope.readonly === 'true') {

                if (elm.text() !== modal.getModal(scope, ngModelCtrl)) { elm.text(modal.getModal(scope, ngModelCtrl)); }
                //addClassElem.addClass('ellipsis areareadOnlyContentPara1');
                $(showLessContent).off('click').on('click', function () {
                    $(this).hide();
                    $(showMoreContent).show();
                    $(addClassElem).removeClass('areareadOnlyContentPara2');
                    $(addClassElem).addClass('ellipsis areareadOnlyContentPara1');
                });
                $(showMoreContent).off('click').on('click', function () {
                    $(this).hide();
                    $(showLessContent).show();
                    $(addClassElem).removeClass('ellipsis areareadOnlyContentPara1');
                    $(addClassElem).addClass('areareadOnlyContentPara2');

                });
            }
            else {
                if (elm.val() !== modal.getModal(scope, ngModelCtrl) && !scope.typing) {
                    elm.val(modal.getModal(scope, ngModelCtrl));
                }
                if (scope.showTitle) {
                    elm.attr('title', modal.getModal(scope, ngModelCtrl));
                }
                if (modal.getModal(scope, ngModelCtrl) === '') {
                    elm.addClass('ng-empty').removeClass('ng-not-empty');
                } else {
                    elm.removeClass('ng-empty').addClass('ng-not-empty');
                }

                /* Adding class truncate to input*/
                if (!elm.hasClass('materialize-textarea') && (scope.readonly === 'true' || scope.disable === 'true')) {
                    elm.addClass('truncate');
                } else {
                    elm.removeClass('truncate')
                };
            }
        
        }
        var modal = {
            getModal: function (scope, ngModelCtrl) {
                return typeof scope.ngModel == "function" ? ngModelCtrl.$modelValue : scope.ngModel;
            },
            setModal: function (scope, value, ngModelCtrl) {

                if (typeof scope.ngModel == "function") {
                    ngModelCtrl.$setViewValue(value)
                    ngModelCtrl.$render()
                } else {
                    scope.ngModel = value;
                }
            }
        };

        var updateDateValue = function (scope, element) {
            var elm = element.find('#' + scope.textfieldId);
            elm.val(scope.dateModel);
            elm.attr('title', scope.dateModel);
        }

        var updateAutocompleteValue = function (scope, element) {
            var elm = element.find('#' + scope.textfieldId);
            elm.val(scope.displayModel);
            elm.attr('title', scope.displayModel);
        }


        var checkRule = function (scope, element) {
            var rules = scope.$eval(scope.rules);
            var isFoundInvalid = false;

            for (var i = 0; i < rules.length; i++) {
                if (typeof rules[i] == 'object') {
                    if (eval((rules[i].rule).replace(/this/g, scope.type == 'autocomplete' ? 'scope.displayModel' : 'scope.ngModel'))) {
                        scope.validate = true;
                        scope.errorMessage = rules[i].error;
                        scope.errorModel = rules[i].error;
                        break;
                    } else {
                        if (scope.type === 'date') {
                            angular.element('#' + scope.textfieldId).removeClass('invalid');
                        }
                    }
                }
                else {
                    if (!isFoundInvalid) {
                        if (typeof scope.ngModel != 'object')
                            var data = scope.ngModel;
                        else
                            var data = scope.displayModel;

                        RuleEngine.isValid(rules[i], function (e) {
                            scope.validate = true;
                            scope.errorMessage = e.errorData.error;
                            scope.errorModel = rules[i].error;
                            isFoundInvalid = true;
                        }, data);
                    }
                    else {
                        break;
                    }
                }
            }
        }

        var validateRules = function (scope, ngModelCtrl, element, attrs) {
            if (typeof scope.readonly !== 'undefined' && scope.readonly == 'true') {
                scope.isActive = true;
                return;
            }

            if ((scope.type === 'text' || scope.type === 'area') && angular.isString(scope.ngModel)) {
                if (attrs.noTrim == 'true') {
                    //scope.ngModel = scope.ngModel;
                } else {
                    //scope.ngModel = scope.ngModel.trim();
                    modal.setModal(scope, modal.getModal(scope, ngModelCtrl).trim(), ngModelCtrl);
                }
                //ngModelCtrl.$setViewValue(scope.ngModel);
            }

            if ((scope.type == 'autocomplete' && scope.$eval(scope.isMandatory) && !scope.clienterror && (typeof scope.ngModel === 'undefined' || scope.displayModel == '' || scope.displayModel == null || scope.displayModel == undefined || scope.ngModel.id === 0)) || (scope.type != 'autocomplete' && scope.$eval(scope.isMandatory) && !scope.clienterror && (scope.ngModel + '' == '' || scope.ngModel == null || scope.ngModel == undefined))) {
                scope.validate = true;
                scope.errorMessage = $translate.instant("enterValueErrMsg");
                scope.errorModel = $translate.instant("enterValueErrMsg");

                return;
            }

            if (scope.clienterror) {
                scope.validate = true;
                scope.errorMessage = $translate.instant("clientErrMsg");
                scope.errorModel = $translate.instant("clientErrMsg");

                return;
            }

            if (scope.type == 'number') {
                if (!scope.$eval(scope.isMandatory) && isNaN(scope.ngModel)) {
                    angular.element('#' + scope.textfieldId).val('');
                    return;
                }
                if (!scope.$eval(scope.isMandatory) && scope.ngModel === null) {
                    if (scope.rules) {
                        checkRule(scope, element);
                    }
                    return;
                }
                //if (scope.$eval(scope.isMandatory) && isNaN(scope.ngModel) || (!scope.$eval(scope.isMandatory) && number == undefined)) {
                //    scope.validate = true;
                //    scope.errorMessage = $translate.instant('enterNumberErrMsg');
                //    scope.errorModel = $translate.instant('enterNumberErrMsg');
                //    return;
                //}

            }

            // CON-5898
            if (scope.type == 'date' && !scope.rules) {
                $('#' + scope.textfieldId).removeClass('invalid');
            }

            scope.validate = false;
            scope.errorMessage = null;
            scope.errorModel = null;

            if (scope.rules) {
                checkRule(scope, element);
            }
        };

        var debounce = function (func, wait, immediate) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };

        var updateDateClass = function (scope, element) {
            var el = element.find('#' + scope.textfieldId);
            if (scope.type == 'date') {
                if (!el.hasClass('datepicker')) {
                    el.addClass('datepicker');
                }
            }


        }
        var assignDateEvents = function (scope, element) {
            var el = element.find('#' + scope.textfieldId);
            el.bind('keydown', scope.ngKeyDown);
            el.bind('keypress', scope.ngKeyPress);
            el.bind('keyup', scope.ngKeyUp);

        }

        var assignAutocompleteEvents = function (scope, element) {
            var el = element.find('#' + scope.textfieldId);
            //el.bind('keydown', scope.ngKeyDown);
            //el.bind('keypress', scope.ngKeyPress);
            el.bind('keyup', debounce(scope.ngKeyUp, 250));
            el.on('input', debounce(scope.search, 250));

        }

        /*
          * This function is required to generate value attribute 
          * and useful when up/down key is pressed
          */
        var getFormattedData = function (data, scope) {
            if (!data || data.length == 0) {
                return [];
            }
            for (var i = 0; i < data.length; i++) {
                var str = scope.ndisplayFormat;
                try {
                    var parentSplit = str.split('{');
                    for (var j = 0; j < parentSplit.length; j++) {
                        var childSplit = parentSplit[j].split('}');
                        for (var k = 0; k < childSplit.length; k++) {
                            if (childSplit[k].indexOf('.') > 0 || data[i].hasOwnProperty(childSplit[k])) {
                                str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), eval('data[i].' + childSplit[k]));
                            }
                        }
                    }
                }
                catch (e) { }
                data[i].value = str.trim();
            }
            return data;
        };
        /*
            *  Convert timestamp to UTC timestamp 
            */
        var toUTC = function (date) {
            return Date.UTC(
                date.getFullYear()
                , date.getMonth()
                , date.getDate()
                , date.getHours()
                , date.getMinutes()
                , date.getSeconds()
                , date.getMilliseconds()
            );
        };

        var getGridFormatToTimestamp = function (scope, stringdate) {
            var tmpModel = (stringdate + '').replace(new RegExp("/", "ig"), '');
            // tmpModel = tmpModel.split('+');
            // tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + tmpModel.join('+') + '").getTime()') : tmpModel[0]));
            //if (scope.applyClientZone) {
            //    return moment(tmpModel).parseZone().format(scope.dateFormat);
            //}
            //else {
            return moment(tmpModel).format(scope.dateFormat);
            //}
        }

        var updateNgModel = function (scope, timestamp) {
            scope.dateModifiedbyUser = true;
            if (scope.timePicker == true) {
                if (scope.convertIntoUTC || timeZoneOffset != 20) {
                    // that means the date will be saved in UTC Format
                    scope.ngModel = moment(timestamp * 1000).add((timeZoneOffset * -60), 'minute').format('YYYY-MM-DDTHH:mm:ss');  //'\/Date(' + ((timestamp - (moment().zone() * 60)) * 1000) + ')\/';
                } else {
                    //This case is applied for Sourcing. because of the converstion happed before saving.
                    scope.ngModel = '\/Date(' + (timestamp * 1000) + ')\/';
                }
            }
            else {
                // hooking a fixed time to fix the flipping issues.
                // if (scope.convertIntoUTC) {
                //scope.ngModel = moment(timestamp * 1000).format('YYYY-MM-DD') + 'T12:00:00';//'\/Date(' + (((timestamp- (moment().zone() * 60)) * 1000) + 43200000) + ')\/';
                //}else
                //{
                //    scope.ngModel = '\/Date(' + ((timestamp * 1000) + 43200000) + ')\/';
                //}

                if (timeZoneOffset != 20) {
                    scope.ngModel = moment(timestamp * 1000).format('YYYY-MM-DD') + 'T12:00:00';//'\/Date(' + (((timestamp- (moment().zone() * 60)) * 1000) + 43200000) + ')\/';
                } else {
                    scope.ngModel = '\/Date(' + ((timestamp * 1000) + 43200000) + ')\/';
                }
            }
        }


        var createDatePicker = function (scope, element, ngModelCtrl) {
            setTimeout(function () {
                var picker = element.find('#' + scope.textfieldId);
                var callApplyFuncFlag = true;
                function setDateFormate(datePar) {
                    updateNgModel(scope, datePar.unix());
                    $timeout(function () {
                        // if (scope.doesContainDateString) {

                        //} else {
                        //    if (scope.isValueDateObj) {
                        //        var tempDate = datePar.format();
                        //        scope.ngModel = new Date(tempDate);
                        //    } else {
                        //        scope.ngModel = (datePar.unix() * 1000);
                        //    }
                        //}
                        // ngModelCtrl.$setViewValue(scope.ngModel);
                        scope.isDateBlank = false;
                        if (angular.isFunction(scope.onDateChange)) {
                            scope.onDateChange({ $event: { date: scope.ngModel }});
                        }

                    })
                }
                var minDate = angular.isDefined(scope.min) ? scope.doesContainDateString ? getGridFormatToTimestamp(scope.min) : moment(parseInt(scope.min)).format(scope.dateFormat) : '';
                var maxDate = angular.isDefined(scope.max) ? scope.doesContainDateString ? getGridFormatToTimestamp(scope.max) : moment(parseInt(scope.max)).format(scope.dateFormat) : '';

                var timePicker24Hour = angular.isDefined(scope.timePicker12Hour) ? false : true;
                var timePickerIncrement = angular.isDefined(scope.minuteIncrement) ? scope.$eval(scope.minuteIncrement) : 1;

                var pickerObj = picker.daterangepicker({
                    "singleDatePicker": true,
                    "showDropdowns": true,
                    "timePicker": scope.datetimePicker,
                    "timePicker24Hour": timePicker24Hour,
                    "timePickerIncrement": timePickerIncrement,
                    "autoApply": false,
                    "opens": "right",
                    "drops": "down",
                    "minDate": minDate,
                    "maxDate": maxDate,
                    "autoUpdateInput": false,
                    "locale": {
                        "format": scope.dateFormat,
                        'cancelLabel': $translate.instant('cancelBtn'),
                        'applyLabel': $translate.instant('applyBtn')
                    }
                }, function (start, end, label) {
                    callApplyFuncFlag = false;
                    setDateFormate(start);
                }).bind("show.daterangepicker", function () { // callback on after open datepicker
                    var pos = pickerObj.container.offset(),
                        wHeight = window.innerHeight,
                        srTop = $(window).scrollTop();
                    if ((pos.top + pickerObj.container.outerHeight() - srTop) > wHeight) { // if datepicker goes down then push it up
                        pickerObj.drops = "up";
                        pickerObj.move();
                    } else if (pos.top < srTop) { // else if datepicker goes up then push it down
                        pickerObj.drops = "down";
                        pickerObj.move();
                    }
                }).data("daterangepicker");

                picker.on('apply.daterangepicker', function (ev, pickerObj) {
                    if (callApplyFuncFlag) {
                        setDateFormate(pickerObj.startDate)
                    }
                    callApplyFuncFlag = true;
                    pickerObj.autoUpdateInput = true;
                    pickerObj.updateElement();
                    pickerObj.autoUpdateInput = false;
                });

                if (scope.isDateBlank) {
                    picker.val('');
                    scope.ngModel = "";
                    // WS-2072
                    //ngModelCtrl.$setViewValue('');

                };
            });
        }

        var getDisplayData = function (data, scope) {
            if (data == undefined || data == null || data == '') {
                return '';
            }
            var str = scope.ndisplayFormat, evalResult, evaluatedKeysCounter = 0, nullKeysCounter = 0;
            try {
                var parentSplit = str.split('{');
                for (var j = 0; j < parentSplit.length; j++) {
                    var childSplit = parentSplit[j].split('}');
                    for (var k = 0; k < childSplit.length; k++) {
                        if (childSplit[k].indexOf('.') > 0 || data.hasOwnProperty(childSplit[k])) {
                            evalResult = eval('data.' + childSplit[k]);
                            evaluatedKeysCounter++;
                            if (evalResult == undefined || evalResult == null || (evalResult + '').trim().length == 0) {
                                evalResult = '';
                                nullKeysCounter++;
                            }
                            str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), evalResult);
                        }
                    }
                }
                if (evaluatedKeysCounter == nullKeysCounter) {
                    str = '';
                }
            }
            catch (e) { }
            return str === undefined || str === null || str === 'undefined' || str === 'null' ? '' : str;
        }

        function debounce(func, wait, immediate) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };


        var service = {
            buildTemplate: buildTemplate,
            setActiveClass: setActiveClass,
            updateTextFieldClass: updateTextFieldClass,
            checkIfActive: checkIfActive,
            validateRules: validateRules,
            checkRule: checkRule,
            updateTextValue: updateTextValue,
            debounce: debounce,
            updateDateClass: updateDateClass,
            assignDateEvents: assignDateEvents,
            getFormattedData: getFormattedData,
            toUTC: toUTC,
            getGridFormatToTimestamp: getGridFormatToTimestamp,
            createDatePicker: createDatePicker,
            updateDateValue: updateDateValue,
            updateAutocompleteValue: updateAutocompleteValue,
            getDisplayData: getDisplayData,
            assignAutocompleteEvents: assignAutocompleteEvents,
            modal: modal
        };

        return service;
    }

    angular.module('SMART2').factory('smartTextField3Service', ['ScrollTo', 'RuleEngine', '$templateCache', '$compile', '$translate', '$timeout', smartTextField3ServiceFunc])
        function smartTextField3ServiceFunc(ScrollTo, RuleEngine, $templateCache, $compile, $translate, $timeout) {
        var _selectedDate, _previousDate;
        var getSelectedDate = function () {
            return _selectedDate;
        };
        var setSelectedDate = function (date) {
            _selectedDate = date;
        };
        var getPreviousDate = function () {
            return _previousDate;
        };
        var setPreviousDate = function (date) {
            _previousDate = date;
        };
        var checkIfActive = function (scope) {
            if (typeof scope.readonly !== 'undefined' && scope.readonly == 'true') {
                return true;
        }
            if (scope.type == 'number' && scope.ngModel !== 0 + '' && (typeof scope.placeholder !== 'undefined' && scope.placeholder === '') && (typeof scope.ngModel === 'undefined' || scope.ngModel === '' || isNaN(scope.ngModel) || scope.ngModel === undefined || scope.ngModel === null)) {
                return false;
        }
            if (scope.type != 'number' && scope.type != 'autocomplete' && (typeof scope.placeholder !== 'undefined' && scope.placeholder === '') && (typeof scope.ngModel === 'undefined' || scope.ngModel === '' || scope.ngModel === undefined || scope.ngModel === null)) {
                return false;
        }
            if (scope.type == 'autocomplete' && (typeof scope.placeholder !== 'undefined' && scope.placeholder === '') && (typeof scope.ngModel === 'undefined' || scope.displayModel === '' || scope.displayModel === undefined || scope.displayModel === null)) {
                return false;
        }
            return true;
        }

        var setActiveClass = function (scope, element, eventType) {
            scope.active = checkIfActive(scope);
            var el = element.find('#' + scope.textfieldId + '_label');

            if ((typeof scope.active !== 'undefined' && scope.active == true) || (typeof scope.validate !== 'undefined' && scope.validate == true)) {
                if (!el.hasClass('active')) {
                    el.addClass('active');
            }
            } else {
                if (el.hasClass('active')) {
                    el.removeClass('active');
            }
        }
        }

        var updateTextFieldClass = function (scope, element) {
            var elm = $(element).find('#' + scope.textfieldId);
            var elmContainer = $(element).find('#' + scope.textfieldId + '_container');
            var lbl = $(element).find('#' + scope.textfieldId + '_label');
            if (typeof scope.validate !== 'undefined' && scope.validate == true && typeof scope.errorMessage !== 'undefined' && scope.errorMessage) {
                if (!elm.hasClass('invalid')) {
                    elm.addClass('invalid');
                    lbl.attr('data-error', $translate.instant(scope.errorMessage));
            }
            }
            else {
                if (elm.hasClass('invalid')) {
                    elm.removeClass('invalid');
                    lbl.attr('data-error', '');
            }
        }

            if (typeof scope.textAlign !== 'undefined' && scope.textAlign == 'right') {
                if (!elm.hasClass('right-align')) {
                    elm.addClass('right-align');
            }
            }
            else {
                if (elm.hasClass('right-align')) {
                    elm.removeClass('right-align');
            }
        }

            if (typeof scope.textAlign !== 'undefined' && scope.textAlign == 'left') {
                if (!elm.hasClass('left-align')) {
                    elm.addClass('left-align');
            }
            }
            else {
                if (elm.hasClass('left-align')) {
                    elm.removeClass('left-align');
            }
        }

            if ((typeof scope.readonly !== 'undefined' && (scope.readonly == true || scope.readonly == 'true')) || (typeof scope.disable !== 'undefined' && (scope.disable === 'true' || scope.disable === true))) {
                elm.prop("readonly", true);
                elm.attr("disabled", "disabled");
                elm.attr('tabindex', -1);
                elmContainer.addClass('readOnlyField');
                if (elm.hasClass('invalid')) {
                    elm.removeClass('invalid');
                    lbl.attr('data-error', '');
            }
            }
            else {
                elm.prop("readonly", false);
                elm.attr("disabled", false);
                elm.removeAttr('tabindex');
                elmContainer.removeClass('readOnlyField');
        }


            if (typeof scope.autocomplete != 'undefiend' && (scope.autocomplete == 'true' || scope.autocomplete == true))// "{{autocomplete?'on':'off'}}")
            {

            }
            else {
                // elm.autocomplete().disable();
        }

            //if (typeof scope.disable !== 'undefined' && scope.disable == true) {
            //    elm.attr("disabled", "disabled")
            //}
            //else {
            //    elm.attr("disabled", false);
            //}


            if (!elm.hasClass('ng-valid')) {
                elm.addClass('ng-pristine ng-valid ng-scope ng-touched');
        }


            if (typeof scope.placeholder !== 'undefined' && scope.placeholder != '') {
                elm.attr("placeholder", scope.placeholder)
        }

            //Optional Field
            var optionalField = $(element).find('#' + scope.textfieldId + '_opField');
            if ((typeof scope.isMandatory !== 'undefined' && (scope.isMandatory == 'false' || scope.isMandatory == false)) && (scope.isRemovable == true || scope.isRemovable == 'true')) {
                var container = $(element).find('#' + scope.textfieldId + '_container');
                if (typeof optionalField == 'undefiend' || (typeof optionalField !== 'undefiend' && optionalField.length == 0)) {
                    container.append(buildOptionalFieldTemplate(scope));
                    optionalField = $(element).find('#' + scope.textfieldId + '_opField');
                    if (typeof optionalField != 'undefined' && optionalField.length > 0) {
                        optionalField.bind("click", scope.hideShowField);
                }
            }
                if (!container.hasClass('optionalField')) {
                    container.addClass('optionalField');
            }

            }
            else {
                if (typeof optionalField !== 'undefiend' && optionalField.length > 0) {
                    optionalField.remove();
            }
        }

            if (scope.type === 'text' || scope.type === 'number' || scope.type === 'area') {
                if (typeof scope.maxlength != 'undefined') {
                    if (parseInt(scope.maxlength) > -1) {
                        elm.attr('maxlength', parseInt(scope.maxlength));
                }
            }
        }

            var className = '';
            if (element.length > 0) {
                className = element[0].className;
                className = className.replace('ng-hide', "");
                element.removeClass(className);
        }
            elmContainer.addClass(className);
        }

        var buildOptionalFieldTemplate = function (scope) {
            if ((typeof scope.isMandatory !== 'undefined' && (scope.isMandatory == 'false' || scope.isMandatory === false)) && (scope.isRemovable == true || scope.isRemovable == 'true')) {
                var optionalField = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldOptionalFieldTemplate.html');
                optionalField = optionalField.replace('{{id}}', scope.textfieldId + '_opField');
                return optionalField;
        }
            return '';
        };

        var buildPrefixiconTemplate = function (scope) {
            if (typeof scope.prefixicon !== 'undefined' && scope.prefixicon) {
                var html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldprefixiconTemplate.html');
                html = html.replace('{{id}}', scope.textfieldId + '_prefixicon');
                html = html.replace('{{prefixicon}}', scope.prefixicon);
                return html;
        }
            return '';
        };

        var buildSpinnerTemplate = function (scope) {
            if (!scope.type == 'autocomplete' && typeof scope.loading !== 'undefined' && scope.loading == true) {
                var html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldSpinnerTemplate.html');
                html = html.replace('{{id}}', scope.textfieldId + '_spinner');
                return html;
        }
            return '';
        };

        var buildTextFieldTemplate = function (scope) {
            var html = '';
            if (scope.type === 'area' && (scope.readonly === 'true' || scope.disable === 'true')) {
                html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextareaReadonlyElementTemplate.html');
            } else if (scope.type === 'area') {
                html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextareaElementTemplate.html');
            } else {
                html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldElementTemplate.html');
        }
            if (scope.type === 'password') {
                html = html.replace('type="text"', 'type="password"');
        }
            html = html.replace('{{id}}', scope.textfieldId);
            html = html.replace('{{showHideReadMoreContent}}', 'showHideReadMoreContent' + scope.textfieldId);
            html = html.replace('{{showLessContent}}', $translate.instant('showLess'));
            html = html.replace('{{showMoreContent}}', $translate.instant('showMoreContent'));
            return html;
        };

        var buildInfoIconTemplate = function (scope) {
            var html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldinfoiconTemplate.html');
            //if (scope.showwarning || scope.showinfo) {
            //    html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldinfoiconTemplate.html');
            //}
            return html;
        };

            //var buildWarningIconTemplate = function (scope) {
            //    var html = '';
            //    if (scope.showwarning || scope.showinfo) {
            //        html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldwarningiconTemplate.html');
            //    }
            //    return html;
            //};

        var buildLabelTemplate = function (scope) {
            var html = '';
            //if (typeof scope.label !== 'undefined' && scope.label.trim() != '') {
            html = $templateCache.get('shared/directives/uiElements/smartTextfield/smartTextfieldLabelTemplate.html');
            html = html.replace('{{id}}', scope.textfieldId + '_label');
            html = html.replace('{{textfieldId}}', scope.textfieldId);
            html = html.replace('{{label}}', typeof scope.label === 'undefined' ? '' : scope.label);
            if (!scope.label) {
                html = html.replace('class=""', 'class="empty-label"');
        }

            //}
            return html;
        };

        var buildTemplate = function (scope, element, onChangeCallback, attrs) {
            var container = $('<div/>', { id: scope.textfieldId + '_container' });// document.createElement('div');

            var css = '';
            if ((scope.isMandatory === false || scope.isMandatory === 'false') && scope.isRemovable === true) {
                css += ' optionalField';
        }
            if (scope.showinfo || scope.showwarning) {
                css += ' field-has-icon';
                //if (scope.showinfo && scope.showwarning) {
                //    css += ' field-has-two-icons';
                //}
        }
            if (scope.readonly === 'true' || scope.disable === 'true') {
                css += ' readOnlyField';
        }
            //if (!scope.customoption) {
            //    css += ' defaultSelected';
            //}
            //if (scope.validate === true && scope.errorMessage) {
            //    css += ' invalid';
            //}
            var className = '';
            if (element.length > 0) {
                className = element[0].className;
                element.removeClass(className);
                if (className) {
                    scope.className = className;
                }
            }
            container.addClass(scope.className + ' input-field ' + css);


            container.append('<div class="elements-include">' + buildOptionalFieldTemplate(scope) + buildPrefixiconTemplate(scope) + buildSpinnerTemplate(scope) + buildTextFieldTemplate(scope) + buildLabelTemplate(scope) + '</div>');
            container.append($compile(buildInfoIconTemplate(scope))(scope));
            //if (scope.showinfo || scope.showwarning) {
            //    container.append($compile(buildInfoIconTemplate(scope))(scope));
            //}

            element.html(container);
            var elm = $(element).find('#' + scope.textfieldId);
            elm.on("change", function (el) {
                //console.log(el);
                onChangeCallback(el);
            });
            elm.on("blur", scope.ngBlur);

            if (scope.type != undefined && scope.type == 'number') {
                // elm.attr('type', 'number');

                if (scope.min != undefined && scope.min != null) {
                    if ($.isNumeric(scope.min)) {
                        elm.attr('min', scope.min);
                }
            }
                if (scope.max != undefined && scope.max != null) {
                    if ($.isNumeric(scope.max)) {
                        elm.attr('max', scope.max);
                }
            }

                elm.bind('keypress', scope.ngKeyPress);



            } else if (scope.type != undefined && scope.type == 'autocomplete') {
                elm.on("focus", scope.ngFocus);

                if (attrs.onKeyPress || attrs.onEnter) {
                    elm.bind('keypress', debounce(scope.ngKeyPress, 250));
            }
            } else if (scope.type != undefined && (scope.type == 'area' || scope.type == 'text')) {

                // Need to add debounce for updating the ngModel
                if (attrs.onKeyPress || attrs.onEnter) {
                    elm.bind('keypress', debounce(scope.ngKeyPress, 250));
            }
                //if (attrs.onKeyUp) {
                //    elm.bind('keyup', debounce(scope.ngKeyUp, 250));
                //}
                if (attrs.onKeyDown) {
                    elm.bind('keydown', debounce(scope.ngKeyDown, 250));
            }
                if (attrs.onFocus) {
                    elm.bind('focus', scope.ngFocus);
            }
                // Need to optimize this line, post finding of better approach. It is required for filtering ng-repeat
                elm.bind('keyup', scope.ngKeyUp);
            }


            var optionalField = $(element).find('#' + scope.textfieldId + '_opField > i');
            if (typeof optionalField != 'undefined' && optionalField.length > 0) {
                optionalField.bind("click", scope.hideShowField);

        }
            updateTextFieldClass(scope, element);
            setActiveClass(scope, element);

            if (angular.isDefined(scope.charactercounter) && scope.charactercounter == 'true') {
                elm.attr('length', scope.maxlength);
                elm.characterCounter();
        }

        };

        var updateTextValue = function (scope, element, ngModelCtrl) {
            var elm = element.find('#' + scope.textfieldId),
                addClassElem = element.find('#showHideReadMoreContent' + scope.textfieldId),
                showLessContent = element.find('.readOnlyshowLess'),
                showMoreContent = element.find('.readOnlyShowMore');
                showLessContent.hide();
                showMoreContent.hide();
            if (!addClassElem.hasClass('areareadOnlyContentPara2')) {
                if (modal.getModal(scope, ngModelCtrl) && modal.getModal(scope, ngModelCtrl).length < 150) {
                    showLessContent.hide();
                    showMoreContent.hide();
                } else if (modal.getModal(scope, ngModelCtrl) && modal.getModal(scope, ngModelCtrl).length > 150) {
                    addClassElem.addClass('ellipsis areareadOnlyContentPara1');
                    showLessContent.hide();
                    showMoreContent.show();
            }
        }
         
            if (scope.type === 'area' && (scope.readonly === 'true' || scope.disable === 'true')) {
                elm.text(modal.getModal(scope, ngModelCtrl));
                $(showLessContent).off('click').on('click', function () {
                    $(this).hide();
                    $(showMoreContent).show();
                    $(addClassElem).removeClass('areareadOnlyContentPara2');
                    $(addClassElem).addClass('ellipsis areareadOnlyContentPara1');
                });
                $(showMoreContent).off('click').on('click', function () {
                    $(this).hide();
                    $(showLessContent).show();
                    $(addClassElem).removeClass('ellipsis areareadOnlyContentPara1');
                    $(addClassElem).addClass('areareadOnlyContentPara2');
                });
            }
            else {
                if (typeof scope.ngModel == "function") {
                    $timeout(function () {
                        elm = element.find('#' + scope.textfieldId);
                        var gm = modal.getModal(scope, ngModelCtrl);
                        if (elm.val() !== gm) {
                            elm.val(gm);
                        }
                        if (scope.showTitle) {
                            elm.attr('title', gm);
                        }
                        if (gm === '' || typeof gm == 'undefined') {
                            elm.addClass('ng-empty').removeClass('ng-not-empty');
                            elm.attr('title', '');
                        } else {
                             angular.element('#' + scope.textfieldId+"_label").addClass("active");
                             elm.removeClass('ng-empty').addClass('ng-not-empty');
                        }
                    });
                }else if (scope.type == 'number') {
                    var modelVal = modal.getModal(scope, ngModelCtrl)
                    if (typeof elm.autoNumeric == 'function') {
                        if (elm.autoNumeric('get') != modelVal) {
                            elm.autoNumeric('set', modelVal);
                        }
                        if (scope.showTitle) {
                            elm.attr('title', elm.autoNumeric('get'));
                        }
                    }
                    else {
                        if (elm.val() !== modelVal) {
                            elm.val(modelVal);
                        }
                        if (scope.showTitle) {
                            elm.attr('title', modelVal);
                        }
                    }
                   
                    if (modelVal === null && scope.placeholder === "") {
                        elm.addClass('ng-empty').removeClass('ng-not-empty');
                    } else {
                        elm.removeClass('ng-empty').addClass('ng-not-empty');
                    }
                }
                else {
                    if (elm.val() !== modal.getModal(scope, ngModelCtrl)) {
                        if (scope.typing) {
                            smartTextFieldService.modal.setModal(scope, elm.val(), ngModelCtrl);
                        } else {
                            elm.val(modal.getModal(scope, ngModelCtrl));
                        }

                    }
                    if (scope.showTitle) {
                        elm.attr('title', modal.getModal(scope, ngModelCtrl));
                    }
                    if (modal.getModal(scope, ngModelCtrl) === '') {
                        elm.addClass('ng-empty').removeClass('ng-not-empty');
                    } else {
                        elm.removeClass('ng-empty').addClass('ng-not-empty');
                    }
                }

                /* Adding class truncate to input*/
                if (!elm.hasClass('materialize-textarea') && (scope.readonly === 'true' || scope.disable === 'true')) {
                    elm.addClass('truncate');
                } else {
                    elm.removeClass('truncate')
            };
        }
            if (scope.type === 'area') {
                    $timeout(function(){
                         angular.element('#' + scope.textfieldId).trigger('autoresize');
                    });
            }
       }

        var modal = {
                getModal: function (scope, ngModelCtrl) {
                return typeof scope.ngModel == "function" ? ngModelCtrl.$modelValue : scope.ngModel;
        },
                setModal: function (scope, value, ngModelCtrl) {

                if (typeof scope.ngModel == "function") {
                    ngModelCtrl.$setViewValue(value)
                    ngModelCtrl.$render()
                } else {
                    scope.ngModel = value;
                }
        }
        };

        var updateDateValue = function (scope, element) {
            var elm = element.find('#' + scope.textfieldId);
            elm.val(scope.dateModel);
            elm.attr('title', scope.dateModel);
        }

        var updateAutocompleteValue = function (scope, element) {
            var elm = element.find('#' + scope.textfieldId);
            elm.val(scope.displayModel);
            elm.attr('title', scope.displayModel);
        }


        var checkRule = function (scope, element) {
            var rules = scope.$eval(scope.rules);
            var isFoundInvalid = false;

            for (var i = 0; i < rules.length; i++) {
                if (typeof rules[i] == 'object') {
                    if (eval((rules[i].rule).replace(/this/g, scope.type == 'autocomplete' ? 'scope.displayModel' : 'scope.ngModel'))) {
                        scope.validate = true;
                        scope.errorMessage = rules[i].error;
                        scope.errorModel = rules[i].error;
                        break;
                    } else {
                        if (scope.type === 'date') {
                            angular.element('#' + scope.textfieldId).removeClass('invalid');
                    }
                }
                }
                else {
                    if (!isFoundInvalid) {
                        if (typeof scope.ngModel != 'object')
                            var data = scope.ngModel;
                        else
                            var data = scope.displayModel;

                        RuleEngine.isValid(rules[i], function (e) {
                            scope.validate = true;
                            scope.errorMessage = e.errorData.error;
                            scope.errorModel = rules[i].error;
                            isFoundInvalid = true;
                        }, data);
                    }
                    else {
                        break;
                }
            }
        }
        }

        var validateRules = function (scope, ngModelCtrl, element, attrs) {
            if (typeof scope.readonly !== 'undefined' && scope.readonly == 'true') {
                scope.isActive = true;
                return;
        }

            if ((scope.type === 'text' || scope.type === 'area') && angular.isString(scope.ngModel)) {
                if (attrs.noTrim == 'true') {
                    //scope.ngModel = scope.ngModel;
                } else {
                    //scope.ngModel = scope.ngModel.trim();
                    var tempString = modal.getModal(scope, ngModelCtrl);
                    if (tempString.trim().length <= 0) {
                        modal.setModal(scope, tempString.trim(), ngModelCtrl);
                    } else {
                        modal.setModal(scope, tempString, ngModelCtrl);
                }
            }
                //ngModelCtrl.$setViewValue(scope.ngModel);
        }

            if ((scope.type == 'autocomplete' && scope.$eval(scope.isMandatory) && !scope.clienterror && (typeof scope.ngModel === 'undefined' || scope.displayModel == '' || scope.displayModel == null || scope.displayModel == undefined || scope.ngModel.id === 0)) || (scope.type != 'autocomplete' && scope.$eval(scope.isMandatory) && !scope.clienterror && (scope.ngModel + '' == '' || scope.ngModel == null || scope.ngModel == undefined))) {
                scope.validate = true;
                scope.errorMessage = $translate.instant("enterValueErrMsg");
                scope.errorModel = $translate.instant("enterValueErrMsg");

                return;
        }

            if (scope.clienterror) {
                scope.validate = true;
                scope.errorMessage = $translate.instant("clientErrMsg");
                scope.errorModel = $translate.instant("clientErrMsg");

                return;
        }

            if (scope.type == 'number') {
                if (!scope.$eval(scope.isMandatory) && isNaN(scope.ngModel)) {
                    angular.element('#' + scope.textfieldId).val('');
                    return;
            }
                if (!scope.$eval(scope.isMandatory) && scope.ngModel === null) {
                    if (scope.rules) {
                        checkRule(scope, element);
                }
                    return;
            }
                //if (scope.$eval(scope.isMandatory) && isNaN(scope.ngModel) || (!scope.$eval(scope.isMandatory) && number == undefined)) {
                //    scope.validate = true;
                //    scope.errorMessage = $translate.instant('enterNumberErrMsg');
                //    scope.errorModel = $translate.instant('enterNumberErrMsg');
                //    return;
                //}

        }

            // CON-5898
            if (scope.type == 'date' && !scope.rules) {
                $('#' + scope.textfieldId).removeClass('invalid');
        }

            scope.validate = false;
            scope.errorMessage = null;
            scope.errorModel = null;

            if (scope.rules) {
                checkRule(scope, element);
        }
        };

        var debounce = function (func, wait, immediate) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
            };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
        };
        };

        var updateDateClass = function (scope, element) {
            var el = element.find('#' + scope.textfieldId);
            if (scope.type == 'date') {
                if (!el.hasClass('datepicker')) {
                    el.addClass('datepicker');
            }
        }


        }
        var assignDateEvents = function (scope, element) {
            var el = element.find('#' + scope.textfieldId);
            el.bind('keydown', scope.ngKeyDown);
            el.bind('keypress', scope.ngKeyPress);
            el.bind('keyup', scope.ngKeyUp);

        }

        var assignAutocompleteEvents = function (scope, element) {
            var el = element.find('#' + scope.textfieldId);
            //el.bind('keydown', scope.ngKeyDown);
            //el.bind('keypress', scope.ngKeyPress);
            el.bind('keyup', debounce(scope.ngKeyUp, 250));
            el.on('input', debounce(scope.search, 250));

        }

            /*
              * This function is required to generate value attribute 
              * and useful when up/down key is pressed
              */
        var getFormattedData = function (data, scope) {
            if (!data || data.length == 0) {
                return [];
        }
            for (var i = 0; i < data.length; i++) {
                var str = scope.ndisplayFormat;
                try {
                    var parentSplit = str.split('{');
                    for (var j = 0; j < parentSplit.length; j++) {
                        var childSplit = parentSplit[j].split('}');
                        for (var k = 0; k < childSplit.length; k++) {
                            if (childSplit[k].indexOf('.') > 0 || data[i].hasOwnProperty(childSplit[k])) {
                                str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), eval('data[i].' + childSplit[k]));
                        }
                    }
                }
            }
                catch (e) { }
                data[i].value = str.trim();
        }
            return data;
        };
            /*
                *  Convert timestamp to UTC timestamp 
                */
        var toUTC = function (date) {
            return Date.UTC(
                date.getFullYear()
                , date.getMonth()
                , date.getDate()
                , date.getHours()
                , date.getMinutes()
                , date.getSeconds()
                , date.getMilliseconds()
            );
        };

        var getGridFormatToTimestamp = function (scope, stringdate) {
            var tmpModel = (stringdate + '').replace(new RegExp("/", "ig"), '');
            // tmpModel = tmpModel.split('+');
            // tmpModel = eval('new ' + (tmpModel.length > 1 ? ('Date("' + tmpModel.join('+') + '").getTime()') : tmpModel[0]));
            //if (scope.applyClientZone) {
            //    return moment(tmpModel).parseZone().format(scope.dateFormat);
            //}
            //else {
            return moment(tmpModel).format(scope.dateFormat);
            //}
        }

        var updateNgModel = function (scope, timestamp) {
            scope.dateModifiedbyUser = true;
            if (scope.timePicker == true) {
                if (scope.convertIntoUTC || timeZoneOffset != 20) {
                    // that means the date will be saved in UTC Format
                    scope.ngModel = moment(timestamp * 1000).add((timeZoneOffset * -60), 'minute').format('YYYY-MM-DDTHH:mm:ss');  //'\/Date(' + ((timestamp - (moment().zone() * 60)) * 1000) + ')\/';
                } else {
                    //This case is applied for Sourcing. because of the converstion happed before saving.
                    scope.ngModel = '\/Date(' + (timestamp * 1000) + ')\/';
            }
            }
            else {
                // hooking a fixed time to fix the flipping issues.
                // if (scope.convertIntoUTC) {
                //scope.ngModel = moment(timestamp * 1000).format('YYYY-MM-DD') + 'T12:00:00';//'\/Date(' + (((timestamp- (moment().zone() * 60)) * 1000) + 43200000) + ')\/';
                //}else
                //{
                //    scope.ngModel = '\/Date(' + ((timestamp * 1000) + 43200000) + ')\/';
                //}

                if (timeZoneOffset != 20) {
                    scope.ngModel = moment(timestamp * 1000).format('YYYY-MM-DD') + 'T12:00:00';//'\/Date(' + (((timestamp- (moment().zone() * 60)) * 1000) + 43200000) + ')\/';
                } else {
                    scope.ngModel = '\/Date(' + ((timestamp * 1000) + 43200000) + ')\/';
            }
        }
        }


        var createDatePicker = function (scope, element, ngModelCtrl) {
            setTimeout(function () {
                var picker = element.find('#' + scope.textfieldId);
                var callApplyFuncFlag = true;
                function setDateFormate(datePar) {
                    updateNgModel(scope, datePar.unix());
                    ngModelCtrl.$setViewValue(scope.ngModel);
                    scope.$apply();
                    $timeout(function () {
                        // if (scope.doesContainDateString) {

                        //} else {
                        //    if (scope.isValueDateObj) {
                        //        var tempDate = datePar.format();
                        //        scope.ngModel = new Date(tempDate);
                        //    } else {
                        //        scope.ngModel = (datePar.unix() * 1000);
                        //    }
                        //}
                        //ngModelCtrl.$setViewValue(scope.ngModel);
                        scope.isDateBlank = false;                        
                            if (angular.isFunction(scope.onDateChange)) {
                                scope.onDateChange({ $event: { date: scope.ngModel } });
                    }
                        
                    })
            }
                var minDate = angular.isDefined(scope.min) ? scope.doesContainDateString ? getGridFormatToTimestamp(scope.min) : moment(parseInt(scope.min)).format(scope.dateFormat) : '';
                var maxDate = angular.isDefined(scope.max) ? scope.doesContainDateString ? getGridFormatToTimestamp(scope.max) : moment(parseInt(scope.max)).format(scope.dateFormat) : '';

                var timePicker24Hour = angular.isDefined(scope.timePicker12Hour) ? false : true;
                var timePickerIncrement = angular.isDefined(scope.minuteIncrement) ? scope.$eval(scope.minuteIncrement) : 1;

                var pickerObj = picker.daterangepicker({
                    "singleDatePicker": true,
                    "showDropdowns": true,
                    "timePicker": scope.datetimePicker,
                    "timePicker24Hour": timePicker24Hour,
                    "timePickerIncrement": timePickerIncrement,
                    "autoApply": false,
                    "opens": "right",
                    "drops": "down",
                    "minDate": minDate,
                    "maxDate": maxDate,
                    "autoUpdateInput": false,
                    "locale": {
                        "format": scope.dateFormat,
                        'cancelLabel': $translate.instant('cancelBtn'),
                        'applyLabel': $translate.instant('applyBtn')
                        }
                        }, function (start, end, label) {
                    callApplyFuncFlag = false;
                    setDateFormate(start);
                }).bind("show.daterangepicker", function () { // callback on after open datepicker
                    setPreviousDate(pickerObj.element.val());
                    var pos = pickerObj.container.offset(),
                        wHeight = window.innerHeight,
                        srTop = $(window).scrollTop();
                    if ((pos.top + pickerObj.container.outerHeight() - srTop) > wHeight) { // if datepicker goes down then push it up
                        pickerObj.drops = "up";
                        pickerObj.move();
                    } else if (pos.top < srTop) { // else if datepicker goes up then push it down
                        pickerObj.drops = "down";
                        pickerObj.move();
                }
                }).data("daterangepicker");

                picker.on('apply.daterangepicker', function (ev, pickerObj) {
                    if (callApplyFuncFlag) {
                        setDateFormate(pickerObj.startDate)
                }
                    callApplyFuncFlag = true;
                    pickerObj.autoUpdateInput = true;
                    pickerObj.updateElement();
                    pickerObj.autoUpdateInput = false;
                    setPreviousDate(pickerObj.element.val());
                    setSelectedDate('\/Date(' + ((pickerObj.startDate.unix() * 1000) + 43200000) + ')\/');
                });

                if (scope.isDateBlank) {
                    picker.val('');
                    scope.ngModel = "";
                    // WS-2072
                    //ngModelCtrl.$setViewValue('');

            };
            });
        }

        var getDisplayData = function (data, scope) {
            if (data == undefined || data == null || data == '') {
                return '';
        }
            var str = scope.ndisplayFormat, evalResult, evaluatedKeysCounter = 0, nullKeysCounter = 0;
            try {
                var parentSplit = str.split('{');
                for (var j = 0; j < parentSplit.length; j++) {
                    var childSplit = parentSplit[j].split('}');
                    for (var k = 0; k < childSplit.length; k++) {
                        if (childSplit[k].indexOf('.') > 0 || data.hasOwnProperty(childSplit[k])) {
                            evalResult = eval('data.' + childSplit[k]);
                            evaluatedKeysCounter++;
                            if (evalResult == undefined || evalResult == null || (evalResult + '').trim().length == 0) {
                                evalResult = '';
                                nullKeysCounter++;
                        }
                            str = str.replace(new RegExp("{" + childSplit[k] + "}", "ig"), evalResult);
                    }
                }
            }
                if (evaluatedKeysCounter == nullKeysCounter) {
                    str = '';
            }
        }
            catch (e) { }
            return str === undefined || str === null || str === 'undefined' || str === 'null' ? '' : str;
        }

            function debounce(func, wait, immediate) {
            var timeout;
            return function () {
                var context = this, args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
            };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) func.apply(context, args);
            };
        };


        var service = {
                buildTemplate: buildTemplate,
                setActiveClass: setActiveClass,
                updateTextFieldClass: updateTextFieldClass,
                checkIfActive: checkIfActive,
                validateRules: validateRules,
                checkRule: checkRule,
                updateTextValue: updateTextValue,
                debounce: debounce,
                updateDateClass: updateDateClass,
                assignDateEvents: assignDateEvents,
                getFormattedData: getFormattedData,
                toUTC: toUTC,
                getGridFormatToTimestamp: getGridFormatToTimestamp,
                createDatePicker: createDatePicker,
                updateDateValue: updateDateValue,
                updateAutocompleteValue: updateAutocompleteValue,
                getDisplayData: getDisplayData,
                assignAutocompleteEvents: assignAutocompleteEvents,
                modal: modal,
                setSelectedDate: setSelectedDate,
                getSelectedDate: getSelectedDate,
                setPreviousDate: setPreviousDate,
                getPreviousDate: getPreviousDate
        };

        return service;
    }

    (function ($) {

        $.extend({

                debounce: function (fn, timeout, invokeAsap, ctx) {

                if (arguments.length == 3 && typeof invokeAsap != 'boolean') {
                    ctx = invokeAsap;
                    invokeAsap = false;
                }

                var timer;

                return function () {

                    var args = arguments;
                    ctx = ctx || this;

                    invokeAsap && !timer && fn.apply(ctx, args);

                    clearTimeout(timer);

                    timer = setTimeout(function () {
                        !invokeAsap && fn.apply(ctx, args);
                        timer = null;
                    }, timeout);

                };

        },

                throttle: function (fn, timeout, ctx) {

                var timer, args, needInvoke;

                return function () {

                    args = arguments;
                    needInvoke = true;
                    ctx = ctx || this;

                    if (!timer) {
                        (function () {
                            if (needInvoke) {
                                fn.apply(ctx, args);
                                needInvoke = false;
                                timer = setTimeout(arguments.callee, timeout);
                            }
                            else {
                                timer = null;
                        }
                        })();
                }

                };

        }

        });

    })(jQuery);
    angular.module('SMART2').directive('smartCharacterCount', [function () {
        return {
                restrict: 'A',
                link: function (scope, element, attrs) {
                if (parseInt(attrs.smartCharacterCount) > -1) {
                    element.attr('length', attrs.smartCharacterCount);
                    element.characterCounter();
                }
        }
    }
    }]);

})();
/**
*  Ajax Autocomplete for jQuery, version 1.2.24
*  (c) 2015 Tomas Kirda
*
*  Ajax Autocomplete for jQuery is freely distributable under the terms of an MIT-style license.
*  For details, see the web site: https://github.com/devbridge/jQuery-Autocomplete
*/

/*jslint  browser: true, white: true, plusplus: true, vars: true */
/*global define, window, document, jQuery, exports, require */

// Expose plugin as an AMD module if AMD loader is present:
(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object' && typeof require === 'function') {
        // Browserify
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {
    'use strict';

    var getCompiledOption = function (str, option) {
        try {
            //var keys = Object.keys(suggestion);

            //for(var i=0; i<keys.length; i++) {
            //    if(suggestion.hasOwnProperty(keys[i])) {
            //        str = str.replace(new RegExp("{"+keys[i]+"}", "ig"), suggestion[keys[i]]);
            //    }
            //}

            var parentSplit = str.split('{');
            for (var i = 0; i < parentSplit.length; i++) {
                var childSplit = parentSplit[i].split('}');
                for (var j = 0; j < childSplit.length; j++) {
                    if (childSplit[j].indexOf('.') > 0 || option.hasOwnProperty(childSplit[j])) {
                        str = str.replace(new RegExp("{" + childSplit[j] + "}", "ig"), eval('option.' + childSplit[j]));
                    }
                }
            }
        }
        catch(e) {}
        return str;
    };

    var
        utils = (function () {
            return {
                escapeRegExChars: function (value) {
                    return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                },
                createNode: function (containerClass) {
                    var div = document.createElement('div');
                    div.className = containerClass;
                    div.style.position = 'absolute';
                    div.style.display = 'none';
                    div.onclick = "event.stopPropagation()";
                    div.addEventListener('click', function () {
                        event.stopPropagation();
                    });
                    return div;
                }
            };
        }()),

        keys = {
            ESC: 27,
            TAB: 9,
            RETURN: 13,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        };

    function Autocomplete(el, options) {
        var noop = function () { },
            that = this,
            defaults = {
                ajaxSettings: {},
                autoSelectFirst: false,
                appendTo: document.body,
                serviceUrl: null,
                lookup: null,
                onSelect: null,
                width: 'auto',
                minChars: 1,
                maxHeight: 300,
                deferRequestBy: 0,
                params: {},
                formatResult: Autocomplete.formatResult,
                delimiter: null,
                zIndex: 9999,
                type: 'GET',
                noCache: false,
                onSearchStart: noop,
                onSearchComplete: noop,
                onSearchError: noop,
                preserveInput: false,
                containerClass: 'autocomplete-suggestions',
                tabDisabled: false,
                dataType: 'text',
                currentRequest: null,
                triggerSelectOnValidInput: true,
                preventBadQueries: true,
                lookupFilter: function (suggestion, originalQuery, queryLowerCase) {
                    //  Added by Sushant
                    try {
                        var str = '';
                        for (var i = 0; i < that.filterKeys.length; i++) {
                            str = str + eval('suggestion.' + that.filterKeys[i]).toLowerCase().trim() + ' ';
                        }
                        str = str.trim();
                    }
                    catch (e) { }
                    return str.indexOf(queryLowerCase) > -1;
                },
                paramName: 'query',
                transformResult: function (response) {
                    return typeof response === 'string' ? $.parseJSON(response) : response;
                },
                showNoSuggestionNotice: false,
                noSuggestionNotice: 'No results',
                orientation: 'bottom',
                forceFixPosition: false,
                multiselect: false,
                showLookup: false,
                addnew: false,
                loading: false
            };

        // Shared variables:
        that.element = el;
        that.el = $(el);
        that.suggestions = [];
        that.badQueries = [];
        that.selectedIndex = -1;
        that.currentValue = that.element.value;
        that.intervalId = 0;
        that.cachedResponse = {};
        that.onChangeInterval = null;
        that.onChange = null;
        that.isLocal = false;
        that.suggestionsContainer = null;
        that.noSuggestionsContainer = null;
        that.options = $.extend({}, defaults, options);
        that.classes = {
            selected: 'autocomplete-selected',
            suggestion: 'autocomplete-suggestion'
        };
        that.hint = null;
        that.hintValue = '';
        that.selection = null;

        //  Added by Sushant
        that.displayKey = options.displayKey ? options.displayKey : 'value';
        that.filterKeys = options.filterKeys ? options.filterKeys : [that.displayKey];
        that.optionFormat = options.optionFormat ? options.optionFormat : '{' + that.displayKey + '}';

        that.setLookup = function (lookup) {
            that.options.lookup = lookup;
            if ($(that.element).is(":focus")) {
                that.onValueChange();
            }
        };
        that.setLoading = function (flag) {
            that.options.loading = flag;
            if ($(that.element).is(":focus")) {
                that.onValueChange();
            }
        };

        // Initialize and set options:
        that.initialize();
        that.setOptions(options);

        //if (!that.options.addnew && !that.options.showLookup) {
        //    that.onValueChange();
        //}
        if ($(that.element).is(":focus")) {
            that.onValueChange();
            that.suggest();
        }
    }

    Autocomplete.utils = utils;
    function isHTML(str) {
        var a = document.createElement('div');
        a.innerHTML = str;
        for (var c = a.childNodes, i = c.length; i--;) {
            if (c[i].nodeType == 1) return true;
        }
        return false;
    }
    $.Autocomplete = Autocomplete;
    Autocomplete.formatResult = function (suggestion, currentValue, optionFormat) {
        var str = suggestion.optionFormat ? suggestion.optionFormat : optionFormat;
        str = getCompiledOption(str, suggestion);
        if (isHTML(str)) {
            return str;
        }
        var reg = new RegExp(currentValue, 'gi');
        return str.replace(reg, function (val) { return '<strong>' + val + '</strong>' });
    };

    Autocomplete.prototype = {

        killerFn: null,

        initialize: function () {
            var that = this,
                suggestionSelector = '.' + that.classes.suggestion,
                selected = that.classes.selected,
                options = that.options,
                container;

            // Remove autocomplete attribute to prevent native suggestions:
            that.element.setAttribute('autocomplete', 'off');

            that.killerFn = function (e) {
                if ($(e.target).closest('.' + that.options.containerClass).length === 0) {
                    that.killSuggestions();
                    that.disableKillerFn();
                }
            };

            // html() deals with many types: htmlString or Element or Array or jQuery
            that.noSuggestionsContainer = $('<div class="autocomplete-no-suggestion"></div>')
                                          .html(this.options.noSuggestionNotice).get(0);

            that.suggestionsContainer = Autocomplete.utils.createNode(options.containerClass);

            container = $(that.suggestionsContainer);

            container.appendTo(options.appendTo);

            // Only set width if it was provided:
            if (options.width !== 'auto') {
                container.width(options.width);
            }

            // Listen for mouse over event on suggestions list:
            container.on('mouseover.autocomplete', suggestionSelector, function () {
                that.activate($(this).data('index'));
            });

            // Deselect active element when mouse leaves suggestions container:
            container.on('mouseout.autocomplete', function () {
                that.selectedIndex = -1;
                container.children('.' + selected).removeClass(selected);
            });

            // Listen for click event on suggestions list:
            container.on('click.autocomplete', suggestionSelector, function () {
                that.select($(this).data('index'));
               // $(that.element).focus(); comment this line due to text overwrapping issue in autocomplete.
            });

            that.fixPositionCapture = function () {
                if (that.visible) {
                    that.fixPosition();
                }
            };

            $(window).on('resize.autocomplete', that.fixPositionCapture);

            that.el.on('keydown.autocomplete', function (e) { that.onKeyPress(e); });
            that.el.on('keyup.autocomplete', function (e) { that.onKeyUp(e); });
            that.el.on('blur.autocomplete', function () { that.onBlur(); });
            that.el.on('focus.autocomplete', function (e) { that.onFocus(); });
            that.el.on('change.autocomplete', function (e) { that.onKeyUp(e); });
            that.el.on('input.autocomplete', function (e) { that.onKeyUp(e); });
            that.el.on('click.autocomplete', function (e) { e.stopPropagation(); });
        },

        onFocus: function () {
            var that = this;
            that.fixPosition();
            //if (that.options.minChars === 0 && that.el.val().length === 0) {
            //    that.onValueChange();
            //}
            if ($(that.element).is(":focus")) {
                that.onValueChange();
                that.suggest();
            }
        },

        onBlur: function () {
            if ($(document.activeElement).hasClass('scroll-inner-wrapp')) {
                return;
            }
            var that = this;
            //if(that.suggestions.length > 0 && that.suggestions[0].value.toLowerCase() === that.el.val().toLowerCase().trim()) {
            //    that.hide();
            //    that.onSelect(0);
            //}
            if (that.selectedIndex === -1) {
                that.hide();
         //       return;
           }
            this.enableKillerFn();
        },
        
        abortAjax: function () {
            var that = this;
            if (that.currentRequest) {
                that.currentRequest.abort();
                that.currentRequest = null;
            }
        },

        setOptions: function (suppliedOptions) {
            var that = this,
                options = that.options;

            $.extend(options, suppliedOptions);

            that.isLocal = $.isArray(options.lookup);

            if (that.isLocal) {
                options.lookup = that.verifySuggestionsFormat(options.lookup);
            }

            options.orientation = that.validateOrientation(options.orientation, 'bottom');

            // Adjust height, width and z-index:
            $(that.suggestionsContainer).css({
                'max-height': options.maxHeight + 'px',
                'width': options.width + 'px',
                'z-index': options.zIndex
            });
        },
        
        clearCache: function () {
            this.cachedResponse = {};
            this.badQueries = [];
        },

        clear: function () {
            this.clearCache();
            this.currentValue = '';
            this.suggestions = [];
        },

        disable: function () {
            var that = this;
            that.disabled = true;
            clearInterval(that.onChangeInterval);
            that.abortAjax();
        },

        enable: function () {
            this.disabled = false;
        },

        fixPosition: function () {
            // Use only when container has already its content

            var that = this,
                $container = $(that.suggestionsContainer),
                containerParent = $container.parent().get(0);
            // Fix position automatically when appended to body.
            // In other cases force parameter must be given.
            if (containerParent !== document.body && !that.options.forceFixPosition) {
                return;
            }

            // Choose orientation
            var orientation = that.options.orientation,
                containerHeight = $container.outerHeight(),
                height = that.el.outerHeight(),
                offset = that.el.offset(),
                styles = { 'top': offset.top, 'left': offset.left };

            if (orientation === 'auto') {
                var viewPortHeight = $(window).height(),
                    scrollTop = $(window).scrollTop(),
                    topOverflow = -scrollTop + offset.top - containerHeight,
                    bottomOverflow = scrollTop + viewPortHeight - (offset.top + height + containerHeight);

                orientation = (Math.max(topOverflow, bottomOverflow) === topOverflow) ? 'top' : 'bottom';
            }

            if (orientation === 'top') {
                styles.top += -containerHeight;
            } else {
                styles.top += height;
            }

            // If container is not positioned to body,
            // correct its position using offset parent offset
            if(containerParent !== document.body) {
                var opacity = $container.css('opacity'),
                    parentOffsetDiff;

                    if (!that.visible){
                        $container.css('opacity', 0).show();
                    }

                parentOffsetDiff = $container.offsetParent().offset();
                styles.top -= parentOffsetDiff.top;
                styles.left -= parentOffsetDiff.left;

                if (!that.visible){
                    $container.css('opacity', opacity).hide();
                }
            }

            // -2px to account for suggestions border.
            if (that.options.width === 'auto') {
                styles.width = (that.el.outerWidth() - 2) + 'px';
            }

            $container.css(styles);
        },

        enableKillerFn: function () {
            var that = this;
            $(document).on('click.autocomplete', that.killerFn);
        },

        disableKillerFn: function () {
            var that = this;
            $(document).off('click.autocomplete', that.killerFn);
        },

        killSuggestions: function () {
            var that = this;
            that.stopKillSuggestions();
            that.intervalId = window.setInterval(function () {
                if (that.visible) {
                    that.el.val(that.currentValue);
                    that.hide();
                }
                
                that.stopKillSuggestions();
            }, 50);
        },

        stopKillSuggestions: function () {
            window.clearInterval(this.intervalId);
        },

        isCursorAtEnd: function () {
            var that = this,
                valLength = that.el.val().length,
                selectionStart = that.element.selectionStart,
                range;

            if (typeof selectionStart === 'number') {
                return selectionStart === valLength;
            }
            if (document.selection) {
                range = document.selection.createRange();
                range.moveStart('character', -valLength);
                return valLength === range.text.length;
            }
            return true;
        },

        onKeyPress: function (e) {
            var that = this;

            // If suggestions are hidden and user presses arrow down, display suggestions:
            if (!that.disabled && !that.visible && e.which === keys.DOWN && that.currentValue) {
                that.suggest();
                return;
            }

            if (that.disabled || !that.visible) {
                return;
            }

            switch (e.which) {
                case keys.ESC:
                    that.el.val(that.currentValue);
                    that.hide();
                    break;
                case keys.RIGHT:
                    if (that.hint && that.options.onHint && that.isCursorAtEnd()) {
                        that.selectHint();
                        break;
                    }
                    return;
                case keys.TAB:
                    if (that.hint && that.options.onHint) {
                        that.selectHint();
                        return;
                    }
                    if (that.suggestions.length > 0 && that.currentValue.length >= that.options.minChars && that.selectedIndex === -1 && that.currentValue.length > 0) {
                        that.selectedIndex = 0;
                    }
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    if (that.options.tabDisabled === false) {
                        return;
                    }
                    break;
                case keys.RETURN:
                    if (that.selectedIndex === -1) {
                        that.hide();
                        return;
                    }
                    that.select(that.selectedIndex);
                    break;
                case keys.UP:
                    that.moveUp();
                    break;
                case keys.DOWN:
                    that.moveDown();
                    break;
                default:
                    return;
            }

            // Cancel event if function did not return:
            e.stopImmediatePropagation();
            e.preventDefault();
        },

        onKeyUp: function (e) {
            var that = this;

            if (that.disabled) {
                return;
            }

            switch (e.which) {
                case keys.UP:
                case keys.DOWN:
                    return;
            }

            clearInterval(that.onChangeInterval);

            if (that.currentValue !== that.el.val()) {
                that.findBestHint();
                if (that.options.deferRequestBy > 0) {
                    // Defer lookup in case when value changes very quickly:
                    that.onChangeInterval = setInterval(function () {
                        that.onValueChange();
                    }, that.options.deferRequestBy);
                } else {
                    that.onValueChange();
                }
            }
        },

        onValueChange: function () {
            var that = this,
                options = that.options,
                value = that.el.val(),
                query = that.getQuery(value);

            if (that.selection && that.currentValue !== query) {
                that.selection = null;
                (options.onInvalidateSelection || $.noop).call(that.element);
            }

            clearInterval(that.onChangeInterval);
            that.currentValue = value;
            that.selectedIndex = -1;

            // Check existing suggestion for the match before proceeding:
            if (options.triggerSelectOnValidInput && that.isExactMatch(query)) {
                that.select(0);
                return;
            }

            if (query.length < options.minChars) {
                //Suggestion will not hide 
                if (!(that.options.showLookup || that.options.addnew))
                    that.hide();
            } else {
                that.getSuggestions(query);
            }
        },

        isExactMatch: function (query) {
            return false;
        },

        getQuery: function (value) {
            var delimiter = this.options.delimiter,
                parts;

            if (!delimiter) {
                return value;
            }
            parts = value.split(delimiter);
            return $.trim(parts[parts.length - 1]);
        },

        getSuggestionsLocal: function (query) {
            var that = this,
                options = that.options,
                queryLowerCase = query.toLowerCase(),
                filter = options.lookupFilter,
                limit = parseInt(options.lookupLimit, 10),
                data;

            data = {
                suggestions: $.grep(options.lookup, function (suggestion) {
                    //  If suggestion is set to filterable false, it will not get filtered
                    if ((suggestion.filterable != null || suggestion.filterable != undefined) && suggestion.filterable === false) {
                        return true;
                    }
                    return filter(suggestion, query, queryLowerCase);
                })
            };
            
            if (limit && data.suggestions.length > limit) {
                data.suggestions = data.suggestions.slice(0, limit);
            }

            return data;
        },

        getSuggestions: function (q) {
            var response,
                that = this,
                options = that.options,
                serviceUrl = options.serviceUrl,
                params,
                cacheKey,
                ajaxSettings;

            options.params[options.paramName] = q;
            params = options.ignoreParams ? null : options.params;

            if (options.onSearchStart.call(that.element, options.params) === false) {
                return;
            }

            if ($.isFunction(options.lookup)){
                options.lookup(q, function (data) {
                    that.suggestions = data.suggestions;
                    that.suggest();
                    options.onSearchComplete.call(that.element, q, data.suggestions);
                });
                return;
            }

            if (that.isLocal) {
                response = that.getSuggestionsLocal(q);
            } else {
                if ($.isFunction(serviceUrl)) {
                    serviceUrl = serviceUrl.call(that.element, q);
                }
                cacheKey = serviceUrl + '?' + $.param(params || {});
                response = that.cachedResponse[cacheKey];
            }

            if (response && $.isArray(response.suggestions)) {
                that.suggestions = response.suggestions;
                that.suggest();
                options.onSearchComplete.call(that.element, q, response.suggestions);
            } else if (!that.isBadQuery(q)) {
                that.abortAjax();

                ajaxSettings = {
                    url: serviceUrl,
                    data: params,
                    type: options.type,
                    dataType: options.dataType
                };

                $.extend(ajaxSettings, options.ajaxSettings);

                that.currentRequest = $.ajax(ajaxSettings).done(function (data) {
                    var result;
                    that.currentRequest = null;
                    result = options.transformResult(data, q);
                    that.processResponse(result, q, cacheKey);
                    options.onSearchComplete.call(that.element, q, result.suggestions);
                }).fail(function (jqXHR, textStatus, errorThrown) {
                    options.onSearchError.call(that.element, q, jqXHR, textStatus, errorThrown);
                });
            } else {
                options.onSearchComplete.call(that.element, q, []);
            }
        },

        isBadQuery: function (q) {
            if (!this.options.preventBadQueries){
                return false;
            }

            var badQueries = this.badQueries,
                i = badQueries.length;

            while (i--) {
                if (q.indexOf(badQueries[i]) === 0) {
                    return true;
                }
            }

            return false;
        },

        hide: function () {
            var that = this,
                container = $(that.suggestionsContainer);

            if ($.isFunction(that.options.onHide) && that.visible) {
                that.options.onHide.call(that.element, container);
            }

            that.visible = false;
                that.selectedIndex = -1;
                clearInterval(that.onChangeInterval);
                $(that.suggestionsContainer).hide();
            that.signalHint(null);
        },

        suggest: function () {
            //Skip condition when showlookup and addNew flag true
            if (!(this.options.showLookup || this.options.addnew)) {
                if (this.suggestions.length === 0) {
                    if (this.options.showNoSuggestionNotice) {
                        this.noSuggestions();
                    } else {
                        this.hide();
                    }
                    return;
                }
            }

            var that = this,
                options = that.options,
                groupBy = options.groupBy,
                formatResult = options.formatResult,
                value = that.getQuery(that.currentValue),
                className = that.classes.suggestion,
                classSelected = that.classes.selected,
                container = $(that.suggestionsContainer),
                noSuggestionsContainer = $(that.noSuggestionsContainer),
                beforeRender = options.beforeRender,
                html = '',
                category,
                formatGroup = function (suggestion, index) {
                        var currentCategory = suggestion.data[groupBy];

                        if (category === currentCategory){
                            return '';
                        }

                        category = currentCategory;

                        return '<div class="autocomplete-group"><strong>' + category + '</strong></div>';
                    };

            if (options.triggerSelectOnValidInput && that.isExactMatch(value)) {
                that.select(0);
                return;
            }


            var formattedResult, formattedTitle;

            //Loader HTMLs
            var loaderHtmls = (that.options.loading && that.options.minChars <= that.currentValue.length) ? '<div class="autocomplete-suggestion center">\
                    <div class="preloader-wrapper x-small field-suffix-loader active">\
                        <div class="spinner-layer spinner-blue-only">\
                            <div class="circle-clipper circle-clipper--x left">\
                                <div class="circle"></div>\
                            </div>\
                            <div class="gap-patch">\
                                <div class="circle"></div>\
                            </div>\
                            <div class="circle-clipper circle-clipper--x right">\
                                <div class="circle"></div>\
                            </div>\
                        </div>\
                    </div>\
                </div>':'';

            // Build suggestions inner HTML:
            var totalIndex = 0;
            var innerWrapMaxHeight = (that.options.addnew == true || that.options.showLookup == true) ? that.options.maxHeight - 40 : that.options.maxHeight - 2;
            html += "<div class='scroll-inner-wrapp' style='max-height:" + innerWrapMaxHeight + "px;'>";
            if (!that.options.loading) {
                $.each(that.suggestions, function (i, suggestion) {
                    if (groupBy) {
                        html += formatGroup(suggestion, value, i);
                    }
                    formattedResult = formatResult(suggestion, value, that.optionFormat);
                    try {
                        formattedTitle = escape(formattedResult);
                        formattedTitle = unescape(formattedTitle.replace(/%28/g, 'openingroundbracket').replace(/%29/g, 'closingroundbracket'));
                        //formattedTitle = $(formattedTitle).text() ? $(formattedTitle).text() : formattedTitle;
                        formattedTitle = formattedTitle.replace(/<("[^"]*"|'[^']*'|[^'">])*>/g, '');
                    }
                    catch (e) { }
                    formattedTitle = formattedTitle.replace(/openingroundbracket/g, '(').replace(/closingroundbracket/g, ')');
                    html += '<div class="' + className + '" data-index="' + i + '" title="' + unescape(formattedTitle) + '">' + formattedResult + '</div>';
                    totalIndex = i + 1;
                });
            } else {
                html += loaderHtmls;
            }
            html += "</div>";

            var noSuggestionsMessage = (that.suggestions.length < 1 && that.options.showNoSuggestionNotice && that.options.minChars <= that.currentValue.length) ? $('<i></i>').append(that.noSuggestionsContainer).html() : '';
            if (that.options.addnew == true && that.options.showLookup == true) {
                html += (that.options.loading) ? '' : noSuggestionsMessage;
                html += '<div class="typeaHeade-add-new blue-text autocomplete-suggestion-half ' + className + '" data-index="' + totalIndex + '" title="' + that.options.addNewKey + '"><i class="icon icon-fix-overlay iconSmall" smart-tooltip position="bottom" delay="50" message="' + that.options.addNewKey + '"><svg><use xlink:href="#icon_CirclePlus"></use></svg></i></div>';
                html += '<div class="typeaHeade-open-lookup autocomplete-suggestion-half ' + className + '" data-index="' + ++totalIndex + '"><a href="javascript:void(0)" class="waves-effect waves-light">' + that.options.showLookupKey + '</a></div>';
            } else {
                if (that.options.addnew == true) {
                    html += (that.options.loading) ? '' : noSuggestionsMessage;
                    html += '<div class="typeaHeade-add-new width-adj-to blue-text ' + className + '" data-index="' + totalIndex + '" title="' + that.options.addNewKey + '"><i class="icon icon-fix-overlay iconSmall" smart-tooltip position="bottom" delay="50" message="' + that.options.addNewKey + '"><svg><use xlink:href="#icon_CirclePlus"></use></svg></i></div>';
            	}
                if (that.options.showLookup == true) {
                    html += (that.options.loading) ? '' : noSuggestionsMessage;
                    html += '<div class="typeaHeade-open-lookup width-adj-to ' + className + '" data-index="' + ++totalIndex + '"><a href="javascript:void(0)" class="waves-effect waves-light">' + that.options.showLookupKey + '</a></div>';
            	}
            }
            
            this.adjustContainerWidth();

            noSuggestionsContainer.detach();
            container.html(html);

            if ($.isFunction(beforeRender)) {
                beforeRender.call(that.element, container);
            }

            that.fixPosition();
            container.show();

            // Select first value by default:
            if (options.autoSelectFirst) {
                that.selectedIndex = 0;
                container.scrollTop(0);
                container.children('.' + className).first().addClass(classSelected);
            }

            that.visible = true;
            that.findBestHint();
        },

        noSuggestions: function() {
             var that = this,
                 container = $(that.suggestionsContainer),
                 noSuggestionsContainer = $(that.noSuggestionsContainer);

            this.adjustContainerWidth();

            // Some explicit steps. Be careful here as it easy to get
            // noSuggestionsContainer removed from DOM if not detached properly.
            noSuggestionsContainer.detach();
            container.empty(); // clean suggestions if any
            container.append(noSuggestionsContainer);

            that.fixPosition();

            container.show();
            that.visible = true;
        },

        adjustContainerWidth: function() {
            var that = this,
                options = that.options,
                width,
                container = $(that.suggestionsContainer);

            // If width is auto, adjust width before displaying suggestions,
            // because if instance was created before input had width, it will be zero.
            // Also it adjusts if input width has changed.
            // -2px to account for suggestions border.
            if (options.width === 'auto') {
                width = that.el.outerWidth() - 2;
                container.width(width > 0 ? width : 300);
            }
        },

        findBestHint: function () {
            var that = this,
                value = that.el.val().toLowerCase(),
                bestMatch = null;

            if (!value) {
                return;
            }

            $.each(that.suggestions, function (i, suggestion) {
                var str = suggestion.optionFormat ? suggestion.optionFormat : that.optionFormat;
                str = getCompiledOption(str, suggestion);
                var foundMatch = str.toLowerCase().indexOf(value) === 0;
                if (foundMatch) {
                    bestMatch = suggestion;
                }
                return !foundMatch;
            });

            that.signalHint(bestMatch);
        },

        signalHint: function (suggestion) {
            var hintValue = '',
                that = this;
            if (suggestion) {
                var str = suggestion.optionFormat ? suggestion.optionFormat : that.optionFormat;
                str = getCompiledOption(str, suggestion);
                hintValue = that.currentValue + str.substr(that.currentValue.length);
            }
            if (that.hintValue !== hintValue) {
                that.hintValue = hintValue;
                that.hint = suggestion;
                (this.options.onHint || $.noop)(hintValue);
            }
        },

        verifySuggestionsFormat: function (suggestions) {
            // If suggestions is string array, convert them to supported format:
            if (suggestions.length && typeof suggestions[0] === 'string') {
                return $.map(suggestions, function (value) {
                    return { value: value, data: null };
                });
            }

            return suggestions;
        },

        validateOrientation: function(orientation, fallback) {
            orientation = $.trim(orientation || '').toLowerCase();

            if($.inArray(orientation, ['auto', 'bottom', 'top']) === -1){
                orientation = fallback;
            }

            return orientation;
        },

        processResponse: function (result, originalQuery, cacheKey) {
            var that = this,
                options = that.options;

            result.suggestions = that.verifySuggestionsFormat(result.suggestions);

            // Cache results if cache is not disabled:
            if (!options.noCache) {
                that.cachedResponse[cacheKey] = result;
                if (options.preventBadQueries && result.suggestions.length === 0) {
                    that.badQueries.push(originalQuery);
                }
            }

            // Return if originalQuery is not matching current query:
            if (originalQuery !== that.getQuery(that.currentValue)) {
                return;
            }

            that.suggestions = result.suggestions;
            that.suggest();
        },

        activate: function (index) {
            var that = this,
                activeItem,
                selected = that.classes.selected,
                container = $(that.suggestionsContainer),
                children = container.find('.' + that.classes.suggestion);

            container.find('.' + selected).removeClass(selected);

            that.selectedIndex = index;

            if (that.selectedIndex !== -1 && children.length > that.selectedIndex) {
                activeItem = children.get(that.selectedIndex);
                $(activeItem).addClass(selected);
                return activeItem;
            }

            return null;
        },

        selectHint: function () {
            var that = this,
                i = $.inArray(that.hint, that.suggestions);

            that.select(i);
        },

        select: function (i) {
            var that = this;
            if(!that.options.multiselect) //prevent hiding suggetions for multiselect
                that.hide();
            that.onSelect(i);
        },

        moveUp: function () {
            var that = this;

            if (that.selectedIndex === -1) {
                return;
            }

            if (that.selectedIndex === 0) {
                $(that.suggestionsContainer).children().first().removeClass(that.classes.selected);
                that.selectedIndex = -1;
                that.el.val(that.currentValue);
                that.findBestHint();
                return;
            }

            that.adjustScroll(that.selectedIndex - 1);
        },

        moveDown: function () {
            var that = this;

            if (that.selectedIndex === (that.suggestions.length - 1)) {
                return;
            }

            that.adjustScroll(that.selectedIndex + 1);
        },

        adjustScroll: function (index) {
            var that = this,
                activeItem = that.activate(index);

            if (!activeItem) {
                return;
            }

            var offsetTop,
                upperBound,
                lowerBound,
                heightDelta = $(activeItem).outerHeight();

            offsetTop = activeItem.offsetTop;
            upperBound = $(that.suggestionsContainer).children('.scroll-inner-wrapp').scrollTop();
            lowerBound = upperBound + that.options.maxHeight - heightDelta;

            if (offsetTop < upperBound) {
                $(that.suggestionsContainer).children('.scroll-inner-wrapp').scrollTop(offsetTop);
            } else if (offsetTop > lowerBound) {
                $(that.suggestionsContainer).children('.scroll-inner-wrapp').scrollTop(offsetTop - that.options.maxHeight + heightDelta);
            }

            if (!that.options.preserveInput) {
                that.el.val(that.getValue(that.suggestions[index].value));
            }
            that.signalHint(null);
        },

        onSelect: function (index) {
            var that = this;
            //Added new callback for show lookup and Add New
            var getTotalSuggested = that.suggestions.length;
            if (index > getTotalSuggested && that.options.showLookup == true) {
                that.hide();
                if ($.isFunction(that.options.onClickShowLookup)) {
                    that.options.onClickShowLookup.call(that.element, "ShowLookup");
                    return;
                }
            }
            if (index == getTotalSuggested && that.options.addnew == true) {
                that.hide();
                if ($.isFunction(that.options.onClickAddNew)) {
                    that.options.onClickAddNew.call(that.element, "AddNEW");
                    return;
                }
            }
            var onSelectCallback = that.options.onSelect,
                suggestion = that.suggestions[index];

            that.currentValue = suggestion.value ? that.getValue(suggestion.value) : that.getValue(suggestion[that.options.displayFormat.slice(1, that.options.displayFormat.length - 1)]);

            if (that.currentValue !== that.el.val() && !that.options.preserveInput) {
                that.el.val(that.currentValue);
            }

            that.signalHint(null);
            that.suggestions = [];
            that.selection = suggestion;

            if ($.isFunction(onSelectCallback)) {
                onSelectCallback.call(that.element, suggestion);
            }
        },

        getValue: function (value) {
            var that = this,
                delimiter = that.options.delimiter,
                currentValue,
                parts;

            if (!delimiter) {
                return value;
            }

            currentValue = that.currentValue;
            parts = currentValue.split(delimiter);

            if (parts.length === 1) {
                return value;
            }

            return currentValue.substr(0, currentValue.length - parts[parts.length - 1].length) + value;
        },

        dispose: function () {
            var that = this;
            that.el.off('.autocomplete').removeData('autocomplete');
            that.disableKillerFn();
            $(window).off('resize.autocomplete', that.fixPositionCapture);
            $(that.suggestionsContainer).remove();
        }
    };

    // Create chainable jQuery plugin:
    $.fn.autocomplete = $.fn.devbridgeAutocomplete = function (options, args) {
        var dataKey = 'autocomplete';
        // If function invoked without argument return
        // instance of the first matched element:
        if (arguments.length === 0) {
            return this.first().data(dataKey);
        }

        return this.each(function () {
            var inputElement = $(this),
                instance = inputElement.data(dataKey);

            if (typeof options === 'string') {
                if (instance && typeof instance[options] === 'function') {
                    instance[options](args);
                }
            } else {
                // If instance already exists, destroy it:
                if (instance && instance.dispose) {
                    instance.dispose();
                }
                instance = new Autocomplete(this, options);
                inputElement.data(dataKey, instance);
            }
        });
    };
    $(document).on('click', function (e) {
        if ($('.autocomplete-suggestions').is(':visible')) {
            $('.autocomplete-suggestions').hide();
        }
    });
}));
(function () {
    'use strict';
    var smartTimeLineID = 0;
    angular.module('SMART2').directive('smartTimeline', ['$rootScope', '$timeout', '$translate', 'ScrollTo', 'lookup', 'APPCONSTANTS', function ($rootScope, $timeout, $translate, ScrollTo, lookup, APPCONSTANTS) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                label: '@',
                ngModel: '=?',
                readonly: '@',
                dateFormat: '@',
                selectable: '@',
                showCurrentTime: '@',
                zoomMin: '@',
                zoomMax: '@',
                marginSpace: '@',
                onSelect: '&',
                onLoad: '&',
                groupOrder: '&'
            },
            link: function (scope, element, attrs) {
                var cultureCode = APPCONSTANTS.userPreferences.UserBasicDetails.Culture;
                var readonly = (scope.readonly == null || scope.readonly == "undefined") ? false : (scope.readonly == 'true') ? true : false;
                var selectable = (scope.selectable == null || scope.selectable == "undefined") ? true : (scope.selectable == 'true') ? true : false;
                var showCurrentTime = (angular.isDefined(scope.showCurrentTime)) ? (scope.showCurrentTime == 'true') ? true : false : true;
                scope.ngModel = scope.ngModel ? scope.ngModel : null;
                var defaultMin = 1000 * 60 * 60 * 24, defaultMax = 1000 * 60 * 60 * 24 * 31 * 3;
                var zoomMin = angular.isDefined(scope.zoomMin) ? (scope.zoomMin != "") ? parseInt(scope.zoomMin) : defaultMin : defaultMin; // Default 1Day
                var zoomMax = angular.isDefined(scope.zoomMax) ? (scope.zoomMax != "") ? parseInt(scope.zoomMax) : defaultMax : defaultMax;  // Default 3Month
                var marginSpace = (scope.marginSpace == null || scope.marginSpace == "undefined") ? 20 : parseInt(scope.marginSpace, 10);
                var timeline = null;
                var groupOrderFunc = function (a, b) {
                    if (angular.isDefined(attrs.groupOrder)) {
                        return scope.groupOrder({ $a: a, $b: b });
                    } else {
                        if (angular.isDefined(scope.ngModel[a.id]) && angular.isDefined(scope.ngModel[b.id])) {
                            return scope.ngModel[a.id].lines[0].start - scope.ngModel[b.id].lines[0].start;
                        }
                    }
                };
                scope.timelineID = "TimeLineId-" + smartTimeLineID;
                smartTimeLineID++;
                function isTodayInBetween(s, e) {
                    s = parseInt(s);
                    e = parseInt(e);
                    var d = new Date();
                    var c = d.getTime();
                    if (s < c && c < e) { // running 
                        return 0;
                    }
                    if (e < c) { // ended
                        return -1;
                    }
                    if (c < s) { // not started
                        return 1;
                    }
                }
                function getAngularDateFormat(format) {
                    return format.replace(/d/g, 'D').replace(/y/g, 'Y').replace(/E/g, 'd');
                }
                scope.$watch("ngModel", function (newVal) {
                    scope.ngModel = newVal;
                    //var dateFormat = scope.dateFormat ? scope.dateFormat : 'dd/MM/yyyy';
                    scope.getCultureCode = function (culturecode) {
                        switch (culturecode) {
                            case 'en-US':
                                return 'MM/dd/yyyy hh:mm a';
                                break;
                            case 'zh-CN':
                                return 'yyyy-MM-dd hh:mm a';
                                break;
                            case 'zh-CHT':
                                return 'yyyy-MM-dd hh:mm a';
                                break;
                            case 'da-DK':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'de-DE':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'en-AU':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'es-ES':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'fr-FR':
                                return 'yyyy/MM/dd hh:mm a';
                                break;
                            case 'it-IT':
                                return 'yyyy/MM/dd hh:mm a';
                                break;
                            case 'ja-JP':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'ko-KR':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'nl-NL':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'pl-PL':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'pt-PT':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'ru-RU':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'sv-SE ':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            case 'th-TH ':
                                return 'dd/MM/yyyy hh:mm a';
                                break;
                            default:
                                return 'dd/MM/yyyy hh:mm a';
                        }
                    };

                    var dateFormat = scope.getCultureCode(cultureCode) ? scope.getCultureCode(cultureCode) : 'dd/MM/yyyy hh:mm a';
                    dateFormat = getAngularDateFormat(dateFormat);
                    var groups = [];
                    var items = [];
                    var groupItemPeer = [];
                    function formateData() {
                        moment.locale(cultureCode);
                        groups = [];
                        items = [];
                        var k = 0;
                        for (var i = 0; i < scope.ngModel.length; i++) {
                            groups.push({
                                id: i,
                                content: scope.ngModel[i].title,
                                className: (typeof scope.ngModel[i].className === 'undefined') ? "" : scope.ngModel[i].className,
                                style: (typeof scope.ngModel[i].style === 'undefined') ? "" : scope.ngModel[i].style
                            });

                            for (var j = 0; j < scope.ngModel[i].lines.length; j++) {
                                var obj = {
                                    id: k,
                                    group: i
                                }
                                groupItemPeer[k] = j;
                                var flagS = false, flagE = false;
                                var classNamee = "vis-timeline-cstyle-" + (i % 10);
                                if (scope.ngModel[i].lines[j].start != null && scope.ngModel[i].lines[j].start != "" && typeof scope.ngModel[i].lines[j].start != "undefined") {
                                    obj.start = new Date(scope.ngModel[i].lines[j].start * 1);
                                    obj.startFormated = moment.unix(scope.ngModel[i].lines[j].start / 1000).format(dateFormat);
                                    flagS = true;
                                }
                                if (scope.ngModel[i].lines[j].end != null && scope.ngModel[i].lines[j].end != "" && typeof scope.ngModel[i].lines[j].end != "undefined") {
                                    obj.end = new Date(scope.ngModel[i].lines[j].end * 1);
                                    obj.endFormated = moment.unix(scope.ngModel[i].lines[j].end / 1000).format(dateFormat);
                                    flagE = true;
                                }
                                if (flagS && flagE) {
                                    var respo = isTodayInBetween(obj.start.getTime(), obj.end.getTime());
                                    if (respo == -1) {
                                        classNamee = classNamee + " line-ended";
                                    }
                                    if (respo == 1) {
                                        classNamee = classNamee + " line-not-started";
                                    }
                                }
                                var passedClassName = (typeof scope.ngModel[i].lines[j].className === 'undefined') ? "" : scope.ngModel[i].lines[j].className;
                                classNamee = classNamee + " " + passedClassName;
                                obj.className = classNamee;
                                var barStyle = (typeof scope.ngModel[i].lines[j].style === 'undefined') ? "" : scope.ngModel[i].lines[j].style;
                                obj.style = barStyle;
                                if (typeof scope.ngModel[i].lines[j].content === 'undefined') {
                                    obj.content = "<div class='padding5' smart-tooltip title='" + obj.startFormated + " - " + obj.endFormated + "' position='top' delay='500' message= " + $translate.instant('tooltipMsg') + "></div>";
                                } else {
                                    obj.content = scope.ngModel[i].lines[j].content;
                                }
                                items.push(obj);
                                k++;
                            }
                        }
                    }
                    formateData();
                    $timeout(function () {
                        var groupSet = new vis.DataSet(groups);
                        var itemSet = new vis.DataSet(items);
                        var container = document.getElementById(scope.timelineID);
                        if (timeline == null) {
                            timeline = new vis.Timeline(container);
                            container.addEventListener("touchmove", function (e) {
                                // to avoid original touch device (iPad, tablet) effects like pinch to zoom in/out. 
                                e.preventDefault();
                            });
                        }
                        timeline.setGroups(groupSet);
                        timeline.setItems(itemSet);
                        var options = {
                            editable: readonly,
                            groupOrder: groupOrderFunc,
                            selectable: selectable,
                            showCurrentTime: showCurrentTime,
                            zoomMin: zoomMin,
                            zoomMax: zoomMax,
                            margin: { item: marginSpace },
                            locales: {},
                            locale: cultureCode,
                            format: {
                            	minorLabels: {
                            		millisecond: 'SSS',
                            		second: 's',
                            		minute: 'hh:mm a',
                            		hour: 'hh:mm a',
                            		weekday: 'ddd D',
                            		day: 'D',
                            		month: 'MMM',
                            		year: 'YYYY'
                            	},
                            	majorLabels: {
                            		millisecond: 'hh:mm:ss a',
                            		second: 'D MMMM hh:mm a',
                            		minute: 'ddd D MMMM',
                            		hour: 'ddd D MMMM',
                            		weekday: 'MMMM YYYY',
                            		day: 'MMMM YYYY',
                            		month: 'YYYY',
                            		year: ''
                            	}
                            }
                        };
                        options.locales[cultureCode] = {
                            current: $translate.instant('labelCurrent'),
                            time: $translate.instant('labelTime')
                        };
                        timeline.setOptions(options);
                        if (attrs.fittobound === 'true') {
                            timeline.fit(options);
                        }
                        $timeout(function () {
                            if (angular.isFunction(scope.onLoad)) {
                                scope.onLoad();
                            }
                        }, 2000);
                        $(timeline.currentTime.bar).append('<span class="timelineLabelToday">' + $translate.instant('timelineLabelToday') + '</span>');
                        timeline.on('select', function (obj) {
                            var props = timeline.getEventProperties(obj.event);
                            var groupObj = (props.group != null) ? scope.ngModel[props.group] : null;
                            var itemObj = (props.item != null) ? scope.ngModel[props.group].lines[groupItemPeer[props.item]] : null;
                            var returnObj = {
                                item: itemObj,
                                group: groupObj,
                                properties: props
                            }

                            if (angular.isFunction(scope.onSelect)) {
                                scope.onSelect({
                                    $res: returnObj
                                });
                            }
                        });
                    });
                }, true);
            },
            templateUrl: 'shared/directives/uiElements/smartTimeline/smartTimelineTemplate.html'
        };
    }]);
})();
  /**
   * @memberof SMART2
   * @ngdoc directive
   * @name Tooltip
   * @description This directive is useful for creating a tooltip.
   * 
   * @attr {String} position
   *    Tooltip position. Possible values are left, right, top, bottom. Default value is 'left'.
   * @attr {Number} delay
   *    Tooltip delay. Default value is '250'.
   * @attr {String} tooltip
   *    Tooltip message
   * 
   * @example
   Usage:
   <span smart-tooltip position="top" delay="500" message="Tooltip message"></span>
   */

(function () {
    'use strict';
    angular.module('SMART2').directive('smartTooltip', [function () {
        return {
            restrict: 'A',
            replace: true,
            scope: {
                customStyle: "="
            },
            link: function (scope, element, attrs) {
                var onMessage = attrs.$observe('message', function (value) {
                    element.attr('data-tooltip', value);
                });
                element.attr('data-position', attrs.position ? attrs.position : 'left');
                element.attr('data-delay', attrs.delay ? attrs.delay : '50');
                element.attr('data-tooltip', attrs.message ? attrs.message : '');
                element.addClass('tooltipped');
                if (typeof scope.customStyle != "undefined") {
                    var optionsObject = {
                        "customStyle": scope.customStyle
                    };
                }
                element.tooltip(optionsObject);
                element.on('click', function () {
                    element.trigger('mouseleave');
                });
                //  Destroy tooltip on scope destroy
                scope.$on('$destroy', function () {
                    element.tooltip('remove');
                    onMessage();
                });
            }
        };
    }]);
})();
/**
 * @memberof SMART2
 * @ngdoc directive
 * @name Typeahead
 * @description This directive is used for creating a typeahead component ie Type and search plus select.
 * 
 * @attr {String} label
 *    Label to be displayed for identification of this ui element
 * @attr {String} placeholder
 *    Hint text to be displayed
 * @attr {String} info-icon
 *    To show a custom icon
 * @attr {Array} ng-model
 *    Default values to be displayed (Note: Pass array only if multiselect is set to true. Else pass an object.)
 *  @attr {Array} options
 *    Values to be shown in suggestions
 * @attr {Boolean} multiselect
 *    To allow/disallow multiple selections
 * @attr {Boolean} addnew
 *    To allow add new option
 * @attr {Boolean} show-lookup
 *    To make autocomplete plus lookup available
 * @attr {Boolean} focus 
 *    If set to true, this ui element will be focused
 * @attr {Boolean} validate
 *    If set to true, this ui element will be validated on the basis of rules passed to it
 * @attr {Array} rules 
 *    Rules to be evaluated when this element's blur event is fired. A rule must have 'rule' and 'errorMessage' properties (keys).
 *    'rule' must be a condition or group of conditions. 'errorMessage' will be the message to be displayed when corresponding rule fails. See example for more.
 * @attr {String} error-message 
 *    Error message to be displayed. This attribute can be set at any point to display an error message.
 * @attr {Boolean} is-mandatory 
 *    If set to true, default error message will be displayed when blur event is fired and this ui element is left blank
 * @attr {Boolean} disable 
 *    If set to true, field cannot be edited. Blur and focus events will not be fired (default behaviour).
 * @attr {Function} on-focus
 *    Callback function when ui element's focus event is fired
 * @attr {Function} on-blur
 *    Callback function when ui element's blur event is fired
 * @attr {Function} on-key-up
 *    Callback function when ui element's keyup event is fired
 * @attr {Function} on-key-down
 *    Callback function when ui element's keydown event is fired
 * @attr {Function} on-key-press
 *    Callback function when ui element's keypress event is fired
 * @attr {Function} on-select
 *    Callback function when a value is selected 
 * @attr {Function} callback-on-iconclick
 *    Callback function for icon on the right side
 * @attr {Function} call-addnew
 *    Callback function for add new icon
 * 
 *    
 * @example
 Static:
 Controller:
      $scope.options = [
		{
			"UserId": 28360,
			"UserName": "SRUser1@outlook.com",                  
			"FirstName": "SR",                  
			"LastName": "User1"
		}, {                 
			"UserId": 28977,                  
			"UserName": "SRUser1@outlook.com11",
			"FirstName": "Test",
			"LastName": "TestLastName"    
		}, {                  
			"UserId": 57900,                  
			"UserName": "SRUser1@outlook.com234",                  
			"FirstName": "Test23",                  
			"LastName": "test23lastname"                 
		}
	]; 
	$scope.selected = [{            
		"UserId": 28360,               
		"UserName": "SRUser1@outlook.com",               
		"FirstName": "SR",               
		"LastName": "User1"              
	}];  
 Usage:
      <smart-typeahead class="col s2" multiselect="true" addnew="true" showlookup="true" placeholder="Place Holder" ng-model="selected" options="options" filterkeys="['FirstName', 'LastName']" optionformat="<span>{FirstName} {LastName}</span>" displayformat="{FirstName} {LastName}" label="{{typeaheadLabel}}" callback-on-iconclick="callAfterClickedOnRightSideIcon(e)" info-icon="#icon_CirclePlus" call-addnew="callAfterAddNewFuncClick(e)"></smart-typeahead>       
 */
(function () {
    'use strict';
    var typeaheadId = 0;
    angular.module('SMART2').directive('smartTypeahead', ['$rootScope', '$timeout', '$translate', 'ScrollTo', 'lookup', 'RuleEngine', '$window', function ($rootScope, $timeout, $translate, ScrollTo, lookup, RuleEngine, $window) {
        return {
            restrict: 'E',
            replace: true,
            require: 'ngModel',
            scope: {
                label: '@',
                ngModel: '=?',
                options: '=?',
                isMandatory: '@',
                isVisible: '=?',
                rules: '@',
                validate: '=?',
                focus: '=?',
                parentElement: '@',
                onChange: '&',
                onFocus: '&',
                onBlur: '&',
                onKeyUp: '&',
                onKeyDown: '&',
                onKeyPress: '&',
                onEnter: '&',
                onSelect: '&',
                callbackOnIconClick: '&',
                callAddNew: '&',
                lookupOpen: '&',
                lookupHide: '&',
                onScrollEnd: '&',
                onScrollTop: '&',
                onScrollInProgress: '&',
                searchtextKeyUp: '&',
                errorMessage: '@',
                //  input element's attribute except for listeners should be in small letters
                align: '@',
                format: '@',    //  date format
                readonly: '@',
                disable: '@',
                prefixicon: '@',
                maxlength: '@',
                charactercounter: '@',
                decimalprecision: '@',
                minmaxprecision: '@',
                placeholder: '@',
                autocomplete: '@',
                removable: '@',
                datakey: '@',
                filterkeys: '@',
                optionformat: '@',
                displayformat: '@',
                desckey: '@',
                multiselect: '@',
                showLookup: '@',
                infoIcon: '@',
                infoIconTooltip: '@',
                addnew: '@',
                titleofmodel: '@',
                selecttypeoption: '=?',
                showInfoIcon: '=?',
                isSupplier: '=?',
                defaultselectoption: '@',
                defaultselectiontext: '=?',
                width: '@',
                height: '@',
                isDefaultMandatory: '@',
                minCharForTrigger: '@',
                noSuggestionNotice: '@',
                showNoSuggestion: '@',
                errorModel: '=?',
                loading: '=?',
                minMultiselect: '@',
                showinfo: '@',
                showwarning: '@',
                clienterror: '=?',
                isLazyLoadingEnabled: '@'
            },
            link: function (scope, element, attrs, ngModel) {
                scope.placeholder = (scope.placeholder == undefined || scope.placeholder == null) ? '' : scope.placeholder;
                scope.ngModel = (scope.ngModel == undefined || scope.ngModel == null) ? '' : scope.ngModel;
                scope.label = (scope.label == undefined || scope.label == null) ? '' : scope.label;
                scope.textAlign = (scope.align == undefined || scope.align == null) ? 'left' : scope.align;
                scope.infoIconFlag = (scope.infoIcon == undefined || scope.infoIcon == null) ? false : true;
                scope.titleofmodel = (scope.titleofmodel == undefined || scope.titleofmodel == null) ? $translate.instant('titleOfModel') : scope.titleofmodel;
                scope.infoIconTooltip = (scope.infoIconTooltip == undefined || scope.infoIconTooltip == null) ? '' : scope.infoIconTooltip;
                scope.isLazyLoadingEnabled = angular.isDefined(scope.isLazyLoadingEnabled) ? scope.isLazyLoadingEnabled : false;
                var multiselect = (scope.multiselect == undefined || scope.multiselect == null) ? false : scope.multiselect == "true" ? true : false;
                var minMultiselect = (scope.minMultiselect == undefined || scope.minMultiselect == null) ? { event: false } : { event: true, value: scope.minMultiselect };
                var showLookup = (scope.showLookup == undefined || scope.showLookup == null) ? true : scope.showLookup == "true" ? true : false;
                var addnew = (scope.addnew == undefined || scope.addnew == null) ? false : scope.addnew == "true" ? true : false;
                var readonly = (scope.readonly == undefined || scope.readonly == null) ? false : scope.readonly == "true" ? true : false;
                var minCharForTrigger = scope.minCharForTrigger ? parseInt(scope.minCharForTrigger) : 3;
                var noSuggestionNotice = angular.isDefined(scope.noSuggestionNotice) ? scope.noSuggestionNotice : $translate.instant('noResultsErrMsg');
                var showNoSuggestion = angular.isDefined(scope.showNoSuggestion) ? (scope.showNoSuggestion == 'true') ? true : false : false;
                var loading = angular.isDefined(scope.loading) ? scope.loading : false;
                if (noSuggestionNotice == '') {
                    showNoSuggestion = false;
                }
                //showNoSuggestion = (noSuggestionNotice == '') ? false : showNoSuggestion;
                var number, rulesValidationEvent;
                var showLookupKey = $translate.instant('showLookupLabel'),
                    addNewKey = $translate.instant('addNew');
                scope.disabled = "";
                scope.showInfoIcon = (scope.showInfoIcon == undefined || scope.showInfoIcon == null) ? false : scope.showInfoIcon;
                var isInfoTipEnable = attrs.showInfoTip == 'true' ? true : false,
                    checkInfoToolTip = function () {
                        if (isInfoTipEnable) {
                            scope.infotipData = scope.displayModel.replace(/,/g, '  ').trim().replace(/  /g, '<br>');
                        } else {
                            scope.infotipData = "";
                        }
                    };

                var selectedArr = [], newOptionsSelected = [], newArr = [], copyArray = [], selectedArrIndex;
                if (readonly) {
                    scope.disabled = "disabled";
                }
                var uniqueIDGenerator = function () {
                    var d = new Date().getTime();
                    var uniqueID = 'xx2xxpxxoxx'.replace(/[xy]/g, function (c) {
                        var r = (d + Math.random() * 16) % 16 | 0;
                        d = Math.floor(d / 16);
                        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                    });
                    return uniqueID;
                };

                function checkIfActive() {
                    if (scope.placeholder === '' && (scope.displayModel === '' || scope.displayModel === undefined || scope.displayModel === null)) {
                        return false;
                    }
                    return true;
                }
                scope.isActive = checkIfActive();
                if (attrs.id != undefined || attrs.id != null) {
                    scope.typeaheadId = attrs.id;
                    element.removeAttr('id');
                }
                else {
                    var typeaheadId = uniqueIDGenerator();
                    scope.typeaheadId = 'typeahead-' + typeaheadId;
                }
                scope.labelFortypeaheadId = 'label-for-' + scope.typeaheadId;

                /*
				* Skip tab key focus, if field is readonly
				*/
               var cancelMe =  setTimeout(function () {
                    if (readonly) {
                        angular.element('#' + scope.typeaheadId).attr('tabindex', -1);
                    }
                    clearTimeout(cancelMe);
                    cancelMe = null;
                });

                var unbindFocus = scope.$watch('focus', function (newVal, oldVal) {
                    if (newVal) {
                        ScrollTo.perform(element, angular.element('#' + scope.parentElement));
                        var clrTout = setTimeout(function () {
                            angular.element('#' + scope.labelFortypeaheadId).trigger('click');
                            clearTimeout(clrTout);
                            clrTout = null;
                        });
                        scope.focus = false;
                    }
                });

                var changeTimeout, keyUpTimeout, keyDownTimeout, keyPressTimeout;
                scope.ngChange = function (e) {
                    scope.isActive = checkIfActive();

                    if (changeTimeout) {
                        $timeout.cancel(changeTimeout);
                    }
                    changeTimeout = $timeout(function () {
                        scope.onChange({
                            $event: {
                                data: angular.element('#' + scope.typeaheadId)
                            }
                        });
                    }, 500);
                };
                scope.ngFocus = function (e) {
                    scope.isActive = true;
                    scope.onFocus({ $event: e });
                    autoCompleteField.suggestions.length = 0;
                };
                scope.ngBlur = function (e) {
                    var model = getModel();
                    setValues(model);

                    if (multiselect && model.length > 0) {
                        scope.multiselectFlag = true;
                    }

                    scope.isActive = checkIfActive();
                    scope.onBlur({ $event: e });
                    if (model == undefined || model == null || model == '' || Object.getOwnPropertyNames(model).length === 0) {
                        scope.showInfoIcon = false;
                    } else {
                        scope.showInfoIcon = true;
                    }

                    // Needed to add $timeout for not showing error message before show lookup open.
                    var tout = $timeout(function () {
                        if (!showLookupTrigger) {
                            scope.validateRules();
                        } else {
                            showLookupTrigger = false;
                        }
                        $timeout.cancel(tout);
                        tout = null;
                    }, 200);
                };
                var preventKeyArray = [37, 38, 39, 40];
                var showLookupTrigger = false;
                scope.ngKeyUp = function (e) {
                    if (multiselect && e.target.value == "") {
                        setModel([]);
                    }
                    if (!multiselect && e.target.value == "") {
                        setModel(null);
                    }
                    scope.showInfoIcon = false;
                    if (keyUpTimeout) {
                        $timeout.cancel(keyUpTimeout);
                    }
                    keyUpTimeout = $timeout(function () {
                        var key = 'which' in e ? e.which : e.keyCode;
                        if (!(preventKeyArray.indexOf(key) > -1)) {
                            scope.onKeyUp({ $event: e });
                        }
                    }, 500);
                    DuplicateData(scope.displayModel, e);
                };
                scope.ngKeyDown = function (e) {
                    scope.showInfoIcon = false;
                    if (keyDownTimeout) {
                        $timeout.cancel(keyDownTimeout);
                    }
                    keyDownTimeout = $timeout(function () {
                        var key = 'which' in e ? e.which : e.keyCode;
                        if (!(preventKeyArray.indexOf(key) > -1)) {
                            scope.onKeyDown({ $event: e });
                        }
                    }, 500);
                    var formattedData = getFormattedData(newOptionsSelected);
                    copyArray = angular.copy(formattedData).map(function (data) { return data.value.toLowerCase(); });
                    DuplicateData(scope.displayModel, e);
                };
                scope.ngKeyPress = function (e) {
                    if (keyPressTimeout) {
                        $timeout.cancel(keyPressTimeout);
                    }
                    keyPressTimeout = $timeout(function () {
                        var key = 'which' in e ? e.which : e.keyCode;
                        if (!(preventKeyArray.indexOf(key) > -1)) {
                            scope.onKeyPress({ $event: e });
                        }

                        if (e.charCode == 13) {
                            scope.onEnter({ $event: e });
                        }
                    }, 500);
                   DuplicateData(scope.displayModel, e);
                };

                scope.clickedOnIcon = function (e) {
                    scope.callbackOnIconClick({ $event: e });
                };

                scope.validateRules = function () {
                    var model = getModel();
                    if (scope.readonly == 'true') {
                        scope.isActive = true;
                        return;
                    }
                    if (scope.$eval(scope.isMandatory) && !scope.clienterror && (Object.keys(model).length == 0 || model == null || model == undefined || model == '' || model.id == 0)) {
                        scope.validate = true;
                        scope.errorMessage = $translate.instant("enterValueErrMsg");
                        scope.errorModel = $translate.instant("enterValueErrMsg");
                        return;
                    }
                    if (scope.clienterror) {
                        scope.validate = true;
                        scope.errorMessage = $translate.instant("clientErrMsg");
                        scope.errorModel = $translate.instant("clientErrMsg");

                        return;
                    }

                    scope.validate = false;
                    scope.errorMessage = null;
                    scope.errorModel = null;

                    if (scope.rules) {
                        var rules = scope.$eval(scope.rules);
                        var isFoundInvalid = false,
                            ruleLlen = rules.length;
                        for (var i = 0; i < ruleLlen; i++) {
                            var tRule = rules[i];
                            if (typeof tRule == 'object') {
                                if (eval((tRule.rule).replace(/this/g, 'scope.displayModel'))) {
                                    scope.validate = true;
                                    scope.errorMessage = tRule.error;
                                    scope.errorModel = tRule.error;
                                    break;
                                }
                            }
                            else {
                                if (!isFoundInvalid) {
                                    RuleEngine.isValid(tRule, function (e) {
                                        scope.validate = true;
                                        scope.errorMessage = $translate.instant(e.errorData.error);
                                        scope.errorModel = $translate.instant(e.errorData.error);
                                        isFoundInvalid = true;
                                    });
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                };

                var unbindValidate = scope.$watchGroup(['validate', 'clienterror', 'showinfo', 'showwarning'], function (newVal, oldVal) {
                    if (newVal[0] || newVal[1] != oldVal[1]) {
                        scope.validateRules();
                    }

                    if (newVal[2] != oldVal[2] || newVal[3] != oldVal[3]) {
                        if (scope.showinfo || scope.showwarning) {
                            element.hasClass('input-field').addClass('field-has-icon');
                        }
                        else {
                            element.hasClass('.input-field').removeClass('field-has-icon');
                        }
                    }
                });

                if (scope.clienterror) {
                    scope.validateRules();
                }

                function setModel(value, mode) {
                    value = !value ? (multiselect ? [] : {}) : value;
                    if (typeof scope.ngModel == "function") {
                        if (multiselect && mode == "autocomplete") {
                            var v = value;
                            value = ngModel.$modelValue;
                            value.push(v);
                        };
                        ngModel.$setViewValue(value);
                        ngModel.$render();
                        if (mode != "autocomplete") {
                            setValues(value);
                        };
                    } else {
                        if (multiselect && mode == "autocomplete") {
                            scope.ngModel.push(value)
                        } else if (multiselect === true) {
                            if (typeof scope.ngModel == "string") {
                                scope.ngModel = value;
                            } else {
                                if (scope.ngModel == value) {
                                    value = angular.copy(value);
                                }
                                scope.ngModel.length = 0;
                                [].push.apply(scope.ngModel, value);
                            };
                        } else {
                            scope.ngModel = value;
                        }
                        setValues(scope.ngModel);
                    }
                };

                function getModel() {
                    var model;
                    if (typeof scope.ngModel == "function") {
                        model = ngModel.$modelValue;
                    } else {
                        model = scope.ngModel;
                    }
                    return model;
                }

                function DuplicateData(editTest, event) {

                    var newArrLen = '';
                    if (editTest || event.keyCode == 188 || event.type == "keyup") {
                        var str_array = editTest.split(','),
                            strLen = str_array.length;
                        for (var i = 0; i < strLen; i++) {
                            str_array[i] = str_array[i].replace(/^\s*/, "").replace(/\s*$/, "");
                        }
                        angular.forEach(str_array, function (val) {
                            var indexabc = copyArray.indexOf(val.toLowerCase());
                            selectedArrIndex = newOptionsSelected.map(function (data) { return data.value.toLowerCase(); }).indexOf(val.toLowerCase());

                            if (selectedArrIndex != -1 && newArr.indexOf(val) == -1) {
                                selectedArr.push(selectedArrIndex);
                                var ab = newOptionsSelected.splice(selectedArrIndex, 1)[0];
                                newArr.push(ab);
                                ab._$index = indexabc;
                            }
                        });
                        if (event) {
                            if (event.keyCode == 8 || event.keyCode == 46 || editTest.length == 3) {
                            angular.forEach(str_array, function (val, v1, v2) {
                                var isPresent = newArr.map(function (data) { return data.value; }).indexOf(val);
                                if (isPresent == -1) {
                                    newArrLen = newArr.length;
                                    for (var i = 0 ; i < newArrLen; i++) {
                                        var tNewArr = newArr[i];
                                        if (newOptionsSelected.indexOf(tNewArr) == -1 && v2.indexOf(tNewArr.value) == -1) {
                                            newOptionsSelected.splice(tNewArr._$index, 0, tNewArr);
                                            newArr.splice(i, 1);
                                        }
                                    }
                                }
                            });
                        }
                        }
                    }
                    else {
                        newArrLen = newArr.length;
                        for (var i = 0 ; i < newArrLen; i++) {
                            if (newOptionsSelected.indexOf(newArr[i]) == -1) {
                                newOptionsSelected.splice(newArr[i]._$index, 0, newArr[i]);
                                newArr.splice(i, 1);
                            }
                        }
                    }
                }


                function getFormattedData(data) {
                    var dataLength = data.length;
                    if (!data || dataLength == 0) {
                        return [];
                    }
                    for (var i = 0; i < dataLength; i++) {
                        var str = displayFormat;
                        try {
                            var parentSplit = str.split('{'),
                                parentSplitLen = parentSplit.length;
                            for (var j = 0; j < parentSplitLen; j++) {
                                var childSplit = parentSplit[j].split('}'),
                                    childSplitLen = childSplit.length;
                                for (var k = 0; k < childSplitLen; k++) {
                                    var childObj = childSplit[k];
                                    if (childObj.indexOf('.') > 0 || data[i].hasOwnProperty(childObj)) {
                                        str = str.replace(new RegExp("{" + childObj + "}", "ig"), eval('data[i].' + childObj));
                                    }
                                }
                            }
                        }
                        catch (e) { }
                        data[i].value = str.trim();
                    }
                    return data;
                };

                var filterKeys;
                if (angular.isDefined(scope.filterkeys) && scope.filterkeys.trim().indexOf('[') == 0) {
                    filterKeys = scope.filterkeys ? scope.$eval(scope.filterkeys) : ['title'];
                }
                else {
                    filterKeys = scope.filterkeys ? scope.$eval('[' + scope.filterkeys + ']') : ['title'];
                }

                //set optionFormat displayFormat related to filterKeys incase undefined
                scope.filterKeys = scope.$eval(scope.filterkeys);
                function getOpFormate() {
                    var opFor = "",
                        filterKeyLen = filterKeys.length;
                    for (var i = 0; i < filterKeyLen; i++) {
                        opFor = opFor + "{" + filterKeys[i] + "} ";
                    }
                    if (opFor == "") {
                        return "{title}";
                    }
                    opFor.trim();
                    return opFor;
                }

                function getDispFormate() {
                    var opDisp = "<span>",
                        filterKeyLen = filterKeys.length;
                    for (var i = 0; i < filterKeyLen; i++) {
                        opDisp = opDisp + "{" + filterKeys[i] + "} ";
                    }
                    if (opDisp == "<span>") {
                        return "{title}";
                    }
                    opDisp.trim();
                    opDisp = opDisp + "</span>";
                    return opDisp;
                }

                var optionFormat = scope.optionformat ? scope.optionformat : getDispFormate();
                var displayFormat = scope.displayformat ? scope.displayformat : getOpFormate();

                function getDisplayData(data) {
                    if (data == undefined || data == null || data == '') {
                        return '';
                    }
                    var str = displayFormat, evalResult, evaluatedKeysCounter = 0, nullKeysCounter = 0;
                    try {
                        var parentSplit = str.split('{'),
                            parentSplitLen = parentSplit.length;
                        for (var j = 0; j < parentSplitLen; j++) {
                            var childSplit = parentSplit[j].split('}'),
                                childSplitLen = childSplit.length;
                            for (var k = 0; k < childSplitLen; k++) {
                                var tChild = childSplit[k];
                                if (tChild.indexOf('.') > 0 || data.hasOwnProperty(tChild)) {
                                    evalResult = eval('data.' + tChild);
                                    evaluatedKeysCounter++;
                                    if (evalResult == undefined || evalResult == null || (evalResult + '').trim().length == 0) {
                                        evalResult = '';
                                        nullKeysCounter++;
                                    }
                                    str = str.replace(new RegExp("{" + tChild + "}", "ig"), evalResult);
                                }
                            }
                        }
                        if (evaluatedKeysCounter == nullKeysCounter) {
                            str = '';
                        }
                    }
                    catch (e) {
                    }
                    return str === undefined || str === null || str === 'undefined' || str === 'null' ? '' : str;
                }
                //Function return the array of proprrties Input:"{abc} {dfg}"; Output:["abc","dfg"]
                function getFormatedArray(formatString) {
                    var str = formatString.trim();
                    try {
                        var parentSplit = str.split('{'), propArray = [],
                            tLen = parentSplit.length;
                        for (var j = 0; j < tLen; j++) {
                            var childSplit = parentSplit[j].split('}');
                            if (j != 0) {
                                propArray.push(childSplit[0].trim());
                            }
                        }
                    }
                    catch (e) { }
                    return propArray === undefined || propArray === null || propArray === 'undefined' || propArray === 'null' ? '' : propArray;
                };
                var formatedArray = getFormatedArray(displayFormat);
                
                var delimiterVal = null;
                if (multiselect == true) {
                    delimiterVal = /(,|;)\s*/;
                }
                var unbindOptions, autoCompleteField;
               var toutOptions =  $timeout(function () {
                    unbindOptions = scope.$watch('options', function (newOptions) {
                        try {
                            newOptionsSelected = newOptions;
                            var formattedData = getFormattedData(newOptionsSelected);
                            copyArray = angular.copy(formattedData).map(function (data) { return data.value.toLowerCase(); });
                            if (!readonly) {
                                if (!$('#' + scope.typeaheadId).devbridgeAutocomplete()) {
                                    autoCompleteField = $('#' + scope.typeaheadId).devbridgeAutocomplete({
                                        filterKeys: filterKeys,
                                        optionFormat: optionFormat,
                                        displayFormat: displayFormat,
                                        lookup: formattedData,
                                        width: scope.width,
                                        maxHeight: scope.height,
                                        multiselect: multiselect,
                                        showLookup: showLookup,
                                        addnew: addnew,
                                        minChars: minCharForTrigger,
                                        delimiter: delimiterVal,
                                        showNoSuggestionNotice: showNoSuggestion,
                                        noSuggestionNotice: noSuggestionNotice,
                                        loading: loading,
                                        minMultiselect: minMultiselect,
                                        showLookupKey: showLookupKey,
                                        addNewKey: addNewKey,
                                        onSelect: function (suggestion) {
                                            angular.element('#' + scope.labelFortypeaheadId).trigger('click');
                                            scope.$evalAsync(function () {
                                                if (multiselect == true) {
                                                    scope.displayModel = "";
                                                    setModel(suggestion, 'autocomplete');
                                                    angular.forEach(getModel(), function (val) {
                                                        scope.displayModel = scope.displayModel + val.value + ', ';
                                                    });
                                                    DuplicateData(scope.displayModel);
                                                } else {
                                                    scope.displayModel = getDisplayData(suggestion);
                                                    setModel(suggestion, 'autocomplete');
                                                }
                                                var tOutTemp = $timeout(function () {
                                                    scope.onSelect(suggestion);
                                                    $timeout.cancel(tOutTemp);
                                                    tOutTemp = null;
                                                });
                                            });
                                        },
                                        onClickAddNew: function (e) {
                                            if (addnew) {
                                                scope.callAddNew({ $event: e });
                                                document.body.style.height = document.body.scrollHeight + 2 + "px";
                                                var tTout = setTimeout(function () {
                                                    window.scrollTo(0, (document.body.scrollTop + 1));
                                                    window.scrollTo(0, (document.body.scrollTop - 1));
                                                    document.body.style.height = "";
                                                    clearTimeout(tTout);
                                                    tTout = null;
                                                });
                                            }
                                        },
                                        onClickShowLookup: function (e) {
                                            if (showLookup) {
                                                scope.openLookup();
                                            }
                                        }
                                    }).devbridgeAutocomplete();

                                    $(autoCompleteField.element).focus(function (e) {
                                        alignLookUp.call(this, e, autoCompleteField);
                                        var drp = $window.lastOpenedDropdownConfig;
                                        if (drp && !drp.activates.is(":hidden") && !angular.element(this).closest(drp.activates).length) { // focused textBox shuld not be within the Materlized dropDown thenonly close the Materlized dropDown.
                                            //Materlized dropdown should be closed on focus on autoComplatetextbox
                                            drp.origin.trigger('close');
                                        }
                                    }).keyup(function (e) {
                                        alignLookUp.call(this, e, autoCompleteField);
                                    });

                                    //Closing the suggestions on scroll to prevent overlapping issue
                                    angular.element($window).scroll(function (e) {
                                        if (autoCompleteField.visible) {
                                            autoCompleteField.hide();
                                        }
                                    });
                                    //End of closing the suggestions on scroll to prevent overlapping issue

                                  
                                } else {
                                    $('#' + scope.typeaheadId).devbridgeAutocomplete().setLookup(getFormattedData(newOptions));
                                }
                            }
                        }
                        catch (e) { }
                    });
                    var unbindLoading = scope.$watch('loading', function (newVal, oldVal) {
                        if (newVal == true || newVal == false) {
                            $('#' + scope.typeaheadId).devbridgeAutocomplete().setLoading(newVal);
                        }
                    });
                });

                function alignLookUp(e) {
                    var _this = $(this),
                        scrollTop = $("html").scrollTop() || $("body").scrollTop(),
                        elPosition = _this.offset(),
                        elHeight = _this.outerHeight(),
                        lookup = $(autoCompleteField.suggestionsContainer),
                        lookupPosition = lookup.offset(),
                        lookupHeight = lookup.outerHeight(),
                        isOutOfBound = ((elPosition.top - scrollTop) + elHeight + lookupHeight) > window.innerHeight;

                    lookup.css("opacity", 0);
                    if (isOutOfBound) { // if lookup list is going out of window
                        if (autoCompleteField.options.orientation != "top") {
                            autoCompleteField.options.orientation = "top";
                            autoCompleteField.fixPosition();
                        }
                    } else {
                        if (autoCompleteField.options.orientation == "top") {
                            autoCompleteField.options.orientation = "bottom";
                            autoCompleteField.fixPosition();
                        }
                    }
                    lookup.css("opacity", 1);
                };
                scope.openLookup = function () {
                    showLookupTrigger = true;
                    var len = newArr.length;
                    for (var i = 0 ; i < len; i++) {
                        var tItem = newArr[i];
                        if (newOptionsSelected.indexOf(tItem) == -1) {
                            newOptionsSelected.splice(tItem._$index, 0, tItem);
                            newArr.splice(i, 1);
                        }
                    }
                    if (scope.readonly === 'true' && !scope.mutiselectVal[1]) return false;

                    if ($.isFunction(scope.lookupOpen)) {
                        scope.lookupOpen();
                    }
                    var lookupConfig = {
                        modelData: lookup.getTempModel() || getModel(),
                        config: {
                            mutliselect: multiselect,
                            displayProperties: formatedArray,
                            options: scope.options,
                            descriptionKey: scope.desckey,
                            addnew: addnew,
                            onKeyUp: attrs.searchtextKeyUp ? scope.searchtextKeyUp : '',
                            titleOfModel: scope.titleofmodel,
                            defaultSelectOption: scope.defaultselectoption,
                            defaultSelectionText: scope.defaultselectiontext,
                            selectTypeOption: scope.selecttypeoption,
                            readonly: (scope.readonly == undefined || scope.readonly == null) ? false : scope.readonly == "true" ? true : false,
                            isMandatory: scope.isMandatory,
                            isDefaultMandatory: scope.isDefaultMandatory,
                            errorModel: scope.errorModel,
                            minMultiselect: minMultiselect,
                            label: scope.label,
                            searchFilterKey: scope.$eval(scope.filterkeys),
                            isLazyLoadingEnabled: scope.isLazyLoadingEnabled
                        }
                    }
                    var lookupTout = $timeout(function () {
                        lookup.open(lookupConfig, function (response) {
                            if (response.addnew) {
                                if ($.isFunction(scope.callAddNew)) {
                                    scope.callAddNew();
                                }
                            }
                            setModel(response.result);
                            scope.defaultselectiontext = response.defaultSelectionText;
                            scope.selecttypeoption = response.selectTypeOption;
                            scope.errorModel = response.errorModel;
                            scope.validateRules();
                            if ($.isFunction(scope.lookupHide)) {
                                scope.lookupHide({ data: response });
                            }
                        });
                        lookup.onScrollEnd(function () {
                            scope.onScrollEnd({});
                        });
                        lookup.onScrollTop(function () {
                            scope.onScrollTop({});
                        });
                        lookup.onScrollInProgress(function () {
                            scope.onScrollInProgress({});
                        });
                        $timeout.cancel(lookupTout);
                        lookupTout = null;
                    });
                }
                scope.$on('$destroy', function () {
                    if ($('#' + scope.typeaheadId).devbridgeAutocomplete()) {
                        $('#' + scope.typeaheadId).devbridgeAutocomplete().dispose();
                    }
                    destroyEverythingElse();
                });

                scope.multiselectFlag = false;

                function setValues(newVal) {
                     scope.mutiselectVal = [""];
                    if (angular.isDefined(newVal) && newVal != null) {
                        var valuee = "",
                        totalEl = newVal.length;
                        if (multiselect == true) {
                            if (totalEl > 0) {

                                if (minMultiselect.event) {
                                    if ((totalEl == minMultiselect.value) && (getModel().length == minMultiselect.value)) {
                                        scope.validateRules();
                                    }
                                }

                                if (showLookup) {
                                    scope.multiselectFlag = true;
                                }
                                if (scope.defaultselectoption) {
                                    if (!scope.defaultselectiontext) {
                                        scope.defaultselectiontext = getDisplayData(newVal[0]).replace(/(^\s*)|(\s*$)/gi, "");
                                        scope.mutiselectVal = [scope.defaultselectiontext + " (Default)"];
                                    }
                                    for (var i = 0; i < totalEl; i++) {
                                        if (newVal[i].name === scope.defaultselectiontext) {
                                            scope.mutiselectVal = [getDisplayData(newVal[i]) + " (Default)"]; break;
                                        }
                                    }

                                } else {
                                    scope.mutiselectVal = [getDisplayData(newVal[0])];
                                }

                                if (totalEl > 1) {
                                    scope.mutiselectVal.push("+" + (totalEl - 1) + " More");
                                }
                            } else {
                                scope.multiselectFlag = false;
                            }
                            for (var i = 0; i < totalEl; i++) {
                                if (valuee && totalEl > 1) {
                                    valuee += "," + getDisplayData(newVal[i]);
                                }
                                else {
                                    valuee += getDisplayData(newVal[i])
                                }
                            }

                        }

                        else {
                            valuee = getDisplayData(newVal);
                            scope.showInfoIcon = (valuee == '' || scope.isSupplier) ? false: true;
                        }
                        scope.displayModel = valuee.trim();
                    }
                    scope.isActive = checkIfActive();
                    checkInfoToolTip();
                }

                var unbindNumber = scope.$watch("ngModel", function (newVal) {
                    if (typeof scope.ngModel == "function") {
                        setValues(ngModel.$modelValue);
                    } else {
                        setValues(newVal);
                    }
                });
                function destroyEverythingElse() {
                    element.off(); // deregister all event handlers
                    $('#' + scope.typeaheadId).off();
                    $('#' + scope.labelFortypeaheadId).off();
                    if (unbindFocus)
                        unbindFocus();
                    if (angular.isFunction(unbindOptions))
                        unbindOptions();
                    if (unbindNumber)
                        unbindNumber();
                    // Removing contents of HTML from DOM
                    $('#' + scope.typeaheadId).remove();
                    $('#' + scope.labelFortypeaheadId).remove();
                    $timeout.cancel(toutOptions);

                }
            },
            templateUrl: 'shared/directives/uiElements/smartTypeahead/smartTypeaheadTemplate.html'
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartUiGrid', ['$timeout', '$filter', 'gridConfigProvider', 'APPCONSTANTS', 'httpService', 'uiGridConstants', '$injector',
    function ($timeout, $filter, gridConfigProvider, APPCONSTANTS, httpService, uiGridConstants, $injector) {
        return {
            restrict: 'AE',
            scope: {
                colDef: '@',
                model: '=',
                callback: '&',
                focusRowCol: '@',
                validationService: '@',
                searchTerm: '@',
                otherGridOptions: '@',
                api: '=',
                onRenderingStart: '&',
                onRenderingFinish: '&',
                dynamicPaginationPageSizes: '=',
                dynamicItemTotal: '='

            },
            link: function (scope, element, attr) {

                var paginationOptions = {
                    pageNumber: 1,
                    pageSize: 12,
                    sort: null
                };

                if (scope.validationService != undefined) {
                    var service = $injector.get(scope.validationService);
                    scope.$parent[scope.validationService] = service;
                    scope.cellClassFunction = scope.validationService + ".validateGridRow";
                    scope.cellEditableConditionFunction = scope.validationService + ".isEditableGridRow";
                }
                var gridInstance;
                var defaultGridOptions = {
                    paginationPageSizes: scope.dynamicPaginationPageSizes ? scope.dynamicPaginationPageSizes : [10, 25, 50, 75],
                    paginationPageSize: scope.dynamicPaginationPageSizes && scope.dynamicPaginationPageSizes[0] ? scope.dynamicPaginationPageSizes[0] : 10,
                    useExternalPagination: scope.dynamicPaginationCallback ? true : false,
                    enableCellEditOnFocus: true,
                    enableFiltering: true,
                    enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                    treeRowHeaderAlwaysVisible: false,
                    showTreeExpandNoChildren: false
                };
                var callback = scope.$eval(scope.callback);
                var cellClassFunction = scope.$parent.$eval(scope.cellClassFunction);
                var cellEditableConditionFunction = scope.$parent.$eval(scope.cellEditableConditionFunction);

                scope.gridConfig = defaultGridOptions;
                var modifiedColDef;

                if (scope.api) {
                    scope.api.getActiveColumns = function () {
                        return scope.gridConfig.columnDefs;
                    };
                }

                scope.$watch('focusRowCol', function (n, o) {
                    if(n){
                        gridInstance.cellNav.scrollToFocus(n.row.entity,n.col.colDef)
                    }
                });

                scope.$watch('scope.dynamicItemTotal', function (n, o) {
                    scope.gridConfig.totalItems = scope.dynamicItemTotal;
                });

                scope.$watch('searchTerm', function (n, o) {
                    if (n && typeof n == 'string') {
                        gridInstance.grid.refresh();
                    }
                });

                scope.$watch('colDef', function (n, o) {
                    angular.isFunction(scope.onRenderingStart) && scope.onRenderingStart();

                    if (scope.$eval(n)) {
                        modifiedColDef = gridConfigProvider.getMassagedGirdConfig(scope.$eval(n), scope, cellClassFunction, cellEditableConditionFunction);
                        _.each(modifiedColDef, function (def, idx, defs) {
                            if (def.customTreeAggregationFinalizerFn) {
                                def.customTreeAggregationFinalizerFn = eval("(" + def.customTreeAggregationFinalizerFn + ")");
                            }
                            if (def.customTreeAggregationFn) {
                                def.customTreeAggregationFn = eval("(" + def.customTreeAggregationFn + ")");
                            }
                        });
                        scope.gridConfig.columnDefs = null;
                        scope.gridConfig.columnDefs = modifiedColDef;

                        var groupingCol = _.filter(scope.gridConfig.columnDefs, function (col) { return col.isGrouped;})
                        if (groupingCol && groupingCol.length > 0 && gridInstance) {
                            gridInstance.grouping.clearGrouping();
                            _.each(groupingCol, function (col) {
                                gridInstance.grouping.groupColumn(col.field);
                            });
                        }
                    }
                });

                scope.$watch('otherGridOptions', function (n, o) {
                    angular.isFunction(scope.onRenderingStart) && scope.onRenderingStart();

                    if (scope.$eval(n)) {
                        var modifiedOtherGridOptions = angular.merge({}, scope.gridConfig, scope.$eval(n));
                        _.each(modifiedOtherGridOptions.appScopeProvider, function (prop, i, props) {
                            modifiedOtherGridOptions.appScopeProvider[i] = eval(prop);
                        });
                        scope.gridConfig = null;
                        scope.gridConfig = modifiedOtherGridOptions;
                    }
                });

                scope.$watch('model', function (newModel) {
                    angular.isFunction(scope.onRenderingStart) && scope.onRenderingStart();

                    if (!newModel) {
                        scope.gridConfig.data = [];
                        return;
                    }
                    var treeColumns = treeViewColumnsToBeCreated(scope.gridConfig.columnDefs);
                    if (treeColumns.length > 0) {
                        scope.gridConfig = angular.extend(scope.gridConfig, {
                            showTreeRowHeader: true,
                            enableRowHeaderSelection: true, // Display checkboxes on every row when it's true
                            showTreeExpandNoChildren: false
                        });
                        scope.gridConfig.data = assignTreeLevel($filter('orderBy')(newModel, treeColumns[0].field), treeColumns[0].field);
                    }
                    else {
                        scope.gridConfig.data = newModel;
                    }
                });


                if (!gridInstance) {
                    scope.gridConfig.onRegisterApi = getGridInstanceCallback;
                }


                /*
                 *  This function will check and return an array of columns for tree view
                 */
                var treeViewColumnsToBeCreated = function (colDefs) {
                    return _.filter(colDefs, function (col) {
                        return col.isTree;
                    });
                };

                /*
                 *  Sort grid data
                 */
                var sortData = function (data, key) {
                    return data.slice(0).sort(function (a, b) {
                        return (eval('a.' + key) > eval('b.' + key)) ? 1 : (eval('a.' + key) < eval('b.' + key)) ? -1 : 0;
                    });
                };

                /*
                 *  Assign tree view since it is required to create a tree view
                 */
                var assignTreeLevel = function (data, key) {
                    var loopedItems = [];
                    for (var i = 0; i < data.length; i++) {
                        data[i].$$treeLevel = 0;
                        if (loopedItems.indexOf(eval('data[i].' + key)) > -1) {
                            data[i].$$treeLevel = 1;
                        }
                        if (eval('data[i].' + key).toString().indexOf('.') > -1) {
                            var SplitLevelArr = eval('data[i].' + key).toString().split('.');
                            data[i].$$treeLevel = SplitLevelArr.length - 1;
                            if (loopedItems.indexOf(eval('data[i].' + key)) > -1) {
                                data[i].$$treeLevel = parseInt(data[i].$$treeLevel) + 1;
                            }
                        }
                        loopedItems.push(eval('data[i].' + key));
                    }
                    return data;
                };

                function getCellValue(row, col) {
                    var data = gridInstance.grid.getCellDisplayValue(row, col);
                    return data ? data.toString() : "";
                };

                function outerSearchCallback(rows, cols) {
                    if (scope.searchTerm && typeof scope.searchTerm == 'string' && scope.searchTerm.length > 0) {
                        _.each(rows, function (row, rowIndex) {
                            var match = false;
                            _.each(cols, function (col) {
                                var cellValue = $filter('translate')(getCellValue(row, col));
                                if (col.colDef.attributes && col.colDef.attributes.type && col.colDef.attributes.type.toLowerCase() == "date") {
                                    var formattedDate = (cellValue).replace(new RegExp("/", "ig"), '');
                                    formattedDate = formattedDate.split('+');
                                    formattedDate = eval('new ' + formattedDate[0] + (formattedDate.length > 1 ? ')' : ''));
                                    var month = formattedDate.getMonth() + 1 + '';
                                    if (month.length === 1) {
                                        month = 0 + '' + month;
                                    }
                                    formattedDate = formattedDate.getDate() + '/' + month + '/' + formattedDate.getFullYear();
                                    var decession = formattedDate.toLowerCase().trim().indexOf(escape(scope.searchTerm).replace(/%5C/g, '').trim()) > -1;
                                    if (decession) {
                                        match = true;
                                    }
                                }
                                else if (cellValue.match(new RegExp(scope.searchTerm, "i"))) {
                                    match = true;
                                }
                            });
                            row.visible = match;
                        });
                    };
                    return rows;
                };

                function onCheckboxSelect(row) {
                    if (angular.isFunction(callback)) {
                        callback('composedGridCheckBoxDispatcher', {
                            "row": row
                        });
                    }
                }

                //  this timeout prevents rows rendered callback being fired multiple times
                var rowsRenderedTimeout;
                function getGridInstanceCallback(instance) {
                    if (angular.isFunction(callback)) {
                        callback('gridInstance', instance);
                    }
                    gridInstance = instance;
                    if (typeof scope.api != undefined && scope.api != null && scope.api.rowSelectionCallback) {
                        scope.gridConfig.isRowSelectable = scope.api.rowSelectionCallback;
                        //gridInstance.core.notifyDataChange(uiGridConstants.dataChange.OPTIONS);
                    }
                    gridInstance.grid.registerRowsProcessor(outerSearchCallback, 200);
                    gridInstance.core.on.rowsRendered(scope, function (row) {
                        if (rowsRenderedTimeout) {
                            $timeout.cancel(rowsRenderedTimeout);
                            rowsRenderedTimeout = undefined;
                        }
                        rowsRenderedTimeout = $timeout(function () {
                            if (angular.isFunction(callback)) {
                                callback('composedGridRowsRenderedDispatcher', {
                                    "row": row
                                });
                            }
                            setHeightForGrid();
                            angular.isFunction(scope.onRenderingFinish) && scope.onRenderingFinish();
                        }, 500);
                    });


                    gridInstance.selection.on.rowSelectionChanged(scope, onCheckboxSelect);
                    gridInstance.cellNav.on.navigate(scope, function (newRowcol, oldRowCol) {
                        if (newRowcol.col.colDef.isRegFocusCol) {
                            if (angular.isFunction(callback)) {
                                callback('composedGridFocusColumnDispatcher', {
                                    "focusedRowColObj": newRowcol,
                                    "bluredRowColObj": oldRowCol,
                                    "instance": gridInstance
                                });
                            }
                        }
                    });
                    gridInstance.edit.on.afterCellEdit(scope, function (rowEntity, colDef) {
                        //if (colDef.isRegUpdateCol) {
                        if (angular.isFunction(callback)) {
                            callback('composedGridUpdateColumnDispatcher', {
                                "rowModel": rowEntity,
                                "colDef": colDef,
                                "instance": gridInstance
                            });
                        }
                        // }
                    });
                    gridInstance.edit.on.beginCellEdit(scope, function (rowEntity, colDef) {
                        //var focusedCell = gridInstance.cellNav.getFocusedCell();
                        //if (!focusedCell.col.cellClass) {
                        //    gridInstance.cellNav.scrollToFocus(rowEntity, colDef);
                        //}

                        switch (colDef.uiType) {
                            case "dropdown":
                                if (colDef.attributes.serviceObj && colDef.attributes.options.length == 0) {
                                    getDataFolDropDown(colDef, rowEntity)
                                } else {
                                    colDef.attributes.options.map(function (x) { x[colDef.attributes.dataKey] = $filter('translate')(x[colDef.attributes.dataKey]) });
                                    scope.dropDownOptions = colDef.attributes.options;
                                }
                                break;
                        };

                        if (colDef.isRegBeginEditCol) {
                            if (angular.isFunction(callback)) {
                                callback('composedGridBeginEditColumnDispatcher', {
                                    "rowModel": rowEntity,
                                    "colDef": colDef
                                });
                            }
                        }
                    });

                    gridInstance.pagination.on.paginationChanged(scope, function (newPage, pageSize) {
                        //alert(newPage+"");
                        if (angular.isFunction(callback)) {
                            callback('composedGridDynamicPaginationCallback', {
                                "gridConfig": scope.gridConfig,
                                "index": newPage,
                                "pageSize": pageSize
                            });
                        }
                    });
                };

                function setHeightForGrid() {
                    var rowCount = gridInstance.core.getVisibleRows(gridInstance.grid).length;
                    var height;
                    if (rowCount == 0) return;
                    if (scope.gridConfig.rowHeight > 0) {
                        height = ((rowCount + 1) * scope.gridConfig.rowHeight) + 54;
                    } else {
                        height = (rowCount * 35) + 54;
                    }
                    $($('.ui-grid')[0]).css({ 'width': '100%', 'height': height });
                    $($('.ui-grid')[0]).find('ui-grid-header-canvas').css("width", "100%");
                    //gridInstance.core.handleWindowResize();
                };


                //*****************************************************autoSuggest bindings START*********************************************
                scope.autoSuggestOptions = [];
                scope.autoSuggestOnChange = function (e, col, row) {
                    if (angular.isUndefined(e.data) || e.data.length == 0) {
                        return;
                    }
                    callback('composedGridAutoSuggestChange', {
                        "row": row,
                        "col": col,
                        "val": (e.data[0] !== undefined ? e.data[0].value : e.displayModel)
                    });
                    //logic to clear split entities autosuggest at grid level, needs to be handled further to make common for other autosuggests
                 
                    if (e.data[0].value == "")   {
                        var obj = row.entity[col.colDef.field.split(".")[0]];
                        var index;
                        if (obj != null && obj != undefined && col.colDef.field.indexOf('split') >= 0) {
                            if (row.entity.id > 0)
                                index = _.findIndex(scope.model, { id: row.entity.id });
                            else {
                                _.each(scope.model, function (data, indexFound) {
                                    if (_.isEqual(data, row.entity)) {
                                        index = indexFound;
                                        return;
                                    }
                                });
                            }
                            scope.model[index][col.colDef.field.split(".")[0]] = {
                                "entityType": obj.entityType, "fieldId": obj.fieldId, "splitEntityId": obj.splitEntityId, "code": 0, "entityCode": null, "name": null, "title": null
                            };
                        }
                    }

                    var serviceObj = col.colDef.attributes.serviceObj;
                    if (serviceObj != undefined) {
                        var req = {
                            type: serviceObj.method === "POST" ?"POST": "GET",
                            url: serviceObj.url,
                            params: JSON.parse(JSON.stringify(serviceObj.param).replace("@term", e.data[0].value)),
                            timeout: 120000,
                            headers: {
                                "Content-Type": "application/json",
                                "UserExecutionContext": JSON.stringify(APPCONSTANTS.userPreferences.UserBasicDetails)
                            }
                        };
                        if (req.type === "POST")
                        {
                            req.data = JSON.parse(JSON.stringify(serviceObj.param).replace("@term", e.data[0].value));
                            delete req.params;
                        }
                        httpService.directhttp(req).then(function (response) {
                            if (serviceObj.CallbackObj) {
                                response = serviceObj.CallbackObj(response, col.colDef.name)
                            }
                            var resp = [];
                            if (typeof response === "string")
                                response = JSON.parse(response);
                            if (serviceObj.isFlatArray) {
                                _.each(response, function (x, index) {
                                    var obj = {};
                                    obj["name"] = x;
                                    obj["code"] = x;
                                    resp.push(obj);
                                });
                            }
                            else {
                                _.each(response, function (obj) {
                                    var mapperObj = {};
                                    _.each(serviceObj.mapper, function (mapper) {
                                        var mapperstri = '';
                                        if (angular.isArray(mapper['toBeMapped'])) {
                                            _.each(mapper['toBeMapped'], function (res) {
                                                mapperstri += obj[res] + " ";
                                            });
                                            mapperstri.trim();
                                        }
                                        else
                                            mapperstri = obj[mapper['toBeMapped']];

                                        mapperObj[mapper['key']] = mapperstri;

                                    });
                                    _.each(serviceObj.staticValues, function (item) {
                                        mapperObj[item['key']] = item['value'];
                                    });
                                    resp.push(mapperObj);
                                });
                            }
                            scope.autoSuggestOptions = resp;

                            //for item number and item description autosuggest
                            if (serviceObj.responseRequired) {
                                callback('composedGridParseItemMasterData', {
                                    "rowModel": row,
                                    "colDef": col,
                                    "response": response,
                                    "value": e.data[0].value
                                });
                            }
                        }, function () {   /* Failure case here */ });
                    }
                    else {
                        return;
                    }

                };
                scope.autoSuggestOnSelect = function (event, autoSuggestModel, row, col) {
                    autoSuggestModel = event.data;
                    callback('composedGridSelectItemMasterData', {
                        "data": autoSuggestModel,
                        "row": row,
                        "col": col,
                        "isModified":true
                    });
                };
                //*****************************************************autoSuggest bindings END***********************************************

                //*****************************************************dropDOwn bindings START***********************************************
                scope.isObject = function (val) {
                    return typeof val == 'object';
                }

                scope.dropDownOnChange = function (row, col, val) {
                    if (angular.isFunction(callback)) {
                        callback('composedGridDropDownOnSelectDispatcher', {
                            "row": row,
                            "col": col,
                            "val": val
                        });
                    }
                };

                scope.dropDownOptions = [];
                function getDataFolDropDown(col, row) {
                    var serviceObj = col.attributes.serviceObj;
                    var req = {
                        method: "GET",
                        url: serviceObj.url,
                        params: serviceObj.param,
                        headers: {
                            "Content-Type": "application/json",
                            "UserExecutionContext": JSON.stringify(APPCONSTANTS.userPreferences.UserBasicDetails)
                        }
                    };
                    httpService.directhttp(req).then(function (response) {
                        if (typeof row[col.field] != 'object') {
                            var resp = [];
                            _.each(response, function (x, index) {
                                var obj = {};
                                obj[col.attributes.dataKey] = $filter('translate')(x);
                                obj[col.attributes.idKey] = index;
                                resp.push(obj);
                            });
                            col.attributes.options = resp;
                        } else {
                            col.attributes.options = response;
                        }
                        scope.dropDownOptions = col.attributes.options;
                    }, function () {
                    });
                };
                //*****************************************************dropDOwn bindings END***********************************************
                //*****************************************************popup bindings START***********************************************


                scope.popUpButtonClickCallback = function (row, col) {
                    // segregate the splitpopup callback function based on config.js 
                    if (angular.isFunction(callback)) {
                        if (col.colDef.isChargesGrid) {
                            callback('composedChargesGridPopupButtonClickDispatcher', {
                                "row": row,
                                "col": col
                            });
                        }
                        else {
                            callback('composedGridPopupButtonClickDispatcher', {
                                "row": row,
                                "col": col
                            });
                        }
                    }

                };

                //*****************************************************popup bindings END***********************************************

                //*****************************************************checkBox bindings START***********************************************
                scope.checkBoxOnChange = function (row, col, val) {
                    callback('composedGridCheckBoxOnChangeDispatcher', {
                        "row": row,
                        "col": col,
                        "val": val
                    });
                };
                //*****************************************************checkBox bindings END***********************************************

                //*****************************************************text & number keyup bindings START***********************************************
                scope.textOrNumberKeyUp = function (e, col, row) {
                    callback('composedGridTextKeyUp', {
                        "row": row,
                        "col": col,
                        "val": e.target.value
                    });
                }
                //*****************************************************text & number keyup bindings END***********************************************

            },
            templateUrl: 'shared/directives/uiElements/smartUiGrid/smartUiGrid.html'
        };
    }]);
})();
(function () {
    'use strict';
    angular.module('SMART2').directive('smartUiTable', ['$timeout', '$filter', 'gridConfigProvider', 'APPCONSTANTS', 'httpService', 'uiGridConstants', '$injector',
    function ($timeout, $filter, gridConfigProvider, APPCONSTANTS, httpService, uiGridConstants, $injector) {
        return {
            restrict: 'AE',
            scope: {
                colDef: '@',
                model: '=',
                callback: '&',
                focusRowCol: '@',
                validationService: '@',
                searchTerm: '@',
                otherGridOptions: '@',
                api: '=',
                onRenderingStart: '&',
                onRenderingFinish: '&',
                dynamicPaginationPageSizes: '=',
                dynamicItemTotal: '='

            },
            link: function (scope, element, attr) {

                var paginationOptions = {
                    pageNumber: 1,
                    pageSize: 12,
                    sort: null
                };

                if (scope.validationService != undefined) {
                    var service = $injector.get(scope.validationService);
                    scope.$parent[scope.validationService] = service;
                    scope.cellClassFunction = scope.validationService + ".validateGridRow";
                    scope.cellEditableConditionFunction = scope.validationService + ".isEditableGridRow";
                }
                var gridInstance;
                var defaultGridOptions = {
                    paginationPageSizes: scope.dynamicPaginationPageSizes ? scope.dynamicPaginationPageSizes : [10, 25, 50, 75],
                    paginationPageSize: scope.dynamicPaginationPageSizes && scope.dynamicPaginationPageSizes[0] ? scope.dynamicPaginationPageSizes[0] : 10,
                    useExternalPagination: scope.dynamicPaginationCallback ? true : false,
                    enableCellEditOnFocus: true,
                    enableFiltering: true,
                    enableVerticalScrollbar: uiGridConstants.scrollbars.NEVER,
                    treeRowHeaderAlwaysVisible: false,
                    showTreeExpandNoChildren: false,
                    enableRowSelection: true
                };
                var callback = scope.$eval(scope.callback);
                var cellClassFunction = scope.$parent.$eval(scope.cellClassFunction);
                var cellEditableConditionFunction = scope.$parent.$eval(scope.cellEditableConditionFunction);

                scope.gridConfig = defaultGridOptions;
                var modifiedColDef;

                if (scope.api) {
                    scope.api.getActiveColumns = function () {
                        return scope.gridConfig.columnDefs;
                    };
                }

                scope.$watch('focusRowCol', function (n, o) {
                    if(n){
                        gridInstance.cellNav.scrollToFocus(n.row.entity,n.col.colDef)
                    }
                });

                scope.$watch('scope.dynamicItemTotal', function (n, o) {
                    scope.gridConfig.totalItems = scope.dynamicItemTotal;
                });

                scope.$watch('searchTerm', function (n, o) {
                    if (n && typeof n == 'string') {
                        gridInstance.grid.refresh();
                    }
                });

                scope.$watch('colDef', function (n, o) {
                    angular.isFunction(scope.onRenderingStart) && scope.onRenderingStart();

                    if (scope.$eval(n)) {
                        modifiedColDef = gridConfigProvider.getMassagedGirdConfig(scope.$eval(n), scope, cellClassFunction, cellEditableConditionFunction);
                        _.each(modifiedColDef, function (def, idx, defs) {
                            if (def.customTreeAggregationFinalizerFn) {
                                def.customTreeAggregationFinalizerFn = eval("(" + def.customTreeAggregationFinalizerFn + ")");
                            }
                            if (def.customTreeAggregationFn) {
                                def.customTreeAggregationFn = eval("(" + def.customTreeAggregationFn + ")");
                            }
                        });
                        scope.gridConfig.columnDefs = null;
                        scope.gridConfig.columnDefs = modifiedColDef;

                        var groupingCol = _.filter(scope.gridConfig.columnDefs, function (col) { return col.isGrouped;})
                        if (groupingCol && groupingCol.length > 0 && gridInstance) {
                            gridInstance.grouping.clearGrouping();
                            _.each(groupingCol, function (col) {
                                gridInstance.grouping.groupColumn(col.field);
                            });
                        }
                    }
                });

                scope.$watch('otherGridOptions', function (n, o) {
                    angular.isFunction(scope.onRenderingStart) && scope.onRenderingStart();

                    if (scope.$eval(n)) {
                        var modifiedOtherGridOptions = angular.merge({}, scope.gridConfig, scope.$eval(n));
                        _.each(modifiedOtherGridOptions.appScopeProvider, function (prop, i, props) {
                            modifiedOtherGridOptions.appScopeProvider[i] = eval(prop);
                        });
                        scope.gridConfig = null;
                        scope.gridConfig = modifiedOtherGridOptions;
                    }
                });

                scope.$watch('model', function (newModel) {
                    angular.isFunction(scope.onRenderingStart) && scope.onRenderingStart();

                    if (!newModel) {
                        scope.gridConfig.data = [];
                        return;
                    }
                    var treeColumns = treeViewColumnsToBeCreated(scope.gridConfig.columnDefs);
                    if (treeColumns.length > 0) {
                        scope.gridConfig = angular.extend(scope.gridConfig, {
                            showTreeRowHeader: true,
                            enableRowHeaderSelection: true, // Display checkboxes on every row when it's true
                            showTreeExpandNoChildren: false
                        });
                        scope.gridConfig.data = assignTreeLevel($filter('orderBy')(newModel, treeColumns[0].field), treeColumns[0].field);
                    }
                    else {
                        scope.gridConfig.data = newModel;
                    }
                });



                if (!gridInstance) {
                    scope.gridConfig.onRegister = getGridInstanceCallback;
                }


                /*
                 *  This function will check and return an array of columns for tree view
                 */
                var treeViewColumnsToBeCreated = function (colDefs) {
                    return _.filter(colDefs, function (col) {
                        return col.isTree;
                    });
                };

                /*
                 *  Sort grid data
                 */
                var sortData = function (data, key) {
                    return data.slice(0).sort(function (a, b) {
                        return (eval('a.' + key) > eval('b.' + key)) ? 1 : (eval('a.' + key) < eval('b.' + key)) ? -1 : 0;
                    });
                };

                /*
                 *  Assign tree view since it is required to create a tree view
                 */
                var assignTreeLevel = function (data, key) {
                    var loopedItems = [];
                    for (var i = 0; i < data.length; i++) {
                        data[i].$$treeLevel = 0;
                        if (loopedItems.indexOf(eval('data[i].' + key)) > -1) {
                            data[i].$$treeLevel = 1;
                        }
                        if (eval('data[i].' + key).toString().indexOf('.') > -1) {
                            var SplitLevelArr = eval('data[i].' + key).toString().split('.');
                            data[i].$$treeLevel = SplitLevelArr.length - 1;
                            if (loopedItems.indexOf(eval('data[i].' + key)) > -1) {
                                data[i].$$treeLevel = parseInt(data[i].$$treeLevel) + 1;
                            }
                        }
                        loopedItems.push(eval('data[i].' + key));
                    }
                    return data;
                };

                function getCellValue(row, col) {
                    var data = gridInstance.grid.getCellDisplayValue(row, col);
                    return data ? data.toString() : "";
                };

                function outerSearchCallback(rows, cols) {
                    if (scope.searchTerm && typeof scope.searchTerm == 'string' && scope.searchTerm.length > 0) {
                        _.each(rows, function (row, rowIndex) {
                            var match = false;
                            _.each(cols, function (col) {
                                var cellValue = $filter('translate')(getCellValue(row, col));
                                if (col.colDef.attributes && col.colDef.attributes.type && col.colDef.attributes.type.toLowerCase() == "date") {
                                    var formattedDate = (cellValue).replace(new RegExp("/", "ig"), '');
                                    formattedDate = formattedDate.split('+');
                                    formattedDate = eval('new ' + formattedDate[0] + (formattedDate.length > 1 ? ')' : ''));
                                    var month = formattedDate.getMonth() + 1 + '';
                                    if (month.length === 1) {
                                        month = 0 + '' + month;
                                    }
                                    formattedDate = formattedDate.getDate() + '/' + month + '/' + formattedDate.getFullYear();
                                    var decession = formattedDate.toLowerCase().trim().indexOf(escape(scope.searchTerm).replace(/%5C/g, '').trim()) > -1;
                                    if (decession) {
                                        match = true;
                                    }
                                }
                                else if (cellValue.match(new RegExp(scope.searchTerm, "i"))) {
                                    match = true;
                                }
                            });
                            row.visible = match;
                        });
                    };
                    return rows;
                };

                function onCheckboxSelect(row) {
                    if (angular.isFunction(callback)) {
                        callback('composedGridCheckBoxDispatcher', {
                            "row": row
                        });
                    }
                }

                //  this timeout prevents rows rendered callback being fired multiple times
                var rowsRenderedTimeout;
                function getGridInstanceCallback(instance) {
                    if (angular.isFunction(callback)) {
                        callback('gridInstance', instance);
                    }
                    gridInstance = instance;
                    if (typeof scope.api != undefined && scope.api != null && scope.api.rowSelectionCallback) {
                        scope.gridConfig.isRowSelectable = scope.api.rowSelectionCallback;
                        //gridInstance.core.notifyDataChange(uiGridConstants.dataChange.OPTIONS);
                    }
                    //gridInstance.grid.registerRowsProcessor(outerSearchCallback, 200);
                    //gridInstance.core.on.rowsRendered(scope, function (row) {
                    //    if (rowsRenderedTimeout) {
                    //        $timeout.cancel(rowsRenderedTimeout);
                    //        rowsRenderedTimeout = undefined;
                    //    }
                    //    rowsRenderedTimeout = $timeout(function () {
                    //        if (angular.isFunction(callback)) {
                    //            callback('composedGridRowsRenderedDispatcher', {
                    //                "row": row
                    //            });
                    //        }
                    //        setHeightForGrid();
                    //        angular.isFunction(scope.onRenderingFinish) && scope.onRenderingFinish();
                    //    }, 500);
                    //});


                    gridInstance.selection.on.rowSelectionChanged(scope, onCheckboxSelect);
                    //gridInstance.cellNav.on.navigate(scope, function (newRowcol, oldRowCol) {
                    //    if (newRowcol.col.colDef.isRegFocusCol) {
                    //        if (angular.isFunction(callback)) {
                    //            callback('composedGridFocusColumnDispatcher', {
                    //                "focusedRowColObj": newRowcol,
                    //                "bluredRowColObj": oldRowCol
                    //            });
                    //        }
                    //    }
                    //});
                    gridInstance.edit.on.afterCellEdit(scope, function (rowEntity, colDef) {
                        //if (colDef.isRegUpdateCol) {
                        if (angular.isFunction(callback)) {
                            callback('composedGridUpdateColumnDispatcher', {
                                "rowModel": rowEntity,
                                "colDef": colDef,
                                "instance": gridInstance
                            });
                        }
                        // }
                    });
                    gridInstance.edit.on.beginCellEdit(scope, function (rowEntity, colDef) {
                        //var focusedCell = gridInstance.cellNav.getFocusedCell();
                        //if (!focusedCell.col.cellClass) {
                        //    gridInstance.cellNav.scrollToFocus(rowEntity, colDef);
                        //}

                        switch (colDef.uiType) {
                            case "dropdown":
                                if (colDef.attributes.serviceObj && colDef.attributes.options.length == 0) {
                                    getDataFolDropDown(colDef, rowEntity)
                                } else {
                                    colDef.attributes.options.map(function (x) { x[colDef.attributes.dataKey] = $filter('translate')(x[colDef.attributes.dataKey]) });
                                    scope.dropDownOptions = colDef.attributes.options;
                                }
                                break;
                        };

                        if (colDef.isRegBeginEditCol) {
                            if (angular.isFunction(callback)) {
                                callback('composedGridBeginEditColumnDispatcher', {
                                    "rowModel": rowEntity,
                                    "colDef": colDef
                                });
                            }
                        }
                    });

                    
                    gridInstance.cell.on.click(scope, function (row, col) {
                        callback('smartTableClick', {
                            row: row,
                            col: col
                        });
                    });

                    //gridInstance.pagination.on.paginationChanged(scope, function (newPage, pageSize) {
                    //    //alert(newPage+"");
                    //    if (angular.isFunction(callback)) {
                    //        callback('composedGridDynamicPaginationCallback', {
                    //            "gridConfig": scope.gridConfig,
                    //            "index": newPage,
                    //            "pageSize": pageSize
                    //        });
                    //    }
                    //});
                };

                function setHeightForGrid() {
                    var rowCount = gridInstance.core.getVisibleRows(gridInstance.grid).length;
                    var height;
                    if (rowCount == 0) return;
                    if (scope.gridConfig.rowHeight > 0) {
                        height = ((rowCount + 1) * scope.gridConfig.rowHeight) + 54;
                    } else {
                        height = (rowCount * 35) + 54;
                    }
                    $($('.ui-grid')[0]).css({ 'width': '100%', 'height': height });
                    $($('.ui-grid')[0]).find('ui-grid-header-canvas').css("width", "100%");
                    //gridInstance.core.handleWindowResize();
                };


                //*****************************************************autoSuggest bindings START*********************************************
                scope.autoSuggestOptions = [];
                scope.autoSuggestOnChange = function (e, col, row) {
                    if (angular.isUndefined(e.data) || e.data.length == 0) {
                        return;
                    }
                    callback('composedGridAutoSuggestChange', {
                        "row": row,
                        "col": col,
                        "val": (e.data[0] !== undefined ? e.data[0].value : e.displayModel)
                    });
                    //logic to clear split entities autosuggest at grid level, needs to be handled further to make common for other autosuggests
                    if (e.data[0].value == "")
                    {
                        var obj = row.entity[col.colDef.field.split(".")[0]];
                        var index;
                        if (obj != null && obj != undefined && col.colDef.field.indexOf('split') >= 0)
                        {
                            if (row.entity.id > 0)
                                index = _.findIndex(scope.model, { id: row.entity.id });
                            else
                            {
                                _.each(scope.model, function (data, indexFound) {
                                    if (_.isEqual(data, row.entity)) {
                                        index = indexFound;
                                        return;
                                    }
                                });
                            }
                            scope.model[index][col.colDef.field.split(".")[0]] = {
                                "entityType": obj.entityType, "fieldId": obj.fieldId, "splitEntityId": obj.splitEntityId, "code": 0, "entityCode": null, "name": null, "title": null
                            };
                        }
                    }

                    var serviceObj = col.colDef.attributes.serviceObj;
                    if (serviceObj != undefined) {
                        var req = {
                            type: serviceObj.method === "POST" ?"POST": "GET",
                            url: serviceObj.url,
                            params: JSON.parse(JSON.stringify(serviceObj.param).replace("@term", e.data[0].value)),
                            timeout: 120000,
                            headers: {
                                "Content-Type": "application/json",
                                "UserExecutionContext": JSON.stringify(APPCONSTANTS.userPreferences.UserBasicDetails)
                            }
                        };
                        if (req.type === "POST")
                        {
                            req.data = JSON.parse(JSON.stringify(serviceObj.param).replace("@term", e.data[0].value));
                            delete req.params;
                        }
                        httpService.directhttp(req).then(function (response) {
                            if (serviceObj.CallbackObj) {
                                response = serviceObj.CallbackObj(response, col.colDef.name)
                            }
                            var resp = [];
                            if (typeof response === "string")
                                response = JSON.parse(response);
                            if (serviceObj.isFlatArray) {
                                _.each(response, function (x, index) {
                                    var obj = {};
                                    obj["name"] = x;
                                    obj["code"] = x;
                                    resp.push(obj);
                                });
                            }
                            else {
                                _.each(response, function (obj) {
                                    var mapperObj = {};
                                    _.each(serviceObj.mapper, function (mapper) {
                                        var mapperstri = '';
                                        if (angular.isArray(mapper['toBeMapped'])) {
                                            _.each(mapper['toBeMapped'], function (res) {
                                                mapperstri += obj[res] + " ";
                                            });
                                            mapperstri.trim();
                                        }
                                        else
                                            mapperstri = obj[mapper['toBeMapped']];

                                        mapperObj[mapper['key']] = mapperstri;

                                    });
                                    _.each(serviceObj.staticValues, function (item) {
                                        mapperObj[item['key']] = item['value'];
                                    });
                                    resp.push(mapperObj);
                                });
                            }
                            scope.autoSuggestOptions = resp;

                            //for item number and item description autosuggest
                            if (serviceObj.responseRequired) {
                                callback('composedGridParseItemMasterData', {
                                    "rowModel": row,
                                    "colDef": col,
                                    "response": response,
                                    "value": e.data[0].value
                                });
                            }
                        }, function () {   /* Failure case here */ });
                    }
                    else {
                        return;
                    }

                };
                scope.autoSuggestOnSelect = function (event, autoSuggestModel, row, col) {
                    autoSuggestModel = event.data;
                    callback('composedGridSelectItemMasterData', {
                        "data": autoSuggestModel,
                        "row": row,
                        "col": col,
                        "isModified":true
                    });
                };
                //*****************************************************autoSuggest bindings END***********************************************

                //*****************************************************dropDOwn bindings START***********************************************
                scope.isObject = function (val) {
                    return typeof val == 'object';
                }

                scope.dropDownOnChange = function (row, col, val) {
                    if (angular.isFunction(callback)) {
                        callback('composedGridDropDownOnSelectDispatcher', {
                            "row": row,
                            "col": col,
                            "val": val
                        });
                    }
                };

                scope.dropDownOptions = [];
                function getDataFolDropDown(col, row) {
                    var serviceObj = col.attributes.serviceObj;
                    var req = {
                        method: "GET",
                        url: serviceObj.url,
                        params: serviceObj.param,
                        headers: {
                            "Content-Type": "application/json",
                            "UserExecutionContext": JSON.stringify(APPCONSTANTS.userPreferences.UserBasicDetails)
                        }
                    };
                    httpService.directhttp(req).then(function (response) {
                        if (typeof row[col.field] != 'object') {
                            var resp = [];
                            _.each(response, function (x, index) {
                                var obj = {};
                                obj[col.attributes.dataKey] = $filter('translate')(x);
                                obj[col.attributes.idKey] = index;
                                resp.push(obj);
                            });
                            col.attributes.options = resp;
                        } else {
                            col.attributes.options = response;
                        }
                        scope.dropDownOptions = col.attributes.options;
                    }, function () {
                    });
                };
                //*****************************************************dropDOwn bindings END***********************************************
                //*****************************************************popup bindings START***********************************************


                scope.popUpButtonClickCallback = function (row, col) {
                    // segregate the splitpopup callback function based on config.js 
                    if (angular.isFunction(callback)) {
                        if (col.colDef.isChargesGrid) {
                            callback('composedChargesGridPopupButtonClickDispatcher', {
                                "row": row,
                                "col": col
                            });
                        }
                        else {
                            callback('composedGridPopupButtonClickDispatcher', {
                                "row": row,
                                "col": col
                            });
                        }
                    }

                };

                //*****************************************************popup bindings END***********************************************

                //*****************************************************checkBox bindings START***********************************************
                scope.checkBoxOnChange = function (row, col, val) {
                    callback('composedGridCheckBoxOnChangeDispatcher', {
                        "row": row,
                        "col": col,
                        "val": val
                    });
                };
                //*****************************************************checkBox bindings END***********************************************

                //*****************************************************text & number keyup bindings START***********************************************
                scope.textOrNumberKeyUp = function (e, col, row) {
                    callback('composedGridTextKeyUp', {
                        "row": row,
                        "col": col,
                        "val": e.target.value
                    });
                }
                //*****************************************************text & number keyup bindings END***********************************************

            },
            templateUrl: 'shared/directives/uiElements/smartUiTable/smartUiTable.html'
        };
    }]);
})();
(function (angular) {
    'use strict';
    angular.module('SMART2').service('trackStatusService', ['$http', '$q', function ($http, $q) {
        var self = this;
        // Watch the change of main object
        self.statusDataChange = { 'dataChange': '' };
        self.legendChange = {'dataChange' : ''};
        self.dataChange = function () {
            self.statusDataChange['dataChange'] = new Date().getTime();
        }
        self.getChange = function () {
            return self.statusDataChange['dataChange'];
        }
        self.legendChange = function () {
            self.legendChange['dataChange'] = new Date().getTime();
        }
        self.getLegendChange = function () {
            return self.legendChange['dataChange'];
        }
    }]);
})(angular);

(function (angular) {
    'use strict';
    angular.module('SMART2').directive('smartTrackStatus', ['trackStatusService', '$filter', '$translate',
        function (trackStatusService, $filter, $translate) {
        
        return {
            restrict: 'E',
            replace: true,
            scope: {
                data: "=trackstatusData",
                onTabChange: "=onTabChange",
                cycleChange: "=onCycleChange",
                statusLegend: "=statusLegend",
                approverLegend: "=approverLegend",
                fileDownloadCallback: "=fileDownloadCallback",
                scrollToStatus: "=scrollToStatus",
                downloadAllAttachment : "=downloadAllAttachment"
            },
            templateUrl: 'shared/directives/uiElements/trackStatus/popupNewTrackStatus.html',
            link: function (scope, elem, attr) {
                scope.trackStatusService = trackStatusService;
		        
                // translate the static labels
                scope.headerLable = $translate.instant('TRACK_STATUS'); // header
                scope.tsDocName = $translate.instant('TRACK_STATUS_DOC_NAME');
                //scope.tsCreatedOn = $translate.instant('CREATED_ON');
                scope.tsCreatedOn = attr.trackStatusType === 'milestone' ? $translate.instant('ACHIEVED_ON') : $translate.instant('CREATED_ON');
                scope.tsCurrStatus = $translate.instant('CURRENT_STATUS');
                scope.labelOn = $translate.instant('ON');
                scope.legend = $translate.instant('Legend');
                scope.by = $translate.instant('By');
                scope.defContentCommentLen = 60; // 60 chars to be displayed in case of longer comments.
                
                // HTML page map for tabs
                var htmlForDetail = 'shared/directives/uiElements/trackStatus/trackStatusDetail.html';
                var dateFormat;
                //if (typeof RegionalSettingEnable != "undefined" && RegionalSettingEnable) {
                //    dateFormat = moment.localeData().longDateFormat('L');
                //} else
                if (attr.dateFormat && attr.dateFormat != '') {
                    dateFormat = attr.dateFormat;
                } else {
                    dateFormat = 'DD/MM/YYYY';
                }
                // Utility methods
                scope.getDate = function (date) {
                    //return $filter('date')(date, dateFormat);
                    return moment(parseInt(date)).format(dateFormat);
                }
                function dataChanged(a_data) {
                    scope.data = a_data;
                }
                function statusListData(a_data) {
                    scope.statusLists = a_data.datailedData;
                }
                scope.tabClicked = function (e) {
                    scope.onTabChange(e);
                }
                scope.changeCycle = function (model) {
                    scope.cycleChange(model);
                }
                statusListData(scope.data);
                // To update cycles
                scope.cycleObject = [];
                function selectCycle(a_data) {
                    var cycles = a_data.cycles,
                        len = cycles.length;
                    scope.cycleObject = cycles;
                    for(var indx = 0; indx < len; indx++) {
                        if (cycles[indx].selected === true) {
                            scope.selectedCycle = cycles[indx];
                        }
                    }
                }
                selectCycle(scope.data);

                // update tabs
                scope.trackStatusTabs = [];
                function updateTabs(a_data) {
                    var tabs = a_data.trackStatusTabs,
                        len = tabs.length;
                    for (var t = 0; t < len; t++) {
                        var tobj = tabs[t];
                        if (tobj.active === true) {
                            tobj.contentUrl = htmlForDetail;
                        }
                    }
                    scope.trackStatusTabs = tabs;
                }
                updateTabs(scope.data);
                
                // update doc name, created on and by, doc curr status
                function updateHeaderData(a_data) {
                    scope.headerSecData = a_data;
                    scope.headerSecData.Comments.date = scope.getDate(a_data.Comments.date);
                    scope.docCreatedOn = scope.getDate(a_data.createdOn);
                }
                updateHeaderData(scope.data.projectStatus);

                // check if comment exists
                scope.hasComments = function (a_comment) {
                    var flag = (a_comment !== "" && a_comment) ? true : false;
                    return flag;
                }
                // show more less comments
                scope.showLess = {};
                scope.showMore = {};
                scope.showMoreLess = function (id, arg) {
                    if(arg === "less") {
                        scope.showMore[id] = true;
                        scope.showLess[id] = false;
                    } else if (arg === "more") {
                        scope.showLess[id] = true;
                        scope.showMore[id] = false;
                    }
                }
                // init show more
                scope.showMoreComment = {};
                scope.initShowModel = function (id) {
                    scope.showMore[id] = true;
                    scope.showLess[id] = false;
                }
                // Watch for any update in data change
                scope.$watch('trackStatusService.getChange()', function (newVal, oldVal) {
                    if (newVal !== oldVal && newVal) {
                        // Data changed
                        //dataChanged(scope.data);
                        statusListData(scope.data);
                        selectCycle(scope.data);
                        updateTabs(scope.data);
                        setTimeout(function () {
                            scrollToLatestStatus();
                        }, 1000);
                    }

                });
                // Get string to be displayed for comments
                scope.getString = function (a_str, a_count) {
                    var strLen = a_str.length,
                        str = "";
                    if(strLen > a_count) {
                        str = a_str.substr(0, a_count) +'...';
                    } else {
                        str = a_str.substr(0, a_count);
                    }
                        
                    return str;
                }
                scope.applyStatusColor = function (ele) {
                    switch (ele.toLowerCase()) {
                        case 'approved':
                        case 'accepted':
                        case 'approval':
                        case 'auto_approved':
                            return 'color-approved';
                            break;
                        case 'approval pending':
                        case 'delegated':
                        case 'withdrawn':
                        case 'approval withdrawn':
                        case 'withdraw':
                        case 'approval withdraw':
                            return 'color-approved-pending';
                            break;
                        case 'rejected':
                            return 'color-rejected';
                            break;
                        case 'pending':
                            return 'color-approved-pending';
                            break;
                        case 'budget overriden':
                            return 'color-bud-overrid';
                        default:
                            return 'grey-text';
                    }
                };
                scope.IconStatus = function (ele) {
                    var iconMap = {
                        'pending': '',
                        'approval': '',
                        'rejected': '',
                        'accepted': '',
                        'approved': '',
                        'auto_approved': '',
                        'approval pending': '',
                        'approval withdrawn': '',
                        'withdrawn': '',
                        'approval withdraw': '',
                        'withdraw': ''
                    }
                    if (ele && iconMap.hasOwnProperty([ele.toLowerCase()])) {
                        return '#icon_TSHexOutlin';
                    } else {
                        return '#icon_Info_i';
                    }
                };
                scope.InnerIconStatus = function (ele) {
                    switch (ele.toLowerCase()) {
                        case 'pending':
                        case 'approval pending' : 
                            return '#icon_TSPending';
                            break;
                        case 'approval':
                        case 'accepted':
                        case 'approved':
                            return '#icon_TSAccepted';
                            break;
                        case 'rejected':
                            return '#icon_TSRejected';
                            break;
                        case 'auto_approved':
                            return '#Icon_AppAuto';
                            break;
                        case 'approval withdrawn':
                        case 'withdrawn':
                        case 'approval withdraw':
                        case 'withdraw':
                            return 'icon_TSWithdrawn';
                            break;
                        default:
                            return '#icon_Info';
                    }
                };

                // Currently not being used
                scope.approvalGroupType = function (ele) {
                    switch (ele.toLowerCase()) {
                        case 'pool approval':
                            return 'a-g-pool-approval';
                            break;
                        case 'parallel approval':
                            return 'a-g-parallel-approval';
                            break;
                        case 'hr approval':
                            return 'a-g-HR-approval';
                            break;
                        case 'group approval':
                            return 'a-g-group-approval';
                            break;
                        default:
                            return false;
                    }
                };
                scope.slideDetailsTS = function (id) {
                    var detailDataCopy = scope.data.datailedData,
                        len = detailDataCopy.length;
                    for (var indx = 0; indx < len; indx++) {
                        if (detailDataCopy[indx].uniqueId === id) {
                            detailDataCopy[indx].isDetailShow = !detailDataCopy[indx].isDetailShow;
                        }
                    }
                }
				scope.changeScreenSize = function (e) {
					scope.isFullscreen = !scope.isFullscreen;
				}

                // add unique id to each actioner items
                function addUniqueId() {
                    var pItems = scope.data.datailedData,
                        pLen = pItems.length;
                    for (var indx = 0 ; indx < pLen; indx++) {
                        var cArr = pItems[indx].actionerDetails,
                            cLen = cArr.length;
                        for (var c = 0; c < cLen; c++) {
                            cArr[c].uniqueId = c +'-'+ uniqueIDGenerator();
                        }
                        pItems[indx].uniqueId = "details" + uniqueIDGenerator() + '-' + indx;
                    }
                }
                addUniqueId();
                // Unique id generator
                function uniqueIDGenerator() {
                    var d = new Date().getTime();
                    var uniqueID = 'xxx2xxxpxxxoxxx'.replace(/[xy]/g, function (c) {
                        var r = (d + Math.random() * 16) % 16 | 0;
                        d = Math.floor(d / 16);
                        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                    });
                    return uniqueID;
                };

                // Watch the legend change
                scope.$watch('trackStatusService.getLegendChange()', function (newVal, oldVal) {
                    if (newVal !== oldVal && newVal) {
                        displayLegend(); // if legend changed
                    }

                });
                // Approver legend
                var defApproverLegend = [
        	        {
        	            "icon": "#icon_AppOne",
        	            "color": "color-approved-pending",
        	            "text": $translate.instant("POOL_APP_ATLEAST_ONE")
        	        },
	                {
	                    "icon": "#icon_AppAll",
	                    "color": "color-approved-pending",
	                    "text": $translate.instant("PARALLEL_APPROVAL_FORALL")
	                },
	                {
	                    "icon": "#icon_AppSingle",
	                    "color": "color-approved-pending",
	                    "text": $translate.instant("INDIVIDUAL_MUST_APPROVE")
	                },
	                {
	                    "icon": "#Icon_AppAuto",
	                    "color": "color-approved",
	                    "text": $translate.instant("AUTO_SYSTEM_APPROVE")
	                },
	                {
	                    "icon": "#icon_AppHoc",
	                    "color": "color-add-Hoc",
	                    "text": $translate.instant("ADHOC_APPROVER")
	                }
                ];
                var defStatusLegend = [
                        {
                            "icon": "#icon_TSAccepted",
                            "color": "color-approved",
                            "text": $translate.instant("APPROVED")
                        },
                        {
                            "icon": "#icon_TSRejected",
                            "color": "color-rejected",
                            "text": $translate.instant("REJECTED")
                        },
                        {
                            "icon": "#icon_TSPartialAc",
                            "color": "color-approved",
                            "text": $translate.instant("PARTIALLY_APPROVED")
                        },
                        {
                            "icon": "#icon_TSPartialRe",
                            "color": "color-rejected",
                            "text": $translate.instant("PARTIALLY_REJECTED")
                        },
                        {
                            "icon": "#icon_TSPending",
                            "color": "color-approved-pending",
                            "text": $translate.instant("PENDING")
                        },
                        {
                            "icon": "#icon_TSWithdrawn",
                            "color": "color-approved-pending",
                            "text": $translate.instant("Approval Withdrawn")
                        },
                        {
                            "icon": "#icon_Info_i",
                            "color": "grey-text",
                            "text": $translate.instant("INFORMATION")
                        }

                ];
                function displayLegend() {
                    var statusLegend = (scope.statusLegend) ? scope.statusLegend : false; // status legend
                    var approverLegend = (scope.approverLegend) ? scope.approverLegend : false;// approver legend
                    scope.approverLegend = (!approverLegend) ? defApproverLegend : scope.approverLegend;                    
                    scope.statusLegend = (!statusLegend) ? defStatusLegend : statusLegend;
                };
                displayLegend(); // will execute on load case
                scope.isFullscreen = false; // default not full screen
				scope.changeScreenSize = function (e) {
				    scope.isFullscreen = !scope.isFullscreen;
				    if (scope.isFullscreen) {
				        scope.defContentCommentLen = 95;
				    } else {
				        scope.defContentCommentLen = 60;
				    }
				    return;
				}
				
                // set scroll to latest status
				attr.$observe('focusLatest', function (newVal) {
				    if (newVal == "true") {
				        setTimeout(function () {
				            scrollToLatestStatus();
				        }, 200);
				        
				    } else {
				        //$('.scrollbar-outer').animate({ scrollTop: 0}, "slow");
				    }
				});

                // Set z-index and position relative for tabs to pass content within shadow
				function setTabCss() {
				    var tabDiv = $('#trackStatusTabId').children(":first");
				    if (tabDiv.hasClass('borderBtmGray')) {
				        tabDiv.css({
				            'z-index': 2,
				            'position': 'relative'
				        });
				    }
				    
				}
				
				function scrollToLatestStatus() {
				    var idToSetScroll = "",
                        $target = "",
                        len = scope.data.datailedData.length,
                        scrollIndex = (scope.scrollToStatus && scope.scrollToStatus != "") ? Number(scope.scrollToStatus) : (len - 1),
				        uniqueid = scope.data.datailedData[scrollIndex].uniqueId;// get the last element id and set the scroll

				    setTabCss();
				    
				    $target = $('[uniqueid=' + uniqueid + ']');
				    var scrollPosition = $('#scroll-8').scrollTop() + $target.parent().position().top;
				    $('.scrollbar-outer').animate({ scrollTop: scrollPosition }, "slow", 'swing');
				    return false;
				}
            }
            ,
            controller: ['$scope', function ($scope) {
                this.getFDownloadCallback = function () {
                    return $scope.fileDownloadCallback;
                },
                this.getDownloadAllAttchment = function () {
                    return $scope.downloadAllAttachment;
                }
            }]
        }
        }])

        // To show attachments attached and downaloadable
    .directive('attachmentsCallout', ['$timeout', function ($timeout) {
        return {
            restrict : 'EA',
            scope: {
                attachments: '=attachments',
                identifier: '=identifier',
                id: '=id'
            },
            require: '^smartTrackStatus',
            templateUrl: 'shared/directives/uiElements/trackStatus/attachmentsDownload.html',
            link: function (scope, elem, attr, cntrl) {
                scope.downloadFile = cntrl.getFDownloadCallback();
                scope.showDownloadAllAttachment = cntrl.getDownloadAllAttchment();
                scope.filedownload = function (a_data) {
                    scope.downloadFile(a_data);
                }
            }
        }
    }]);
})(angular);
(function() {

    /*
     *  Prevent document's default scroll behaviour on space
     */
    window.onkeydown = function(e) {
        if (e.keyCode == 32 && $(e.target).hasClass('ui-grid-focuser')) {
            e.preventDefault();
            return false;
        }
    };


    angular.module('SMART2')
        .directive("uigridCompatible", ['uiGridConstants', 'uiGridEditConstants', '$rootScope', uigridCompatibleFunc]);

    function uigridCompatibleFunc(uiGridConstants, uiGridEditConstants, $rootScope) {
        return {
            require: ['?^uiGrid', '?^uiGridRenderContainer'],
            restrict: 'A',
            link: function(scope, element, attrs, controllers) {
                var uiGridCtrl = controllers[0];
                var renderContainerCtrl = controllers[1];

                var isFocused = false;
                var isSelectElement = false;

                /*
                 *  Remove previous cell scope if any
                 */
                if (window.lastRenderedElementScope) {
                    try {
                        window.lastRenderedElementScope.stopEdit();
                        window.lastRenderedElementScope = undefined;
                    }
                    catch (e) { }
                }

                window.lastRenderedElementScope = scope;

                /*
                 *  On popup close listener
                 */
                var onPopupClosed = $rootScope.$on("popupClosed", function () {
                    uiGridCtrl.focus();
                });

                /*
                *  On date component close listener
                */
                var onDatePopupClosed = $rootScope.$on("closedPopup", function () {
                    uiGridCtrl.focus();
                });

                /*
                 *  On popup open listener
                 */
                var onPopupOpened = $rootScope.$on("popupOpened", function () {
                    document.activeElement.blur();
                });

                /*
                 *  Viewport keydown broadcast listener
                 */
                var onViewPortKeyDown = uiGridCtrl.grid.api.cellNav.on.viewPortKeyDown(scope, function (e, rowCol) {
                    var inputText = element.find("input");
                    var anchor = element.find("a");

                    switch (e.keyCode) {
                        case 32:
                            if (anchor.length > 0) {
                                window.isPopupOpenedByUIGridCompatibleElement = true;
                                anchor.trigger("click");
                            }
                            else if (inputText.length > 0 && !isFocused) {
                                inputText.focus();
                                isFocused = true;
                            }
                            else if (isSelectElement) {
                                select.focus();
                            }
                            break;
                        case 9:
                            scope.stopEdit();
                            break;
                        default:
                            if (element.attr("type") !== "date") {
                                inputText.focus();
                            }
                            break;
                    }
                });

                /*
                 *  Stop cell editing and destroy the scope
                 */
                scope.stopEdit = function (e) {
                    if (isSelectElement) {
                        select.blur();
                    }
                    scope.$emit(uiGridEditConstants.events.END_CELL_EDIT);
                };


                /*
                 *  Element key down handler
                 */
                var onElementKeyDown = function (e) {
                    switch (e.keyCode) {
                        case 32:
                            var inputText = element.find("input");
                            var anchor = element.find("a");

                            if (anchor.length > 0) {
                                window.isPopupOpenedByUIGridCompatibleElement = true;
                                anchor.trigger("click");
                            }
                            else if (isSelectElement) {
                                select.focus();
                            }
                            break;
                        case uiGridConstants.keymap.ESC:
                            e.stopPropagation();
                            scope.$emit(uiGridEditConstants.events.CANCEL_CELL_EDIT);
                            break;
                    }
                    if (uiGridCtrl && uiGridCtrl.grid.api.cellNav) {
                        e.uiGridTargetRenderContainerId = renderContainerCtrl.containerId;
                        if (uiGridCtrl.cellNav.handleKeyDown(e) !== null) {
                            scope.stopEdit(e);
                        }
                    }
                    else {
                        //handle enter and tab for editing not using cellNav
                        switch (e.keyCode) {
                            case uiGridConstants.keymap.ENTER: // Enter (Leave Field)
                            case uiGridConstants.keymap.TAB:
                                scope.stopEdit(e);
                                break;
                        }
                    }
                };

                element.on('keydown', onElementKeyDown);


                //  Focus select element
                var select = element.find("select");
                isSelectElement = select.length > 0;
                if (isSelectElement) {
                    setTimeout(function () {
                        select.focus();
                    });
                }



                //  Trigger anchor tag's click event if cell clicked
                if (window.isCellClicked) {
                    setTimeout(function () {
                        var anchor = element.find("a");
                        if (anchor.length > 0) {
                            window.isPopupOpenedByUIGridCompatibleElement = true;
                            anchor.trigger('click');
                        }
                    });
                    window.isCellClicked = false;
                }


                /*
                 *  Destroy broadcast listeners on scope destroy
                 */
                scope.$on('$destroy', function () {
                    onPopupClosed();
                    onDatePopupClosed();
                    onPopupOpened();
                    onViewPortKeyDown();
                    element.off('keydown', onElementKeyDown);
                });
            }
        };
    };
})();
